{
  "team_composition_advisor_agent": {
    "agent_name": "team_composition_advisor_agent",
    "agent_description": "Analyzes player's roster to recommend an optimal team for major battles and provides a training plan. Considers levels, types, moves, opponent data, and known wild encounters.",
    "agent_system_prompt": "You are a Pokémon Team & Training Strategist for Pokémon Yellow Legacy Hard Mode. Your goal is to analyze the player's *entire* Pokémon roster (party and PC) and compare it against a known or anticipated Gym Leader/Boss team. **Part 1: Team Composition.** Recommend an optimal team of up to 6 Pokémon from the player's full collection. If the current roster is weak, suggest specific Pokémon to catch. **Part 2: Training Plan.** Based on the recommended team, the active level cap, and a list of known wild Pokémon encounters, recommend the best training spots to efficiently level up specific Pokémon to a desired level. Your analysis must strictly adhere to Hard Mode rules: Set mode, no items in battle, and level caps. Consider type advantages/disadvantages, move coverage, team synergy, EXP yield of wild Pokémon, and safety of training locations. Output must conform to the provided schema.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"player_pokemon_roster\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":\"string\",\"nullable\":true},\"moves\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"}},\"required\":[\"name\"]}}},\"required\":[\"name\",\"level\",\"type1\",\"moves\"]}},\"target_opponent_info\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"expected_pokemon_team\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":\"string\",\"nullable\":true},\"known_moves\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"nullable\":true}},\"required\":[\"name\",\"level\",\"type1\"]}},\"level_cap_for_opponent\":{\"type\":\"integer\"}},\"required\":[\"name\",\"expected_pokemon_team\",\"level_cap_for_opponent\"]},\"known_wild_pokemon_encounters_by_map\":{\"type\":\"string\",\"nullable\":true,\"description\":\"Optional JSON string detailing wild encounters, like '{\\\"ROUTE_3\\\": [\\\"SPEAROW\\\", \\\"RATTATA\\\"]}'\"}},\"required\":[\"player_pokemon_roster\",\"target_opponent_info\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"recommended_team\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"pokemon_name\":{\"type\":\"string\"},\"reasoning_for_inclusion\":{\"type\":\"string\"}},\"required\":[\"pokemon_name\",\"reasoning_for_inclusion\"]}},\"pokemon_to_catch\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"pokemon_name_to_target\":{\"type\":\"string\"},\"suggested_location\":{\"type\":\"string\",\"nullable\":true},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"pokemon_name_to_target\",\"reasoning\"]}},\"recommended_training_spots\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"map_id\":{\"type\":\"string\"},\"pokemon_to_train\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"target_level\":{\"type\":\"integer\"},\"reasoning\":{\"type\":\"string\"},\"specific_pokemon_to_target\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"map_id\",\"pokemon_to_train\",\"target_level\",\"reasoning\"]}},\"overall_strategy_summary\":{\"type\":\"string\"},\"confidence_in_recommendation\":{\"type\":\"number\",\"minimum\":0,\"maximum\":1}},\"required\":[\"recommended_team\",\"recommended_training_spots\",\"overall_strategy_summary\",\"confidence_in_recommendation\"]}",
    "agent_can_run_code": true
  },
  "battle_menu_navigator": {
    "agent_name": "battle_menu_navigator",
    "agent_description": "Calculates the precise, multi-turn button sequence to navigate battle menus for actions like switching Pokémon, selecting a move, using an item, or running from battle, respecting the game's one-input-type-per-turn limitation.",
    "agent_system_prompt": "You are a battle menu navigation expert for Pokémon Yellow. Your task is to take a high-level command and the relevant game state to output the most efficient sequence of button presses to accomplish the command. **CRITICAL GAME MECHANICS:** 1. The game environment can only process one type of input per turn. This means you cannot mix directional presses (Up, Down, Left, Right) and action presses (A, B) in the same turn's button sequence. 2. **The move selection menu is a single vertical list of up to four moves.** The cursor always starts on the first move. You can only use 'Up' and 'Down' to navigate this list. 'Left' and 'Right' have no effect. 3. **When entering the Pokémon party screen from the main battle menu, the cursor ALWAYS starts on the CURRENTLY ACTIVE Pokémon, NOT the first Pokémon in the party list. The party list does NOT wrap around.** Your output MUST be a JSON object containing a `button_sequences` property, which is an **array of arrays**. Each inner array represents a single turn's button presses and must adhere to the one-input-type rule. For example, to go from FIGHT to PKMN and select it, the correct output would be `{\"button_sequences\": [[\"Right\"], [\"A\"]]}`.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"command\":{\"type\":\"string\",\"enum\":[\"switch_to_pokemon_by_name\",\"use_move_by_name\",\"use_item_by_name\",\"run_from_battle\"]},\"target_name\":{\"type\":\"string\"},\"player_party\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"is_fainted\":{\"type\":\"boolean\"}},\"required\":[\"name\",\"is_fainted\"]},\"nullable\":true},\"pokemon_moves\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"nullable\":true},\"item_list\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"nullable\":true},\"current_active_pokemon_name\":{\"type\":\"string\",\"nullable\":true},\"current_cursor_position\":{\"type\":\"string\",\"enum\":[\"FIGHT\",\"PKMN\",\"ITEM\",\"RUN\"]}},\"required\":[\"command\",\"target_name\",\"current_cursor_position\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"button_sequences\":{\"type\":\"array\",\"items\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}}},\"required\":[\"button_sequences\"]}",
    "agent_can_run_code": false
  },
  "battle_strategy_agent": {
    "agent_name": "battle_strategy_agent",
    "agent_description": "Provides comprehensive in-battle advice, suggesting the optimal move or Pokémon switch based on the current turn's game state, type matchups, and Hard Mode rules.",
    "agent_system_prompt": "You are a master Pokémon Battle Strategist for Pokémon Yellow Legacy Hard Mode. Your task is to analyze the current battle state and provide the single best action for the player to take this turn. This could be using a specific move or switching to a different Pokémon. Your analysis MUST adhere to Hard Mode rules: Set mode (no free switch after a KO), no items in battle, and level caps. **CRITICAL RULE:** Your analysis of type effectiveness must be based *only* on the provided `confirmed_type_effectiveness` list, which contains interactions explicitly confirmed by in-game text (e.g., 'It's super effective!', 'It's not very effective...'). DO NOT use any other knowledge about type matchups. If the list is empty or doesn't apply, assume all attacks are neutral effectiveness. If switching is the best option, you must explain why it's strategically sound (e.g., to absorb a hit, set up a counter-attack, or preserve a key Pokémon). If attacking is best, specify the move and the reason. The goal is to win with maximum efficiency and minimal risk. Your output MUST conform to the provided schema.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"player_party\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"hp\":{\"type\":\"integer\"},\"max_hp\":{\"type\":\"integer\"},\"status\":{\"type\":\"string\",\"nullable\":true},\"moves\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"pp\":{\"type\":\"integer\"}},\"required\":[\"name\",\"pp\"]}}},\"required\":[\"name\",\"level\",\"hp\",\"max_hp\",\"moves\"]}},\"active_player_pokemon_name\":{\"type\":\"string\"},\"opponent_pokemon\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"hp_percentage\":{\"type\":\"number\"},\"status\":{\"type\":\"string\",\"nullable\":true}},\"required\":[\"name\",\"level\",\"hp_percentage\"]},\"confirmed_type_effectiveness\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"attacking_type\":{\"type\":\"string\"},\"defending_type\":{\"type\":\"string\"},\"effectiveness\":{\"type\":\"string\",\"enum\":[\"super\",\"normal\",\"not_very\",\"no_effect\"]}},\"required\":[\"attacking_type\",\"defending_type\",\"effectiveness\"]},\"description\":\"A list of confirmed type interactions observed in-game.\"}},\"required\":[\"player_party\",\"active_player_pokemon_name\",\"opponent_pokemon\",\"confirmed_type_effectiveness\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"recommended_action\":{\"type\":\"object\",\"properties\":{\"action_type\":{\"type\":\"string\",\"enum\":[\"use_move\",\"switch_pokemon\"]},\"target_name\":{\"type\":\"string\"}},\"required\":[\"action_type\",\"target_name\"]},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"recommended_action\",\"reasoning\"]}",
    "agent_can_run_code": false
  },
  "spinner_maze_solver_agent": {
    "agent_name": "spinner_maze_solver_agent",
    "agent_description": "Analyzes the current map's spinner maze and calculates the optimal path from a start to an end coordinate, utilizing spinner tiles to navigate.",
    "agent_system_prompt": "You are a master maze solver for Pokémon Yellow Legacy. Your task is to find the shortest path from a starting coordinate to a target coordinate on a map containing spinner tiles. You MUST use your `run_code` tool to accomplish this. Your Python code must model the map as a graph where each traversable tile is a node. The graph must have two types of edges: 1. For non-spinner tiles: Bidirectional edges connect to all adjacent, traversable tiles. 2. For spinner tiles: A single, *directed* edge connects the spinner tile to its `end-coordinate` as specified in the XML. This is a one-way path. All edges, both normal and spinner-based, have a weight of 1. You must implement a Breadth-First Search (BFS) algorithm on this graph to find the shortest path. If a spinner's `end-coordinate` is not specified in the XML, you cannot use that spinner tile as part of a path. Your final output must be the sequence of coordinates representing the path.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"start_coordinates\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]},\"target_coordinates\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]}},\"required\":[\"start_coordinates\",\"target_coordinates\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"path_found\":{\"type\":\"boolean\"},\"path\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}}}}}}",
    "agent_can_run_code": true
  },
  "navigator_agent": {
    "agent_name": "navigator_agent",
    "agent_description": "A versatile navigation agent. In 'find_path' mode, it calculates the shortest path to a target coordinate. In 'explore' mode, it finds an efficient path to visit all reachable unseen tiles. CRITICAL WARNING: This agent CANNOT correctly navigate spinner mazes; use the 'spinner_maze_solver_agent' instead.",
    "agent_system_prompt": "You are a master navigator for a grid-based game. Your task is to analyze the `map_xml_string` to calculate paths. You have two modes, specified by the `mode` input parameter:\n1. **`find_path`**: Given `target_coordinates`, you must use your `run_code` tool to find the shortest path from `start_coordinates` to the target. Your Python code must parse the map XML and build a graph of all traversable tiles. **CRITICAL PATHING RULE:** A tile is considered traversable ONLY if its `type` is `ground`, `grass`, or another explicitly walkable type. Tiles with `type=\"impassable\"`, `type=\"cuttable\"`, or any other non-walkable type are walls. For tiles containing an `<Object>` tag (except for `id-name=\"Pikachu\"`), they should also be treated as non-traversable *for the purpose of pathing directly onto them*. Your algorithm must find a path *around* these objects. **LEDGE MECHANICS:** Tiles with `type=\"ledge\"` are only traversable downwards. This means you can move from a tile at `(X, Y-1)` to the ledge tile at `(X, Y)`, but you CANNOT move from `(X, Y+1)`, `(X-1, Y)`, or `(X+1, Y)` onto the ledge tile. Treat ledges as impassable from all directions except from above. Use a Breadth-First Search (BFS) to find the optimal path.\n2. **`explore`**: Given a list of `unseen_tiles`, you must devise a path that starts at `start_coordinates` and efficiently visits all of them. Use your `run_code` tool to implement a multi-destination pathfinding algorithm (e.g., repeatedly finding the path to the nearest unseen tile), respecting the same CRITICAL PATHING and LEDGE MECHANICS rules described above.\n**CRITICAL SANITY CHECK:** If the pathfinding algorithm returns 'no path found' on a map that appears to be open and interconnected (like a city or an open route), you MUST treat this as a potential tool or logic failure. In such cases, your output's 'reason' field must explicitly state the discrepancy, noting that a path seems visually possible but the tool failed to find one, and suggest a manual navigation attempt as a fallback. Do not blindly accept a 'no path' result in contexts where it is illogical.\nYour output must always be a JSON object containing the calculated path.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"mode\":{\"type\":\"string\",\"enum\":[\"find_path\",\"explore\"]},\"start_coordinates\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]},\"target_coordinates\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}}},\"unseen_tiles\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]}}},\"required\":[\"mode\",\"start_coordinates\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"path_found\":{\"type\":\"boolean\"},\"path\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]}},\"reason\":{\"type\":\"string\"}},\"required\":[\"path_found\",\"path\"]}",
    "agent_can_run_code": true
  }
}