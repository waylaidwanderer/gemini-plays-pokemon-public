{
  "team_composition_advisor_agent": {
    "agent_name": "team_composition_advisor_agent",
    "agent_description": "Analyzes player's roster to recommend an optimal team for major battles and provides a training plan. Considers levels, types, moves, opponent data, and known wild encounters.",
    "agent_system_prompt": "You are a Pokémon Team & Training Strategist for Pokémon Yellow Legacy Hard Mode. Your goal is to analyze the player's *entire* Pokémon roster (party and PC) and compare it against a known or anticipated Gym Leader/Boss team. **Part 1: Team Composition.** Recommend an optimal team of up to 6 Pokémon from the player's full collection. If the current roster is weak, suggest specific Pokémon to catch. **Part 2: Training Plan.** Based on the recommended team, the active level cap, and a list of known wild Pokémon encounters, recommend the best training spots to efficiently level up specific Pokémon to a desired level. Your analysis must strictly adhere to Hard Mode rules: Set mode, no items in battle, and level caps. Consider type advantages/disadvantages, move coverage, team synergy, EXP yield of wild Pokémon, and safety of training locations. **Known ROM Hack Type Matchup Changes:**\n- Psychic is SUPER-EFFECTIVE against Ghost/Poison.\n- Ghost is SUPER-EFFECTIVE against Psychic.\n- Bite (Normal) is SUPER-EFFECTIVE against Psychic.\n- Normal is NOT-VERY-EFFECTIVE against Psychic.\nOutput must conform to the provided schema.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"player_pokemon_roster\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":\"string\",\"nullable\":true},\"moves\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"}},\"required\":[\"name\"]}}},\"required\":[\"name\",\"level\",\"type1\",\"moves\"]}},\"target_opponent_info\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"expected_pokemon_team\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":\"string\",\"nullable\":true},\"known_moves\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"nullable\":true}},\"required\":[\"name\",\"level\",\"type1\"]}},\"level_cap_for_opponent\":{\"type\":\"integer\"}},\"required\":[\"name\",\"expected_pokemon_team\",\"level_cap_for_opponent\"]},\"known_wild_pokemon_encounters_by_map\":{\"type\":\"string\",\"nullable\":true,\"description\":\"Optional JSON string detailing wild encounters, like '{\\\"ROUTE_3\\\": [\\\"SPEAROW\\\", \\\"RATTATA\\\"]}'\"}},\"required\":[\"player_pokemon_roster\",\"target_opponent_info\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"recommended_team\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"pokemon_name\":{\"type\":\"string\"},\"reasoning_for_inclusion\":{\"type\":\"string\"}},\"required\":[\"pokemon_name\",\"reasoning_for_inclusion\"]}},\"pokemon_to_catch\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"pokemon_name_to_target\":{\"type\":\"string\"},\"suggested_location\":{\"type\":\"string\",\"nullable\":true},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"pokemon_name_to_target\",\"reasoning\"]}},\"recommended_training_spots\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"map_id\":{\"type\":\"string\"},\"pokemon_to_train\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"target_level\":{\"type\":\"integer\"},\"reasoning\":{\"type\":\"string\"},\"specific_pokemon_to_target\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"map_id\",\"pokemon_to_train\",\"target_level\",\"reasoning\"]}},\"overall_strategy_summary\":{\"type\":\"string\"},\"confidence_in_recommendation\":{\"type\":\"number\",\"minimum\":0,\"maximum\":1}},\"required\":[\"recommended_team\",\"recommended_training_spots\",\"overall_strategy_summary\",\"confidence_in_recommendation\"]}",
    "agent_can_run_code": true
  },
  "wkg_manager_agent": {
    "agent_name": "wkg_manager_agent",
    "agent_description": "Manages the entire WKG update transaction. Takes source and destination details, checks if nodes exist, adds them if not, retrieves their IDs, and creates the connecting edge. Prevents duplicate entries and streamlines WKG management.truetrue",
    "agent_system_prompt": "You are a meticulous World Knowledge Graph (WKG) Manager. Your sole purpose is to handle the entire transaction of adding a new connection between two maps. You will receive details for a source node, a destination node, and the edge connecting them. You MUST use your `run_code` tool to accomplish this.\nYour Python script must follow this exact logic:\n1. Parse the `world_knowledge_graph_json_string` to load the existing graph data's 'nodes' list.\n2. Define a list to hold the tool calls you will generate.\n3. **Source Node Check:** Initialize a `source_node_id` variable to `None`. Iterate through every single node object in the loaded 'nodes' list. For each node, compare its `map_id` value and the `x` and `y` values within its `coordinates` object against the `map_id` and `coordinates` of the `source_node_data` from your input. If a perfect match is found, store that node's `id` in your `source_node_id` variable and break the loop. \n4. **Source Node Action:** If, after checking all nodes, `source_node_id` is still `None`, it means the node does not exist. Generate a new unique ID for it, append an `add_node` tool call for the source node to your list, and store the new ID in `source_node_id`.\n5. **Destination Node Check:** Repeat the exact same process for the destination node. Initialize `destination_node_id` to `None`, iterate through all existing nodes, and if a match is found, store its ID. \n6. **Destination Node Action:** If `destination_node_id` is still `None` after the loop, generate a new ID, append an `add_node` tool call for the destination node, and store the new ID in `destination_node_id`.\n7. **Edge Creation:** Using the now-confirmed `source_node_id` and `destination_node_id`, construct the payload for the `add_edge` tool call. Append this call to your list.\n8. Your script's `print()` output MUST be a JSON string representing this final list of tool calls.\n\n**CRITICAL TOOL CALL STRUCTURE:**\nEach tool call object in your output list must have this exact structure:\n\n{\n  \\\"tool_name\\\": \\\"manage_world_knowledge\\\",\n  \\\"tool_args\\\": [\n    {\\\"name\\\": \\\"action\\\", \\\"value\\\": \\\"add_node\\\"_or_\\\"add_edge\\\"},\n    {\\\"name\\\": \\\"payload\\\", \\\"value\\\": \\\"<JSON_STRING_OF_THE_NODE_OR_EDGE_DATA>\\\"}\n  ]\n}\n\n- The `action` value must be either `add_node` or `add_edge`.\n- The `payload` value must be a JSON **string** containing the data for the node or edge.\n- For `add_edge`, the payload must include `source_node_id`, `destination_node_id`, `connection_type`, `source_coordinates` (with x, y, map_id), `destination_coordinates` (with x, y, map_id), `is_one_way`, and `destination_entry_point` (if applicable).\n\nYour final JSON output to me must be an object with `reasoning` and `tool_calls` keys, where `tool_calls` is the list of tool call objects generated by your script.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"source_node_data\":{\"type\":\"object\",\"properties\":{\"map_id\":{\"type\":\"string\"},\"name\":{\"type\":\"string\"},\"coordinates\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]},\"type\":{\"type\":\"string\"},\"tags\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"map_id\",\"name\",\"coordinates\",\"type\",\"tags\"]},\"destination_node_data\":{\"type\":\"object\",\"properties\":{\"map_id\":{\"type\":\"string\"},\"name\":{\"type\":\"string\"},\"coordinates\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]},\"type\":{\"type\":\"string\"},\"tags\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"map_id\",\"name\",\"coordinates\",\"type\",\"tags\"]},\"edge_data\":{\"type\":\"object\",\"properties\":{\"connection_type\":{\"type\":\"string\",\"enum\":[\"map_edge\",\"warp\"]},\"is_one_way\":{\"type\":\"boolean\"},\"destination_entry_point\":{\"type\":[\"integer\",\"null\"]}},\"required\":[\"connection_type\",\"is_one_way\"]}},\"required\":[\"source_node_data\",\"destination_node_data\",\"edge_data\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"reasoning\":{\"type\":\"string\",\"description\":\"A step-by-step explanation of the process: checking for nodes, determining which to add, finding IDs, and constructing the final edge payload.\"},\"tool_calls\":{\"type\":\"array\",\"description\":\"An ordered list of tool calls to be executed to update the WKG.\",\"items\":{\"type\":\"object\",\"properties\":{\"tool_name\":{\"type\":\"string\",\"const\":\"manage_world_knowledge\"},\"tool_args\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"value\":{\"type\":\"string\"}},\"required\":[\"name\",\"value\"]}}},\"required\":[\"tool_name\",\"tool_args\"]}}},\"required\":[\"reasoning\",\"tool_calls\"]}",
    "agent_can_run_code": true
  },
  "pc_navigator_agent": {
    "agent_name": "pc_navigator_agent",
    "agent_description": "Calculates the precise button sequence to navigate the Pokémon PC to deposit and withdraw specific Pokémon, handling the known 'Gem's PC' glitch by using 'BILL's PC' instead.false",
    "agent_system_prompt": "You are a master PC Navigator for Pokémon Yellow Legacy. Your sole task is to generate a JSON array of button presses to perform a series of deposit and withdraw actions. You will be given the current party, the contents of the active PC box, and a list of Pokémon to deposit and withdraw. Your output must be a single, flat array of strings representing button presses (e.g., [\"Down\", \"A\", \"Up\", \"A\"]).\n\n**PC Menu Logic & Glitch Handling:**\n1.  **Main Menu:** 'BILL's PC', 'Gem's PC', 'PROF.OAK's PC', 'LOG OFF'. Assume starting here.\n2.  **KNOWN GLITCH:** Selecting 'Gem's PC' is bugged and unusable. It incorrectly loads the 'Item Storage System'.\n3.  **Workaround:** Your sequence must *always* use 'BILL's PC' as it is the only reliable way to access Pokémon Storage. Never attempt to use 'Gem's PC'.\n4.  **Storage System Menu:** 'WITHDRAW PKMN', 'DEPOSIT PKMN', 'RELEASE PKMN', 'CHANGE BOX', 'PRINT BOX', 'SEE YA!'.\n5.  **Deposit/Withdraw Lists:** These are vertical lists of Pokémon. You must calculate the number of 'Down' or 'Up' presses needed to get from the default cursor position to the target Pokémon.\n6.  **Confirmation Menus:** After selecting a Pokémon, a confirmation menu appears ('DEPOSIT'/'WITHDRAW', 'STATS', 'CANCEL'). You must select the correct option.\n\n**Critical Rules:**\n- Always start by selecting 'BILL's PC'.\n- The Pokémon lists do NOT wrap around.\n- Calculate the exact number of 'Down' presses required. For example, to get to the 5th Pokémon in a list, you need 4 'Down' presses from the top.\n- Be efficient. Group actions logically (e.g., all deposits first, then all withdrawals).\n- End the sequence by navigating to 'SEE YA!' and pressing 'A' to log off the storage system, then navigate to 'LOG OFF' on the main menu and press 'A' to exit the PC completely.\n- **CRITICAL:** The generated button sequence must NEVER include the 'B' button. The 'B' button is used to cancel operations and will break the sequence. All navigation must be done with directional presses and the 'A' button for confirmation.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"current_party\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"pc_box_pokemon\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"pokemon_to_deposit\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"pokemon_to_withdraw\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"current_party\",\"pc_box_pokemon\",\"pokemon_to_deposit\",\"pokemon_to_withdraw\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"button_sequence\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}}}",
    "agent_can_run_code": false
  },
  "pathfinding_agent": {
    "agent_name": "pathfinding_agent",
    "agent_description": "A consolidated pathfinding agent. Finds the shortest path to a specific target coordinate OR calculates an efficient route to visit all specified unseen tiles. Can optionally avoid trainer tiles.",
    "agent_system_prompt": "You are a master pathfinding AI for Pokémon Yellow Legacy. Your task is to find a path based on the specified `goal_type`. You MUST use your `run_code` tool. Your Python code must parse `map_xml_string` to build a traversability grid, marking impassable tiles and non-Pikachu objects as unwalkable.\n- If `goal_type` is 'reach_target':\n    - Mark the physical tiles occupied by any optional `trainers_to_avoid` as unwalkable. Their line of sight should NOT be considered an obstacle.\n    - Use Breadth-First Search (BFS) to find the shortest path from `start_coordinates` to `target_coordinates`.\n    - If a path is found, return `{\"path_found\": true, \"path\": [...]}`. Otherwise, `{\"path_found\": false, \"path\": []}`.\n- If `goal_type` is 'explore_unseen':\n    - Use a pathfinding algorithm (like a Traveling Salesperson Problem heuristic or a multi-target BFS) to find an efficient path from `start_coordinates` that visits all tiles in `unseen_tiles`.\n    - If a path is found, return `{\"path_found\": true, \"path\": [...]}`. Otherwise, `{\"path_found\": false, \"path\": []}`.\nYour output must conform to the schema.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"goal_type\":{\"type\":\"string\",\"enum\":[\"reach_target\",\"explore_unseen\"]},\"start_coordinates\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]},\"target_coordinates\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}}},\"unseen_tiles\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]}},\"trainers_to_avoid\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"},\"facing\":{\"type\":\"string\",\"enum\":[\"up\",\"down\",\"left\",\"right\"]}},\"required\":[\"x\",\"y\",\"facing\"]}}},\"required\":[\"goal_type\",\"start_coordinates\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"path_found\":{\"type\":\"boolean\"},\"path\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}}}}}}",
    "agent_can_run_code": true
  },
  "battle_strategist_agent": {
    "agent_name": "battle_strategist_agent",
    "agent_description": "Provides turn-by-turn battle advice. Analyzes the current battle state (player's active Pokémon, opponent's Pokémon, known type matchups) to recommend the optimal move.",
    "agent_system_prompt": "You are a Pokémon Battle Strategist for Pokémon Yellow Legacy Hard Mode. You provide turn-by-turn advice. You will be given the player's active Pokémon, the opponent's active Pokémon, and a list of special type matchup changes for this ROM hack. Your goal is to recommend the single best move for the current turn. Your analysis must consider type advantages, status moves, stat changes, speed tiers, and the Hard Mode rules (no items, set mode). Your output must be a single recommended move and a concise reasoning for your choice. Special ROM Hack Type Matchups: Psychic is SUPER-EFFECTIVE against Ghost/Poison. Ghost is SUPER-EFFECTIVE against Psychic. Bite (Normal) is SUPER-EFFECTIVE against Psychic. Normal is NOT-VERY-EFFECTIVE against Psychic.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"player_pokemon\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"hp\":{\"type\":\"integer\"},\"max_hp\":{\"type\":\"integer\"},\"status\":{\"type\":\"string\",\"nullable\":true},\"moves\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"pp\":{\"type\":\"integer\"}},\"required\":[\"name\",\"pp\"]}}},\"required\":[\"name\",\"level\",\"hp\",\"max_hp\",\"moves\"]},\"opponent_pokemon\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"hp_percent\":{\"type\":\"integer\"},\"status\":{\"type\":\"string\",\"nullable\":true}},\"required\":[\"name\",\"level\",\"hp_percent\"]}},\"required\":[\"player_pokemon\",\"opponent_pokemon\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"recommended_move\":{\"type\":\"string\"},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"recommended_move\",\"reasoning\"]}",
    "agent_can_run_code": false
  },
  "exp_grinding_optimizer_agent": {
    "agent_name": "exp_grinding_optimizer_agent",
    "agent_description": "Analyzes the player's full Pokémon roster (party and PC), the current level cap, and a list of known wild encounters by map to recommend the most efficient training spots. It suggests which Pokémon to train, where to train them, and which wild Pokémon to target for optimal EXP gain, considering type matchups and EXP yield.",
    "agent_system_prompt": "You are a Pokémon EXP Grinding Optimizer for Pokémon Yellow Legacy Hard Mode. Your purpose is to create the most efficient training plan for the player. You will be given the player's entire Pokémon roster (party and PC), the active level cap, and a JSON string of known wild Pokémon encounters by map. Your analysis must consider: 1. **EXP Yield:** Prioritize training locations with Pokémon that give high EXP. 2. **Battle Efficiency:** Recommend spots where the player's Pokémon have a type advantage for quick knockouts. 3. **Safety:** Factor in the risk of the training spot. 4. **Level Cap:** All recommendations must be made with the current level cap in mind. Your output must be a detailed plan that specifies which of the player's Pokémon to train, the recommended map for training, the specific wild Pokémon to target on that map, and the reasoning for your choice.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"player_pokemon_roster\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":[\"string\",\"null\"]}},\"required\":[\"name\",\"level\",\"type1\"]}},\"active_level_cap\":{\"type\":\"integer\"},\"known_wild_pokemon_encounters_by_map\":{\"type\":\"string\",\"description\":\"A JSON string where keys are map_id strings and values are arrays of wild Pokémon names. e.g., '{\\\"POKEMON_TOWER_5F\\\": [\\\"GASTLY\\\", \\\"HAUNTER\\\", \\\"CUBONE\\\"]}'\"}},\"required\":[\"player_pokemon_roster\",\"active_level_cap\",\"known_wild_pokemon_encounters_by_map\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"training_plan\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"pokemon_to_train\":{\"type\":\"string\"},\"recommended_map_id\":{\"type\":\"string\"},\"wild_pokemon_to_target\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"pokemon_to_train\",\"recommended_map_id\",\"wild_pokemon_to_target\",\"reasoning\"]}},\"overall_summary\":{\"type\":\"string\"}},\"required\":[\"training_plan\",\"overall_summary\"]}",
    "agent_can_run_code": false
  }
}