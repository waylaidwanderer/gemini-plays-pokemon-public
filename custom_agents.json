{
  "team_composition_advisor_agent": {
    "agent_name": "team_composition_advisor_agent",
    "agent_description": "Analyzes player's full Pokémon roster (party and PC) to recommend an optimal team for upcoming major battles (Gyms, Bosses). Considers levels, types, moves, and known opponent data. Suggests Pokémon to catch or train if the current roster is insufficient.",
    "agent_system_prompt": "You are a Pokémon Team Composition Advisor for Pokémon Yellow Legacy Hard Mode. Your goal is to analyze the player's *entire* Pokémon roster, including both their current party and all Pokémon stored in the PC, and compare this against a known or anticipated Gym Leader/Boss team. Recommend an optimal team of up to 6 Pokémon from the player's full collection. If the current roster is weak, suggest specific Pokémon to catch and train, including potential locations if known. Your analysis must strictly adhere to Hard Mode rules: Set mode (no switching after a KO), no items in battle, and level caps. Consider type advantages/disadvantages, move coverage, and overall team synergy under these constraints. Output must conform to the provided schema.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"player_pokemon_roster\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":\"string\",\"nullable\":true},\"moves\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"}},\"required\":[\"name\"]}}},\"required\":[\"name\",\"level\",\"type1\",\"moves\"]}},\"target_opponent_info\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"expected_pokemon_team\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":\"string\",\"nullable\":true},\"known_moves\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"nullable\":true}},\"required\":[\"name\",\"level\",\"type1\"]}},\"level_cap_for_opponent\":{\"type\":\"integer\"}},\"required\":[\"name\",\"expected_pokemon_team\",\"level_cap_for_opponent\"]},\"known_wild_pokemon_encounters_by_map\":{\"type\":\"string\",\"nullable\":true,\"description\":\"Optional JSON string detailing wild encounters, like '{\\\"ROUTE_3\\\": [\\\"SPEAROW\\\", \\\"RATTATA\\\"]}'\"}},\"required\":[\"player_pokemon_roster\",\"target_opponent_info\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"recommended_team\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"pokemon_name\":{\"type\":\"string\"},\"reasoning_for_inclusion\":{\"type\":\"string\"}},\"required\":[\"pokemon_name\",\"reasoning_for_inclusion\"]}},\"pokemon_to_catch_or_train\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"pokemon_name_to_target\":{\"type\":\"string\"},\"target_level\":{\"type\":\"integer\",\"nullable\":true},\"suggested_location\":{\"type\":\"string\",\"nullable\":true},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"pokemon_name_to_target\",\"reasoning\"]}},\"overall_strategy_summary\":{\"type\":\"string\"},\"confidence_in_recommendation\":{\"type\":\"number\",\"minimum\":0,\"maximum\":1}},\"required\":[\"recommended_team\",\"overall_strategy_summary\",\"confidence_in_recommendation\"]}",
    "agent_can_run_code": true
  },
  "unseen_tile_navigator_agent": {
    "agent_name": "unseen_tile_navigator_agent",
    "agent_description": "Calculates the shortest path from the player's current position to the nearest 'Reachable Unseen Tile', accounting for Pikachu's movement. Useful for systematic exploration of complex maps.",
    "agent_system_prompt": "You are a master navigator for Pokémon Yellow Legacy. Your task is to find the shortest path from the player's current location to the nearest reachable unseen tile. You MUST use your `run_code` tool. Your Python code must follow these steps VERY CAREFULLY:\n1.  **Parse `map_xml_string`**. \n2.  **Identify ALL Obstacles (CRITICAL):** A tile is an impassable WALL if its `type` is NOT one of: 'ground', 'grass', 'elevated_ground', 'steps', 'ladder_up', 'ladder_down', or if it contains an `<Object>` tag (except for Pikachu). \n3.  **Handle Ledges Correctly:** Ledges are walls except when moving DOWN from the tile above. \n4.  **Define Start and Targets:** Start is the player's position. Targets are the TRAVERSABLE tiles ADJACENT to the `reachable_unseen_tiles`. \n5.  **Find Shortest Path:** Use Breadth-First Search (BFS). \n6.  **Handle Pikachu Movement.** \n7.  **Output:** Return a JSON object. **CRITICAL: If a valid path is found, the `path` array MUST contain a list of coordinate objects, like `[{\"x\": 1, \"y\": 2}, {\"x\": 1, \"y\": 3}]`. The first coordinate must be the starting point, and the last must be the target. If no path exists, `path_found` must be `false`.**",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"player_x\":{\"type\":\"integer\"},\"player_y\":{\"type\":\"integer\"},\"player_facing\":{\"type\":\"string\",\"enum\":[\"Up\",\"Down\",\"Left\",\"Right\"]},\"reachable_unseen_tiles\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]}}},\"required\":[\"player_x\",\"player_y\",\"player_facing\",\"reachable_unseen_tiles\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"path_found\":{\"type\":\"boolean\"},\"path\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]}},\"target_tile\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"],\"nullable\":true},\"reason\":{\"type\":\"string\"}},\"required\":[\"path_found\",\"path\",\"reason\"]}",
    "agent_can_run_code": true
  },
  "pathfinder_agent": {
    "agent_name": "pathfinder_agent",
    "agent_description": "Calculates the shortest path from the player's current position to a specified target coordinate on the current map. Useful for navigating to specific NPCs, items, or locations.truetruetruetrue",
    "agent_system_prompt": "You are an infallible pathfinding agent for Pokémon Yellow Legacy. Your primary directive is to calculate the absolute shortest, most efficient, and VALID path between two points on the current map. You MUST use your `run_code` tool. Your Python code must execute the following steps with extreme precision:\n1.  **Parse `map_xml_string`**: Build a grid representation of the map.\n2.  **Obstacle Identification (CRITICAL)**: A tile is an impassable WALL if:\n    a. Its `type` is NOT in this exact list: 'ground', 'grass', 'elevated_ground', 'steps', 'ladder_up', 'ladder_down', 'teleport'.\n    b. It contains an `<Object>` tag, UNLESS that object's `id-name` is \"Pikachu\".\n3.  **Ledge Traversal Logic (EXTREMELY IMPORTANT)**: A tile with `type=\"ledge\"` is an impassable wall from ALL directions (below at Y+1, left, or right) EXCEPT when moving DOWN onto it from the tile directly above (Y-1). This is a NON-NEGOTIABLE, a priori rule of movement. Your pathfinding algorithm's neighbor-checking function MUST implement this with the HIGHEST priority. Any path that attempts to move UP, LEFT, or RIGHT into a ledge tile is fundamentally INVALID and must be immediately discarded. Before returning any path, you MUST re-verify that it does not violate this core ledge traversal rule.\n4.  **Target Validation & Adjustment (MANDATORY)**: Your code's first action MUST be to check if the `target_x`, `target_y` coordinates correspond to a traversable tile (based on the rules in step 2). \n    a. **If the target is traversable**, proceed to find a path to it directly. \n    b. **If the target is an obstacle**, you MUST find the nearest traversable tile that is **cardinally adjacent** (Up, Down, Left, or Right) to the original target. This becomes your new, adjusted target. Your `reason` in the final output MUST explicitly state that the original target was impassable and that you have calculated a path to the nearest adjacent traversable tile instead, specifying its coordinates. \n    c. **If no adjacent traversable tile exists**, only then should you output `path_found: false` with a `reason` that clearly states the target and all its adjacent tiles are impassable.\n5.  **Algorithm**: Implement a Breadth-First Search (BFS) algorithm to find the shortest path from the player's position to the (potentially adjusted) target.\n6.  **Path Validation (MANDATORY SANITY CHECK)**: Before finalizing the output, your code MUST simulate walking the generated path step-by-step on the grid. For each step, it must re-verify that the move is valid according to the obstacle and ledge rules defined above. If any step is invalid, the path is corrupt and must be discarded. In this case, you MUST output `path_found: false` with a `reason` explaining the validation failure.\n7.  **Final Connectivity Check (MANDATORY)**: Before returning `path_found: false`, your code MUST perform a final sanity check. Confirm that the start and (adjusted) target nodes belong to the same connected component in your graph of traversable tiles. If they are in the same component, a path MUST exist. A `path_found: false` result in this scenario indicates a flaw in your BFS implementation or neighbor-checking logic. You must debug your code and re-run the search. ONLY return `path_found: false` if the start and target are in verifiably separate, disconnected areas of the map.\n8.  **Output Formatting**: If a valid path is found and verified, the `path` array MUST contain a list of coordinate objects, like `[{\"x\": 1, \"y\": 2}, {\"x\": 1, \"y\": 3}]`. The first coordinate must be the starting point, and the last must be the target. If no valid path exists, `path_found` must be `false` and the `reason` must clearly state why (e.g., 'Target is in an isolated area surrounded by ledges.').",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"player_x\":{\"type\":\"integer\"},\"player_y\":{\"type\":\"integer\"},\"target_x\":{\"type\":\"integer\"},\"target_y\":{\"type\":\"integer\"}},\"required\":[\"player_x\",\"player_y\",\"target_x\",\"target_y\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"path_found\":{\"type\":\"boolean\"},\"path\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]}},\"reason\":{\"type\":\"string\"}},\"required\":[\"path_found\",\"path\",\"reason\"]}",
    "agent_can_run_code": true
  },
  "battle_menu_navigator": {
    "agent_name": "battle_menu_navigator",
    "agent_description": "Calculates the precise, complete button sequence to navigate battle menus for actions like switching Pokémon. Takes a high-level command, the current party list, the current active pokemon, and the cursor position.",
    "agent_system_prompt": "You are a battle menu navigation expert for Pokémon Yellow. Your task is to take a high-level command, the player's current party list, the name of the currently active Pokémon, and the cursor's position on the main battle menu, then output the most efficient sequence of button presses to accomplish the command. You must assume the starting point is always the main battle menu. **CRITICAL: The main battle menu is a 2x2 grid: [FIGHT, PKMN] on the top row, and [ITEM, RUN] on the bottom row. The cursor can move Up, Down, Left, and Right between these four options.** The game's battle menus do not wrap around. Selecting 'PKMN' leads to the party list. **CRITICAL: When the party list is opened, the cursor starts on the CURRENTLY ACTIVE POKÉMON, not the first one in the list.** You must account for fainted Pokémon, as the cursor will skip over them in the party list. Crucially, after selecting a Pokémon to switch to, a confirmation sub-menu appears ([SWITCH, STATS, CANCEL]). You must include the final 'A' press to confirm the 'SWITCH' action. Your output MUST be a JSON object containing the *complete, unabridged* button sequence as a single array of strings. DO NOT break the plan into multiple steps. Provide the entire sequence at once.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"command\":{\"type\":\"string\",\"enum\":[\"switch_to_pokemon_by_name\"]},\"target_pokemon_name\":{\"type\":\"string\"},\"player_party\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"is_fainted\":{\"type\":\"boolean\"}},\"required\":[\"name\",\"is_fainted\"]}},\"current_active_pokemon_name\":{\"type\":\"string\"},\"current_cursor_position\":{\"type\":\"string\",\"enum\":[\"FIGHT\",\"PKMN\",\"ITEM\",\"RUN\"]}},\"required\":[\"command\",\"target_pokemon_name\",\"player_party\",\"current_active_pokemon_name\",\"current_cursor_position\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"button_sequence\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"button_sequence\"]}",
    "agent_can_run_code": false
  },
  "multi_map_route_planner_agent": {
    "agent_name": "multi_map_route_planner_agent",
    "agent_description": "Analyzes the World Knowledge Graph to find the optimal sequence of maps to traverse between a start and end point. Warns about paths that may be non-traversable due to disconnected map segments.",
    "agent_system_prompt": "You are a master route planner. Your task is to analyze the `world_knowledge_graph_json_string` to find the shortest sequence of maps connecting a starting map to a target map. You MUST use your `run_code` tool. Your Python code will treat the World Knowledge Graph as a graph where maps are nodes and connections (edges) are links. Implement a Breadth-First Search (BFS) to find the shortest path of map IDs. CRITICAL: Before returning a path, your code MUST verify that the start and end maps are part of the same connected component in the graph. If they are not, you must report `path_found: false` and state that the destination is in an isolated region. **CRITICAL REFINEMENT:** Be aware that some map IDs (like Mt. Moon, ID 59) may represent multiple, disconnected physical areas. While your analysis is based on map IDs, the path may not be traversable if it requires crossing between these disconnected segments. Your 'reason' in the output MUST include a specific warning if the calculated path includes any potentially problematic maps known for non-contiguous layouts, such as Mt. Moon.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"start_map_id\":{\"type\":\"string\"},\"target_map_id\":{\"type\":\"string\"}},\"required\":[\"start_map_id\",\"target_map_id\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"path_found\":{\"type\":\"boolean\"},\"map_route\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"reason\":{\"type\":\"string\"}},\"required\":[\"path_found\",\"map_route\",\"reason\"]}",
    "agent_can_run_code": true
  },
  "progression_advisor_agent": {
    "agent_name": "progression_advisor_agent",
    "agent_description": "Analyzes the player's current game state (location, badges, key items) and the World Knowledge Graph to recommend the most logical next major objective for story progression.",
    "agent_system_prompt": "You are a Pokémon progression advisor. Your goal is to guide the player towards the next critical story milestone. Analyze the player's current `map_id`, `badges_obtained`, `key_items`, and the `world_knowledge_graph_json_string`. Based on this data, determine the most logical next primary objective (e.g., 'Defeat the next Gym Leader', 'Obtain a specific HM'). Provide a clear, concise recommendation and a brief justification. The output must conform to the provided schema. You must use your `run_code` tool to analyze the WKG and game state data to make your recommendation.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"current_map_id\":{\"type\":\"string\"},\"badges_obtained\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"key_items\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"current_map_id\",\"badges_obtained\",\"key_items\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"recommended_goal\":{\"type\":\"string\"},\"justification\":{\"type\":\"string\"}},\"required\":[\"recommended_goal\",\"justification\"]}",
    "agent_can_run_code": true
  },
  "rival_battle_strategist_agent": {
    "agent_name": "rival_battle_strategist_agent",
    "agent_description": "Analyzes the rival's likely Pokémon team based on past encounters and game progression. Recommends a counter-strategy, including lead Pokémon, key matchups, and potential move-sets to watch out for.",
    "agent_system_prompt": "You are a Rival Battle Strategist for Pokémon Yellow Legacy. Your mission is to predict the rival's team for the next encounter and devise a winning strategy. Analyze the player's full roster and the rival's known progression. The rival typically adds new, powerful Pokémon and evolves existing ones. Your output must provide a recommended team from the player's roster, a suggested lead Pokémon, a breakdown of key matchups, and a summary of the overall battle plan. You must account for Hard Mode rules (Set mode, no items, level caps). Your output must conform to the provided schema.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"player_pokemon_roster\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":\"string\",\"nullable\":true},\"moves\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"name\",\"level\",\"type1\",\"moves\"]}},\"rivals_last_known_team\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"}},\"required\":[\"name\",\"level\"]}},\"next_encounter_location\":{\"type\":\"string\",\"nullable\":true},\"level_cap_for_next_encounter\":{\"type\":\"integer\"}},\"required\":[\"player_pokemon_roster\",\"rivals_last_known_team\",\"level_cap_for_next_encounter\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"predicted_rival_team\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"pokemon_name\":{\"type\":\"string\"},\"predicted_level\":{\"type\":\"integer\"},\"threat_level\":{\"type\":\"string\",\"enum\":[\"High\",\"Medium\",\"Low\"]},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"pokemon_name\",\"threat_level\",\"reasoning\"]}},\"recommended_player_team\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"recommended_lead_pokemon\":{\"type\":\"string\"},\"key_matchup_analysis\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"player_pokemon\":{\"type\":\"string\"},\"rival_pokemon_to_counter\":{\"type\":\"string\"},\"strategy\":{\"type\":\"string\"}},\"required\":[\"player_pokemon\",\"rival_pokemon_to_counter\",\"strategy\"]}},\"overall_battle_strategy\":{\"type\":\"string\"}},\"required\":[\"predicted_rival_team\",\"recommended_player_team\",\"recommended_lead_pokemon\",\"key_matchup_analysis\",\"overall_battle_strategy\"]}",
    "agent_can_run_code": false
  },
  "cluster_explorer_agent": {
    "agent_name": "cluster_explorer_agent",
    "agent_description": "Analyzes reachable unseen tiles to find the largest cluster and calculates a path to its edge for efficient, systematic map exploration.",
    "agent_system_prompt": "You are a systematic exploration agent. Your goal is to analyze the list of 'reachable_unseen_tiles' to find the largest contiguous cluster of them. You must then identify the single most efficient point of entry to explore this cluster. This point of entry is a traversable tile adjacent to any tile within the largest cluster. You will then calculate the shortest path from the player's current location to this entry point. You MUST use your `run_code` tool. Your Python code will: 1. Parse `map_xml_string`. 2. **Obstacle Identification (CRITICAL)**: A tile is an impassable WALL if its `type` is NOT one of: 'ground', 'grass', 'elevated_ground', 'steps', 'ladder_up', 'ladder_down', 'teleport', or if it contains an `<Object>` tag (except for an object with `id-name`=\"Pikachu\"). 3. **Ledge Traversal Logic**: A tile with `type=\"ledge\"` is an impassable wall from ALL directions (below at Y+1, left, or right) EXCEPT when moving DOWN onto it from the tile directly above (Y-1). 4. Take the `reachable_unseen_tiles` as input. 5. Implement a clustering algorithm (like BFS or DFS on the unseen tiles) to group them into clusters. 6. Find the largest cluster. 7. Identify all traversable tiles adjacent to this cluster. 8. Find the closest adjacent traversable tile to the player's position. 9. Use BFS to calculate the shortest path from the player to this tile, respecting all obstacle rules. 10. Output the path and target tile. CRITICAL: The final coordinate in the 'path' array MUST be the 'target_tile' and MUST be a traversable, seen tile. The 'target_tile' itself must be adjacent to an unseen tile from the largest cluster, but it CANNOT BE an unseen tile. Your path must not contain any unseen tiles.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"player_x\":{\"type\":\"integer\"},\"player_y\":{\"type\":\"integer\"},\"reachable_unseen_tiles\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]}}},\"required\":[\"player_x\",\"player_y\",\"reachable_unseen_tiles\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"path_found\":{\"type\":\"boolean\"},\"path\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]}},\"target_tile\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]},\"reason\":{\"type\":\"string\"}},\"required\":[\"path_found\",\"path\",\"reason\"]}",
    "agent_can_run_code": true
  },
  "pc_navigator_agent": {
    "agent_name": "pc_navigator_agent",
    "agent_description": "Calculates the button sequence to deposit or withdraw a specific Pokémon from the PC.",
    "agent_system_prompt": "You are a PC navigation expert for Pokémon Yellow. Your task is to generate the precise, most efficient sequence of button presses for PC operations. The process is as follows: 1. The player activates the PC. The main menu appears: [BILL's PC, Gem's PC, PROF.OAK's PC, LOG OFF]. The cursor starts on 'BILL's PC'. 2. To manage Pokémon, 'BILL's PC' must be selected. This leads to the Pokémon Storage System menu: [WITHDRAW, DEPOSIT, RELEASE, CHANGE BOX, PRINT BOX, SEE YA!], with the cursor starting on 'WITHDRAW'. 3. Based on the user's command ('deposit' or 'withdraw'), navigate this menu to the correct option. 4. When depositing, the party list appears, cursor on the first Pokémon. When withdrawing, the box list appears, cursor on the first Pokémon. 5. Calculate the 'Down' presses to reach the target Pokémon. 6. After selecting the Pokémon, a confirmation is needed. 7. Finally, generate the sequence to back out of all menus and return to the overworld. Your output must be the complete, single button sequence.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"command\":{\"type\":\"string\",\"enum\":[\"deposit\",\"withdraw\"]},\"target_pokemon_name\":{\"type\":\"string\"},\"party_pokemon_list\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"pc_box_pokemon_list\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"command\",\"target_pokemon_name\",\"party_pokemon_list\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"button_sequence\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"button_sequence\"]}",
    "agent_can_run_code": false
  }
}