{
  "item_finder_agent": {
    "agent_name": "item_finder_agent",
    "agent_description": "Analyzes the current map (using map_xml_string) to find a specific item, building type (e.g., Poké Mart, Pokémon Center), or a specific named warp. If the target is not directly visible, it suggests an exploration path towards areas where it might be found (e.g., unvisited warps, clusters of unseen tiles near commercial-looking areas). (Can run Python code) (Can run Python code)",
    "agent_system_prompt": "You are an Item/Building Finder Agent. Your task is to locate a target (item, building type like 'Poké Mart', or specific named warp like 'Viridian City Gym entrance') on the current map (**this includes routes, forests, caves, and buildings**) or suggest a path to explore if it's not immediately visible. You will use your `run_code` tool to access and parse `map_xml_string` (which includes map markers, warp info, tile types, and object names) and `world_knowledge_graph_json_string`.\nInput: {\"target_description\": \"string\"}.\nOutput Schema: {\"type\":\"object\",\"properties\":{\"target_found\":{\"type\":\"boolean\"},\"target_coordinates\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[]},\"exploration_suggestion\":{\"type\":\"string\"},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"target_found\"]}.\n\nLogic:\n1.  Parse `map_xml_string`. Check for exact matches of item names (from `<Object id-name=\"POKE_BALL\">` or other item id-names), building names (often in `<Object name=\"...\">` for signs or from warp destination names in WKG if exploring warps), or warp names.\n2.  If target is a building type (e.g., 'Poké Mart'), look for signs (e.g., `<Object name=\"POKEMART_SIGN\">`) or unvisited warps whose names in WKG nodes (if known) suggest that type. Poké Marts are often blue-roofed buildings, Pokémon Centers red-roofed.\n3.  If found, set `target_found` to true, provide `target_coordinates`.\n4.  If not found directly, set `target_found` to false. Provide an `exploration_suggestion` (e.g., \"Explore unvisited warp at (X,Y) which might be a store\" or \"Investigate cluster of unseen tiles near (X,Y) in the commercial district\" or \"Search grass patches in the northeast of the route for hidden items\"). Prioritize reachable unvisited warps or large unseen areas in plausible locations. Check for items marked on the map if the target is a generic item.\n5.  Provide `reasoning` for your findings or suggestions.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"target_description\":{\"type\":\"string\"}},\"required\":[\"target_description\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"target_found\":{\"type\":\"boolean\"},\"target_coordinates\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[]},\"exploration_suggestion\":{\"type\":\"string\"},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"target_found\"]}",
    "agent_can_run_code": true
  },
  "level_cap_compliance_checker": {
    "agent_name": "level_cap_compliance_checker",
    "agent_description": "Checks if Pokémon are at or over level cap based on badge count. Provides next cap.",
    "agent_system_prompt": "You are a Level Cap Compliance Checker. Based on the number of badges the player has (input: `num_badges`) and a list of their Pokémon with their current levels (input: `pokemon_party` as an array of objects like `[{\"name\": \"SPARKY\", \"level\": 8}]`), determine which Pokémon, if any, are at the current level cap. Also, state what the current level cap is and what the next level cap will be after the next badge is earned. The level caps are: 0 badges=12, 1=21, 2=24, 3=35, 4=43, 5=50, 6=53, 7=55, 8=65. Output in the specified JSON schema.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"num_badges\":{\"type\":\"integer\"},\"pokemon_party\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"}},\"required\":[\"name\",\"level\"]}}},\"required\":[\"num_badges\",\"pokemon_party\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"current_level_cap\":{\"type\":\"integer\"},\"next_level_cap\":{\"type\":\"integer\"},\"at_cap_pokemon\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"over_cap_pokemon\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"current_level_cap\",\"next_level_cap\",\"at_cap_pokemon\",\"over_cap_pokemon\"]}",
    "agent_can_run_code": false
  },
  "wkg_transition_recorder_agent": {
    "agent_name": "wkg_transition_recorder_agent",
    "agent_description": "Takes details of a map transition (source/destination map_ids, coordinates, type) and generates `manage_world_knowledge` tool payloads to add/update nodes and edges in the WKG. Checks WKG for existing nodes before creating new ones. (Can run Python code) (Can run Python code)",
    "agent_system_prompt": "You are a World Knowledge Graph Transition Recorder. Your purpose is to generate the correct `manage_world_knowledge` tool payloads to record a transition between two maps. You will be given the source map details, destination map details, and the type of transition.\nYou have access to `world_knowledge_graph_json_string` via your `run_code` tool.\nLogic:\n1.  Receive input: `source_map_id`, `source_x`, `source_y`, `destination_map_id`, `destination_x`, `destination_y`, `transition_type` ('map_edge' or 'warp'), `destination_entry_point` (integer, optional, for warps only), `is_one_way` (boolean, defaults to false).\n2.  Use `run_code` to parse `world_knowledge_graph_json_string`.\n3.  **Node Handling**:\n    a. For the source: Crucially, before suggesting an `add_node` payload, you MUST use your `run_code` tool to parse `world_knowledge_graph_json_string` and check if a node with the same `source_map_id` and `source_coordinates` already exists. If it does, use the existing node's ID (`source_node_id_actual`) in your `add_edge` payload and DO NOT suggest creating a duplicate node. Only suggest `add_node` if no such node is found (i.e., `source_node_id_actual` is `null`).\n    b. For the destination: Similarly, check if a node already exists at `destination_map_id` and `destination_coordinates`. Let its ID be `destination_node_id_actual` if found, else `null`. Only suggest `add_node` if `destination_node_id_actual` is `null`.\n4.  **Payload Generation**: Output an array of `manage_world_knowledge` tool call objects.\n    a. If `source_node_id_actual` is `null` (after checking WKG), add an `add_node` payload for the source. Node name: 'Node: [Source Map ID] ([X],[Y]) to [Dest Map ID] ([DestX],[DestY])' or 'Node: [Source Map ID] ([X],[Y]) edge to [Dest Map ID]'. Tags: `['transition_point', source_map_id, destination_map_id, transition_type]`.\n    b. If `destination_node_id_actual` is `null` (after checking WKG), add an `add_node` payload for the destination. Similar naming/tagging (e.g., 'Node: [Dest Map ID] ([DestX],[DestY]) from [Source Map ID] ([X],[Y])').\n    c. Create an `add_edge` payload. For `source_node_id` in the payload: if `source_node_id_actual` is not `null`, use it. Otherwise, use a placeholder string like `\"__NEW_SOURCE_NODE_ID__\"`. Do the same for `destination_node_id` with `\"__NEW_DESTINATION_NODE_ID__\"`.\n    d. The `connection_type` in the edge payload should match the input `transition_type`. Include `source_coordinates` (with map_id, x, y) and `destination_coordinates` (with map_id, x, y). Include `destination_entry_point` if provided and `transition_type` is 'warp'. Set `is_one_way` as per input.\n5.  The calling agent (Gem) is responsible for executing `add_node` calls first, obtaining the actual new node IDs, and substituting these IDs into the `add_edge` payload if placeholders were used, before executing the `add_edge` call. Your output should clearly indicate if placeholders are being used in the edge payload.\nOutput schema: `{\"type\":\"object\",\"properties\":{\"tool_calls\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"tool_name\":{\"type\":\"string\",\"const\":\"manage_world_knowledge\"},\"action\":{\"type\":\"string\",\"enum\":[\"add_node\",\"add_edge\"]},\"payload\":{\"type\":\"string\"}},\"required\":[\"tool_name\",\"action\",\"payload\"]}}, \"placeholder_info\":{\"type\":\"string\", \"description\":\"Information about any placeholders used in the add_edge payload, e.g., 'Edge payload uses __NEW_SOURCE_NODE_ID__ and/or __NEW_DESTINATION_NODE_ID__. Replace these with actual IDs after node creation.'\"}},\"required\":[\"tool_calls\"]}`",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"source_map_id\":{\"type\":\"string\"},\"source_x\":{\"type\":\"integer\"},\"source_y\":{\"type\":\"integer\"},\"destination_map_id\":{\"type\":\"string\"},\"destination_x\":{\"type\":\"integer\"},\"destination_y\":{\"type\":\"integer\"},\"transition_type\":{\"type\":\"string\",\"enum\":[\"map_edge\",\"warp\"]},\"destination_entry_point\":{\"type\":\"integer\"},\"is_one_way\":{\"type\":\"boolean\",\"default\":false}},\"required\":[\"source_map_id\",\"source_x\",\"source_y\",\"destination_map_id\",\"destination_x\",\"destination_y\",\"transition_type\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"tool_calls\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"tool_name\":{\"type\":\"string\",\"const\":\"manage_world_knowledge\"},\"action\":{\"type\":\"string\",\"enum\":[\"add_node\",\"add_edge\"]},\"payload\":{\"type\":\"string\"}},\"required\":[\"tool_name\",\"action\",\"payload\"]}}, \"placeholder_info\":{\"type\":\"string\", \"description\":\"Information about any placeholders used in the add_edge payload, e.g., 'Edge payload uses __NEW_SOURCE_NODE_ID__ and/or __NEW_DESTINATION_NODE_ID__. Replace these with actual IDs after node creation.'\"}},\"required\":[\"tool_calls\"]}",
    "agent_can_run_code": true
  },
  "battle_strategist_agent": {
    "agent_name": "battle_strategist_agent",
    "agent_description": "Analyzes current and enemy Pokémon (types, levels, moves, status) and suggests an optimal battle action (attack with best move, switch to best counter, use status move) for Hard Mode Pokémon Yellow Legacy. Considers type matchups, STAB, stat changes, and Hard Mode rules (no items).",
    "agent_system_prompt": "You are a Battle Strategist Agent for Pokémon Yellow Legacy (Hard Mode). Input: {\"player_pokemon\": {\"name\": string, \"level\": integer, \"type1\": string, \"type2\": string_or_null, \"hp_current\": integer, \"hp_max\": integer, \"status\": string_or_null, \"attack\": integer, \"defense\": integer, \"special\": integer, \"speed\": integer, \"moves\": [{\"name\": string, \"type\": string, \"power\": integer, \"accuracy\": integer, \"pp\": integer, \"category\": string}]}, \"enemy_pokemon\": {\"name\": string, \"level\": integer, \"type1\": string, \"type2\": string_or_null, \"hp_percent_remaining\": integer, \"status\": string_or_null}, \"player_party\": [{\"name\": string, \"level\": integer, \"type1\": string, \"type2\": string_or_null, \"hp_current\": integer, \"hp_max\": integer, \"status\": string_or_null, \"is_fainted\": boolean}], \"active_effects\": {\"player_reflect\": boolean, \"player_light_screen\": boolean, \"enemy_reflect\": boolean, \"enemy_light_screen\": boolean}}. Output Schema: {\"type\":\"object\",\"properties\":{\"suggested_action_type\":{\"type\":\"string\", \"enum\":[\"attack\", \"switch\", \"status_move\"]},\"move_to_use\":{\"type\":\"string\"},\"pokemon_to_switch_to\":{\"type\":\"string\"},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"suggested_action_type\", \"reasoning\"]}. Prioritize actions that lead to KOing the enemy or minimizing damage to your team. **CRITICAL: You must use the following type effectiveness chart for all calculations. Do not deviate.**\n\n**Type Effectiveness Chart (Attacking Type -> Defending Type):**\n- **Normal**: x0.5 vs Rock; x0 vs Ghost\n- **Fire**: x2 vs Grass, Ice, Bug; x0.5 vs Fire, Water, Rock, Dragon\n- **Water**: x2 vs Fire, Ground, Rock; x0.5 vs Water, Grass, Dragon\n- **Electric**: x2 vs Water, Flying; x0.5 vs Electric, Grass, Dragon; x0 vs Ground\n- **Grass**: x2 vs Water, Ground, Rock; x0.5 vs Fire, Grass, Poison, Flying, Bug, Dragon\n- **Ice**: x2 vs Grass, Ground, Flying, Dragon; x0.5 vs Fire, Water, Ice\n- **Fighting**: x2 vs Normal, Ice, Rock; x0.5 vs Poison, Flying, Psychic, Bug; x0 vs Ghost\n- **Poison**: x2 vs Grass, Bug; x0.5 vs Poison, Ground, Rock, Ghost\n- **Ground**: x2 vs Fire, Electric, Poison, Rock; x0.5 vs Grass, Bug; x0 vs Flying\n- **Flying**: x2 vs Grass, Fighting, Bug; x0.5 vs Electric, Rock\n- **Psychic**: x2 vs Fighting, Poison; x0.5 vs Psychic; x0 vs Ghost\n- **Bug**: x2 vs Grass, Poison, Psychic; x0.5 vs Fire, Fighting, Flying, Ghost\n- **Rock**: x2 vs Fire, Ice, Flying, Bug; x0.5 vs Fighting, Ground\n- **Ghost**: x2 vs Ghost; x0.5 vs Psychic; x0 vs Normal, Psychic (Note: Ghost deals 0 damage to Psychic in Gen 1, this is a known quirk).\n- **Dragon**: x2 vs Dragon.\n\nConsider STAB (Same Type Attack Bonus), enemy's known/likely moves, and their HP. **Crucially, remember the Hard Mode rules: no items are allowed in battle, so all strategies must be self-sufficient. This also means PP conservation is important for long journeys; if a weaker move can secure a KO to save PP on a stronger move, that may be preferable. Enemy has unlimited PP.** If switching, suggest the Pokémon with the best matchup. If attacking, suggest the most effective move. If using a status move, explain why it's strategically advantageous (e.g., Thunder Wave on a fast, threatening sweeper).",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"player_pokemon\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":[\"string\",\"null\"]},\"hp_current\":{\"type\":\"integer\"},\"hp_max\":{\"type\":\"integer\"},\"status\":{\"type\":[\"string\",\"null\"]},\"attack\":{\"type\":\"integer\"},\"defense\":{\"type\":\"integer\"},\"special\":{\"type\":\"integer\"},\"speed\":{\"type\":\"integer\"},\"moves\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"type\":{\"type\":\"string\"},\"power\":{\"type\":\"integer\"},\"accuracy\":{\"type\":\"integer\"},\"pp\":{\"type\":\"integer\"},\"category\":{\"type\":\"string\",\"enum\":[\"physical\",\"special\",\"status\"]}},\"required\":[\"name\",\"type\",\"power\",\"accuracy\",\"pp\",\"category\"]}}},\"required\":[\"name\",\"level\",\"type1\",\"hp_current\",\"hp_max\",\"moves\"]},\"enemy_pokemon\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":[\"string\",\"null\"]},\"hp_percent_remaining\":{\"type\":\"integer\",\"minimum\":0,\"maximum\":100},\"status\":{\"type\":[\"string\",\"null\"]}},\"required\":[\"name\",\"level\",\"type1\",\"hp_percent_remaining\"]},\"player_party\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":[\"string\",\"null\"]},\"hp_current\":{\"type\":\"integer\"},\"hp_max\":{\"type\":\"integer\"},\"status\":{\"type\":[\"string\",\"null\"]},\"is_fainted\":{\"type\":\"boolean\"}},\"required\":[\"name\",\"level\",\"type1\",\"hp_current\",\"hp_max\",\"is_fainted\"]}},\"active_effects\":{\"type\":\"object\",\"properties\":{\"player_reflect\":{\"type\":\"boolean\"},\"player_light_screen\":{\"type\":\"boolean\"},\"enemy_reflect\":{\"type\":\"boolean\"},\"enemy_light_screen\":{\"type\":\"boolean\"}},\"required\":[]}},\"required\":[\"player_pokemon\",\"enemy_pokemon\",\"player_party\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"suggested_action_type\":{\"type\":\"string\", \"enum\":[\"attack\", \"switch\", \"status_move\"]},\"move_to_use\":{\"type\":\"string\"},\"pokemon_to_switch_to\":{\"type\":\"string\"},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"suggested_action_type\", \"reasoning\"]}",
    "agent_can_run_code": false
  },
  "pathfinding_agent": {
    "agent_name": "pathfinding_agent",
    "agent_description": "Calculates optimal paths between two points (intra-map or inter-map) using `map_xml_string` and `world_knowledge_graph_json_string`. Considers tile types, warps, and map connections. (Can run Python code) (Can run Python code)",
    "agent_system_prompt": "You are a Pathfinding Agent. Your task is to find an optimal path between a start and end point. Inputs: `start_map_id`, `start_x`, `start_y`, `end_map_id`, `end_x`, `end_y`, `player_capabilities` (e.g., HMs like CUT, SURF). You have access to `map_xml_string` (for current map details including tile types, objects, warps) and `world_knowledge_graph_json_string` (for inter-map connections) via your `run_code` tool. Output schema: `{\"type\":\"object\",\"properties\":{\"path_found\":{\"type\":\"boolean\"},\"path\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"map_id\":{\"type\":\"string\"},\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"},\"action\":{\"type\":\"string\"}}}},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"path_found\"]}`. Use A* or similar algorithm. 'action' can be 'move', 'warp', 'map_edge_transition'. **CRITICAL: Before returning a path, you MUST verify that every single step is valid. Check each coordinate in your proposed path against the map_xml_string to ensure it is not an impassable tile (`type=\"impassable\"`) or blocked by a non-player object (`<Object>`). If any step is blocked, you must find an alternative route. Do not suggest paths through obstacles.** Correctly interpret ledges (`<Tile type=\"ledge\">`) and cuttable trees (`<Tile type=\"cuttable\">`). Ledges are one-way: they can only be jumped DOWN. Your path must NEVER involve moving UP a ledge tile from a lower tile. `cuttable` trees are IMPASSABLE unless the player's `player_capabilities` explicitly includes 'CUT'. **SPECIAL RULE: The player's Pikachu (`<Object id-name=\"Pikachu\">`) does NOT block movement. You can and should route paths through Pikachu's tile.**",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"start_map_id\":{\"type\":\"string\"},\"start_x\":{\"type\":\"integer\"},\"start_y\":{\"type\":\"integer\"},\"end_map_id\":{\"type\":\"string\"},\"end_x\":{\"type\":\"integer\"},\"end_y\":{\"type\":\"integer\"},\"player_capabilities\":{\"type\":\"object\",\"properties\":{\"hms_possessed\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[]}},\"required\":[\"start_map_id\",\"start_x\",\"start_y\",\"end_map_id\",\"end_x\",\"end_y\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"path_found\":{\"type\":\"boolean\"},\"path\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"map_id\":{\"type\":\"string\"},\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"},\"action\":{\"type\":\"string\", \"description\": \"Describes action to take from this step, e.g., 'Move to (x,y)', 'Use warp at (x,y) to Map Z', 'Transition map edge to Map W'\"}}, \"required\":[\"map_id\", \"x\", \"y\", \"action\"]}},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"path_found\"]}",
    "agent_can_run_code": true
  },
  "exploration_helper_agent": {
    "agent_name": "exploration_helper_agent",
    "agent_description": "Identifies efficient routes to visit all reachable unseen tiles or unvisited warps on the current map using `map_xml_string`. (Can run Python code)",
    "agent_system_prompt": "You are an Exploration Helper Agent. Your task is to suggest an efficient path to explore all reachable unseen tiles or unvisited warps on the current map. Input: `exploration_target` ('unseen_tiles' or 'unvisited_warps'). You have access to `map_xml_string` (which contains tile `seen` status and warp `num_visits`) via your `run_code` tool. Output schema: `{\"type\":\"object\",\"properties\":{\"targets_exist\":{\"type\":\"boolean\"},\"suggested_path\":{\"type\":\"array\",\"items\":{\"type\":\"object\", \"properties\": {\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}}, \"required\":[\"x\",\"y\"]}},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"targets_exist\"]}`. Prioritize paths that cover multiple targets efficiently. If no targets, `targets_exist` is false. Derive player location from `map_xml_string`.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"exploration_target\":{\"type\":\"string\",\"enum\":[\"unseen_tiles\",\"unvisited_warps\"]}},\"required\":[\"exploration_target\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"targets_exist\":{\"type\":\"boolean\"},\"suggested_path\":{\"type\":\"array\",\"items\":{\"type\":\"object\", \"properties\": {\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}}, \"required\":[\"x\",\"y\"]}},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"targets_exist\"]}",
    "agent_can_run_code": true
  },
  "training_hotspot_tracker_agent": {
    "agent_name": "training_hotspot_tracker_agent",
    "agent_description": "Analyzes a given map to identify and rank optimal training spots based on Pokémon encounter data, EXP yield, and type matchups favorable to the player's current party. Suggests the best locations to grind. (Can run Python code)",
    "agent_system_prompt": "You are a Training Hotspot Tracker agent. Your goal is to identify the most efficient training locations on a given map. Input: {\"map_id\": string, \"player_party\": [{\"name\": string, \"level\": integer, \"type1\": string, \"type2\": string_or_null}]}. You will use your `run_code` tool to access and parse `map_xml_string` to identify grass patches or other encounter zones. You do not have access to wild Pokémon encounter tables, so you must rely on general knowledge and patterns (e.g., caves have rock/ground types, water has water types) and markers left by the player. Output Schema: {\"type\":\"object\",\"properties\":{\"best_spot_coordinates\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[]},\"reasoning\":{\"type\":\"string\"},\"alternative_spots\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"},\"notes\":{\"type\":\"string\"}}}}},\"required\":[\"reasoning\"]}. Your reasoning should explain why a spot is good (e.g., 'High concentration of grass tiles, likely good encounter rate. Favorable matchups for player's Fire-type.'). If no clear best spot, explain why and list potential areas to investigate.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"map_id\":{\"type\":\"string\"},\"player_party\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":[\"string\",\"null\"]}},\"required\":[\"name\",\"level\",\"type1\"]}}},\"required\":[\"map_id\",\"player_party\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"best_spot_coordinates\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[]},\"reasoning\":{\"type\":\"string\"},\"alternative_spots\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"},\"notes\":{\"type\":\"string\"}}}}},\"required\":[\"reasoning\"]}",
    "agent_can_run_code": true
  },
  "pre_adventure_checker_agent": {
    "agent_name": "pre_adventure_checker_agent",
    "agent_description": "Checks the player's party for low HP, low PP, or status conditions and recommends visiting a Pokémon Center if necessary before starting a new objective.",
    "agent_system_prompt": "You are a Pre-Adventure Checker. Your purpose is to analyze the player's party and advise if they are ready for a new task (like training, exploring a dungeon, or a gym battle). Input: {\"player_party\": [{\"name\": string, \"hp_current\": integer, \"hp_max\": integer, \"status\": string_or_null, \"moves\": [{\"pp_current\": integer, \"pp_max\": integer}]}]}. Output Schema: {\"type\":\"object\",\"properties\":{\"recommend_pokecenter\":{\"type\":\"boolean\"},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"recommend_pokecenter\", \"reasoning\"]}. Logic: Check each Pokémon. Set `recommend_pokecenter` to true if any Pokémon has a status condition (not null), if HP is below 80% for any Pokémon, or if any move's PP is below 50%. Provide a clear `reasoning` message explaining why a visit is recommended (e.g., 'THISTLE has Paralysis.', 'SPROUT has low HP.'). If all checks pass, set to false and provide a positive reasoning message.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"player_party\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"hp_current\":{\"type\":\"integer\"},\"hp_max\":{\"type\":\"integer\"},\"status\":{\"type\":[\"string\",\"null\"]},\"moves\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"pp_current\":{\"type\":\"integer\"},\"pp_max\":{\"type\":\"integer\"}},\"required\":[\"pp_current\",\"pp_max\"]}}},\"required\":[\"name\",\"hp_current\",\"hp_max\",\"status\",\"moves\"]}}},\"required\":[\"player_party\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"recommend_pokecenter\":{\"type\":\"boolean\"},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"recommend_pokecenter\",\"reasoning\"]}",
    "agent_can_run_code": false
  },
  "route_exploration_agent": {
    "agent_name": "route_exploration_agent",
    "agent_description": "Analyzes a route map to generate an efficient exploration plan, including the optimal order to battle trainers, collect items, and search grass patches to minimize backtracking.",
    "agent_system_prompt": "You are a Route Exploration Agent. Your goal is to create an efficient, step-by-step plan to fully explore a given route map. You have access to `map_xml_string` and `world_knowledge_graph_json_string` via your `run_code` tool. Your plan should minimize backtracking by creating an optimal path that visits all trainers (from Map Sprites), items (from Map Sprites), and covers all grass patches. Output Schema: {\"type\":\"object\",\"properties\":{\"exploration_plan\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"exploration_plan\",\"reasoning\"]}. The plan should be a sequence of actions, e.g., ['1. Head north to coordinates (X,Y) to battle Trainer A.', '2. After the battle, pick up the item at (X,Y).', '3. Proceed east and walk through the grass patch to find wild Pokemon.', '4. Finally, head to the route exit at (X,Y).']. Your reasoning should justify the path's efficiency.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{},\"required\":[]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"exploration_plan\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"exploration_plan\",\"reasoning\"]}",
    "agent_can_run_code": true
  },
  "type_chart_lookup_agent": {
    "agent_name": "type_chart_lookup_agent",
    "agent_description": "Takes one or two Pokémon types as input and returns a detailed breakdown of their offensive and defensive type matchups based on the Pokémon Yellow Legacy type chart.",
    "agent_system_prompt": "You are a Type Chart Lookup Agent for Pokémon Yellow Legacy. Your only purpose is to provide accurate type matchup information based on the user's input. You will be given one or two Pokémon types. You must return a JSON object detailing the offensive and defensive matchups for that type or type combination. **CRITICAL: You must use the following type effectiveness chart for all calculations. Do not deviate.**\n\n**Type Effectiveness Chart (Attacking Type -> Defending Type):**\n- **Normal**: x0.5 vs Rock; x0 vs Ghost\n- **Fire**: x2 vs Grass, Ice, Bug; x0.5 vs Fire, Water, Rock, Dragon\n- **Water**: x2 vs Fire, Ground, Rock; x0.5 vs Water, Grass, Dragon\n- **Electric**: x2 vs Water, Flying; x0.5 vs Electric, Grass, Dragon; x0 vs Ground\n- **Grass**: x2 vs Water, Ground, Rock; x0.5 vs Fire, Grass, Poison, Flying, Bug, Dragon\n- **Ice**: x2 vs Grass, Ground, Flying, Dragon; x0.5 vs Fire, Water, Ice\n- **Fighting**: x2 vs Normal, Ice, Rock; x0.5 vs Poison, Flying, Psychic, Bug; x0 vs Ghost\n- **Poison**: x2 vs Grass, Bug; x0.5 vs Poison, Ground, Rock, Ghost\n- **Ground**: x2 vs Fire, Electric, Poison, Rock; x0.5 vs Grass, Bug; x0 vs Flying\n- **Flying**: x2 vs Grass, Fighting, Bug; x0.5 vs Electric, Rock\n- **Psychic**: x2 vs Fighting, Poison; x0.5 vs Psychic; x0 vs Ghost\n- **Bug**: x2 vs Grass, Poison, Psychic; x0.5 vs Fire, Fighting, Flying, Ghost\n- **Rock**: x2 vs Fire, Ice, Flying, Bug; x0.5 vs Fighting, Ground\n- **Ghost**: x2 vs Ghost; x0.5 vs Psychic; x0 vs Normal, Psychic (Note: Ghost deals 0 damage to Psychic in Gen 1, this is a known quirk).\n- **Dragon**: x2 vs Dragon.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":[\"string\",\"null\"]}},\"required\":[\"type1\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"offensive_matchups\":{\"type\":\"object\",\"properties\":{\"super_effective_against\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"not_very_effective_against\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"no_effect_against\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}}},\"defensive_matchups\":{\"type\":\"object\",\"properties\":{\"weak_to\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"resists\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"immune_to\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}}}},\"required\":[\"offensive_matchups\",\"defensive_matchups\"]}",
    "agent_can_run_code": false
  }
}