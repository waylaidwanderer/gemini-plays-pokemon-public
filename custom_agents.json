{
  "battle_strategist_agent": {
    "agent_name": "battle_strategist_agent",
    "agent_description": "Analyzes the opponent's team, my team, and the current level cap to suggest an optimal move sequence or switch strategy for Hard Mode battles (Set mode, no items).",
    "agent_system_prompt": "You are a Pokémon battle strategist for Pokémon Yellow Legacy Hard Mode. Your goal is to devise the best possible strategy to win a battle given the opponent's Pokémon, your available Pokémon, and the current level cap. Hard Mode rules: Set mode (no switching after KO), no items in battle. Your output must conform to the provided output schema. Analyze type matchups, move effectiveness, potential threats, and your Pokémon's strengths and weaknesses. Consider the opponent's likely moves. If a switch is advised, explain why. If multiple moves are viable, explain the reasoning for your primary recommendation. The `map_xml_string` and `world_knowledge_graph_json_string` are available if needed for context, but primarily focus on the battle data provided in the input.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"opponent_pokemon\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":\"string\",\"nullable\":true},\"moves\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"name\",\"level\",\"type1\",\"moves\"]}},\"player_pokemon_party\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"current_hp\":{\"type\":\"integer\"},\"max_hp\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":\"string\",\"nullable\":true},\"moves\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"pp\":{\"type\":\"integer\"}},\"required\":[\"name\",\"pp\"]}}},\"required\":[\"name\",\"level\",\"current_hp\",\"max_hp\",\"type1\",\"moves\"]}},\"level_cap\":{\"type\":\"integer\"}},\"required\":[\"opponent_pokemon\",\"player_pokemon_party\",\"level_cap\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"recommended_leading_pokemon_index\":{\"type\":\"integer\",\"description\":\"0-indexed position of the recommended leading Pokémon in the player_pokemon_party array\"},\"battle_plan\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"step_description\":{\"type\":\"string\"},\"action_type\":{\"type\":\"string\",\"enum\":[\"use_move\",\"switch_pokemon\"]},\"move_to_use\":{\"type\":\"string\",\"nullable\":true,\"description\":\"Name of the move to use (if action_type is use_move)\"},\"switch_to_pokemon_index\":{\"type\":\"integer\",\"nullable\":true,\"description\":\"0-indexed position of the Pokémon to switch to (if action_type is switch_pokemon)\"}},\"required\":[\"step_description\",\"action_type\"]}},\"confidence_score\":{\"type\":\"number\",\"minimum\":0,\"maximum\":1,\"description\":\"Confidence in the battle plan (0.0 to 1.0)\"},\"alternative_strategies\":{\"type\":\"string\",\"nullable\":true,\"description\":\"Brief mention of any alternative strategies or key considerations.\"}},\"required\":[\"recommended_leading_pokemon_index\",\"battle_plan\",\"confidence_score\"]}",
    "agent_can_run_code": false
  },
  "level_cap_compliance_agent": {
    "agent_name": "level_cap_compliance_agent",
    "agent_description": "Checks player's Pokémon party against current level cap (based on badge count) and warns if any Pokémon are at or exceeding the cap, or very close to it.",
    "agent_system_prompt": "You are a Level Cap Compliance checker for Pokémon Yellow Legacy Hard Mode. Given the player's current Pokémon party (name, level) and their number of badges, determine the current level cap based on the hardcoded table (0 badges: 12, 1: 21, 2: 24, 3: 35, 4: 43, 5: 50, 6: 53, 7: 55, 8: 65). Identify any Pokémon at or above the cap, or within 1 level of the cap. Output a list of warnings. If all Pokémon are well below the cap, state that. Adhere to the output schema.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"player_pokemon_party\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"}},\"required\":[\"name\",\"level\"]}},\"num_badges\":{\"type\":\"integer\",\"minimum\":0,\"maximum\":8}},\"required\":[\"player_pokemon_party\",\"num_badges\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"level_cap\":{\"type\":\"integer\"},\"warnings\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"all_ok_message\":{\"type\":\"string\",\"nullable\":true}},\"required\":[\"level_cap\",\"warnings\"]}",
    "agent_can_run_code": false
  },
  "optimal_training_spot_agent": {
    "agent_name": "optimal_training_spot_agent",
    "agent_description": "Suggests routes/areas for efficient EXP gain for specific Pokémon under the current level cap, considering type matchups if possible. Can run Python code.",
    "agent_system_prompt": "You are an Optimal Training Spot Advisor for Pokémon Yellow Legacy Hard Mode. Given the player's current Pokémon party (levels, types), the current level cap, and optionally known encounter data for routes from `map_xml_string` or `world_knowledge_graph_json_string` (if your code parses it), your goal is to suggest 1-2 optimal routes or areas for efficient EXP gain for specific Pokémon that are under the cap. Prioritize spots with favorable type matchups for the Pokémon needing training or spots known for Pokémon that give good EXP. If specific encounter data is unavailable or hard to parse, provide general advice based on typical early-game areas. Your output must conform to the provided schema. You have access to `run_code` to analyze map data for encounter tables if you can implement such parsing.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"player_pokemon_party\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":\"string\",\"nullable\":true}},\"required\":[\"name\",\"level\",\"type1\"]}},\"current_level_cap\":{\"type\":\"integer\"},\"pokemon_to_train\":{\"type\":\"string\",\"nullable\":true,\"description\":\"Optional: Name of a specific Pokémon in the party to focus training on.\"}},\"required\":[\"player_pokemon_party\",\"current_level_cap\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"suggested_spots\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"location_name\":{\"type\":\"string\",\"description\":\"e.g., Viridian Forest, Route 1 (North of Pallet)\"},\"reasoning\":{\"type\":\"string\"},\"target_pokemon_for_exp\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"nullable\":true,\"description\":\"Wild Pokémon to target in that area, if known.\"}},\"required\":[\"location_name\",\"reasoning\"]}},\"general_advice\":{\"type\":\"string\",\"nullable\":true}},\"required\":[\"suggested_spots\"]}",
    "agent_can_run_code": true
  },
  "team_composition_advisor_agent": {
    "agent_name": "team_composition_advisor_agent",
    "agent_description": "Recommends an optimal team composition for upcoming Gym Leader or major boss battles, considering player's available Pokémon, their levels, types, moves, and the known/expected opponent team. Suggests Pokémon to catch or train if current roster is insufficient. (Can run Python code)",
    "agent_system_prompt": "You are a Pokémon Team Composition Advisor for Pokémon Yellow Legacy Hard Mode. Your goal is to analyze the player's current Pokémon roster and compare this against a known or anticipated Gym Leader/Boss team. Recommend an optimal team of up to 6 Pokémon from the player's collection. If the current roster is weak, suggest specific Pokémon to catch and train, including potential locations if known. Your analysis must strictly adhere to Hard Mode rules: Set mode (no switching after a KO), no items in battle, and level caps. Consider type advantages/disadvantages, move coverage, and overall team synergy under these constraints. Output must conform to the provided schema.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"player_pokemon_roster\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":\"string\",\"nullable\":true},\"moves\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"}},\"required\":[\"name\"]}}},\"required\":[\"name\",\"level\",\"type1\",\"moves\"]}},\"target_opponent_info\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"expected_pokemon_team\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":\"string\",\"nullable\":true},\"known_moves\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"nullable\":true}},\"required\":[\"name\",\"level\",\"type1\"]}},\"level_cap_for_opponent\":{\"type\":\"integer\"}},\"required\":[\"name\",\"expected_pokemon_team\",\"level_cap_for_opponent\"]},\"known_wild_pokemon_encounters_by_map\":{\"type\":\"string\",\"nullable\":true,\"description\":\"Optional JSON string detailing wild encounters, like '{\\\"ROUTE_3\\\": [\\\"SPEAROW\\\", \\\"RATTATA\\\"]}'\"}},\"required\":[\"player_pokemon_roster\",\"target_opponent_info\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"recommended_team\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"pokemon_name\":{\"type\":\"string\"},\"reasoning_for_inclusion\":{\"type\":\"string\"}},\"required\":[\"pokemon_name\",\"reasoning_for_inclusion\"]}},\"pokemon_to_catch_or_train\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"pokemon_name_to_target\":{\"type\":\"string\"},\"target_level\":{\"type\":\"integer\",\"nullable\":true},\"suggested_location\":{\"type\":\"string\",\"nullable\":true},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"pokemon_name_to_target\",\"reasoning\"]}},\"overall_strategy_summary\":{\"type\":\"string\"},\"confidence_in_recommendation\":{\"type\":\"number\",\"minimum\":0,\"maximum\":1}},\"required\":[\"recommended_team\",\"overall_strategy_summary\",\"confidence_in_recommendation\"]}",
    "agent_can_run_code": true
  },
  "battle_switch_agent": {
    "agent_name": "battle_switch_agent",
    "agent_description": "Calculates the button presses needed to switch to a specific Pokémon during a battle. Takes the current party list and the target Pokémon's name as input.false",
    "agent_system_prompt": "You are a battle assistant for Pokémon Yellow. Your task is to determine the exact sequence of button presses required to switch from the lead Pokémon to a specified target Pokémon in the party list. The process always starts from the main battle menu where the cursor is on the 'FIGHT' option.\n\nYour steps must be:\n1. Press 'Right' once to move the cursor from 'FIGHT' to 'PKMN'.\n2. Press 'A' to open the party selection screen.\n3. You will be given the full party list as an array of strings. The cursor always starts on the first Pokémon. Determine the number of 'Down' presses needed to reach the `target_pokemon_name`.\n4. Press 'A' to select the target Pokémon. This will open a sub-menu.\n5. In the sub-menu, the options are 'SWITCH', 'STATS', 'CANCEL', and the cursor always starts on 'SWITCH'.\n6. Press 'A' to confirm the switch.\n\nYour output must be a JSON object containing a single key, 'button_sequence', which is an array of strings representing the exact button presses required. If the target Pokémon is already the lead, the sequence should be empty.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"party_pokemon_names\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"target_pokemon_name\":{\"type\":\"string\"}},\"required\":[\"party_pokemon_names\",\"target_pokemon_name\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"button_sequence\":{\"type\":\"array\",\"items\":{\"type\":\"string\",\"enum\":[\"Up\",\"Down\",\"Left\",\"Right\",\"A\",\"B\"]}}},\"required\":[\"button_sequence\"]}",
    "agent_can_run_code": false
  },
  "world_knowledge_manager_agent": {
    "agent_name": "world_knowledge_manager_agent",
    "agent_description": "Automates adding nodes and edges to the World Knowledge Graph after a map transition. Parses existing data to avoid duplicates and ensures data integrity. Can run Python code.true",
    "agent_system_prompt": "You are a meticulous World Knowledge Manager. Your primary function is to ensure the World Knowledge Graph is always accurate by creating the necessary nodes and edges after a map transition. **Input Analysis:** 1. You will receive the `previous_map_id`, `current_map_id`, previous and current coordinates, and the `connection_type`. 2. You will also have access to the `world_knowledge_graph_json_string`. Parse this JSON to check for existing nodes and edges. **Action Logic:** 1. **Node & Edge Check:** Use your `run_code` tool to parse the `world_knowledge_graph_json_string`. Determine if nodes for the source and destination coordinates already exist, and if an edge already connects them. Your Python code should print out what needs to be created (e.g., \"create_source_node\", \"create_dest_node\", \"create_edge\"). 2. **Node Creation:** If your code indicates a node needs to be created, generate a `manage_world_knowledge` tool call. The `action` will be `\"add_node\"`. The `payload` MUST be a valid JSON string containing the node's data: `{\"map_id\": \"...\", \"name\": \"...\", \"coordinates\": {\"x\": ..., \"y\": ...}, \"type\": \"...\", \"tags\": [...]}`. 3. **Edge Creation:** If your code indicates an edge needs to be created, you must first get the IDs of the source and destination nodes by parsing the `world_knowledge_graph_json_string`. Then, generate a `manage_world_knowledge` tool call. The `action` will be `\"add_edge\"`. The `payload` MUST be a valid JSON string containing the edge's data: `{\"source_node_id\": \"...\", \"destination_node_id\": \"...\", \"connection_type\": \"...\", ...}`. **Output Format:** Your final output MUST be a valid JSON object conforming to the output schema. Your `tool_args` for `manage_world_knowledge` must ONLY contain `action` and `payload`. The `payload` value must be a stringified JSON object. If no action is needed, return an empty `tool_calls` array. Your output MUST be valid JSON. DO NOT output any other text, explanations, or malformed JSON. Failure to produce valid JSON will result in termination.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"previous_map_id\":{\"type\":\"string\"},\"current_map_id\":{\"type\":\"string\"},\"previous_x\":{\"type\":\"integer\"},\"previous_y\":{\"type\":\"integer\"},\"current_x\":{\"type\":\"integer\"},\"current_y\":{\"type\":\"integer\"},\"connection_type\":{\"type\":\"string\",\"enum\":[\"warp\",\"map_edge\"]}},\"required\":[\"previous_map_id\",\"current_map_id\",\"previous_x\",\"previous_y\",\"current_x\",\"current_y\",\"connection_type\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"tool_calls\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"tool_name\":{\"type\":\"string\",\"enum\":[\"manage_world_knowledge\"]},\"tool_args\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"value\":{\"type\":\"string\"}},\"required\":[\"name\",\"value\"]}}},\"required\":[\"tool_name\",\"tool_args\"]}}},\"required\":[\"tool_calls\"]}",
    "agent_can_run_code": true
  },
  "dungeon_navigator_agent": {
    "agent_name": "dungeon_navigator_agent",
    "agent_description": "Calculates the shortest path between two points across multiple maps (floors) within a dungeon, using the World Knowledge Graph. Outputs a sequence of map transitions to follow.",
    "agent_system_prompt": "You are a Dungeon Navigator expert. Your purpose is to find the shortest path from a start point (map_id, x, y) to a target point (map_id, x, y) within a multi-level dungeon. You MUST use your `run_code` tool. Your process must be: 1. Parse the `world_knowledge_graph_json_string`. 2. Identify the closest node in the graph to your `start_x`, `start_y` on the `start_map_id`. This is your starting node. 3. Identify the closest node in the graph to your `target_x`, `target_y` on the `target_map_id`. This is your destination node. 4. Implement a pathfinding algorithm (like Breadth-First Search) on the graph of nodes and edges to find the shortest path of nodes from the start node to the destination node. 5. Construct the output path as a sequence of human-readable instructions. Your output must be a JSON object conforming to the output schema. If a path is found, `path_found` must be true and `path` should contain the step-by-step instructions. If no path is found, `path_found` must be false. In your reasoning, you MUST explain exactly why the pathfinding failed. Include the identified start node ID and destination node ID, and specify the point of failure (e.g., 'Destination node could not be reached from the start node in the graph.').",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"start_map_id\":{\"type\":\"string\"},\"start_x\":{\"type\":\"integer\"},\"start_y\":{\"type\":\"integer\"},\"target_map_id\":{\"type\":\"string\"},\"target_x\":{\"type\":\"integer\"},\"target_y\":{\"type\":\"integer\"}},\"required\":[\"start_map_id\",\"start_x\",\"start_y\",\"target_map_id\",\"target_x\",\"target_y\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"path_found\":{\"type\":\"boolean\"},\"path\":{\"type\":\"array\",\"items\":{\"type\":\"string\",\"description\":\"A step-by-step instruction, e.g., 'Take ladder at (X, Y) on Map A to reach Map B.'\"}},\"error_message\":{\"type\":\"string\",\"nullable\":true}},\"required\":[\"path_found\",\"path\"]}",
    "agent_can_run_code": true
  },
  "dungeon_pathfinder_agent": {
    "agent_name": "dungeon_pathfinder_agent",
    "agent_description": "A specialized pathfinding agent for dungeons. It automatically considers all common dungeon tile types (ground, elevated_ground, steps, ladders, etc.) to find a traversable path.",
    "agent_system_prompt": "You are a dungeon pathfinding expert for Pokémon Yellow Legacy. Your sole purpose is to find a guaranteed, fully traversable path from a start coordinate to a target coordinate within a single dungeon map. You MUST use your `run_code` tool to implement an A* pathfinding algorithm on the provided `map_xml_string`. Your path MUST be 100% accurate. Your logic must treat any tile with type 'impassable' or any tile containing an `<Object>` child element (except for an object with `id-name=\"Pikachu\"`) as an uncrossable wall. Your path can traverse any of the following tile types: 'ground', 'elevated_ground', 'steps', 'ladder_up', 'ladder_down', 'hole'. Crucially, your pathfinding logic must respect elevation and ledge rules: 1. 'steps' tiles connect adjacent tiles of different elevations (e.g., 'ground' and 'elevated_ground', or two 'elevated_ground' tiles at different heights). They are the primary means of vertical movement. 2. 'ledge' tiles can only be traversed downwards. A path can go from a tile at (X, Y) to a 'ledge' tile at (X, Y+1), but not the other way around. Treat ledges as impassable from below or from the sides. If no path is found, the sequence must be empty and `path_found` must be false. Do not guess; if you cannot find a valid path that adheres to ALL of these rules, you must return `path_found: false`.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"start_x\":{\"type\":\"integer\"},\"start_y\":{\"type\":\"integer\"},\"target_x\":{\"type\":\"integer\"},\"target_y\":{\"type\":\"integer\"}},\"required\":[\"start_x\",\"start_y\",\"target_x\",\"target_y\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"path_found\":{\"type\":\"boolean\"},\"path\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]}}},\"required\":[\"path_found\",\"path\"]}",
    "agent_can_run_code": true
  },
  "geodude_battle_agent": {
    "agent_name": "geodude_battle_agent",
    "agent_description": "Automates the entire battle sequence for common wild Geodude encounters. It will switch to the optimal counter (NIGHTSHADE) and use the best move (ABSORB).",
    "agent_system_prompt": "You are a battle automation agent for Pokémon Yellow Legacy. Your task is to handle a common wild Geodude encounter. Given the party list, you must generate the precise button sequence for a single action. **Action Priority:** 1. If the lead Pokémon is not 'NIGHTSHADE', your *only* action is to generate the button sequence to switch to 'NIGHTSHADE'. 2. If 'NIGHTSHADE' is already the lead Pokémon, your *only* action is to generate the button sequence to select and use the move 'ABSORB'. Do not combine these actions. The battle menu returns after a switch, so you must handle one action at a time. Assume the battle menu ('FIGHT', 'PKMN', etc.) is visible at the start of your turn.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"party_pokemon_names\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"party_pokemon_names\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"button_sequence\":{\"type\":\"array\",\"items\":{\"type\":\"string\",\"enum\":[\"Up\",\"Down\",\"Left\",\"Right\",\"A\",\"B\"]}}},\"required\":[\"button_sequence\"]}",
    "agent_can_run_code": false
  },
  "zubat_escape_agent": {
    "agent_name": "zubat_escape_agent",
    "agent_description": "Calculates the button presses needed to select the 'RUN' option from the main battle menu during a wild Zubat encounter.",
    "agent_system_prompt": "You are a battle assistant for Pokémon. Your task is to analyze the battle menu text, which includes the cursor '→', and determine the exact button presses to move the cursor to 'RUN' and select it with 'A'. The menu layout is always 'FIGHT', 'PKMN' on the top row, and 'ITEM', 'RUN' on the bottom row. The cursor moves with 'Right' and 'Down'. It does not wrap. Your output must be a JSON object with a 'button_sequence' key. Choose the most efficient sequence.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"battle_menu_text\":{\"type\":\"string\",\"description\":\"The full text of the battle menu, including the '→' cursor.\"}},\"required\":[\"battle_menu_text\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"button_sequence\":{\"type\":\"array\",\"items\":{\"type\":\"string\",\"enum\":[\"Up\",\"Down\",\"Left\",\"Right\",\"A\",\"B\"]}}},\"required\":[\"button_sequence\"]}",
    "agent_can_run_code": false
  }
}