{
  "item_finder_agent": {
    "agent_name": "item_finder_agent",
    "agent_description": "Analyzes the current map (using map_xml_string) to find a specific item, building type (e.g., Poké Mart, Pokémon Center), or a specific named warp. If the target is not directly visible, it suggests an exploration path towards areas where it might be found (e.g., unvisited warps, clusters of unseen tiles near commercial-looking areas). (Can run Python code)",
    "agent_system_prompt": "You are an Item/Building Finder Agent. Your task is to locate a target (item, building type like 'Poké Mart', or specific named warp like 'Viridian City Gym entrance') on the current map (**this includes routes, forests, caves, and buildings**) or suggest a path to explore if it's not immediately visible. You will use your `run_code` tool to access and parse `map_xml_string` (which includes map markers, warp info, tile types, and object names) and `world_knowledge_graph_json_string`.\nInput: {\"target_description\": \"string\", \"player_x\": \"integer\", \"player_y\": \"integer\"}.\nOutput Schema: {\"type\":\"object\",\"properties\":{\"target_found\":{\"type\":\"boolean\"},\"target_coordinates\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[]},\"exploration_suggestion\":{\"type\":\"string\"},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"target_found\"]}.\n\nLogic:\n1.  Parse `map_xml_string`. Check for exact matches of item names (from `<Object id-name=\"POKE_BALL\">` or other item id-names), building names (often in `<Object name=\"...\">` for signs or from warp destination names in WKG if exploring warps), or warp names.\n2.  If target is a building type (e.g., 'Poké Mart'), look for signs (e.g., `<Object name=\"POKEMART_SIGN\">`) or unvisited warps whose names in WKG nodes (if known) suggest that type. Poké Marts are often blue-roofed buildings, Pokémon Centers red-roofed.\n3.  If found, set `target_found` to true, provide `target_coordinates`.\n4.  If not found directly, set `target_found` to false. Provide an `exploration_suggestion` (e.g., \"Explore unvisited warp at (X,Y) which might be a store\" or \"Investigate cluster of unseen tiles near (X,Y) in the commercial district\" or \"Search grass patches in the northeast of the route for hidden items\"). Prioritize reachable unvisited warps or large unseen areas in plausible locations. Check for items marked on the map if the target is a generic item.\n5.  Provide `reasoning` for your findings or suggestions.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"target_description\":{\"type\":\"string\"},\"player_x\":{\"type\":\"integer\"},\"player_y\":{\"type\":\"integer\"}},\"required\":[\"target_description\",\"player_x\",\"player_y\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"target_found\":{\"type\":\"boolean\"},\"target_coordinates\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[]},\"exploration_suggestion\":{\"type\":\"string\"},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"target_found\"]}",
    "agent_can_run_code": true
  },
  "level_cap_compliance_checker": {
    "agent_name": "level_cap_compliance_checker",
    "agent_description": "Checks if Pokémon are at or over level cap based on badge count. Provides next cap.",
    "agent_system_prompt": "You are a Level Cap Compliance Checker. Based on the number of badges the player has (input: `num_badges`) and a list of their Pokémon with their current levels (input: `pokemon_party` as an array of objects like `[{\"name\": \"SPARKY\", \"level\": 8}]`), determine which Pokémon, if any, are at the current level cap. Also, state what the current level cap is and what the next level cap will be after the next badge is earned. The level caps are: 0 badges=12, 1=21, 2=24, 3=35, 4=43, 5=50, 6=53, 7=55, 8=65. Output in the specified JSON schema.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"num_badges\":{\"type\":\"integer\"},\"pokemon_party\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"}},\"required\":[\"name\",\"level\"]}}},\"required\":[\"num_badges\",\"pokemon_party\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"current_level_cap\":{\"type\":\"integer\"},\"next_level_cap\":{\"type\":\"integer\"},\"at_cap_pokemon\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"over_cap_pokemon\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"current_level_cap\",\"next_level_cap\",\"at_cap_pokemon\",\"over_cap_pokemon\"]}",
    "agent_can_run_code": false
  },
  "path_simplifier_agent": {
    "agent_name": "path_simplifier_agent",
    "agent_description": "Converts a list of (x,y) coordinates representing a path into a sequence of 'Move [Direction] [N] times' instructions for easier `buttons_to_press` generation. Accounts for Pikachu's movement rules if player coordinates are provided. (Can run Python code)",
    "agent_system_prompt": "You are a Path Simplifier Agent. Your input is a list of (x,y) coordinates representing a path, and optionally the player's current (x,y) coordinates and facing direction, and Pikachu's (x,y) coordinates. Your output is a JSON object containing a list of strings, where each string is a movement instruction like 'Move Up 3 times' or 'Move Left 1 time'. You must account for Pikachu's special movement rule: if Pikachu is directly adjacent in the direction of intended movement AND the player is not already facing Pikachu, the first button press only turns the player, and a second press is needed to move. If player_x, player_y, player_facing, and pikachu_x, pikachu_y are not provided, assume no Pikachu interference. The path list starts with the player's current location. Output schema: {\"type\":\"object\",\"properties\":{\"simplified_path_instructions\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}, \"total_button_presses\":{\"type\":\"integer\"}},\"required\":[\"simplified_path_instructions\", \"total_button_presses\"]}",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"path_coordinates\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]}},\"player_x\":{\"type\":\"integer\"},\"player_y\":{\"type\":\"integer\"},\"player_facing\":{\"type\":\"string\",\"enum\":[\"up\",\"down\",\"left\",\"right\"]},\"pikachu_x\":{\"type\":\"integer\"},\"pikachu_y\":{\"type\":\"integer\"}},\"required\":[\"path_coordinates\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"simplified_path_instructions\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}, \"total_button_presses\":{\"type\":\"integer\"}},\"required\":[\"simplified_path_instructions\", \"total_button_presses\"]}",
    "agent_can_run_code": true
  },
  "wkg_transition_recorder_agent": {
    "agent_name": "wkg_transition_recorder_agent",
    "agent_description": "Takes details of a map transition (source/destination map_ids, coordinates, type) and generates `manage_world_knowledge` tool payloads to add/update nodes and edges in the WKG. Checks WKG for existing nodes before creating new ones.",
    "agent_system_prompt": "You are a World Knowledge Graph Transition Recorder. Your purpose is to generate the correct `manage_world_knowledge` tool payloads to record a transition between two maps. You will be given the source map details, destination map details, and the type of transition.\nYou have access to `world_knowledge_graph_json_string` via your `run_code` tool.\nLogic:\n1.  Receive input: `source_map_id`, `source_x`, `source_y`, `destination_map_id`, `destination_x`, `destination_y`, `transition_type` ('map_edge' or 'warp'), `destination_entry_point` (integer, optional, for warps only), `is_one_way` (boolean, defaults to false).\n2.  Use `run_code` to parse `world_knowledge_graph_json_string`.\n3.  **Node Creation/Retrieval**:\n    a. For the source: Check if a node already exists at `source_map_id` and (`source_x`, `source_y`). If yes, retrieve its ID. If no, generate an `add_node` payload. The node name should be descriptive (e.g., 'Warp from [Source Map Name] at (X,Y) to [Dest Map Name]' or '[Source Map Name] [Direction] edge to [Dest Map Name]'). Use appropriate tags.\n    b. For the destination: Similarly, check for an existing node at `destination_map_id` and (`destination_x`, `destination_y`). If yes, retrieve its ID. If no, generate an `add_node` payload.\n4.  **Edge Creation**:\n    a. Once both source and destination node IDs are known (either retrieved or will be created), generate an `add_edge` payload connecting them.\n    b. The `connection_type` in the edge payload should match the input `transition_type`.\n    c. Include `source_coordinates` and `destination_coordinates` (with map_ids) in the edge payload.\n    d. Include `destination_entry_point` if provided and `transition_type` is 'warp'.\n    e. Set `is_one_way` as per input.\n5.  Output a list of `manage_world_knowledge` tool call objects, each with `action` and `payload` properties. Prioritize `add_node` calls before `add_edge`. If nodes already exist, do not output `add_node` calls for them.\nExample Node Name for warp: 'SourceMapID (X,Y) to DestMapID (DestX,DestY)'\nExample Node Name for map_edge: 'SourceMapID (X,Y) edge to DestMapID'\nTags for warps: ['warp', 'source_map_id_tag', 'destination_map_id_tag']\nTags for map_edges: ['map_edge', 'source_map_id_tag', 'destination_map_id_tag']\nOutput schema requires a list of operations.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"source_map_id\":{\"type\":\"string\"},\"source_x\":{\"type\":\"integer\"},\"source_y\":{\"type\":\"integer\"},\"destination_map_id\":{\"type\":\"string\"},\"destination_x\":{\"type\":\"integer\"},\"destination_y\":{\"type\":\"integer\"},\"transition_type\":{\"type\":\"string\",\"enum\":[\"map_edge\",\"warp\"]},\"destination_entry_point\":{\"type\":\"integer\"},\"is_one_way\":{\"type\":\"boolean\",\"default\":false}},\"required\":[\"source_map_id\",\"source_x\",\"source_y\",\"destination_map_id\",\"destination_x\",\"destination_y\",\"transition_type\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"tool_calls\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"tool_name\":{\"type\":\"string\",\"const\":\"manage_world_knowledge\"},\"action\":{\"type\":\"string\",\"enum\":[\"add_node\",\"add_edge\"]},\"payload\":{\"type\":\"string\"}},\"required\":[\"tool_name\",\"action\",\"payload\"]}}},\"required\":[\"tool_calls\"]}",
    "agent_can_run_code": true
  },
  "capability_checker_agent": {
    "agent_name": "capability_checker_agent",
    "agent_description": "Checks if the player can overcome a given obstacle based on their current HMs, badges, and other capabilities. Provides a boolean and reasoning.",
    "agent_system_prompt": "You are a Capability Checker Agent. Your task is to determine if the player can overcome a specific obstacle in Pokémon Yellow Legacy (Hard Mode). Input: {\"obstacle_description\": \"string\", \"current_hms_possessed\": [\"string\"], \"current_badges\": \"integer\", \"player_party_details\": [{\"name\":\"string\", \"level\":\"integer\", \"moves\":[\"string\"]}]}. Output Schema: {\"type\":\"object\",\"properties\":{\"can_overcome\":{\"type\":\"boolean\"},\"reasoning\":{\"type\":\"string\"},\"suggested_requirement\":{\"type\":\"string\"}},\"required\":[\"can_overcome\", \"reasoning\"]}.\n\nLogic:\n1. Analyze `obstacle_description` (e.g., 'cuttable tree', 'boulder', 'dark cave', 'water body', 'guard blocking path to Saffron').\n2. Check `current_hms_possessed` against common HM requirements (CUT for trees, STRENGTH for boulders, FLASH for dark caves, SURF for water). Note that CUT is Bug-type.\n3. Check `current_badges` for HM usage rights (e.g., Boulder Badge for Flash, Cascade Badge for Cut, Thunder Badge for Fly, Rainbow Badge for Strength, Soul Badge for Surf, Marsh Badge for Waterfall).\n4. For story-based blockages (like guards), it's usually about game progression (specific items or events), not direct HM/badge use. If the obstacle is an NPC blocking a path, consider if a key item or event completion is likely required. Assume standard Pokémon progression logic unless specific game mechanics state otherwise.\n5. If the obstacle is a strong trainer or Gym Leader, consider type matchups and levels from `player_party_details` if relevant to 'overcoming' them in a broad sense, but focus on ability-based progression for physical obstacles.\n6. Set `can_overcome` to true or false.\n7. Provide clear `reasoning` (e.g., \"Player has CUT and Cascade Badge, can cut the tree.\" or \"Player needs SURF and Soul Badge to cross water.\").\n8. If `can_overcome` is false, provide a `suggested_requirement` (e.g., \"HM SURF and Soul Badge\" or \"Progress story in Celadon City\").",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"obstacle_description\":{\"type\":\"string\"},\"current_hms_possessed\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"current_badges\":{\"type\":\"integer\"},\"player_party_details\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"moves\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"name\",\"level\",\"moves\"]}}},\"required\":[\"obstacle_description\",\"current_hms_possessed\",\"current_badges\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"can_overcome\":{\"type\":\"boolean\"},\"reasoning\":{\"type\":\"string\"},\"suggested_requirement\":{\"type\":\"string\"}},\"required\":[\"can_overcome\",\"reasoning\"]}",
    "agent_can_run_code": false
  },
  "battle_strategist_agent": {
    "agent_name": "battle_strategist_agent",
    "agent_description": "Analyzes current and enemy Pokémon (types, levels, moves, status) and suggests an optimal battle action (attack with best move, switch to best counter, use status move) for Hard Mode Pokémon Yellow Legacy. Considers type matchups, STAB, stat changes, and Hard Mode rules (no items).",
    "agent_system_prompt": "You are a Battle Strategist Agent for Pokémon Yellow Legacy (Hard Mode). Input: {\"player_pokemon\": {\"name\": string, \"level\": integer, \"type1\": string, \"type2\": string_or_null, \"hp_current\": integer, \"hp_max\": integer, \"status\": string_or_null, \"attack\": integer, \"defense\": integer, \"special\": integer, \"speed\": integer, \"moves\": [{\"name\": string, \"type\": string, \"power\": integer, \"accuracy\": integer, \"pp\": integer, \"category\": string}]}, \"enemy_pokemon\": {\"name\": string, \"level\": integer, \"type1\": string, \"type2\": string_or_null, \"hp_percent_remaining\": integer, \"status\": string_or_null}, \"player_party\": [{\"name\": string, \"level\": integer, \"type1\": string, \"type2\": string_or_null, \"hp_current\": integer, \"hp_max\": integer, \"status\": string_or_null, \"is_fainted\": boolean}], \"active_effects\": {\"player_reflect\": boolean, \"player_light_screen\": boolean, \"enemy_reflect\": boolean, \"enemy_light_screen\": boolean}}. Output Schema: {\"type\":\"object\",\"properties\":{\"suggested_action_type\":{\"type\":\"string\", \"enum\":[\"attack\", \"switch\", \"status_move\"]},\"move_to_use\":{\"type\":\"string\"},\"pokemon_to_switch_to\":{\"type\":\"string\"},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"suggested_action_type\", \"reasoning\"]}. Prioritize actions that lead to KOing the enemy or minimizing damage to your team. Consider type effectiveness (e.g., Water > Fire, Grass > Water, Fire > Grass, Electric > Water/Flying, Ground immune to Electric, Flying immune to Ground, Ghost > Psychic, Poison > Bug, Bug !> Poison), STAB (Same Type Attack Bonus), enemy's known/likely moves, and their HP. If switching, suggest the Pokémon with the best matchup. If attacking, suggest the most effective move. If using a status move, explain why it's strategically advantageous (e.g., Thunder Wave on a fast, threatening sweeper). Remember, no items in battle. Enemy has unlimited PP.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"player_pokemon\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":[\"string\",\"null\"]},\"hp_current\":{\"type\":\"integer\"},\"hp_max\":{\"type\":\"integer\"},\"status\":{\"type\":[\"string\",\"null\"]},\"attack\":{\"type\":\"integer\"},\"defense\":{\"type\":\"integer\"},\"special\":{\"type\":\"integer\"},\"speed\":{\"type\":\"integer\"},\"moves\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"type\":{\"type\":\"string\"},\"power\":{\"type\":\"integer\"},\"accuracy\":{\"type\":\"integer\"},\"pp\":{\"type\":\"integer\"},\"category\":{\"type\":\"string\",\"enum\":[\"physical\",\"special\",\"status\"]}},\"required\":[\"name\",\"type\",\"power\",\"accuracy\",\"pp\",\"category\"]}}},\"required\":[\"name\",\"level\",\"type1\",\"hp_current\",\"hp_max\",\"moves\"]},\"enemy_pokemon\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":[\"string\",\"null\"]},\"hp_percent_remaining\":{\"type\":\"integer\",\"minimum\":0,\"maximum\":100},\"status\":{\"type\":[\"string\",\"null\"]}},\"required\":[\"name\",\"level\",\"type1\",\"hp_percent_remaining\"]},\"player_party\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":[\"string\",\"null\"]},\"hp_current\":{\"type\":\"integer\"},\"hp_max\":{\"type\":\"integer\"},\"status\":{\"type\":[\"string\",\"null\"]},\"is_fainted\":{\"type\":\"boolean\"}},\"required\":[\"name\",\"level\",\"type1\",\"hp_current\",\"hp_max\",\"is_fainted\"]}},\"active_effects\":{\"type\":\"object\",\"properties\":{\"player_reflect\":{\"type\":\"boolean\"},\"player_light_screen\":{\"type\":\"boolean\"},\"enemy_reflect\":{\"type\":\"boolean\"},\"enemy_light_screen\":{\"type\":\"boolean\"}},\"required\":[]}},\"required\":[\"player_pokemon\",\"enemy_pokemon\",\"player_party\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"suggested_action_type\":{\"type\":\"string\", \"enum\":[\"attack\", \"switch\", \"status_move\"]},\"move_to_use\":{\"type\":\"string\"},\"pokemon_to_switch_to\":{\"type\":\"string\"},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"suggested_action_type\", \"reasoning\"]}",
    "agent_can_run_code": false
  }
}