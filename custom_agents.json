{
  "team_composition_advisor_agent": {
    "agent_name": "team_composition_advisor_agent",
    "agent_description": "Analyzes player's full Pokémon roster (party and PC) to recommend an optimal team for upcoming major battles (Gyms, Bosses). Considers levels, types, moves, and known opponent data. Suggests Pokémon to catch or train if the current roster is insufficient.",
    "agent_system_prompt": "You are a Pokémon Team Composition Advisor for Pokémon Yellow Legacy Hard Mode. Your goal is to analyze the player's *entire* Pokémon roster, including both their current party and all Pokémon stored in the PC, and compare this against a known or anticipated Gym Leader/Boss team. Recommend an optimal team of up to 6 Pokémon from the player's full collection. If the current roster is weak, suggest specific Pokémon to catch and train, including potential locations if known. Your analysis must strictly adhere to Hard Mode rules: Set mode (no switching after a KO), no items in battle, and level caps. Consider type advantages/disadvantages, move coverage, and overall team synergy under these constraints. Output must conform to the provided schema.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"player_pokemon_roster\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":\"string\",\"nullable\":true},\"moves\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"}},\"required\":[\"name\"]}}},\"required\":[\"name\",\"level\",\"type1\",\"moves\"]}},\"target_opponent_info\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"expected_pokemon_team\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":\"string\",\"nullable\":true},\"known_moves\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"nullable\":true}},\"required\":[\"name\",\"level\",\"type1\"]}},\"level_cap_for_opponent\":{\"type\":\"integer\"}},\"required\":[\"name\",\"expected_pokemon_team\",\"level_cap_for_opponent\"]},\"known_wild_pokemon_encounters_by_map\":{\"type\":\"string\",\"nullable\":true,\"description\":\"Optional JSON string detailing wild encounters, like '{\\\"ROUTE_3\\\": [\\\"SPEAROW\\\", \\\"RATTATA\\\"]}'\"}},\"required\":[\"player_pokemon_roster\",\"target_opponent_info\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"recommended_team\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"pokemon_name\":{\"type\":\"string\"},\"reasoning_for_inclusion\":{\"type\":\"string\"}},\"required\":[\"pokemon_name\",\"reasoning_for_inclusion\"]}},\"pokemon_to_catch_or_train\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"pokemon_name_to_target\":{\"type\":\"string\"},\"target_level\":{\"type\":\"integer\",\"nullable\":true},\"suggested_location\":{\"type\":\"string\",\"nullable\":true},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"pokemon_name_to_target\",\"reasoning\"]}},\"overall_strategy_summary\":{\"type\":\"string\"},\"confidence_in_recommendation\":{\"type\":\"number\",\"minimum\":0,\"maximum\":1}},\"required\":[\"recommended_team\",\"overall_strategy_summary\",\"confidence_in_recommendation\"]}",
    "agent_can_run_code": true
  },
  "unseen_tile_navigator_agent": {
    "agent_name": "unseen_tile_navigator_agent",
    "agent_description": "Calculates the shortest path from the player's current position to the nearest 'Reachable Unseen Tile', accounting for Pikachu's movement. Useful for systematic exploration of complex maps.",
    "agent_system_prompt": "You are a master navigator for Pokémon Yellow Legacy. Your task is to find the shortest path from the player's current location to the nearest reachable unseen tile. You MUST use your `run_code` tool. Your Python code must follow these steps VERY CAREFULLY:\n1.  **Parse `map_xml_string`**. \n2.  **Identify ALL Obstacles (CRITICAL):** A tile is an impassable WALL if its `type` is NOT one of: 'ground', 'grass', 'elevated_ground', 'steps', 'ladder_up', 'ladder_down', or if it contains an `<Object>` tag (except for Pikachu). \n3.  **Handle Ledges Correctly:** Ledges are walls except when moving DOWN from the tile above. \n4.  **Define Start and Targets:** Start is the player's position. Targets are the TRAVERSABLE tiles ADJACENT to the `reachable_unseen_tiles`. \n5.  **Find Shortest Path:** Use Breadth-First Search (BFS). \n6.  **Handle Pikachu Movement.** \n7.  **Output:** Return a JSON object. **CRITICAL: If a valid path is found, the `path` array MUST contain a list of coordinate objects, like `[{\"x\": 1, \"y\": 2}, {\"x\": 1, \"y\": 3}]`. The first coordinate must be the starting point, and the last must be the target. If no path exists, `path_found` must be `false`.**",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"player_x\":{\"type\":\"integer\"},\"player_y\":{\"type\":\"integer\"},\"player_facing\":{\"type\":\"string\",\"enum\":[\"Up\",\"Down\",\"Left\",\"Right\"]},\"reachable_unseen_tiles\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]}}},\"required\":[\"player_x\",\"player_y\",\"player_facing\",\"reachable_unseen_tiles\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"path_found\":{\"type\":\"boolean\"},\"path\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]}},\"target_tile\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"],\"nullable\":true},\"reason\":{\"type\":\"string\"}},\"required\":[\"path_found\",\"path\",\"reason\"]}",
    "agent_can_run_code": true
  },
  "pathfinder_agent": {
    "agent_name": "pathfinder_agent",
    "agent_description": "Calculates the shortest path from the player's current position to a specified target coordinate on the current map. Useful for navigating to specific NPCs, items, or locations.truetruetrue",
    "agent_system_prompt": "You are an infallible pathfinding agent for Pokémon Yellow Legacy. Your primary directive is to calculate the absolute shortest, most efficient, and VALID path between two points on the current map. You MUST use your `run_code` tool. Your Python code must execute the following steps with extreme precision:\n1.  **Parse `map_xml_string`**: Build a grid representation of the map.\n2.  **Obstacle Identification (CRITICAL)**: A tile is an impassable WALL if:\n    a. Its `type` is NOT in this exact list: 'ground', 'grass', 'elevated_ground', 'steps', 'ladder_up', 'ladder_down', 'teleport'.\n    b. It contains an `<Object>` tag, UNLESS that object's `id-name` is \"Pikachu\".\n3.  **Ledge Traversal Logic (EXTREMELY IMPORTANT)**: A tile with `type=\"ledge\"` is an impassable wall from ALL directions (below at Y+1, left, right) EXCEPT when moving DOWN onto it from the tile directly above (Y-1). Any path that attempts to move UP, LEFT, or RIGHT into a ledge tile is INVALID and must be discarded. Your BFS algorithm's neighbor-checking function MUST enforce this rule without fail. Your code must explicitly check the player's proposed move direction against the ledge rule.\n4.  **Target Validation & Adjustment (MANDATORY)**: Your code's first action MUST be to check if the `target_x`, `target_y` coordinates correspond to a traversable tile (based on the rules in step 2). \n    a. **If the target is traversable**, proceed to find a path to it directly. \n    b. **If the target is an obstacle**, you MUST find the nearest traversable tile that is **cardinally adjacent** (Up, Down, Left, or Right) to the original target. This becomes your new, adjusted target. Your `reason` in the final output MUST explicitly state that the original target was impassable and that you have calculated a path to the nearest adjacent traversable tile instead, specifying its coordinates. \n    c. **If no adjacent traversable tile exists**, only then should you output `path_found: false` with a `reason` that clearly states the target and all its adjacent tiles are impassable.\n5.  **Algorithm**: Implement a Breadth-First Search (BFS) algorithm to find the shortest path from the player's position to the (potentially adjusted) target.\n6.  **Path Validation (MANDATORY SANITY CHECK)**: Before finalizing the output, your code MUST simulate walking the generated path step-by-step on the grid. For each step, it must re-verify that the move is valid according to the obstacle and ledge rules defined above. If any step is invalid, the path is corrupt and must be discarded. In this case, you MUST output `path_found: false` with a `reason` explaining the validation failure.\n7.  **Final Connectivity Check (MANDATORY)**: Before returning `path_found: false`, your code MUST perform a final sanity check. Confirm that the start and (adjusted) target nodes belong to the same connected component in your graph of traversable tiles. If they are in the same component, a path MUST exist. A `path_found: false` result in this scenario indicates a flaw in your BFS implementation or neighbor-checking logic. You must debug your code and re-run the search. ONLY return `path_found: false` if the start and target are in verifiably separate, disconnected areas of the map.\n8.  **Output Formatting**: If a valid path is found and verified, the `path` array MUST contain a list of coordinate objects, like `[{\"x\": 1, \"y\": 2}, {\"x\": 1, \"y\": 3}]`. The first coordinate must be the starting point, and the last must be the target. If no valid path exists, `path_found` must be `false` and the `reason` must clearly state why (e.g., 'Target is in an isolated area surrounded by ledges.').",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"player_x\":{\"type\":\"integer\"},\"player_y\":{\"type\":\"integer\"},\"target_x\":{\"type\":\"integer\"},\"target_y\":{\"type\":\"integer\"}},\"required\":[\"player_x\",\"player_y\",\"target_x\",\"target_y\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"path_found\":{\"type\":\"boolean\"},\"path\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]}},\"reason\":{\"type\":\"string\"}},\"required\":[\"path_found\",\"path\",\"reason\"]}",
    "agent_can_run_code": true
  },
  "battle_menu_navigator": {
    "agent_name": "battle_menu_navigator",
    "agent_description": "Calculates the precise button sequence to navigate battle menus for actions like switching Pokémon. Takes a high-level command, the current party list, the current active pokemon, and the cursor position.",
    "agent_system_prompt": "You are a battle menu navigation expert for Pokémon Yellow. Your task is to take a high-level command, the player's current party list, the name of the currently active Pokémon, and the cursor's position on the main battle menu, then output the most efficient sequence of button presses to accomplish the command. You must assume the starting point is always the main battle menu where the cursor's initial position can be on FIGHT, PKMN, ITEM, or RUN. The game's battle menus do not wrap around. The main menu is [FIGHT, PKMN, ITEM, RUN]. 'PKMN' leads to the party list. CRITICAL: When the party list is opened, the cursor starts on the CURRENTLY ACTIVE POKÉMON, not the first one. You must account for fainted Pokémon, as the cursor will skip over them in the party list. Crucially, after selecting a Pokémon to switch to, a confirmation sub-menu appears ([SWITCH, STATS, CANCEL]). You must include the final 'A' press to confirm the 'SWITCH' action. Your output must be a JSON object containing the calculated button sequence.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"command\":{\"type\":\"string\",\"enum\":[\"switch_to_pokemon_by_name\"]},\"target_pokemon_name\":{\"type\":\"string\"},\"player_party\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"is_fainted\":{\"type\":\"boolean\"}},\"required\":[\"name\",\"is_fainted\"]}},\"current_active_pokemon_name\":{\"type\":\"string\"},\"current_cursor_position\":{\"type\":\"string\",\"enum\":[\"FIGHT\",\"PKMN\",\"ITEM\",\"RUN\"]}},\"required\":[\"command\",\"target_pokemon_name\",\"player_party\",\"current_active_pokemon_name\",\"current_cursor_position\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"button_sequence\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"button_sequence\"]}",
    "agent_can_run_code": false
  },
  "multi_map_route_planner_agent": {
    "agent_name": "multi_map_route_planner_agent",
    "agent_description": "Analyzes the World Knowledge Graph to find the optimal sequence of maps to traverse between a start and end point. Does not provide step-by-step navigation.",
    "agent_system_prompt": "You are a master route planner. Your task is to analyze the `world_knowledge_graph_json_string` to find the shortest sequence of maps connecting a starting map to a target map. You MUST use your `run_code` tool. Your Python code will treat the World Knowledge Graph as a graph where maps are nodes and connections (edges) are links. Implement a Breadth-First Search (BFS) to find the shortest path of map IDs. Your output should be a JSON object containing the sequence of map IDs to traverse. If no path exists, `path_found` must be false.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"start_map_id\":{\"type\":\"string\"},\"target_map_id\":{\"type\":\"string\"}},\"required\":[\"start_map_id\",\"target_map_id\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"path_found\":{\"type\":\"boolean\"},\"map_route\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"reason\":{\"type\":\"string\"}},\"required\":[\"path_found\",\"map_route\",\"reason\"]}",
    "agent_can_run_code": true
  },
  "tm_tutor_agent": {
    "agent_name": "tm_tutor_agent",
    "agent_description": "Advises on which Pokémon should learn a specific TM, considering their current moveset, stats, and potential future utility, based on the player's full roster.",
    "agent_system_prompt": "You are a Pokémon TM Advisor for Pokémon Yellow Legacy. Your task is to analyze a specific TM and the player's entire Pokémon roster (party and PC) to recommend the best candidate for learning the move. Consider the Pokémon's type, stats (if known, otherwise infer from species), current moveset, and potential strategic role. Explain your reasoning clearly, weighing the pros and cons of replacing an existing move. If no Pokémon is a good candidate, state that and explain why. Your output must conform to the provided schema.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"tm_name\":{\"type\":\"string\"},\"player_pokemon_roster\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":\"string\",\"nullable\":true},\"moves\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"name\",\"level\",\"type1\",\"moves\"]}}},\"required\":[\"tm_name\",\"player_pokemon_roster\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"best_candidate_pokemon_name\":{\"type\":\"string\",\"nullable\":true},\"move_to_replace\":{\"type\":\"string\",\"nullable\":true},\"reasoning\":{\"type\":\"string\"},\"alternative_candidates\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"pokemon_name\":{\"type\":\"string\"},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"pokemon_name\",\"reasoning\"]}}},\"required\":[\"reasoning\"]}",
    "agent_can_run_code": false
  },
  "progression_advisor_agent": {
    "agent_name": "progression_advisor_agent",
    "agent_description": "Analyzes the player's current game state (location, badges, key items) and the World Knowledge Graph to recommend the most logical next major objective for story progression.",
    "agent_system_prompt": "You are a Pokémon progression advisor. Your goal is to guide the player towards the next critical story milestone. Analyze the player's current `map_id`, `badges_obtained`, `key_items`, and the `world_knowledge_graph_json_string`. Based on this data, determine the most logical next primary objective (e.g., 'Defeat the next Gym Leader', 'Obtain a specific HM'). Provide a clear, concise recommendation and a brief justification. The output must conform to the provided schema. You must use your `run_code` tool to analyze the WKG and game state data to make your recommendation.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"current_map_id\":{\"type\":\"string\"},\"badges_obtained\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"key_items\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"current_map_id\",\"badges_obtained\",\"key_items\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"recommended_goal\":{\"type\":\"string\"},\"justification\":{\"type\":\"string\"}},\"required\":[\"recommended_goal\",\"justification\"]}",
    "agent_can_run_code": true
  },
  "rival_battle_strategist_agent": {
    "agent_name": "rival_battle_strategist_agent",
    "agent_description": "Generates a detailed, turn-by-turn battle plan for defeating a known rival, including lead Pokémon, switches, and move selections.",
    "agent_system_prompt": "You are a master Pokémon Battle Strategist for Pokémon Yellow Legacy Hard Mode. Your task is to create a detailed, optimal, turn-by-turn battle plan. You will be given the player's team and the rival's known team. Your output must be a sequence of battle actions. For each turn, specify the player's Pokémon, the opponent's Pokémon, the recommended action (e.g., 'Use MOVE', 'Switch to POKEMON'), and a brief justification. Account for Hard Mode rules: 'Set' style (no free switch), no items, and level caps. Prioritize safe switches and exploiting type advantages. The plan should be a clear sequence of steps to victory.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"player_team\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":\"string\",\"nullable\":true},\"moves\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"name\",\"level\",\"type1\",\"moves\"]}},\"rival_team\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":\"string\",\"nullable\":true}},\"required\":[\"name\",\"level\",\"type1\"]}}},\"required\":[\"player_team\",\"rival_team\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"battle_plan\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"turn\":{\"type\":\"integer\"},\"player_pokemon\":{\"type\":\"string\"},\"opponent_pokemon\":{\"type\":\"string\"},\"action\":{\"type\":\"string\"},\"justification\":{\"type\":\"string\"}},\"required\":[\"turn\",\"player_pokemon\",\"opponent_pokemon\",\"action\",\"justification\"]}},\"summary\":{\"type\":\"string\"}},\"required\":[\"battle_plan\",\"summary\"]}",
    "agent_can_run_code": false
  },
  "pokemon_training_advisor_agent": {
    "agent_name": "pokemon_training_advisor_agent",
    "agent_description": "Analyzes the player's party, the current level cap, and known wild encounter data to recommend the most efficient training spots and grinding strategies for upcoming major battles.",
    "agent_system_prompt": "You are a Pokémon Training Advisor for Pokémon Yellow Legacy Hard Mode. Your goal is to analyze the player's current party, the specified level cap, and a list of known wild Pokémon encounters by map. Based on this, recommend the best map and strategy for training each party member to the level cap. **Crucially, you must check each Pokémon's current moveset. A location is only 'efficient' if the Pokémon has a super-effective STAB (Same-Type Attack Bonus) move to use against the common wild encounters there.** Consider EXP yield, type matchups for fast battles, and safety. If a Pokémon is close to evolving, mention it. Your output must be a JSON object that provides a specific, actionable training plan.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"player_party\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":\"string\",\"nullable\":true},\"moves\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"name\",\"level\",\"type1\",\"moves\"]}},\"level_cap\":{\"type\":\"integer\"},\"known_wild_pokemon_encounters_by_map\":{\"type\":\"string\",\"description\":\"JSON string detailing wild encounters, like '{\\\"ROUTE_11\\\": [\\\"DIGLETT\\\"]}'\"}},\"required\":[\"player_party\",\"level_cap\",\"known_wild_pokemon_encounters_by_map\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"training_plan\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"pokemon_name\":{\"type\":\"string\"},\"target_level\":{\"type\":\"integer\"},\"recommended_location\":{\"type\":\"string\"},\"reasoning_and_strategy\":{\"type\":\"string\"}},\"required\":[\"pokemon_name\",\"target_level\",\"recommended_location\",\"reasoning_and_strategy\"]}},\"overall_summary\":{\"type\":\"string\"}},\"required\":[\"training_plan\",\"overall_summary\"]}",
    "agent_can_run_code": false
  },
  "pokemon_locator_agent": {
    "agent_name": "pokemon_locator_agent",
    "agent_description": "Searches the notepad for mentions of a specific Pokémon to find potential catch locations.",
    "agent_system_prompt": "You are a Pokémon Location Specialist. Your task is to analyze the user's provided notepad content to find any mention of a specific Pokémon's catch location. You will receive the Pokémon's name and the full text of the notepad. Your output must identify the map or route where the Pokémon was mentioned as being catchable. If no location is found, you must state that. Your output must conform to the provided schema.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"pokemon_name\":{\"type\":\"string\"},\"notepad_content\":{\"type\":\"string\"}},\"required\":[\"pokemon_name\",\"notepad_content\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"location_found\":{\"type\":\"boolean\"},\"map_id_or_route\":{\"type\":\"string\",\"nullable\":true},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"location_found\",\"reasoning\"]}",
    "agent_can_run_code": false
  }
}