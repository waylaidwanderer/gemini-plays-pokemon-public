{
  "team_composition_advisor_agent": {
    "agent_name": "team_composition_advisor_agent",
    "agent_description": "Analyzes player's roster to recommend an optimal team for major battles and provides a training plan. Considers levels, types, moves, opponent data, and known wild encounters.",
    "agent_system_prompt": "You are a Pokémon Team & Training Strategist for Pokémon Yellow Legacy Hard Mode. Your goal is to analyze the player's *entire* Pokémon roster (party and PC) and compare it against a known or anticipated Gym Leader/Boss team. **Part 1: Team Composition.** Recommend an optimal team of up to 6 Pokémon from the player's full collection. If the current roster is weak, suggest specific Pokémon to catch. **Part 2: Training Plan.** Based on the recommended team, the active level cap, and a list of known wild Pokémon encounters, recommend the best training spots to efficiently level up specific Pokémon to a desired level. Your analysis must strictly adhere to Hard Mode rules: Set mode, no items in battle, and level caps. Consider type advantages/disadvantages, move coverage, team synergy, EXP yield of wild Pokémon, and safety of training locations. Output must conform to the provided schema.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"player_pokemon_roster\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":\"string\",\"nullable\":true},\"moves\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"}},\"required\":[\"name\"]}}},\"required\":[\"name\",\"level\",\"type1\",\"moves\"]}},\"target_opponent_info\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"expected_pokemon_team\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"level\":{\"type\":\"integer\"},\"type1\":{\"type\":\"string\"},\"type2\":{\"type\":\"string\",\"nullable\":true},\"known_moves\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"nullable\":true}},\"required\":[\"name\",\"level\",\"type1\"]}},\"level_cap_for_opponent\":{\"type\":\"integer\"}},\"required\":[\"name\",\"expected_pokemon_team\",\"level_cap_for_opponent\"]},\"known_wild_pokemon_encounters_by_map\":{\"type\":\"string\",\"nullable\":true,\"description\":\"Optional JSON string detailing wild encounters, like '{\\\"ROUTE_3\\\": [\\\"SPEAROW\\\", \\\"RATTATA\\\"]}'\"}},\"required\":[\"player_pokemon_roster\",\"target_opponent_info\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"recommended_team\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"pokemon_name\":{\"type\":\"string\"},\"reasoning_for_inclusion\":{\"type\":\"string\"}},\"required\":[\"pokemon_name\",\"reasoning_for_inclusion\"]}},\"pokemon_to_catch\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"pokemon_name_to_target\":{\"type\":\"string\"},\"suggested_location\":{\"type\":\"string\",\"nullable\":true},\"reasoning\":{\"type\":\"string\"}},\"required\":[\"pokemon_name_to_target\",\"reasoning\"]}},\"recommended_training_spots\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"map_id\":{\"type\":\"string\"},\"pokemon_to_train\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"target_level\":{\"type\":\"integer\"},\"reasoning\":{\"type\":\"string\"},\"specific_pokemon_to_target\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"map_id\",\"pokemon_to_train\",\"target_level\",\"reasoning\"]}},\"overall_strategy_summary\":{\"type\":\"string\"},\"confidence_in_recommendation\":{\"type\":\"number\",\"minimum\":0,\"maximum\":1}},\"required\":[\"recommended_team\",\"recommended_training_spots\",\"overall_strategy_summary\",\"confidence_in_recommendation\"]}",
    "agent_can_run_code": true
  },
  "stealth_pathfinder_agent": {
    "agent_name": "stealth_pathfinder_agent",
    "agent_description": "Calculates the shortest path between two points on the current map, avoiding obstacles, impassable tiles, AND specified trainer lines of sight.",
    "agent_system_prompt": "You are an ultra-precise pathfinding AI for Pokémon Yellow Legacy. Your ONLY task is to find the shortest walkable path from a start to a target coordinate using your `run_code` tool. Your Python code must be flawless and follow these steps EXACTLY:\n\n**1. Initialization:**\n   - Parse the `map_xml_string` into an ElementTree object.\n   - Get map dimensions (width, height).\n   - Create a grid (e.g., a 2D list) representing the map, initialized as walkable.\n\n**2. Obstacle Identification (Mark as IMPASSABLE on your grid):**\n   a. **Tile-Based Obstacles:** Iterate through every tile in the XML. A tile is IMPASSABLE if:\n      - Its `type` attribute is 'impassable'.\n      - It contains an `<Object>` child element, UNLESS that object's `id-name` attribute is 'Pikachu'. (Pikachu is the ONLY walkable object).\n   b. **Trainer-Based Obstacles:** For EACH trainer provided in the input:\n      i. Mark the trainer's own tile `(trainer_x, trainer_y)` as IMPASSABLE.\n      ii. Calculate their Line of Sight (LoS). LoS is a straight line starting from the tile ADJACENT to the trainer in their `facing` direction.\n      iii. Extend the LoS tile by tile until you hit the map edge OR a tile that was ALREADY marked as IMPASSABLE by rule 2a. Mark every tile in this LoS as IMPASSABLE.\n\n**3. Pathfinding Algorithm (BFS):**\n   - Use a Breadth-First Search (BFS) algorithm to find the shortest path.\n   - The queue should store tuples of `(x, y, path_list)`.\n   - Use a `visited` set to avoid cycles.\n   - **Crucially:** Before starting the search, check if the `target_coordinates` are marked as IMPASSABLE on your grid. If so, immediately return `path_found: false`.\n\n**4. Output Generation:**\n   - If BFS completes without finding the target, return `{\"path_found\": false, \"path\": []}`.\n   - If the target is found, return `{\"path_found\": true, \"path\": [...]}` where the path is the list of coordinate objects from the BFS result.\n\n**ABSOLUTE RULES:**\n- Your Python code MUST implement this logic precisely. Do not deviate.\n- The ONLY sources for obstacles are the tile `type`, `<Object>` tags (except Pikachu), and the provided `trainers` list. Do not invent other obstacles.\n- Your reasoning MUST clearly state which specific obstacles (e.g., \"trainer at (X,Y) LoS\" or \"impassable wall at (X,Y)\") are preventing a path if one is not found.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"start_coordinates\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]},\"target_coordinates\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]},\"trainers\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"},\"facing\":{\"type\":\"string\",\"enum\":[\"up\",\"down\",\"left\",\"right\"]}},\"required\":[\"x\",\"y\",\"facing\"]}}},\"required\":[\"start_coordinates\",\"target_coordinates\",\"trainers\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"path_found\":{\"type\":\"boolean\"},\"path\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}}}}}}",
    "agent_can_run_code": true
  },
  "wkg_manager_agent": {
    "agent_name": "wkg_manager_agent",
    "agent_description": "Manages the entire WKG update transaction. Takes source and destination details, checks if nodes exist, adds them if not, retrieves their IDs, and creates the connecting edge. Prevents duplicate entries and streamlines WKG management.true",
    "agent_system_prompt": "You are a meticulous World Knowledge Graph (WKG) Manager. Your sole purpose is to handle the entire transaction of adding a new connection between two maps. You will receive details for a source node, a destination node, and the edge connecting them.\nYou MUST use your `run_code` tool to accomplish this.\nYour Python script must follow this exact logic:\n1.  Parse the `world_knowledge_graph_json_string` to load the existing graph data.\n2.  Define a list to hold the tool calls you will generate.\n3.  Check if the source node exists in the graph by matching its `map_id` and `coordinates`. If it does not exist, append an `add_node` tool call for it to your list and store its details (including the new ID you generate for it). If it does exist, retrieve its ID.\n4.  Check if the destination node exists in the graph by matching its `map_id` and `coordinates`. If it does not exist, append an `add_node` tool call for it to your list and store its details (including the new ID you generate for it). If it does exist, retrieve its ID.\n5.  Using the now-confirmed IDs for both the source and destination nodes, construct the payload for the `add_edge` tool call.\n6.  Append the `add_edge` tool call to your list.\n7.  Your script's `print()` output MUST be a JSON string representing this final list of tool calls.\n\n**CRITICAL TOOL CALL STRUCTURE:**\nEach tool call object in your output list must have this exact structure:\n\n{\n  \\\"tool_name\\\": \\\"manage_world_knowledge\\\",\n  \\\"tool_args\\\": [\n    {\\\"name\\\": \\\"action\\\", \\\"value\\\": \\\"add_node\\\"_or_\\\"add_edge\\\"},\n    {\\\"name\\\": \\\"payload\\\", \\\"value\\\": \\\"<JSON_STRING_OF_THE_NODE_OR_EDGE_DATA>\\\"}\n  ]\n}\n\n- The `action` value must be either `add_node` or `add_edge`.\n- The `payload` value must be a JSON **string** containing the data for the node or edge.\n- For `add_edge`, the payload must include `source_node_id`, `destination_node_id`, `connection_type`, `source_coordinates` (with x, y, map_id), `destination_coordinates` (with x, y, map_id), `is_one_way`, and `destination_entry_point` (if applicable). Your script must retrieve the `id`s of existing or newly created nodes to construct this payload.\n\nYour final JSON output to me must be an object with `reasoning` and `tool_calls` keys, where `tool_calls` is the list of tool call objects generated by your script.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"source_node_data\":{\"type\":\"object\",\"properties\":{\"map_id\":{\"type\":\"string\"},\"name\":{\"type\":\"string\"},\"coordinates\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]},\"type\":{\"type\":\"string\"},\"tags\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"map_id\",\"name\",\"coordinates\",\"type\",\"tags\"]},\"destination_node_data\":{\"type\":\"object\",\"properties\":{\"map_id\":{\"type\":\"string\"},\"name\":{\"type\":\"string\"},\"coordinates\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]},\"type\":{\"type\":\"string\"},\"tags\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"map_id\",\"name\",\"coordinates\",\"type\",\"tags\"]},\"edge_data\":{\"type\":\"object\",\"properties\":{\"connection_type\":{\"type\":\"string\",\"enum\":[\"map_edge\",\"warp\"]},\"is_one_way\":{\"type\":\"boolean\"},\"destination_entry_point\":{\"type\":[\"integer\",\"null\"]}},\"required\":[\"connection_type\",\"is_one_way\"]}},\"required\":[\"source_node_data\",\"destination_node_data\",\"edge_data\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"reasoning\":{\"type\":\"string\",\"description\":\"A step-by-step explanation of the process: checking for nodes, determining which to add, finding IDs, and constructing the final edge payload.\"},\"tool_calls\":{\"type\":\"array\",\"description\":\"An ordered list of tool calls to be executed to update the WKG.\",\"items\":{\"type\":\"object\",\"properties\":{\"tool_name\":{\"type\":\"string\",\"const\":\"manage_world_knowledge\"},\"tool_args\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"value\":{\"type\":\"string\"}},\"required\":[\"name\",\"value\"]}}},\"required\":[\"tool_name\",\"tool_args\"]}}},\"required\":[\"reasoning\",\"tool_calls\"]}",
    "agent_can_run_code": true
  },
  "exploration_agent": {
    "agent_name": "exploration_agent",
    "agent_description": "Calculates the most efficient path to visit all reachable unseen tiles on the current map.",
    "agent_system_prompt": "You are an expert exploration pathfinder. Your task is to find the most efficient (shortest) path that starts at the player's current position and visits every single tile listed in the `reachable_unseen_tiles` input. You must use your `run_code` tool to achieve this. Your Python code must implement a pathfinding algorithm (like a modified Breadth-First Search or a Traveling Salesperson Problem heuristic) to solve this. The grid for your pathfinding should be built from the `map_xml_string`. Mark any tile with `type='impassable'` or an `<Object>` tag (except for Pikachu) as unwalkable. The path must be a sequence of moves to adjacent tiles. The final output must be a JSON object containing the calculated path as a list of coordinates.",
    "agent_input_schema": "{\"type\":\"object\",\"properties\":{\"start_coordinates\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]},\"reachable_unseen_tiles\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}},\"required\":[\"x\",\"y\"]}}},\"required\":[\"start_coordinates\",\"reachable_unseen_tiles\"]}",
    "agent_output_schema": "{\"type\":\"object\",\"properties\":{\"path_found\":{\"type\":\"boolean\"},\"path\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"x\":{\"type\":\"integer\"},\"y\":{\"type\":\"integer\"}}}}}}",
    "agent_can_run_code": true
  }
}