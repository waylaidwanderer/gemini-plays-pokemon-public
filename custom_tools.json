{
  "find_path_bfs": {
    "description": "Finds a path from the player's current position to a target coordinate using Breadth-First Search (BFS). It correctly handles one-way ledges and other obstacles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef parse_map(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    tiles = {}\n    player_pos = None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tiles[(x, y)] = tile\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n    return tiles, player_pos, width, height\n\ndef is_obstacle(tile):\n    if tile is None: return True\n    tile_type = tile.attrib['type']\n    return tile_type in ['WALL', 'HEADBUTT_TREE', 'VOID', 'CUT_TREE'] or tile.find('Object') is not None\n\ndef bfs_search(tiles, start, goal, width, height):\n    neighbors = [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]\n\n    if is_obstacle(tiles.get(goal)):\n        potential_goals = []\n        for dx, dy, move in neighbors:\n            adj_tile_coord = (goal[0] + dx, goal[1] + dy)\n            if not is_obstacle(tiles.get(adj_tile_coord)):\n                potential_goals.append(adj_tile_coord)\n        if not potential_goals:\n            return None\n        goal = potential_goals[0] # Simplistic choice, could be improved\n\n    queue = deque([[start]])\n    visited = {start}\n\n    while queue:\n        path = queue.popleft()\n        node = path[-1]\n\n        if node == goal:\n            return path\n\n        for i, j, move_dir in neighbors:\n            neighbor_coord = (node[0] + i, node[1] + j)\n            \n            if not (1 <= neighbor_coord[0] <= width and 1 <= neighbor_coord[1] <= height):\n                continue\n\n            if neighbor_coord in visited:\n                continue\n            \n            neighbor_tile = tiles.get(neighbor_coord)\n\n            if is_obstacle(neighbor_tile):\n                continue\n            \n            current_tile_type = tiles.get(node).attrib.get('type')\n            neighbor_tile_type = neighbor_tile.attrib.get('type')\n\n            if move_dir == 'Up' and neighbor_tile_type == 'LEDGE_HOP_DOWN':\n                continue\n            if move_dir == 'Right' and neighbor_tile_type == 'LEDGE_HOP_LEFT':\n                continue\n            if move_dir == 'Left' and neighbor_tile_type == 'LEDGE_HOP_RIGHT':\n                continue\n\n            new_path = list(path)\n            new_path.append(neighbor_coord)\n            queue.append(new_path)\n            visited.add(neighbor_coord)\n            \n    return None\n\ntry:\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    tiles, player_pos, map_width, map_height = parse_map(map_xml_string)\n    if player_pos:\n        path = bfs_search(tiles, player_pos, (target_x, target_y), map_width, map_height)\n        if path:\n            path_coords = [{'x': p[0], 'y': p[1]} for p in path]\n            print(json.dumps(path_coords))\n        else:\n            print(json.dumps([]))\n    else:\n        print(json.dumps([]))\nexcept Exception as e:\n    import traceback\n    print(f'An error occurred: {e}\\n{traceback.format_exc()}')"
  }
}