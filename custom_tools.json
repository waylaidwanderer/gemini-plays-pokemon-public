{
  "analyze_map": {
    "description": "Analyzes the map XML to find reachable 'unseen' frontier tiles and identifying accessible areas. Returns the 5 closest unexplored tiles.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n        p_tile = root.find(\".//Tile[@has-player='true']\")\n        if p_tile is None:\n            print(json.dumps({\"error\": \"No player found\"}))\n            return\n\n        start_x = int(p_tile.get('id'))\n        start_y = int(p_tile.get('coordinate').split(',')[1].strip(') '))\n        \n        # Parse map into grid\n        grid = {}\n        unseen = set()\n        \n        base_obstacles = {\n            \"WALL\", \"COUNTER\", \"PC\", \"SIGN\", \"TREE\", \"ROCK\", \"BOULDER\", \"WHIRLPOOL\", \n            \"LEDGE_DOWN\", \"LEDGE_UP\", \"LEDGE_LEFT\", \"LEDGE_RIGHT\", \n            \"LEDGE_HOP_DOWN\", \"LEDGE_HOP_UP\", \"LEDGE_HOP_LEFT\", \"LEDGE_HOP_RIGHT\",\n            \"WINDOW\", \"DOOR_LOCKED\", \"HEADBUTT_TREE\", \"PIT\", \"LADDER\", \"BUOY\",\n            \"FLOOR_UP_WALL\", \"FLOOR_DOWN_WALL\", \"FLOOR_LEFT_WALL\", \"FLOOR_RIGHT_WALL\"\n        }\n\n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                x = int(tile.get('id'))\n                t_type = tile.get('type')\n                seen = tile.get('seen') == 'true'\n                has_object = tile.get('has-object') == 'true'\n                \n                # Identify unseen\n                if not seen or t_type == \"unseen\":\n                    unseen.add((x, y))\n                    continue\n                \n                # Walkability\n                walkable = True\n                if t_type in base_obstacles:\n                    walkable = False\n                if has_object:\n                    walkable = False\n                \n                # Markers\n                for marker in tile.findall('Marker'):\n                    label = marker.text or \"\"\n                    emoji = marker.get('emoji') or \"\"\n                    if \"Hole\" in label or \"üï≥Ô∏è\" in emoji:\n                        walkable = False\n                \n                if walkable:\n                    grid[(x, y)] = True\n        \n        # BFS for Reachable\n        queue = deque([(start_x, start_y, 0)])\n        visited = set([(start_x, start_y)])\n        reachable_frontiers = []\n        \n        while queue:\n            cx, cy, dist = queue.popleft()\n            \n            # Check neighbors\n            for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                nx, ny = cx + dx, cy + dy\n                \n                # If neighbor is unseen, it's a frontier\n                if (nx, ny) in unseen:\n                    # Check if already added\n                    is_added = False\n                    for f in reachable_frontiers:\n                        if f['coord'] == [nx, ny]:\n                            is_added = True\n                            break\n                    if not is_added:\n                        reachable_frontiers.append({\"coord\": [nx, ny], \"dist\": dist + 1})\n                    continue\n\n                # If neighbor is walkable and not visited, add to queue\n                if grid.get((nx, ny)) and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, dist + 1))\n        \n        # Sort frontiers by distance\n        reachable_frontiers.sort(key=lambda k: k['dist'])\n        \n        print(json.dumps({\n            \"frontiers\": reachable_frontiers[:5], \n            \"total_frontiers\": len(reachable_frontiers)\n        }))\n\n    except Exception as e:\n        print(json.dumps({\"error\": str(e)}))\n\nsolve()",
    "history": [
      {
        "commit_message": "feat: Add analyze_map tool to identify reachable unseen tiles (frontiers) for exploration.",
        "timestamp": "2025-11-24T01:43:39.303Z",
        "action_counter": 6548
      }
    ]
  },
  "find_path": {
    "description": "Calculates a path from the player's current position to a target coordinate (x, y) using BFS. Returns a JSON array of button presses. Treats tiles with objects, object-linked markers, markers labeled 'Hole', 'PIT' tiles, 'LADDER' tiles, 'BUOY' tiles, and 'FLOOR_UP_WALL' variants as obstacles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n        \n        # Get player position\n        p_tile = root.find(\".//Tile[@has-player='true']\")\n        if p_tile is None:\n            print(\"[]\")\n            return\n\n        start_x = int(p_tile.get('id'))\n        start_y = int(p_tile.get('coordinate').split(',')[1].strip(') '))\n        start_type = p_tile.get('type')\n        \n        if 'target_x' not in input_data or 'target_y' not in input_data:\n             print(\"[]\")\n             return\n\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n        \n        grid = {}\n        # Base obstacles that are always impassable\n        base_obstacles = {\n            \"WALL\", \"COUNTER\", \"PC\", \"SIGN\", \"TREE\", \"ROCK\", \"BOULDER\", \"WHIRLPOOL\", \n            \"LEDGE_DOWN\", \"LEDGE_UP\", \"LEDGE_LEFT\", \"LEDGE_RIGHT\", \n            \"LEDGE_HOP_DOWN\", \"LEDGE_HOP_UP\", \"LEDGE_HOP_LEFT\", \"LEDGE_HOP_RIGHT\",\n            \"WINDOW\", \"DOOR_LOCKED\", \"HEADBUTT_TREE\", \"PIT\", \"LADDER\", \"BUOY\",\n            \"FLOOR_UP_WALL\", \"FLOOR_DOWN_WALL\", \"FLOOR_LEFT_WALL\", \"FLOOR_RIGHT_WALL\"\n        }\n        \n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                x = int(tile.get('id'))\n                t_type = tile.get('type')\n                has_object = tile.get('has-object') == 'true'\n                \n                walkable = True\n                \n                # Check base obstacles\n                if t_type in base_obstacles:\n                    walkable = False\n                \n                # Context-aware water logic\n                if start_type != \"WATER\" and t_type == \"WATER\":\n                    walkable = False\n                \n                # Check for objects (NPCs, items, etc) - they are walls\n                if has_object:\n                    walkable = False\n                \n                # Check for Markers\n                for marker in tile.findall('Marker'):\n                    label = marker.text or \"\"\n                    emoji = marker.get('emoji') or \"\"\n                    obj_id = marker.get('object_id')\n                    \n                    if \"Hole\" in label or \"üï≥Ô∏è\" in emoji:\n                        walkable = False\n                    \n                    if obj_id:\n                        walkable = False\n\n                grid[(x, y)] = walkable\n\n        # Logic: If target is blocked (e.g. it's a LADDER or PIT or Object), path to nearest adjacent walkable\n        target_walkable = grid.get((target_x, target_y), False)\n        targets = set()\n        \n        if target_walkable:\n            targets.add((target_x, target_y))\n        else:\n            # If target is obstacle, allow adjacent tiles\n            for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                nx, ny = target_x + dx, target_y + dy\n                if grid.get((nx, ny), False):\n                    targets.add((nx, ny))\n            \n            if not targets:\n                print(\"[]\")\n                return\n\n        # BFS\n        queue = deque([(start_x, start_y, [])])\n        visited = set([(start_x, start_y)])\n        \n        while queue:\n            cx, cy, path = queue.popleft()\n            \n            if (cx, cy) in targets:\n                buttons = []\n                curr_x, curr_y = start_x, start_y\n                for (nx, ny) in path:\n                    if nx > curr_x: buttons.append(\"Right\")\n                    elif nx < curr_x: buttons.append(\"Left\")\n                    elif ny > curr_y: buttons.append(\"Down\")\n                    elif ny < curr_y: buttons.append(\"Up\")\n                    curr_x, curr_y = nx, ny\n                print(json.dumps(buttons))\n                return\n\n            for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                nx, ny = cx + dx, cy + dy\n                if (nx, ny) not in visited and grid.get((nx, ny), False):\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [(nx, ny)]))\n                    \n        print(\"[]\")\n\n    except Exception as e:\n        print(\"[]\")\n\nsolve()",
    "history": [
      {
        "commit_message": "feat: Add find_path tool. Calculates shortest path using BFS, handling walls, objects, and one-way ledges.",
        "timestamp": "2025-11-20T08:35:46.882Z",
        "action_counter": 924
      },
      {
        "commit_message": "fix: Add LADDER to traversable basic_types in find_path. Previously, the tool considered LADDER tiles as walls, preventing pathfinding to or from them.",
        "timestamp": "2025-11-20T10:46:07.670Z",
        "action_counter": 1068
      },
      {
        "commit_message": "fix: Add FLOOR_UP_WALL to traversable tiles when moving down. This tile type appears on Route 32 and visually resembles a ledge, so it is assumed to be jumpable from the north.",
        "timestamp": "2025-11-20T21:10:28.299Z",
        "action_counter": 1479
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. In-game testing proved this tile type blocks movement from the north, contrary to the initial hypothesis that it was a jumpable ledge.",
        "timestamp": "2025-11-20T21:14:51.875Z",
        "action_counter": 1484
      },
      {
        "commit_message": "fix: Reinforce object collision check in find_path and add debug prints for player's neighbors to diagnose issues where objects are ignored.",
        "timestamp": "2025-11-20T23:31:27.320Z",
        "action_counter": 1632
      },
      {
        "commit_message": "fix: Add CAVE to traversable basic_types. This tile type represents cave entrances (warps) and must be traversable to enter dungeons like Union Cave. Also removed debug prints.",
        "timestamp": "2025-11-20T23:38:16.306Z",
        "action_counter": 1641
      },
      {
        "commit_message": "fix: Enable FLOOR_UP_WALL as a traversable ledge when moving down. This is necessary to test if the western ledge at (12, 18) is jumpable, as the eastern path is blocked.",
        "timestamp": "2025-11-21T00:47:29.072Z",
        "action_counter": 1752
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. Verified in-game at (16, 21) that this tile type acts as a wall and cannot be jumped from the north.",
        "timestamp": "2025-11-21T00:59:17.529Z",
        "action_counter": 1768
      },
      {
        "commit_message": "fix: Ensure FLOOR_UP_WALL is treated as a wall. Previous testing at (16, 21) confirmed it is not jumpable from the north.",
        "timestamp": "2025-11-21T01:01:08.516Z",
        "action_counter": 1771
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. Verified in-game at (12, 17) -> (12, 18) that this tile type acts as a wall and cannot be jumped from the north.",
        "timestamp": "2025-11-21T01:05:06.366Z",
        "action_counter": 1776
      },
      {
        "commit_message": "feat: Allow movement UP onto FLOOR_UP_WALL tiles. Verified in-game at Union Cave (5, 19) -> (5, 18) that this tile type acts as a climbable ramp from the south.",
        "timestamp": "2025-11-21T02:01:30.245Z",
        "action_counter": 1847
      },
      {
        "commit_message": "feat: Allow horizontal movement on FLOOR_UP_WALL. The tiles at row 18 act as a traversable ridge connecting the west and east sides of the room.",
        "timestamp": "2025-11-21T02:05:19.643Z",
        "action_counter": 1850
      },
      {
        "commit_message": "feat: Update find_path to automatically target adjacent traversable tiles if the destination is blocked by a wall or object. This eliminates the need for manual coordinate guessing when targeting NPCs or obstacles.",
        "timestamp": "2025-11-22T00:45:06.962Z",
        "action_counter": 3307
      },
      {
        "commit_message": "feat: Enhance find_path to treat tiles with object-linked markers as obstacles. This prevents the pathfinder from routing through off-screen NPCs or objects that are known to exist but not currently rendered in the viewport.",
        "timestamp": "2025-11-22T02:29:58.782Z",
        "action_counter": 3465
      },
      {
        "commit_message": "refactor: Change output format from coordinates to button presses (e.g. [\"Up\", \"Right\"]). This enables compatibility with the `autopress_buttons: true` feature for automated navigation.",
        "timestamp": "2025-11-22T06:33:20.386Z",
        "action_counter": 3846
      },
      {
        "commit_message": "fix: Update find_path to return a JSON array of button strings (e.g. ['Up', 'Right']) instead of coordinates, enabling compatibility with autopress_buttons. Also re-implements logic to path to adjacent tiles if the target is blocked.",
        "timestamp": "2025-11-22T06:37:44.405Z",
        "action_counter": 3851
      },
      {
        "commit_message": "fix: Rewrite find_path to output a JSON array of button strings (e.g. [\"Up\", \"Right\"]) instead of coordinate objects. Adds logic to automatically path to an adjacent tile if the target is blocked by a wall, object, or marker.",
        "timestamp": "2025-11-22T06:42:53.734Z",
        "action_counter": 3857
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE to the obstacles list in find_path. Previously, the pathfinder treated these trees as walkable FLOOR tiles, causing pathfinding failures on Route 36.",
        "timestamp": "2025-11-22T09:46:43.517Z",
        "action_counter": 4061
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE to obstacles list in find_path tool. This prevents pathfinding through solid trees on Route 36.",
        "timestamp": "2025-11-22T09:53:42.815Z",
        "action_counter": 4069
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE to obstacles list in find_path tool. This prevents pathfinding failures where the tool tries to route through solid trees on Route 36.",
        "timestamp": "2025-11-22T10:01:47.695Z",
        "action_counter": 4078
      },
      {
        "commit_message": "fix: Add LEDGE_HOP_DOWN, LEDGE_HOP_UP, LEDGE_HOP_LEFT, and LEDGE_HOP_RIGHT to the obstacles list in find_path. This prevents the pathfinder from incorrectly generating paths that try to walk up one-way ledges, which caused a navigation error on Route 37.",
        "timestamp": "2025-11-22T11:03:50.170Z",
        "action_counter": 4148
      },
      {
        "commit_message": "fix: Update find_path to treat tiles marked with 'Hole' or üï≥Ô∏è as obstacles. This prevents the pathfinder from routing the player into pits in the Burned Tower.",
        "timestamp": "2025-11-22T15:38:21.684Z",
        "action_counter": 4436
      },
      {
        "commit_message": "fix: Update find_path to treat tiles marked with 'Hole' or üï≥Ô∏è as obstacles. This prevents the pathfinder from routing the player into pits in the Burned Tower.",
        "timestamp": "2025-11-22T15:45:56.249Z",
        "action_counter": 4441
      },
      {
        "commit_message": "fix: Update find_path to correctly identify tiles with 'Hole' markers or object-linked markers as obstacles. This prevents pathfinding through dangerous tiles in the Burned Tower.",
        "timestamp": "2025-11-22T15:59:15.044Z",
        "action_counter": 4454
      },
      {
        "commit_message": "fix: Add PIT to obstacles list in find_path. This prevents the pathfinder from routing the player into pits in the Lighthouse.",
        "timestamp": "2025-11-23T02:50:16.179Z",
        "action_counter": 5202
      },
      {
        "commit_message": "fix: Add LADDER to obstacles list in find_path. This prevents the pathfinder from routing through ladders which are warps, avoiding accidental map transitions.",
        "timestamp": "2025-11-23T05:18:17.385Z",
        "action_counter": 5381
      },
      {
        "commit_message": "fix: Update find_path to be context-aware for Surfing. Now checks if the player is on a WATER tile; if so, removes WATER from the obstacle list. Also added BUOY to the base obstacle list to prevent pathing into buoys.",
        "timestamp": "2025-11-23T12:00:41.709Z",
        "action_counter": 5818
      },
      {
        "commit_message": "fix: Add FLOOR_UP_WALL, FLOOR_DOWN_WALL, FLOOR_LEFT_WALL, and FLOOR_RIGHT_WALL to the obstacles list in find_path. These tiles represent ledges or one-way walls in the current map data (Mt. Mortar) and were causing pathfinding failures.",
        "timestamp": "2025-11-24T01:30:19.414Z",
        "action_counter": 6532
      },
      {
        "commit_message": "fix: Explicitly add FLOOR_UP_WALL, FLOOR_DOWN_WALL, FLOOR_LEFT_WALL, and FLOOR_RIGHT_WALL to the base_obstacles set. These tiles are solid walls (ledge faces) and caused pathfinding errors when the tool incorrectly treated them as traversable.",
        "timestamp": "2025-11-24T02:01:48.846Z",
        "action_counter": 6571
      }
    ]
  },
  "sequence_press": {
    "description": "Executes a sequence of button presses provided as a comma-separated string. Essential for navigating menus or keyboards where mixing directional and action inputs is required in a single turn.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "string",
          "description": "Comma-separated list of buttons to press, e.g., 'A, Down, Down, A'"
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nbuttons_str = input_data.get('buttons', '')\nif not buttons_str:\n    print('[]')\nelse:\n    button_list = [btn.strip() for btn in buttons_str.split(',')]\n    print(json.dumps(button_list))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-11-22T06:30:16.355Z",
        "action_counter": 3843
      }
    ]
  }
}