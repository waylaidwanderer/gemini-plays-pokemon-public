{
  "pathfinding_tool": {
    "description": "Calculates the shortest path between two points on the current map using A* search. This version is designed to handle different elevations like steps and ledges. Parses the map without external libraries.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import heapq\n\ndef parse_map_to_graph(xml_string):\n    graph = {}\n    try:\n        rows = xml_string.split('<Row id=')\n        for row_str in rows[1:]:\n            y = int(row_str.split('\"')[1])\n            tiles = row_str.split('<Tile id=')\n            for tile_str in tiles[1:]:\n                x = int(tile_str.split('\"')[1])\n                tile_type = tile_str.split('type=\"')[1].split('\"')[0]\n                has_object = 'has-object=\"true\"' in tile_str and 'id-name=\"Pikachu\"' not in tile_str\n                is_impassable = tile_type in ['impassable', 'water', 'unknown'] or has_object\n                graph[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n    except (IndexError, ValueError):\n        return None\n    return graph\n\ndef get_valid_neighbors(node, graph, width, height):\n    neighbors = []\n    x, y = node\n    current_tile_info = graph.get(node)\n    if not current_tile_info:\n        return []\n\n    potential_moves = [(x, y - 1, \"Up\"), (x, y + 1, \"Down\"), (x - 1, y, \"Left\"), (x + 1, y, \"Right\")]\n\n    for nx, ny, direction in potential_moves:\n        neighbor_node = (nx, ny)\n        if not (1 <= nx <= width and 1 <= ny <= height):\n            continue\n\n        neighbor_tile_info = graph.get(neighbor_node)\n        if not neighbor_tile_info or neighbor_tile_info['impassable']:\n            continue\n\n        current_type = current_tile_info['type']\n        neighbor_type = neighbor_tile_info['type']\n\n        if neighbor_type == 'ledge':\n            if y == ny - 1:\n                jump_dest = (nx, ny + 1)\n                if graph.get(jump_dest) and not graph.get(jump_dest)['impassable']:\n                    neighbors.append((jump_dest, direction, 1))\n                continue\n            else:\n                continue\n\n        is_current_elevated = current_type in ['elevated_ground']\n        is_neighbor_elevated = neighbor_type in ['elevated_ground']\n\n        if current_type != 'steps' and neighbor_type != 'steps':\n            if is_current_elevated != is_neighbor_elevated:\n                continue\n\n        if (current_type == 'steps' or neighbor_type == 'steps') and x != nx:\n            continue\n\n        neighbors.append((neighbor_node, direction, 1))\n\n    return neighbors\n\ndef a_star_search(graph, start, end, width, height):\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {node: float('inf') for node in graph}\n    g_score[start] = 0\n    f_score = {node: float('inf') for node in graph}\n    f_score[start] = abs(start[0] - end[0]) + abs(start[1] - end[1])\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == end:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            return path[::-1]\n\n        for neighbor, direction, cost in get_valid_neighbors(current, graph, width, height):\n            tentative_g_score = g_score.get(current, float('inf')) + cost\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + abs(neighbor[0] - end[0]) + abs(neighbor[1] - end[1])\n                if neighbor not in [item[1] for item in open_set]:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    return None\n\ndef path_to_buttons(path, graph):\n    buttons = []\n    if not path or len(path) < 2:\n        return []\n    for i in range(len(path) - 1):\n        curr_node = path[i]\n        next_node = path[i+1]\n        dx = next_node[0] - curr_node[0]\n        dy = next_node[1] - curr_node[1]\n\n        if dx == 1: buttons.append(\"Right\")\n        elif dx == -1: buttons.append(\"Left\")\n        elif dy == 1: buttons.append(\"Down\")\n        elif dy == -1: buttons.append(\"Up\")\n        elif dy == 2 and dx == 0 and graph.get((curr_node[0], curr_node[1]+1), {}).get('type') == 'ledge':\n            buttons.append(\"Down\")\n    return buttons\n\ntry:\n    width = int(map_xml_string.split('width=\"')[1].split('\"')[0])\n    height = int(map_xml_string.split('height=\"')[1].split('\"')[0])\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n    graph = parse_map_to_graph(map_xml_string)\n    if not graph:\n        print(\"Error: Failed to parse map XML.\")\n    else:\n        path = a_star_search(graph, start_node, end_node, width, height)\n        if path:\n            buttons = path_to_buttons(path, graph)\n            print(','.join(buttons))\n        else:\n            print(\"Error: No path found.\")\nexcept Exception as e:\n    import traceback\n    print(f\"Error: An unexpected error occurred - {traceback.format_exc()}\")"
  }
}