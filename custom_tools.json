{
  "menu_navigator_v2_fixed": {
    "description": "Executes a sequence of button presses to navigate menus. Returns a JSON array of buttons. Use this to bypass the restriction on mixing directional and action inputs. Automatically handles autopress_buttons.",
    "input_schema": {
      "properties": {
        "sequence": {
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "sequence"
      ],
      "type": "object"
    },
    "python_script": "import json\nprint(json.dumps(input_data.get('sequence', [])))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-14T06:16:48.631Z",
        "action_counter": 47221
      }
    ]
  },
  "find_path_v4": {
    "description": "Finds a traversable path from the player's current position to a target coordinate on the current map, specifically handling FLOOR_UP_WALL as impassable and LEDGE_HOP_DOWN as one-way. Returns a JSON array of button strings. Distinguishes between LAND and WATER mediums and handles unseen tiles by assuming they match the starting medium.",
    "input_schema": {
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ],
      "type": "object"
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ndef solve():\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = {}\n    player_pos = None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            has_obj = tile.attrib.get('has-object') == 'true'\n            grid[(x, y)] = (t_type, has_obj)\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n\n    if not player_pos:\n        print(\"Error: Player not found on map.\")\n        return\n\n    target = (int(input_data['target_x']), int(input_data['target_y']))\n    \n    # Determine starting medium\n    start_type, _ = grid.get(player_pos, ('unseen', True))\n    start_medium = 'WATER' if start_type == 'WATER' else 'LAND'\n\n    queue = [(player_pos, [])]\n    visited = {player_pos}\n    \n    while queue:\n        (cx, cy), path = queue.pop(0)\n        if (cx, cy) == target:\n            print(json.dumps(path))\n            return\n            \n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = cx + dx, cy + dy\n            if not (0 <= nx < width and 0 <= ny < height): continue\n            if (nx, ny) in visited: continue\n            \n            n_type, n_has_obj = grid.get((nx, ny), ('unseen', False))\n            if n_has_obj: continue\n            \n            # Movement logic\n            passable = False\n            if n_type == 'unseen':\n                passable = True\n            elif start_medium == 'WATER':\n                if n_type == 'WATER': passable = True\n                elif n_type in ['FLOOR', 'DOOR', 'WARP_CARPET']: passable = True\n            else: # LAND\n                if n_type in ['FLOOR', 'DOOR', 'WARP_CARPET']:\n                    passable = True\n                elif n_type == 'LEDGE_HOP_DOWN' and dy == 1:\n                    passable = True\n            \n            if passable:\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [btn]))\n    print(\"null\")\n\nsolve()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-14T22:03:54.305Z",
        "action_counter": 48121
      },
      {
        "commit_message": "Refined find_path_v4 to distinguish between LAND and WATER mediums and handle LEDGE_HOP_DOWN mechanics correctly.",
        "timestamp": "2026-01-14T22:13:13.453Z",
        "action_counter": 48139
      },
      {
        "commit_message": "Refined find_path_v4 to handle unseen tiles correctly by assuming they match the current medium, ensuring it doesn't get stuck when a path passes through unexplored but likely traversable areas.",
        "timestamp": "2026-01-14T22:31:16.211Z",
        "action_counter": 48161
      },
      {
        "commit_message": "Fixed find_path_v4 to correctly handle medium consistency for unseen tiles and robustly identify player Y coordinate.",
        "timestamp": "2026-01-14T22:32:14.969Z",
        "action_counter": 48162
      },
      {
        "commit_message": "Refined pathfinding logic for ledges and medium-specific passability.",
        "timestamp": "2026-01-15T01:41:59.683Z",
        "action_counter": 48434
      },
      {
        "commit_message": "Refined pathfinding logic for ledges and medium-specific passability.",
        "timestamp": "2026-01-15T01:43:19.153Z",
        "action_counter": 48435
      }
    ]
  },
  "find_path_plan": {
    "description": "Finds a traversable path from the player's current position to a target coordinate on the current map, specifically handling FLOOR_UP_WALL as impassable and LEDGE_HOP_DOWN as one-way (South). Returns a JSON array of coordinate objects [{\"x\": x, \"y\": y}]. Distinguishes between LAND and WATER mediums and handles unseen tiles by assuming they match the starting medium. This version also checks map markers for obstacles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef find_path(target_x, target_y, map_xml):\n    root = ET.fromstring(map_xml)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = {}\n    start_x, start_y = None, None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            grid[(x, y)] = tile\n            if tile.find('Player') is not None:\n                start_x, start_y = x, y\n                \n    if start_x is None: return None\n    \n    start_tile = grid.get((start_x, start_y))\n    if start_tile is None: return None\n    start_type = start_tile.attrib['type']\n    is_start_water = (start_type == 'WATER')\n    \n    queue = deque([(start_x, start_y, is_start_water, [{\"x\": start_x, \"y\": start_y}])])\n    visited = {(start_x, start_y, is_start_water)}\n    \n    while queue:\n        cx, cy, surfing, path = queue.popleft()\n        \n        if cx == target_x and cy == target_y:\n            return path\n            \n        for dx, dy, btn in [(0, -1, \"Up\"), (0, 1, \"Down\"), (-1, 0, \"Left\"), (1, 0, \"Right\")]:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < width and 0 <= ny < height:\n                tile = grid.get((nx, ny))\n                t_type = tile.attrib['type'] if tile is not None else \"unseen\"\n                \n                passable = False\n                n_surfing = surfing\n                \n                if surfing:\n                    if t_type in [\"WATER\", \"unseen\"]:\n                        passable = True\n                    elif t_type in [\"FLOOR\", \"DOOR\"]:\n                        passable = True\n                        n_surfing = False\n                    elif t_type == \"BUOY\":\n                        passable = False\n                else:\n                    if t_type in [\"FLOOR\", \"DOOR\", \"unseen\"]:\n                        passable = True\n                    elif t_type == \"WATER\":\n                        passable = True\n                        n_surfing = True\n                    elif t_type == \"LEDGE_HOP_DOWN\":\n                        if dy == 1: passable = True\n                \n                if t_type in [\"WALL\", \"BUOY\", \"FLOOR_UP_WALL\"]:\n                    passable = False\n                \n                if tile is not None:\n                    if tile.find('Object') is not None or tile.find('Boulder') is not None:\n                        if (nx, ny) != (target_x, target_y):\n                            passable = False\n                    for marker in tile.findall('Marker'):\n                        text = marker.text.lower()\n                        if \"rock\" in text or \"wall\" in text or \"dead end\" in text or \"impassable\" in text:\n                            if (nx, ny) != (target_x, target_y):\n                                passable = False\n                            \n                if passable:\n                    if (nx, ny, n_surfing) not in visited:\n                        visited.add((nx, ny, n_surfing))\n                        queue.append((nx, ny, n_surfing, path + [{\"x\": nx, \"y\": ny}]))\n    return None\n\ntry:\n    path = find_path(int(input_data['target_x']), int(input_data['target_y']), map_xml_string)\n    print(json.dumps(path))\nexcept Exception as e:\n    print(f\"Error: {str(e)}\")\n",
    "history": [
      {
        "commit_message": "Refined to return a path plan (list of coordinates) and correctly identify player position from XML. Handles water/land transitions.",
        "timestamp": "2026-01-15T04:34:58.545Z",
        "action_counter": 48649
      },
      {
        "commit_message": "Added marker checking to pathfinder to avoid known rocks and walls.",
        "timestamp": "2026-01-15T04:49:27.277Z",
        "action_counter": 48663
      }
    ]
  },
  "advanced_pathfinder": {
    "description": "Finds a traversable path to a target coordinate using a BFS algorithm, specifically handling tile types, objects, and ledge mechanics. Returns a JSON array of button strings.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "medium": {
          "type": "string",
          "enum": [
            "LAND",
            "WATER"
          ],
          "default": "LAND"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef solve():\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    medium = input_data.get('medium', 'LAND')\n    \n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = {}\n    player_pos = None\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            t_type = tile.get('type')\n            seen = tile.get('seen') == 'true'\n            has_obj = tile.get('has-object') == 'true'\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n            grid[(x, y)] = {'type': t_type, 'seen': seen, 'has_obj': has_obj}\n\n    if player_pos is None:\n        print(json.dumps([]))\n        return\n\n    def is_traversable(x, y, m):\n        if (x, y) not in grid: return True\n        tile = grid[(x, y)]\n        if not tile['seen']: return True\n        if tile['type'] in ['WALL', 'BUOY', 'FLOOR_UP_WALL', 'BREAKABLE ROCK']: return False\n        if tile['has_obj']: return False\n        if m == 'WATER':\n            return tile['type'] == 'WATER'\n        else:\n            return tile['type'] in ['FLOOR', 'DOOR', 'LADDER', 'WARP_CARPET_RIGHT', 'WARP_CARPET_LEFT', 'WARP_CARPET_UP', 'WARP_CARPET_DOWN', 'LEDGE_HOP_DOWN']\n\n    queue = deque([(player_pos[0], player_pos[1], [])])\n    visited = {player_pos}\n    while queue:\n        x, y, path = queue.popleft()\n        if (x, y) == (target_x, target_y):\n            print(json.dumps(path))\n            return\n        for dx, dy, btn in [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:\n                if is_traversable(nx, ny, medium):\n                    if medium == 'LAND' and dy == -1:\n                        t = grid.get((nx, ny), {})\n                        if t.get('seen') and t.get('type') == 'LEDGE_HOP_DOWN':\n                            continue\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [btn]))\n    print(json.dumps([]))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-15T07:01:26.035Z",
        "action_counter": 48811
      }
    ]
  },
  "advanced_pathfinder_v2": {
    "description": "Finds a traversable path to a target coordinate using a BFS algorithm, specifically handling tile types, objects, and ledge mechanics. Returns a JSON array of button strings.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "medium": {
          "type": "string",
          "enum": [
            "LAND",
            "WATER"
          ],
          "default": "LAND"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef solve():\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    medium = input_data.get('medium', 'LAND')\n    \n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = {}\n    player_pos = None\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            t_type = tile.get('type')\n            seen = tile.get('seen') == 'true'\n            has_obj = tile.get('has-object') == 'true'\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n            grid[(x, y)] = {'type': t_type, 'seen': seen, 'has_obj': has_obj}\n\n    if player_pos is None:\n        print(json.dumps([]))\n        return\n\n    def is_traversable(x, y, m):\n        if (x, y) not in grid: return True\n        tile = grid[(x, y)]\n        if not tile['seen']: return True\n        if tile['type'] in ['WALL', 'BUOY', 'FLOOR_UP_WALL', 'BREAKABLE ROCK', 'LEDGE_HOP_DOWN']: return False\n        if tile['has_obj']: return False\n        if m == 'WATER':\n            return tile['type'] == 'WATER'\n        else:\n            return tile['type'] in ['FLOOR', 'DOOR', 'LADDER', 'WARP_CARPET_RIGHT', 'WARP_CARPET_LEFT', 'WARP_CARPET_UP', 'WARP_CARPET_DOWN']\n\n    queue = deque([(player_pos[0], player_pos[1], [])])\n    visited = {player_pos}\n    while queue:\n        x, y, path = queue.popleft()\n        if (x, y) == (target_x, target_y):\n            print(json.dumps(path))\n            return\n        for dx, dy, btn in [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < width and 0 <= ny < height:\n                tile = grid.get((nx, ny), {})\n                # Normal traversability\n                if is_traversable(nx, ny, medium):\n                    if (nx, ny) not in visited:\n                        visited.add((nx, ny))\n                        queue.append((nx, ny, path + [btn]))\n                \n                # Ledge jump (South only)\n                if btn == 'Down' and tile.get('type') == 'LEDGE_HOP_DOWN' and medium == 'LAND':\n                    jx, jy = x, y + 2\n                    if 0 <= jy < height:\n                        if is_traversable(jx, jy, medium) and (jx, jy) not in visited:\n                             visited.add((jx, jy))\n                             queue.append((jx, jy, path + [btn]))\n    print(json.dumps([]))\n\nsolve()",
    "history": [
      {
        "commit_message": "Fix ledge mechanics and traversability logic.",
        "timestamp": "2026-01-15T07:30:33.564Z",
        "action_counter": 48842
      }
    ]
  }
}