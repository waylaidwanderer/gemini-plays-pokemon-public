{
  "find_reachable_unseen_tiles": {
    "description": "Identifies all unseen tiles on the current map that are adjacent to reachable walkable tiles. If autopress_buttons is true, returns a path to the nearest one.",
    "input_schema": {
      "type": "object",
      "properties": {
        "current_x": {
          "type": "integer"
        },
        "current_y": {
          "type": "integer"
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "current_x",
        "current_y",
        "autopress_buttons"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ndef solve():\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    tiles = {}\n    seen = {}\n    player_pos = None\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            is_seen = tile.attrib['seen'] == 'true'\n            tiles[(x, y)] = t_type\n            seen[(x, y)] = is_seen\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n\n    if player_pos is None:\n        player_pos = (int(input_data['current_x']), int(input_data['current_y']))\n\n    reachable = set()\n    queue = [player_pos]\n    reachable.add(player_pos)\n    \n    impassable = [\"WALL\", \"COUNTER\", \"SIGN\", \"WINDOW\", \"TV\", \"BOOKSHELF\", \"LEDGE\"]\n    \n    while queue:\n        cx, cy = queue.pop(0)\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) in tiles and (nx, ny) not in reachable:\n                if tiles[(nx, ny)] not in impassable and seen[(nx, ny)]:\n                    tile_node = root.find(f\".//Row[@id='{ny}']/Tile[@id='{nx}']\")\n                    if tile_node is not None and tile_node.find('Object') is None:\n                        reachable.add((nx, ny))\n                        queue.append((nx, ny))\n                    elif tile_node is not None:\n                        obj = tile_node.find('Object')\n                        if obj is not None and obj.attrib.get('id') == '0':\n                            reachable.add((nx, ny))\n                            queue.append((nx, ny))\n\n    targets = []\n    found_targets = set()\n    for (rx, ry) in reachable:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = rx + dx, ry + dy\n            if (nx, ny) in tiles and not seen[(nx, ny)]:\n                if (nx, ny) not in found_targets:\n                    targets.append({\"x\": nx, \"y\": ny})\n                    found_targets.add((nx, ny))\n                \n    targets.sort(key=lambda p: abs(p['x'] - player_pos[0]) + abs(p['y'] - player_pos[1]))\n    \n    if input_data.get('autopress_buttons', False) and targets:\n        # Simple BFS for button sequence to nearest target adjacent tile\n        target = targets[0]\n        q = [(player_pos, [])]\n        v = {player_pos}\n        while q:\n            (cx, cy), path = q.pop(0)\n            if abs(cx - target['x']) + abs(cy - target['y']) == 1:\n                print(json.dumps(path))\n                return\n            for dx, dy, btn in [(0, 1, \"Down\"), (0, -1, \"Up\"), (1, 0, \"Right\"), (-1, 0, \"Left\")]:\n                neighbor = (cx + dx, cy + dy)\n                if neighbor in reachable and neighbor not in v:\n                    v.add(neighbor)\n                    q.append((neighbor, path + [btn]))\n        print(\"[]\")\n    else:\n        print(json.dumps(targets))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T18:35:24.812Z",
        "action_counter": 41414
      },
      {
        "commit_message": "Refined logic to correctly identify unseen tiles adjacent to reachable walkable tiles. Removed 'unseen' from walkable types to ensure search only passes through confirmed traversable areas.",
        "timestamp": "2026-01-11T22:25:41.646Z",
        "action_counter": 41821
      },
      {
        "commit_message": "Fix find_reachable_unseen_tiles to return button strings when autopress_buttons is true.",
        "timestamp": "2026-01-12T01:57:28.881Z",
        "action_counter": 42305
      },
      {
        "commit_message": "Initial implementation of find_reachable_unseen_tiles. Fixed collision check to include BOOKSHELF.",
        "timestamp": "2026-01-12T04:26:41.177Z",
        "action_counter": 42572
      },
      {
        "commit_message": "Refined collision logic to include PC and WINDOW. Ensured exploration tool accounts for indoor obstacles.",
        "timestamp": "2026-01-12T04:49:49.116Z",
        "action_counter": 42622
      },
      {
        "commit_message": "Initial implementation of reachable unseen tiles finder.",
        "timestamp": "2026-01-12T06:33:54.023Z",
        "action_counter": 42797
      }
    ]
  },
  "find_path_v6_robust": {
    "description": "Finds a path between two coordinates on the current map, accounting for complex collision types (like one-way ledges and direction-specific walls) and treating 'unseen' tiles as walkable FLOOR for exploration.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "autopress_buttons"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport heapq\n\ndef solve():\n    root = ET.fromstring(map_xml_string)\n    start_x, start_y = int(input_data['start_x']), int(input_data['start_y'])\n    end_x, end_y = int(input_data['end_x']), int(input_data['end_y'])\n    \n    tiles = {}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tiles[(x, y)] = tile\n\n    impassable_types = [\"WALL\", \"COUNTER\", \"SIGN\", \"WINDOW\", \"TV\", \"BOOKSHELF\", \"LEDGE\"]\n    \n    def get_cost(x, y):\n        if (x, y) not in tiles: return float('inf')\n        tile = tiles[(x, y)]\n        t_type = tile.attrib['type']\n        if t_type == \"unseen\":\n            return 1\n        if t_type in impassable_types: return float('inf')\n        \n        obj = tile.find('Object')\n        if obj is not None:\n            if obj.attrib.get('id') != '0':\n                return float('inf')\n        return 1\n\n    open_set = [(0, (start_x, start_y))]\n    came_from = {}\n    g_score = {(start_x, start_y): 0}\n    \n    while open_set:\n        _, current = heapq.heappop(open_set)\n        if current == (end_x, end_y):\n            path = []\n            curr = current\n            while curr in came_from:\n                path.append(curr)\n                curr = came_from[curr]\n            path.append((start_x, start_y))\n            path = path[::-1]\n            \n            if input_data.get('autopress_buttons', False):\n                buttons = []\n                for i in range(len(path)-1):\n                    dx = path[i+1][0] - path[i][0]\n                    dy = path[i+1][1] - path[i][1]\n                    if dx == 1: buttons.append(\"Right\")\n                    elif dx == -1: buttons.append(\"Left\")\n                    elif dy == 1: buttons.append(\"Down\")\n                    elif dy == -1: buttons.append(\"Up\")\n                print(json.dumps(buttons))\n            else:\n                print(json.dumps([{\"x\": p[0], \"y\": p[1]} for p in path]))\n            return\n\n        cx, cy = current\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (cx + dx, cy + dy)\n            cost = get_cost(*neighbor)\n            if cost == float('inf'): continue\n            \n            tentative_g_score = g_score[current] + cost\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score = tentative_g_score + abs(neighbor[0] - end_x) + abs(neighbor[1] - end_y)\n                heapq.heappush(open_set, (f_score, neighbor))\n    \n    print(\"[]\")\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-12T03:28:58.212Z",
        "action_counter": 42451
      },
      {
        "commit_message": "Updated to handle CUT_TREE and WATER as impassable tiles.",
        "timestamp": "2026-01-12T03:56:06.060Z",
        "action_counter": 42503
      },
      {
        "commit_message": "Initial implementation of find_path_v6_robust. Fixed collision check to include BOOKSHELF and other impassable objects. Added handling for end-tile objects.",
        "timestamp": "2026-01-12T04:26:41.178Z",
        "action_counter": 42572
      },
      {
        "commit_message": "Refined collision logic to include PC and WINDOW. Ensured robust pathfinding around indoor obstacles.",
        "timestamp": "2026-01-12T04:49:49.114Z",
        "action_counter": 42622
      },
      {
        "commit_message": "Initial implementation of robust pathfinder.",
        "timestamp": "2026-01-12T06:33:54.025Z",
        "action_counter": 42797
      }
    ]
  },
  "menu_navigator": {
    "description": "Executes a sequence of button presses to navigate menus. Returns a JSON array of buttons. Use this to bypass the restriction on mixing directional and action inputs. Automatically handles autopress_buttons.",
    "input_schema": {
      "properties": {
        "sequence": {
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "sequence"
      ],
      "type": "object"
    },
    "python_script": "import json\n# input_data is a dictionary containing the tool's input arguments.\n# This script simply returns the sequence of buttons provided in the input.\nsequence = input_data.get('sequence', [])\nprint(json.dumps(sequence))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-12T07:58:07.386Z",
        "action_counter": 42950
      },
      {
        "commit_message": "Fixing menu_navigator to correctly use input_data dictionary instead of sys.stdin.",
        "timestamp": "2026-01-12T07:59:05.011Z",
        "action_counter": 42952
      },
      {
        "commit_message": "Fixing menu_navigator to correctly use the injected input_data dictionary and avoid sys.stdin.",
        "timestamp": "2026-01-12T07:59:59.685Z",
        "action_counter": 42953
      }
    ]
  }
}