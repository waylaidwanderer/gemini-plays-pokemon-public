{
  "find_path_v4": {
    "description": "Finds the shortest path to a target coordinate. Correctly handles walls, NPCs, and items. Returns an empty list if no path is found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef solve():\n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n        \n        root = ET.fromstring(map_xml_string)\n        \n        start_x, start_y = -1, -1\n        for row in root.findall('Row'):\n            curr_y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                if tile.find('Player') is not None:\n                    start_x = int(tile.attrib['id'])\n                    start_y = curr_y\n                    break\n            if start_x != -1: break\n            \n        if start_x == -1: return []\n\n        grid = {}\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                t_type = tile.attrib['type']\n                is_wall = t_type in ['WALL', 'COUNTER', 'BOOKSHELF', 'TABLE', 'MART_SHELF']\n                obj = tile.find('Object')\n                if obj is not None:\n                    # NPCs and items are walls unless they are the target (for interaction)\n                    if not (x == start_x and y == start_y) and not (x == target_x and y == target_y):\n                        is_wall = True\n                grid[(x, y)] = not is_wall\n\n        queue = deque([(start_x, start_y, [])])\n        visited = {(start_x, start_y)}\n        while queue:\n            x, y, path = queue.popleft()\n            if x == target_x and y == target_y:\n                return path\n            for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n                nx, ny = x + dx, y + dy\n                if (nx, ny) in grid and grid[(nx, ny)] and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [btn]))\n        return []\n    except Exception:\n        return []\n\nprint(json.dumps(solve()))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-21T06:11:17.104Z",
        "action_counter": 8161
      },
      {
        "commit_message": "Fixed find_path_v4: removed non-standard getparent() call and improved player position detection. Consolidated grid construction and BFS.",
        "timestamp": "2025-12-21T06:23:10.110Z",
        "action_counter": 8180
      }
    ]
  },
  "battle_move_selector_v2": {
    "description": "Selects a move from the move selection menu in battle. Assumes the move selection menu is open. Calculates the shortest path between current_index and target_index in a wrapping menu of 4 moves. Includes an initial 1000ms safety delay.",
    "input_schema": {
      "type": "object",
      "properties": {
        "current_index": {
          "description": "The current 0-indexed position of the cursor in the move menu.",
          "type": "integer"
        },
        "target_index": {
          "description": "The 0-indexed position of the move to select (0-3).",
          "type": "integer"
        }
      },
      "required": [
        "current_index",
        "target_index"
      ]
    },
    "python_script": "import json\n\ndef run(input_data):\n    try:\n        current_index = int(input_data.get('current_index', 0))\n        target_index = int(input_data.get('target_index', 0))\n    except (ValueError, TypeError):\n        current_index = 0\n        target_index = 0\n        \n    buttons = [\"sleep 1000\"]\n    \n    # Calculate movement in a wrapping menu of size 4\n    # diff is how many 'Down' presses to get from current to target\n    diff = (target_index - current_index) % 4\n    \n    if diff == 0:\n        pass\n    elif diff <= 2:\n        for _ in range(diff):\n            buttons.append(\"Down\")\n            buttons.append(\"sleep 300\")\n    else:\n        # 3 Downs is the same as 1 Up\n        for _ in range(4 - diff):\n            buttons.append(\"Up\")\n            buttons.append(\"sleep 300\")\n            \n    buttons.append(\"A\")\n    print(json.dumps(buttons))\n\nrun(input_data)\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-21T11:41:54.981Z",
        "action_counter": 8762
      },
      {
        "commit_message": "Corrected tool to use the 'input_data' variable for arguments instead of reading from stdin.",
        "timestamp": "2025-12-21T11:46:11.447Z",
        "action_counter": 8774
      },
      {
        "commit_message": "Added a safety delay (sleep 500) to ensure the move selection menu is fully active before button presses.",
        "timestamp": "2025-12-21T14:19:46.168Z",
        "action_counter": 9031
      },
      {
        "commit_message": "Fixed the tool by adding the necessary 'run(input_data)' call at the end of the script and added a cursor reset (3 Ups) to ensure it starts from move 0.",
        "timestamp": "2025-12-21T14:21:30.713Z",
        "action_counter": 9035
      },
      {
        "commit_message": "Increased initial safety delay to 1000ms to handle menu opening animations and added a 300ms delay after each move selection button to prevent input dropping.",
        "timestamp": "2025-12-21T14:22:49.888Z",
        "action_counter": 9037
      },
      {
        "commit_message": "Removed the faulty 'Up' reset logic which caused misclicks due to menu wrapping. Now relies on Gen 2's default behavior of resetting the cursor to 0 on menu open.",
        "timestamp": "2025-12-21T14:28:43.731Z",
        "action_counter": 9045
      },
      {
        "commit_message": "Re-added cursor reset (Up, Up, Up) with safety delays. In Gen 2, the move selection menu does NOT wrap, making this a reliable way to ensure the tool starts from move 0 even if the menu was already open.",
        "timestamp": "2025-12-21T14:31:21.406Z",
        "action_counter": 9048
      },
      {
        "commit_message": "Removed the faulty 'Up' reset logic and added a clear explanation in the description that the tool assumes the cursor starts at move index 0. This is necessary because the Gen 2 move menu wraps, making 'Up' resets unreliable.",
        "timestamp": "2025-12-21T14:32:49.857Z",
        "action_counter": 9049
      },
      {
        "commit_message": "Refined battle_move_selector_v2 to handle Gen 2's menu wrapping and memory. It now takes both current_index and target_index to calculate the most efficient path (Up or Down). Added safety delays.",
        "timestamp": "2025-12-21T14:44:07.047Z",
        "action_counter": 9061
      }
    ]
  },
  "get_map_warps_v1": {
    "description": "Extracts warp information (coordinates and entry points) for a list of map IDs from the mental map XML.",
    "input_schema": {
      "type": "object",
      "properties": {
        "map_ids": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "map_ids"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ndef run(input_data):\n    try:\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        print(f\"Error parsing XML: {e}\")\n        return\n\n    results = {}\n    map_ids = input_data.get('map_ids', [])\n    \n    # Check all maps in the XML (root and children)\n    for map_node in root.iter('Map'):\n        mid = map_node.get('id')\n        if mid in map_ids:\n            name = map_node.get('name')\n            warps = []\n            for row in map_node.findall('Row'):\n                y = row.get('id')\n                for tile in row.findall('Tile'):\n                    x = tile.get('id')\n                    warp = tile.find('Warp')\n                    if warp is not None:\n                        warps.append({\n                            'x': int(x),\n                            'y': int(y),\n                            'entry': int(warp.get('entry_point'))\n                        })\n            results[mid] = {'name': name, 'warps': warps}\n    print(json.dumps(results, indent=2))\n\nrun(input_data)",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-21T12:56:21.285Z",
        "action_counter": 8882
      },
      {
        "commit_message": "Refined to handle root <Map> element correctly by using root.iter('Map').",
        "timestamp": "2025-12-21T12:58:59.126Z",
        "action_counter": 8885
      }
    ]
  },
  "check_reachable_unseen_v1": {
    "description": "Finds all unseen tiles adjacent to reachable walkable tiles on the current map. Relies on verified traversable tile types from the notepad. Returns a list of coordinate dictionaries.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport sys\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n        # Define walkable types based on verified notepad info\n        walkable_types = ['FLOOR', 'LADDER', 'STAIRCASE', 'WARP_CARPET_DOWN', 'WARP_CARPET_UP', 'GRASS', 'SAND', 'WATER']\n        \n        grid = {}\n        start_x, start_y = -1, -1\n        \n        # Parse the entire map into a coordinate-indexed dictionary\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                coord = (x, y)\n                grid[coord] = {\n                    'type': tile.attrib['type'],\n                    'seen': tile.attrib['seen'] == 'true',\n                    'has_object': tile.get('has-object') == 'true',\n                    'has_player': tile.find('Player') is not None\n                }\n                if grid[coord]['has_player']:\n                    start_x, start_y = x, y\n        \n        if start_x == -1:\n            # Fallback: if player not found in XML, we can't determine reachability\n            print(json.dumps([]))\n            return\n\n        # BFS to find all reachable seen tiles\n        queue = [(start_x, start_y)]\n        visited = {(start_x, start_y)}\n        reachable_seen = set()\n        \n        while queue:\n            cx, cy = queue.pop(0)\n            reachable_seen.add((cx, cy))\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = cx + dx, cy + dy\n                if (nx, ny) in grid:\n                    node = grid[(nx, ny)]\n                    # We can walk through seen walkable tiles that don't have NPCs/objects\n                    # Note: The tile the player is ON is always considered walkable for BFS purposes\n                    if node['seen'] and (nx, ny) not in visited:\n                        if node['type'] in walkable_types and not node['has_object']:\n                            visited.add((nx, ny))\n                            queue.append((nx, ny))\n        \n        # Find all unseen tiles adjacent to reachable seen tiles\n        reachable_unseen = set()\n        for rx, ry in reachable_seen:\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = rx + dx, ry + dy\n                if (nx, ny) in grid and not grid[(nx, ny)]['seen']:\n                    reachable_unseen.add((nx, ny))\n        \n        res = [{\"x\": x, \"y\": y} for x, y in reachable_unseen]\n        print(json.dumps(res))\n    except Exception as e:\n        print(json.dumps([{\"error\": str(e)}]))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-21T13:00:01.847Z",
        "action_counter": 8888
      },
      {
        "commit_message": "Updated to find the map where the player is currently located and better handle traversable types.",
        "timestamp": "2025-12-21T13:01:21.398Z",
        "action_counter": 8891
      },
      {
        "commit_message": "Fixed map node detection to handle both <Map> as root or as a child of <MentalMap>.",
        "timestamp": "2025-12-21T13:01:56.860Z",
        "action_counter": 8892
      },
      {
        "commit_message": "Updated traversable types to include all WARP_CARPET variants and added a more robust player position detection.",
        "timestamp": "2025-12-21T15:01:02.663Z",
        "action_counter": 9075
      },
      {
        "commit_message": "Fixing tool definition by adding mandatory commit message.",
        "timestamp": "2025-12-21T15:48:45.536Z",
        "action_counter": 9183
      },
      {
        "commit_message": "Refining check_reachable_unseen_v1 to be more robust and handle potential edge cases in map XML parsing.",
        "timestamp": "2025-12-21T16:18:22.240Z",
        "action_counter": 9241
      }
    ]
  },
  "detect_tile_changes": {
    "description": "Analyzes the Mental Map XML to identify tiles that have changed type (e.g., from WALL to FLOOR) compared to a provided baseline state. This is useful for identifying dynamic objects like shutters controlled by switches.",
    "input_schema": {
      "properties": {
        "baseline_tiles": {
          "description": "A dictionary where keys are coordinate strings '(x, y)' and values are the expected tile types.",
          "type": "object"
        }
      },
      "required": [
        "baseline_tiles"
      ],
      "type": "object"
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport sys\n\ndef solve():\n    try:\n        baseline = input_data.get('baseline_tiles', {})\n        root = ET.fromstring(map_xml_string)\n        changes = []\n        \n        for row in root.findall('Row'):\n            y = row.attrib['id']\n            for tile in row.findall('Tile'):\n                x = tile.attrib['id']\n                coord = f\"({x}, {y})\"\n                t_type = tile.attrib['type']\n                \n                if coord in baseline and baseline[coord] != t_type:\n                    changes.append({\n                        \"coordinate\": coord,\n                        \"old_type\": baseline[coord],\n                        \"new_type\": t_type\n                    })\n        \n        print(json.dumps(changes))\n    except Exception as e:\n        print(json.dumps({\"error\": str(e)}))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-21T15:36:58.806Z",
        "action_counter": 9153
      }
    ]
  }
}