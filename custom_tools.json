{
  "navigate_fly_map_v2": {
    "description": "Navigates the Johto FLY map from a known starting city to a target city. City names: 'New Bark Town', 'Cherrygrove City', 'Violet City', 'Azalea Town', 'Goldenrod City', 'Ecruteak City', 'Olivine City', 'Cianwood City', 'Mahogany Town', 'Lake of Rage', 'Blackthorn City', 'Mt. Silver', 'Indigo Plateau'. Assumes the FLY map is already open.",
    "input_schema": {
      "properties": {
        "start_city": {
          "default": "New Bark Town",
          "type": "string"
        },
        "target_city": {
          "type": "string"
        }
      },
      "required": [
        "target_city"
      ],
      "type": "object"
    },
    "python_script": "import json\n\ndef navigate_fly_map(target_city, start_city=\"New Bark Town\"):\n    cities = [\n        \"New Bark Town\", \"Cherrygrove City\", \"Violet City\", \"Azalea Town\",\n        \"Goldenrod City\", \"Ecruteak City\", \"Olivine City\", \"Cianwood City\",\n        \"Mahogany Town\", \"Lake of Rage\", \"Blackthorn City\", \"Mt. Silver\", \"Indigo Plateau\"\n    ]\n    \n    if target_city not in cities or start_city not in cities:\n        print(json.dumps([]))\n        return\n\n    start_idx = cities.index(start_city)\n    target_idx = cities.index(target_city)\n    diff = target_idx - start_idx\n    \n    buttons = []\n    # In Crystal Johto FLY map:\n    # 'Up' moves forward in the sequence (index increases).\n    if diff > 0:\n        buttons = [\"Up\"] * diff\n    elif diff < 0:\n        buttons = [\"Down\"] * abs(diff)\n    \n    buttons.append(\"A\")\n    print(json.dumps(buttons))\n\n# The variable 'input_data' is automatically available.\nnavigate_fly_map(input_data['target_city'], input_data.get('start_city', 'New Bark Town'))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-27T03:08:24.414Z",
        "action_counter": 24583
      }
    ]
  },
  "sweep_area_v2": {
    "description": "Iteratively walks all floor tiles within a specified bounding box on the current map to trigger events or find objects. Uses BFS for robust movement between points and handles obstacles. Returns a list of button strings for the path.",
    "input_schema": {
      "type": "object",
      "properties": {
        "bottom_y": {
          "type": "integer"
        },
        "left_x": {
          "type": "integer"
        },
        "right_x": {
          "type": "integer"
        },
        "top_y": {
          "type": "integer"
        }
      },
      "required": [
        "left_x",
        "top_y",
        "right_x",
        "bottom_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n    except:\n        print(json.dumps([]))\n        return\n\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    # Build adjacency and walkable map\n    walkable = {}\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            t_type = tile.get('type')\n            has_obj = tile.get('has-object') == 'true'\n            # Floor, grass, etc are walkable. Walls and objects are not.\n            is_walkable = t_type in ['FLOOR', 'TALL_GRASS', 'LONG_GRASS'] and not has_obj\n            walkable[(x, y)] = is_walkable\n\n    # Correct way to find player\n    start_x, start_y = -1, -1\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            if tile.find('Player') is not None:\n                start_x = int(tile.get('id'))\n                start_y = y\n                break\n        if start_x != -1: break\n\n    left_x = int(input_data['left_x'])\n    top_y = int(input_data['top_y'])\n    right_x = int(input_data['right_x'])\n    bottom_y = int(input_data['bottom_y'])\n\n    targets = []\n    for y in range(top_y, bottom_y + 1):\n        if (y - top_y) % 2 == 0:\n            for x in range(left_x, right_x + 1):\n                if walkable.get((x, y)): targets.append((x, y))\n        else:\n            for x in range(right_x, left_x - 1, -1):\n                if walkable.get((x, y)): targets.append((x, y))\n\n    if not targets:\n        print(json.dumps([]))\n        return\n\n    def get_path(s_x, s_y, e_x, e_y):\n        q = deque([(s_x, s_y, [])])\n        visited = set([(s_x, s_y)])\n        while q:\n            cx, cy, path = q.popleft()\n            if cx == e_x and cy == e_y:\n                return path\n            for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n                nx, ny = cx + dx, cy + dy\n                if (nx, ny) in walkable and walkable[(nx, ny)] and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    q.append((nx, ny, path + [btn]))\n        return None\n\n    full_path = []\n    curr_x, curr_y = start_x, start_y\n    for tx, ty in targets:\n        p = get_path(curr_x, curr_y, tx, ty)\n        if p:\n            full_path.extend(p)\n            curr_x, curr_y = tx, ty\n    \n    print(json.dumps(full_path))\n\nsolve()\n",
    "history": [
      {
        "commit_message": "Initial version of a robust area sweep tool using BFS for navigation between floor tiles.",
        "timestamp": "2025-12-27T05:49:48.091Z",
        "action_counter": 24932
      },
      {
        "commit_message": "Fixing typo 'intelligence' to 'in' and improving logic.",
        "timestamp": "2025-12-27T14:27:39.597Z",
        "action_counter": 26009
      }
    ]
  },
  "find_path_v4": {
    "description": "Calculates a path between two coordinates on the current map using BFS, accounting for walls, objects, and avoiding unintentional warps. Returns a JSON array of button strings. Specifically handles landing from water onto floor tiles.",
    "input_schema": {
      "properties": {
        "can_surf": {
          "default": false,
          "type": "boolean"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "nullable": true,
          "type": "integer"
        },
        "start_y": {
          "nullable": true,
          "type": "integer"
        }
      },
      "required": [
        "end_x",
        "end_y"
      ],
      "type": "object"
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\nimport json\n\ndef find_path():\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    player_tile = root.find(\".//Tile[Player]\")\n    if player_tile is not None:\n        start_x = int(player_tile.get('id'))\n        for row in root.findall('Row'):\n            if player_tile in row.findall('Tile'):\n                start_y = int(row.get('id'))\n                break\n    else:\n        start_x = input_data.get('start_x')\n        start_y = input_data.get('start_y')\n        if start_x is None or start_y is None:\n            print(json.dumps({\"error\": \"Player position not found\"}))\n            return\n\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    can_surf = input_data.get('can_surf', False)\n\n    queue = collections.deque([(start_x, start_y, [])])\n    visited = set([(start_x, start_y)])\n    \n    tiles = {}\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tiles[(x, y)] = tile\n\n    passable_types = ['FLOOR', 'GRASS', 'TALL_GRASS', 'LONG_GRASS', 'WARP_CARPET', 'STAIRS', 'FLOOR_UP_WALL', 'DOOR', 'CAVE', 'WARP', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'WARP_CARPET_UP', 'WARP_CARPET_DOWN', 'LADDER']\n\n    while queue:\n        curr_x, curr_y, path = queue.popleft()\n        \n        if curr_x == end_x and curr_y == end_y:\n            print(json.dumps(path))\n            return\n            \n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = curr_x + dx, curr_y + dy\n            \n            if (nx, ny) in tiles and (nx, ny) not in visited:\n                tile = tiles[(nx, ny)]\n                t_type = tile.get('type')\n                is_warp = tile.get('is-warp') == 'true'\n                has_obj = tile.find('Object') is not None\n                \n                passable = False\n                if t_type in passable_types:\n                    passable = not has_obj\n                elif t_type == 'WATER' and can_surf:\n                    passable = not has_obj\n                \n                curr_tile = tiles.get((curr_x, curr_y))\n                if curr_tile is not None and curr_tile.get('type') == 'WATER' and t_type in passable_types:\n                    passable = not has_obj\n\n                if is_warp and (nx != end_x or ny != end_y):\n                    passable = False\n                \n                if passable:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [btn]))\n\n    print(json.dumps({\"error\": \"Path not found\"}))\n\nfind_path()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-27T11:19:09.748Z",
        "action_counter": 25621
      },
      {
        "commit_message": "Fix parent traversal error and simplify player position detection.",
        "timestamp": "2025-12-27T11:22:42.826Z",
        "action_counter": 25624
      },
      {
        "commit_message": "Fix parent traversal error, simplify player position detection, and add robust error handling.",
        "timestamp": "2025-12-27T11:23:40.857Z",
        "action_counter": 25625
      },
      {
        "commit_message": "Fix output format to use json.dumps for proper JSON array compatibility with autopress_buttons.",
        "timestamp": "2025-12-27T11:32:10.711Z",
        "action_counter": 25643
      },
      {
        "commit_message": "Expand passable_types to include DOOR and various WARP_CARPET types to fix navigation to building entrances.",
        "timestamp": "2025-12-27T11:49:56.943Z",
        "action_counter": 25684
      },
      {
        "commit_message": "Add LADDER to passable_types in find_path_v4.",
        "timestamp": "2025-12-27T11:58:14.551Z",
        "action_counter": 25707
      }
    ]
  },
  "get_exploration_targets": {
    "description": "Analyzes the current map XML and identifies unseen tiles that are adjacent to known walkable tiles, helping prioritize exploration.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ndef run():\n    root = ET.fromstring(map_xml_string)\n    walkable_types = ['FLOOR', 'GRASS', 'TALL_GRASS', 'LONG_GRASS', 'FLOOR_UP_WALL', 'WARP_CARPET_DOWN', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'WARP_CARPET_UP', 'DOOR', 'CAVE']\n    \n    walkable_tiles = set()\n    unseen_tiles = []\n    \n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            t_type = tile.get('type')\n            seen = tile.get('seen') == 'true'\n            \n            if seen and t_type in walkable_types:\n                walkable_tiles.add((x, y))\n            elif not seen:\n                unseen_tiles.append({'x': x, 'y': y})\n                \n    exploration_targets = []\n    for target in unseen_tiles:\n        tx, ty = target['x'], target['y']\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            if (tx + dx, ty + dy) in walkable_tiles:\n                exploration_targets.append(target)\n                break\n    \n    print(json.dumps(exploration_targets))\n\nrun()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-27T12:45:15.743Z",
        "action_counter": 25794
      }
    ]
  }
}