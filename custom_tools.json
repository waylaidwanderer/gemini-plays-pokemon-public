{
  "dungeon_navigator": {
    "description": "Generates a full, systematic exploration path for the current map segment using a proper DFS traversal algorithm. It visits every reachable, non-warp ground tile. This is the primary tool for clearing complex dungeons.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "start_facing": {
          "type": "string",
          "enum": [
            "up",
            "down",
            "left",
            "right"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "start_facing"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef path_to_buttons(path, start_facing, grid):\n    buttons = []\n    if not path or len(path) < 2:\n        return []\n    current_facing = start_facing\n    for i in range(len(path) - 1):\n        x1, y1 = path[i]\n        x2, y2 = path[i+1]\n        move_direction = None\n        if y2 < y1: move_direction = 'up'\n        elif y2 > y1: move_direction = 'down'\n        elif x2 < x1: move_direction = 'left'\n        elif x2 > x1: move_direction = 'right'\n        \n        dest_tile_data = grid.get((x2, y2))\n        is_pikachu_move = dest_tile_data and dest_tile_data.get('is_pikachu', False)\n        \n        if is_pikachu_move and current_facing != move_direction:\n            buttons.extend([move_direction.capitalize(), move_direction.capitalize()])\n        else:\n            buttons.append(move_direction.capitalize())\n        current_facing = move_direction\n    return buttons\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    start_facing = input_data['start_facing']\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    grid = {}\n    for r in root.findall('Row'):\n        y = int(r.get('id'))\n        for t in r.findall('Tile'):\n            x = int(t.get('id'))\n            obj_node = t.find('Object')\n            is_pikachu = obj_node is not None and obj_node.get('id-name') == 'Pikachu'\n            has_impassable_object = obj_node is not None and not is_pikachu\n            grid[(x, y)] = {\n                'type': t.get('type'), \n                'has_object': has_impassable_object,\n                'is_warp': t.get('is-warp') == 'true',\n                'is_pikachu': is_pikachu\n            }\n\n    impassable_types = ['impassable', 'unknown', 'cuttable', 'water', 'closed_gate', 'ledge']\n    \n    print(\"--- Dungeon Navigator v5 --- DEBUG RUN ---\")\n    print(f\"Starting at ({start_x}, {start_y}) facing {start_facing}\")\n\n    path = []\n    stack = [(start_x, start_y)]\n    visited = set()\n\n    while stack:\n        cx, cy = stack[-1]\n        \n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            path.append((cx, cy))\n\n        found_neighbor = False\n        for dx, dy in [(0, -1), (1, 0), (0, 1), (-1, 0)]: # Up, Right, Down, Left\n            nx, ny = cx + dx, cy + dy\n            \n            if (nx, ny) not in visited:\n                neighbor_tile = grid.get((nx, ny))\n                if neighbor_tile and neighbor_tile['type'] not in impassable_types and not neighbor_tile['has_object'] and not neighbor_tile['is_warp']:\n                    stack.append((nx, ny))\n                    found_neighbor = True\n                    break\n        \n        if not found_neighbor:\n            stack.pop()\n            if stack:\n                path.append(stack[-1])\n\n    print(f\"Generated raw DFS path with {len(path)} points, covering {len(visited)} tiles.\")\n    button_sequence = path_to_buttons(path, start_facing, grid)\n    print(f\"Converted to {len(button_sequence)} button presses.\")\n    print(\"--- Dungeon Navigator v5 Complete ---\")\n    print(json.dumps({'path_found': True, 'buttons': button_sequence, 'tiles_visited': len(visited), 'path_length': len(button_sequence)}))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'path_found': False, 'error': str(e), 'traceback': traceback.format_exc()}))\n"
  },
  "map_segment_analyzer": {
    "description": "Analyzes the current map segment to find all reachable tiles, warps, and objects from the player's current position using a proper BFS. Handles `closed_gate` tiles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\nimport traceback\n\ndef analyze_segment_fixed(map_xml_string, start_x, start_y):\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        start_x, start_y = int(start_x), int(start_y)\n\n        grid = {}\n        for r in root.findall('Row'):\n            y = int(r.get('id'))\n            for t in r.findall('Tile'):\n                x = int(t.get('id'))\n                has_impassable_object = False\n                obj_node = t.find('Object')\n                if obj_node is not None and obj_node.get('id-name') != 'Pikachu':\n                    has_impassable_object = True\n                \n                grid[(x, y)] = {\n                    'type': t.get('type'),\n                    'has_object': has_impassable_object,\n                    'is_warp': t.get('is-warp') == 'true',\n                    'original_object_node': obj_node\n                }\n        \n        impassable_types = ['impassable', 'unknown', 'cuttable', 'water', 'closed_gate']\n        \n        queue = deque([(start_x, start_y)])\n        visited = set([(start_x, start_y)])\n        reachable_tiles_coords = set([(start_x, start_y)])\n        reachable_warps, reachable_objects = [], []\n\n        while queue:\n            cx, cy = queue.popleft()\n            \n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = cx + dx, cy + dy\n\n                if (nx, ny) not in visited:\n                    neighbor_data = grid.get((nx, ny))\n                    if neighbor_data:\n                        visited.add((nx, ny))\n                        if neighbor_data['type'] not in impassable_types and not neighbor_data['has_object']:\n                            reachable_tiles_coords.add((nx, ny))\n                            queue.append((nx, ny))\n        \n        for x, y in reachable_tiles_coords:\n            tile_data = grid.get((x, y))\n            if tile_data:\n                if tile_data['is_warp']:\n                    if {'x': x, 'y': y} not in reachable_warps:\n                        reachable_warps.append({'x': x, 'y': y})\n                \n                obj_node = tile_data['original_object_node']\n                if obj_node is not None:\n                    obj_data = {\n                        'id': obj_node.get('id'),\n                        'id-name': obj_node.get('id-name'),\n                        'name': obj_node.get('name'),\n                        'x': x,\n                        'y': y\n                    }\n                    if obj_data not in reachable_objects:\n                        reachable_objects.append(obj_data)\n\n        result = {\n            \"reachable_tiles_count\": len(reachable_tiles_coords),\n            \"reachable_warps\": reachable_warps,\n            \"reachable_objects\": reachable_objects,\n            \"segment_size\": len(reachable_tiles_coords)\n        }\n        return json.dumps(result, indent=2)\n        \n    except Exception as e:\n        return json.dumps({\"error\": str(e), \"traceback\": traceback.format_exc()})\n\nprint(analyze_segment_fixed(map_xml_string, input_data['start_x'], input_data['start_y']))"
  },
  "overworld_navigator": {
    "description": "Calculates a multi-map path between a start and end location using the World Knowledge Graph. This tool is designed for complex navigation that requires traversing between different map_ids via warps or map edges. It returns a sequence of actions, including local pathfinding on each map segment and the necessary warp/transition actions.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_map_id": {
          "type": "string"
        },
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_map_id": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_map_id",
        "start_x",
        "start_y",
        "end_map_id",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import json\nimport heapq\n\ndef heuristic(a, b):\n    return abs(a['x'] - b['x']) + abs(a['y'] - b['y'])\n\ndef a_star_search(graph, start_node_id, end_node_id):\n    nodes_by_id = {n['id']: n for n in graph['nodes']}\n    start_node = nodes_by_id.get(start_node_id)\n    end_node = nodes_by_id.get(end_node_id)\n    if not start_node or not end_node:\n        return None\n\n    open_set = [(0, start_node_id)]\n    came_from = {}\n    g_score = {node_id: float('inf') for node_id in nodes_by_id}\n    g_score[start_node_id] = 0\n    f_score = {node_id: float('inf') for node_id in nodes_by_id}\n    f_score[start_node_id] = heuristic(start_node['coordinates'], end_node['coordinates'])\n    open_set_hash = {start_node_id}\n\n    while open_set:\n        _, current_id = heapq.heappop(open_set)\n        open_set_hash.remove(current_id)\n\n        if current_id == end_node_id:\n            path = []\n            temp = current_id\n            while temp in came_from:\n                path.append(temp)\n                temp = came_from[temp]\n            path.append(start_node_id)\n            return path[::-1]\n\n        for edge in graph['edges']:\n            neighbor_id = None\n            if edge['source_node_id'] == current_id:\n                neighbor_id = edge['destination_node_id']\n            elif edge['destination_node_id'] == current_id and not edge.get('is_one_way', False):\n                neighbor_id = edge['source_node_id']\n\n            if neighbor_id:\n                tentative_g_score = g_score[current_id] + 1\n                if tentative_g_score < g_score[neighbor_id]:\n                    came_from[neighbor_id] = current_id\n                    g_score[neighbor_id] = tentative_g_score\n                    neighbor_node = nodes_by_id.get(neighbor_id)\n                    if neighbor_node:\n                        f_score[neighbor_id] = g_score[neighbor_id] + heuristic(neighbor_node['coordinates'], end_node['coordinates'])\n                        if neighbor_id not in open_set_hash:\n                            heapq.heappush(open_set, (f_score[neighbor_id], neighbor_id))\n                            open_set_hash.add(neighbor_id)\n    return None\n\ntry:\n    world_graph = json.loads(world_knowledge_graph_json_string)\n    start_map_id = input_data['start_map_id']\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_map_id = input_data['end_map_id']\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n\n    start_nodes_on_map = [n for n in world_graph.get('nodes', []) if n.get('map_id') == start_map_id]\n    end_nodes_on_map = [n for n in world_graph.get('nodes', []) if n.get('map_id') == end_map_id]\n\n    if not start_nodes_on_map or not end_nodes_on_map:\n        print(json.dumps({'path_found': False, 'path': [], 'error': 'Start or end map not found in World Knowledge Graph.'}))\n    else:\n        start_node = min(start_nodes_on_map, key=lambda n: heuristic(n['coordinates'], {'x': start_x, 'y': start_y}))\n        end_node = min(end_nodes_on_map, key=lambda n: heuristic(n['coordinates'], {'x': end_x, 'y': end_y}))\n        path_node_ids = a_star_search(world_graph, start_node['id'], end_node['id'])\n\n        if path_node_ids:\n            path_details = []\n            for node_id in path_node_ids:\n                node = next((n for n in world_graph['nodes'] if n['id'] == node_id), None)\n                if node:\n                    path_details.append({'map_id': node['map_id'], 'name': node['name'], 'x': node['coordinates']['x'], 'y': node['coordinates']['y']})\n            print(json.dumps({'path_found': True, 'path': path_details}))\n        else:\n            print(json.dumps({'path_found': False, 'path': [], 'error': 'No path found between nodes in World Knowledge Graph.'}))\nexcept Exception as e:\n    print(json.dumps({'path_found': False, 'path': [], 'error': str(e)}))\n"
  },
  "pathfinder": {
    "description": "Calculates the shortest path on the current map using BFS. Handles ledges. UNRELIABLE for maps with dynamic obstacles like puzzles or moving NPCs.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n\n    grid = {}\n    for r in root.findall('Row'):\n        y = int(r.get('id'))\n        for t in r.findall('Tile'):\n            x = int(t.get('id'))\n            has_impassable_object = False\n            obj_node = t.find('Object')\n            if obj_node is not None and obj_node.get('id-name') != 'Pikachu':\n                has_impassable_object = True\n            grid[(x, y)] = {\n                'type': t.get('type'),\n                'has_object': has_impassable_object\n            }\n\n    impassable_types = ['impassable', 'unknown', 'cuttable', 'water', 'closed_gate']\n\n    queue = deque([([ (start_x, start_y) ])])\n    visited = {(start_x, start_y)}\n\n    while queue:\n        path = queue.popleft()\n        cx, cy = path[-1]\n\n        if (cx, cy) == (end_x, end_y):\n            json_path = [{'x': p[0], 'y': p[1]} for p in path]\n            print(json.dumps({'path_found': True, 'path': json_path}))\n            exit()\n\n        current_tile = grid.get((cx, cy))\n        \n        if current_tile and current_tile['type'] == 'ledge':\n            nx, ny = cx, cy + 1\n            if (1 <= ny <= height):\n                landing_x, landing_y = nx, ny + 1\n                if (landing_x, landing_y) not in visited and (1 <= landing_y <= height):\n                     landing_tile = grid.get((landing_x, landing_y))\n                     if landing_tile and landing_tile['type'] not in impassable_types and not landing_tile['has_object']:\n                        visited.add((landing_x, landing_y))\n                        new_path = path + [(landing_x, landing_y)]\n                        queue.append(new_path)\n            continue\n\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = cx + dx, cy + dy\n\n            if not (1 <= nx <= width and 1 <= ny <= height) or (nx, ny) in visited:\n                continue\n\n            neighbor_tile = grid.get((nx, ny))\n            if not neighbor_tile:\n                continue\n\n            if neighbor_tile['type'] in impassable_types or neighbor_tile['has_object']:\n                continue\n            \n            if neighbor_tile['type'] == 'ledge':\n                if dy == -1 or dx != 0:\n                    continue\n            \n            visited.add((nx, ny))\n            new_path = path + [(nx, ny)]\n            queue.append(new_path)\n\n    print(json.dumps({'path_found': False, 'path': []}))\n\nexcept Exception as e:\n    print(json.dumps({'path_found': False, 'error': str(e)}))"
  },
  "select_battle_option": {
    "description": "Calculates and executes the button presses needed to select a specific option from the main battle menu (FIGHT, PKMN, ITEM, RUN).",
    "input_schema": {
      "type": "object",
      "properties": {
        "option_to_select": {
          "type": "string",
          "enum": [
            "FIGHT",
            "PKMN",
            "ITEM",
            "RUN"
          ]
        }
      },
      "required": [
        "option_to_select"
      ]
    },
    "python_script": "option = input_data['option_to_select']\noptions = [\"FIGHT\", \"PKMN\", \"ITEM\", \"RUN\"]\ncurrent_pos = 0 # Assume cursor starts on FIGHT\npresses = []\ntarget_pos = options.index(option)\n# Simplified logic: Assume cursor moves right and down\nif target_pos == 1: # PKMN\n    presses.append('Right')\nelif target_pos == 2: # ITEM\n    presses.append('Down')\nelif target_pos == 3: # RUN\n    presses.append('Right')\n    presses.append('Down')\npresses.append('A')\nimport json\nprint(json.dumps(presses))"
  }
}