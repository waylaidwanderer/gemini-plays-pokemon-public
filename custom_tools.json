{
  "puzzle_solver": {
    "description": "Solves Sokoban-style boulder puzzles. Takes optional start coordinates, but requires goal coordinates for the final boulder position. It uses a Breadth-First Search algorithm to find the optimal sequence of moves.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer",
          "nullable": true
        },
        "start_y": {
          "type": "integer",
          "nullable": true
        },
        "goal_x": {
          "type": "integer"
        },
        "goal_y": {
          "type": "integer"
        }
      },
      "required": [
        "goal_x",
        "goal_y"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\n\n# Parse map data\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\n\nwalls = set()\nboulders = []\nplayer_start = None\n\nfor r_idx, row_elem in enumerate(root.findall('Row')):\n    y = r_idx + 1\n    for t_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n        x = t_idx + 1\n        tile_type = tile_elem.get('type')\n        if tile_type == 'WALL':\n            walls.add((x, y))\n        if tile_elem.find('Object[@id-name=\"BOULDER\"]') is not None:\n            boulders.append((x, y))\n        if tile_elem.find('Player') is not None:\n            player_start = (x, y)\n\n# Override start position if provided\nif 'start_x' in input_data and input_data['start_x'] is not None:\n    player_start = (int(input_data['start_x']), int(input_data['start_y']))\n\ngoal_pos = (int(input_data['goal_x']), int(input_data['goal_y']))\n\n# --- BFS Solver ---\ninitial_state = (player_start, tuple(sorted(boulders)))\nqueue = collections.deque([(initial_state, [])])\nvisited = {initial_state}\n\npath_found = False\nwhile queue:\n    (current_player, current_boulders), path = queue.popleft()\n\n    # Check for goal state\n    if goal_pos in current_boulders:\n        print(f\"Solution found: {path}\")\n        path_found = True\n        break\n\n    # Explore neighbors\n    for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n        next_player_pos = (current_player[0] + dx, current_player[1] + dy)\n\n        # Simple move (no push)\n        if next_player_pos not in walls and next_player_pos not in current_boulders:\n            new_state = (next_player_pos, current_boulders)\n            if new_state not in visited:\n                visited.add(new_state)\n                queue.append((new_state, path + [move]))\n            continue\n\n        # Boulder push\n        if next_player_pos in current_boulders:\n            boulder_to_push = next_player_pos\n            next_boulder_pos = (boulder_to_push[0] + dx, boulder_to_push[1] + dy)\n\n            if next_boulder_pos not in walls and next_boulder_pos not in current_boulders:\n                new_boulders = list(current_boulders)\n                new_boulders.remove(boulder_to_push)\n                new_boulders.append(next_boulder_pos)\n                new_boulders_tuple = tuple(sorted(new_boulders))\n                \n                new_state = (next_player_pos, new_boulders_tuple)\n                if new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, path + [f\"Push {move}\"])) \n\nif not path_found:\n    print(\"No solution found.\")"
  },
  "pathfinder": {
    "description": "Finds the shortest path between two points on the current map using the A* algorithm. It considers specified traversable tiles and avoids obstacles. It can now path to a tile adjacent to an impassable destination.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "traversable_tiles": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "traversable_tiles"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\nimport json\n\nclass AStar:\n    def __init__(self, map_xml, traversable_tiles):\n        self.root = ET.fromstring(map_xml)\n        self.width = int(self.root.get('width'))\n        self.height = int(self.root.get('height'))\n        self.traversable_tiles = set(traversable_tiles)\n        self.walls = set()\n        self.objects = set()\n        self.ledges = {}\n\n        for row_elem in self.root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.find('Object') is not None\n\n                if has_object:\n                    self.objects.add((x, y))\n                \n                if tile_type in ['FLOOR_UP_WALL', 'LEDGE']:\n                    self.ledges[(x, y)] = (x, y + 1)\n                \n                if tile_type not in self.traversable_tiles:\n                    self.walls.add((x,y))\n\n    def heuristic(self, a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def get_neighbors(self, pos):\n        x, y = pos\n        neighbors = []\n        \n        if pos in self.ledges:\n            nx, ny = self.ledges[pos]\n            if (nx, ny) not in self.walls and (nx, ny) not in self.objects:\n                neighbors.append(((nx, ny), 1))\n            return neighbors\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            neighbor_pos = (nx, ny)\n\n            if 1 <= nx <= self.width and 1 <= ny <= self.height:\n                if neighbor_pos in self.walls or neighbor_pos in self.objects:\n                    continue\n                \n                if neighbor_pos in self.ledges and pos != (neighbor_pos[0], neighbor_pos[1] - 1):\n                    continue\n\n                neighbors.append((neighbor_pos, 1))\n        return neighbors\n\n    def find_path_internal(self, start, end):\n        open_set = [(0, start)]\n        came_from = {}\n        g_score = {start: 0}\n        f_score = {start: self.heuristic(start, end)}\n\n        while open_set:\n            _, current = heapq.heappop(open_set)\n\n            if current == end:\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(start)\n                return path[::-1]\n\n            for neighbor, cost in self.get_neighbors(current):\n                tentative_g_score = g_score[current] + cost\n                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = tentative_g_score + self.heuristic(neighbor, end)\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n        return None\n\n    def find_path(self, start, end):\n        path = self.find_path_internal(start, end)\n        if path:\n            return path\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_x, adj_y = end[0] + dx, end[1] + dy\n            adj_pos = (adj_x, adj_y)\n            if adj_pos not in self.walls and adj_pos not in self.objects and adj_pos not in self.ledges:\n                path_adj = self.find_path_internal(start, adj_pos)\n                if path_adj:\n                    return path_adj\n        \n        return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    traversable = json.loads(input_data['traversable_tiles'])\n\n    astar = AStar(map_xml_string, traversable)\n    path = astar.find_path((start_x, start_y), (end_x, end_y))\n\n    if path:\n        print(json.dumps(path))\n    else:\n        print(\"No path found.\")\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")"
  }
}