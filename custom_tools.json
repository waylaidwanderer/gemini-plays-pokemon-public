{
  "assess_reachability": {
    "description": "Performs a flood-fill BFS starting from a given coordinate to determine all reachable tiles of a specific type (e.g., WATER). Returns the bounds of the reachable area, accessible warps, and adjacent unseen tiles. Useful for determining if a path exists through a maze.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "tile_type": {
          "type": "string",
          "default": "WATER"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef assess_reachability(map_xml_string, start_x, start_y, tile_type=\"WATER\"):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = {}\n    warps = {}\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib.get('type', 'unseen')\n            is_warp = tile.attrib.get('is-warp') == 'true'\n            \n            grid[(x, y)] = t_type\n            if is_warp:\n                # Check for warp details in children\n                warp_node = tile.find('Warp')\n                entry_point = warp_node.attrib.get('entry_point') if warp_node is not None else \"?\"\n                warps[(x, y)] = entry_point\n\n    if grid.get((start_x, start_y)) != tile_type and grid.get((start_x, start_y)) != \"WHIRLPOOL\":\n        print(f\"Error: Start position ({start_x}, {start_y}) is {grid.get((start_x, start_y))}, not {tile_type}.\")\n        return\n\n    queue = deque([(start_x, start_y)])\n    visited = set([(start_x, start_y)])\n    reachable_warps = []\n    reachable_unseen_adjacents = []\n    min_x, max_x, min_y, max_y = start_x, start_x, start_y, start_y\n    \n    # Allow WHIRLPOOL as traversable for surfing if tile_type is WATER\n    traversable_types = {tile_type}\n    if tile_type == \"WATER\":\n        traversable_types.add(\"WHIRLPOOL\")\n\n    while queue:\n        cx, cy = queue.popleft()\n        \n        min_x = min(min_x, cx)\n        max_x = max(max_x, cx)\n        min_y = min(min_y, cy)\n        max_y = max(max_y, cy)\n        \n        if (cx, cy) in warps:\n            reachable_warps.append({'x': cx, 'y': cy, 'entry': warps[(cx, cy)]})\n            \n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < width and 0 <= ny < height:\n                if (nx, ny) in visited:\n                    continue\n                \n                n_type = grid.get((nx, ny), 'unseen')\n                \n                if n_type in traversable_types:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n                elif n_type == 'unseen':\n                    reachable_unseen_adjacents.append({'x': nx, 'y': ny})\n                    # Don't traverse into unseen, just mark it as a frontier\n    \n    print(f\"Reachability Analysis from ({start_x}, {start_y}) for {tile_type}:\")\n    print(f\"  Bounds: X[{min_x}-{max_x}], Y[{min_y}-{max_y}]\")\n    print(f\"  Reachable Tiles Count: {len(visited)}\")\n    print(f\"  Reachable Warps: {reachable_warps}\")\n    print(f\"  Adjacent Unseen Tiles: {len(reachable_unseen_adjacents)} (First 5: {reachable_unseen_adjacents[:5]})\")\n\nassess_reachability(map_xml_string, input_data['start_x'], input_data['start_y'], input_data.get('tile_type', 'WATER'))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-08T11:22:54.983Z",
        "action_counter": 27988
      }
    ]
  },
  "find_path_bfs": {
    "description": "Finds the shortest path from the player's current position to a target coordinate using Breadth-First Search (BFS). Parses map XML to identify walkable tiles, avoiding Walls, Water (if walking), On-screen Objects, and Off-screen Objects marked with markers. Returns a list of button presses.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "movement_mode": {
          "type": "string",
          "enum": [
            "walking",
            "surfing"
          ],
          "default": "walking"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef bfs_path(xml_string, target_x, target_y, movement_mode=\"walking\"):\n    try:\n        root = ET.fromstring(xml_string)\n    except Exception as e:\n        print(f\"Error parsing XML: {e}\")\n        return []\n\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = {}\n    start_pos = None\n    \n    # Allowed tile types\n    walkable_types = {\"FLOOR\", \"GRASS\", \"TALL_GRASS\", \"SAND\", \"CARPET\", \"DOOR\", \n                      \"WARP_CARPET_LEFT\", \"WARP_CARPET_RIGHT\", \"WARP_CARPET_UP\", \"WARP_CARPET_DOWN\",\n                      \"STAIRS\", \"CAVE\"}\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib.get('type', 'WALL')\n            \n            is_blocked = False\n            \n            # Check basic tile type\n            if t_type not in walkable_types:\n                if movement_mode == \"walking\":\n                    is_blocked = True\n                elif movement_mode == \"surfing\":\n                    if t_type != \"WATER\":\n                        is_blocked = True\n            elif movement_mode == \"surfing\":\n                # If surfing, can only move on WATER (usually)\n                if t_type != \"WATER\":\n                    is_blocked = True\n            \n            # Check Objects (On-screen sprites)\n            if not is_blocked:\n                for child in tile:\n                    if child.tag == 'Object':\n                        is_blocked = True\n                        break\n            \n            # Check Markers with object_id (Off-screen known sprites)\n            if not is_blocked:\n                for child in tile:\n                    if child.tag == 'Marker' and child.attrib.get('object_id'):\n                        is_blocked = True\n                        break\n\n            # Check has-object attribute\n            if not is_blocked and tile.attrib.get('has-object') == 'true':\n                 is_blocked = True\n\n            grid[(x, y)] = not is_blocked\n            \n            # Locate Player\n            if tile.find('Player') is not None or tile.attrib.get('has-player') == 'true':\n                start_pos = (x, y)\n                # Player tile is always walkable to start\n                grid[(x, y)] = True\n                \n    if not start_pos:\n        print(\"Error: Player not found on map.\")\n        return []\n        \n    if not grid.get((target_x, target_y), False):\n        print(f\"Error: Target {(target_x, target_y)} is blocked or invalid.\")\n        return []\n        \n    # BFS\n    queue = deque([(start_pos, [])])\n    visited = {start_pos}\n    \n    while queue:\n        current, path = queue.popleft()\n        if current == (target_x, target_y):\n            # Convert path to buttons\n            buttons = []\n            cx, cy = start_pos\n            for nx, ny in path:\n                if nx > cx: buttons.append(\"Right\")\n                elif nx < cx: buttons.append(\"Left\")\n                elif ny > cy: buttons.append(\"Down\")\n                elif ny < cy: buttons.append(\"Up\")\n                cx, cy = nx, ny\n            print(json.dumps(buttons))\n            return buttons\n            \n        cx, cy = current\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) in grid and grid[(nx, ny)] and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [(nx, ny)]))\n                \n    print(f\"Error: No path found to {(target_x, target_y)}.\")\n    return []\n\nif __name__ == \"__main__\":\n    bfs_path(map_xml_string, input_data['target_x'], input_data['target_y'], input_data.get('movement_mode', 'walking'))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-08T13:38:17.154Z",
        "action_counter": 28141
      },
      {
        "commit_message": "Fixed variable access by using `input_data` dictionary instead of assuming global variables.",
        "timestamp": "2026-01-08T13:40:06.080Z",
        "action_counter": 28143
      },
      {
        "commit_message": "Fixing JSON output error when no path is found. Now returns an empty list [] on failure instead of a plain string.",
        "timestamp": "2026-01-08T16:53:53.077Z",
        "action_counter": 28353
      },
      {
        "commit_message": "Fixed missing commit message error and refined BFS logic to handle surfing and landing correctly.",
        "timestamp": "2026-01-08T18:06:59.771Z",
        "action_counter": 28443
      },
      {
        "commit_message": "Fixed JSON output error by removing plain text error messages. Now returns an empty list [] on failure.",
        "timestamp": "2026-01-08T18:13:10.805Z",
        "action_counter": 28451
      },
      {
        "commit_message": "Refined obstacle detection to include <Object> tags and <Marker> tags with object_id, preventing pathing through NPCs.",
        "timestamp": "2026-01-08T21:34:10.018Z",
        "action_counter": 28681
      }
    ]
  },
  "apply_super_repel": {
    "description": "Automatically navigates the Start Menu to use a Super Repel from the Bag. \nAssumptions:\n1. 'Repel wore off' text is already closed.\n2. Start Menu cursor is on 'PACK'.\n3. Bag cursor is on 'SUPER REPEL'.\n4. Player is in Overworld.\nSequence: Start -> Wait -> A (Pack) -> Wait -> A (Select Repel) -> Wait -> A (Use) -> Wait -> B (Text) -> Wait -> B (Bag) -> Wait -> B (Menu).",
    "input_schema": {
      "type": "object",
      "properties": {
        "autopress_buttons": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "python_script": "print('[\"Start\", \"sleep 500\", \"A\", \"sleep 500\", \"A\", \"sleep 500\", \"A\", \"sleep 500\", \"B\", \"sleep 500\", \"B\", \"sleep 500\", \"B\"]')",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-10T03:50:45.163Z",
        "action_counter": 30790
      },
      {
        "commit_message": "Fixed output format to be a JSON array instead of an object.",
        "timestamp": "2026-01-10T03:57:21.406Z",
        "action_counter": 30801
      }
    ]
  },
  "hunt_cycle_v2": {
    "description": "Executes one full roamer check cycle on Route 37. Starts at (8,0), walks south to (8,5) to check grass, walks back north to (8,0), steps up to Ecruteak to reset map, and steps back down to Route 37 (8,0). Safe for battles (only D-pad inputs).",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "python_script": "def hunt_cycle_v2(**kwargs):\n    import json\n    import sys\n    # Down x5 (Check Grass)\n    # Up x5 (Return to Gate)\n    # Up x1 (Enter Ecruteak)\n    # Down x1 (Return to Route 37)\n    buttons = [\"Down\", \"Down\", \"Down\", \"Down\", \"Down\", \"Up\", \"Up\", \"Up\", \"Up\", \"Up\", \"Up\", \"Down\"]\n    print(json.dumps(buttons))\n    sys.stdout.flush()\n    return buttons",
    "history": [
      {
        "commit_message": "Defined hunt_cycle_v2 with explicit stdout flushing to fix JSON error.",
        "timestamp": "2026-01-10T18:49:32.432Z",
        "action_counter": 32110
      }
    ]
  }
}