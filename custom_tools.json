{
  "battle_screen_parser": {
    "description": "A tool that can parse the battle screen text to automatically generate the structured JSON required as input for the master_battle_agent. This will eliminate the current manual and error-prone data entry step, significantly improving battle efficiency.",
    "input_schema": {
      "type": "object",
      "properties": {
        "screen_text": {
          "type": "string"
        }
      },
      "required": [
        "screen_text"
      ]
    },
    "python_script": "import re\nimport json\n\ndef parse_battle_screen(screen_text):\n    player_pokemon = {}\n    opponent_pokemon = {}\n    lines = [line.strip() for line in screen_text.strip().split('\\n')]\n\n    try:\n        # Opponent Info (Line 0)\n        opp_line = lines[0]\n        opp_match = re.search(r'(.+?)\\s*L(\\d+)', opp_line)\n        if opp_match:\n            opponent_pokemon['name'] = opp_match.group(1).strip()\n            opponent_pokemon['level'] = int(opp_match.group(2))\n        else:\n            opponent_pokemon['name'] = opp_line\n\n        # Player Info (Lines 2 and 3)\n        player_line = lines[2]\n        player_match = re.search(r'(.+?)\\s*L(\\d+)', player_line)\n        if player_match:\n            player_pokemon['name'] = player_match.group(1).strip()\n            player_pokemon['level'] = int(player_match.group(2))\n        else:\n            player_pokemon['name'] = player_line\n\n        hp_line = lines[3]\n        hp_match = re.search(r'(\\d+)/\\s*(\\d+)', hp_line)\n        if hp_match:\n            player_pokemon['current_hp'] = int(hp_match.group(1))\n            player_pokemon['max_hp'] = int(hp_match.group(2))\n            \n    except IndexError:\n        pass\n\n    result = {\n        \"player_active_pokemon\": player_pokemon,\n        \"opponent_active_pokemon\": opponent_pokemon\n    }\n    print(json.dumps(result))\n\nparse_battle_screen(input_data['screen_text'])",
    "history": [
      {
        "commit_message": "feat: Create battle_screen_parser tool to automate data entry. In response to an Overwatch critique identifying deferred development as a core violation, this tool automates the extraction of key battle data from screen text. This will streamline the input process for the `master_battle_agent`, improving battle efficiency and adhering to the immediate action directive.",
        "timestamp": "2025-08-22T00:12:14.901Z",
        "action_counter": 159782
      },
      {
        "commit_message": "feat: Create battle_screen_parser tool to automate data entry. In response to an Overwatch critique identifying deferred development as a core violation, this tool automates the extraction of key battle data from screen text. This will streamline the input process for the `master_battle_agent`, improving battle efficiency and adhering to the immediate action directive.",
        "timestamp": "2025-08-22T02:44:28.656Z",
        "action_counter": 160067
      },
      {
        "commit_message": "feat: Create battle_screen_parser tool to automate data entry. In response to an Overwatch critique identifying deferred development as a core violation, this tool automates the extraction of key battle data from screen text. This will streamline the input process for the `master_battle_agent`, improving battle efficiency and adhering to the immediate action directive.",
        "timestamp": "2025-08-22T20:26:49.586Z",
        "action_counter": 161224
      },
      {
        "commit_message": "feat: Create battle_screen_parser tool to automate data entry. In response to an Overwatch critique identifying deferred development as a core violation, this tool automates the extraction of key battle data from screen text. This will streamline the input process for the `master_battle_agent`, improving battle efficiency and adhering to the immediate action directive.",
        "timestamp": "2025-08-22T23:48:11.914Z",
        "action_counter": 161671
      },
      {
        "commit_message": "fix: Update regex to handle multi-line battle info. The previous version of the tool failed because its regex expected all player information to be on a single line. This commit refactors the script to parse the opponent's and player's name, level, and HP from their respective separate lines as provided by the game's screen text, making the tool functional again.",
        "timestamp": "2025-08-23T01:17:14.741Z",
        "action_counter": 161892
      },
      {
        "commit_message": "fix: Update regex to handle name and level on the same line. The previous version failed because its regex expected the level to be on a separate line from the Pokémon's name. This commit refactors the script to parse both from the same line, correctly extracting battle data.",
        "timestamp": "2025-08-23T14:14:53.725Z",
        "action_counter": 163037
      }
    ]
  },
  "find_path": {
    "description": "Finds the shortest path between two points on the current map using the A* algorithm. Can find a path to an adjacent tile if the destination is impassable. Can optionally accept lists of coordinates to treat as temporarily impassable or passable. Reports specific blocking objects on failure.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "temp_impassable": {
          "type": "string",
          "nullable": true
        },
        "passable_objects": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import heapq\nimport json\nimport xml.etree.ElementTree as ET\n\ndef find_path(start_x, start_y, end_x, end_y, temp_impassable_coords, passable_objects_coords, map_xml_string):\n    print(f\"DEBUG(v4): find_path called with start=({start_x},{start_y}), end=({end_x},{end_y})\")\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    grid = [['' for _ in range(width)] for _ in range(height)]\n    objects = {}\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id')) - 1\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id')) - 1\n            grid[y][x] = tile_elem.get('type')\n            \n            obj_elem = tile_elem.find('Object')\n            if obj_elem is not None:\n                obj_id_name = obj_elem.get('id-name', 'Unknown Object')\n                obj_name_attr = obj_elem.get('name')\n                if obj_name_attr:\n                    objects[(x, y)] = obj_name_attr\n                else:\n                    objects[(x, y)] = obj_id_name\n            \n            bg_obj_elem = tile_elem.find('Object[@name]')\n            if bg_obj_elem is not None:\n                objects[(x, y)] = bg_obj_elem.get('name')\n\n    start = (start_x - 1, start_y - 1)\n    end = (end_x - 1, end_y - 1)\n\n    traversable_tiles = {'ground', 'grass', 'cuttable', 'steps', 'elevated_ground', 'cleared_boulder_barrier', 'teleport', 'gate_offscreen', 'open_gate'}\n    \n    temp_impassable = set()\n    if temp_impassable_coords:\n        try:\n            coords_list = json.loads(temp_impassable_coords)\n            for coord in coords_list:\n                temp_impassable.add((int(coord['x']) - 1, int(coord['y']) - 1))\n        except (json.JSONDecodeError, KeyError, TypeError):\n            pass\n\n    passable_objects = set()\n    if passable_objects_coords:\n        try:\n            coords_list = json.loads(passable_objects_coords)\n            for coord in coords_list:\n                passable_objects.add((int(coord['x']) - 1, int(coord['y']) - 1))\n        except (json.JSONDecodeError, KeyError, TypeError):\n            pass\n\n    def is_traversable(x, y):\n        if not (0 <= x < width and 0 <= y < height):\n            return False\n        if (x, y) in temp_impassable:\n            return False\n        \n        is_object_present = (x, y) in objects\n        is_passable_override = (x, y) in passable_objects\n\n        if is_object_present and not is_passable_override:\n            return False\n\n        if grid[y][x] in traversable_tiles:\n            return True\n            \n        return False\n\n    goal_positions = []\n    if is_traversable(end[0], end[1]):\n        goal_positions.append(end)\n    else:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = end[0] + dx, end[1] + dy\n            if is_traversable(nx, ny):\n                goal_positions.append((nx, ny))\n    \n    if not goal_positions:\n        end_obj_name = objects.get(end, grid[end[1]][end[0]])\n        error_result = {\"path\": [], \"error\": f\"Destination ({end_x}, {end_y}) and all adjacent tiles are impassable. Destination contains: {end_obj_name}.\"}\n        return json.dumps(error_result)\n\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    open_set = []\n    heapq.heappush(open_set, (min(heuristic(start, goal) for goal in goal_positions), start))\n    \n    came_from = {}\n    g_score = {start: 0}\n    \n    frontier_impassable = set()\n    \n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current in goal_positions:\n            path = []\n            while current in came_from:\n                path.append({'x': current[0] + 1, 'y': current[1] + 1})\n                current = came_from[current]\n            path.append({'x': start[0] + 1, 'y': start[1] + 1})\n            success_result = {\"path\": path[::-1]}\n            return json.dumps(success_result)\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            current_x, current_y = current\n            neighbor = (current_x + dx, current_y + dy)\n\n            is_ledge_jump = False\n            if dy == 1 and 0 <= neighbor[1] < height and grid[neighbor[1]][neighbor[0]] == 'ledge':\n                neighbor = (neighbor[0], neighbor[1] + 1)\n                is_ledge_jump = True\n            \n            if not (0 <= neighbor[0] < width and 0 <= neighbor[1] < height):\n                continue\n\n            if dy == -1 and 0 <= current_y < height and grid[current_y][current_x] == 'ledge':\n                continue\n\n            if not is_traversable(neighbor[0], neighbor[1]):\n                if neighbor not in g_score:\n                    frontier_impassable.add(neighbor)\n                continue\n\n            current_type = grid[current_y][current_x]\n            neighbor_type = grid[neighbor[1]][neighbor[0]]\n            ground_level_tiles = {'ground', 'grass'}\n            is_valid_transition = False\n            if current_type == 'steps' or neighbor_type == 'steps':\n                is_valid_transition = True\n            elif current_type == neighbor_type:\n                is_valid_transition = True\n            elif current_type in ground_level_tiles and neighbor_type in ground_level_tiles:\n                is_valid_transition = True\n            \n            if not is_valid_transition and not is_ledge_jump:\n                continue\n\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score = tentative_g_score + min(heuristic(neighbor, goal) for goal in goal_positions)\n                if not any(item[1] == neighbor for item in open_set):\n                    heapq.heappush(open_set, (f_score, neighbor))\n    \n    blocking_objects = []\n    for pos in frontier_impassable:\n        obj_name = objects.get(pos, grid[pos[1]][pos[0]])\n        blocking_objects.append({\"x\": pos[0] + 1, \"y\": pos[1] + 1, \"name\": obj_name})\n    \n    error_message = \"No path found. The start and end points may be in disconnected map areas.\"\n    if blocking_objects:\n        blocker_details = \", \".join([f\"{b['name']} at ({b['x']},{b['y']})\" for b in blocking_objects[:3]])\n        error_message = f\"Path blocked by obstacles: {blocker_details}\"\n        if len(blocking_objects) > 3:\n            error_message += \"...\"\n    \n    failure_result = {\"path\": [], \"error\": error_message, \"blocking_objects\": blocking_objects}\n    return json.dumps(failure_result)\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\ntemp_impassable = input_data.get('temp_impassable')\npassable_objects = input_data.get('passable_objects')\n\nresult = find_path(start_x, start_y, end_x, end_y, temp_impassable, passable_objects, map_xml_string)\nprint(result)",
    "history": [
      {
        "commit_message": "feat: Create find_path tool to automate navigation. In response to a critical overwatch review identifying over 100 wasted turns due to manual navigation failure, this tool implements an A* pathfinding algorithm. It parses the map XML, handles impassable destinations by targeting adjacent tiles, and will prevent future catastrophic navigation loops. This replaces the previous, unused pathfinding tool.",
        "timestamp": "2025-08-20T09:43:44.097Z",
        "action_counter": 156512
      },
      {
        "commit_message": "refactor: Add weighted pathfinding to avoid Pikachu. In response to an Overwatch critique, this commit refactors the A* algorithm to assign a higher movement cost to the tile occupied by Pikachu. This addresses the issue of the pathfinder generating suboptimal routes that require an extra button press to traverse, improving navigation efficiency by prioritizing paths that do not pass through the follower Pokémon.",
        "timestamp": "2025-08-21T17:46:30.664Z",
        "action_counter": 159061
      },
      {
        "commit_message": "feat: Add optional temporary impassable tiles. In response to an Overwatch critique, this commit refactors the `find_path` tool to accept an optional JSON string of coordinates to treat as impassable. This addresses the tool's failure to navigate around invisible, scripted barriers, such as the one in Lorelei's Room, and will prevent future navigation loops caused by this limitation.",
        "timestamp": "2025-08-22T03:48:43.455Z",
        "action_counter": 160172
      },
      {
        "commit_message": "feat: Add diagnostic output on pathfinding failure. In response to an Overwatch critique, this commit refactors the `find_path` tool to report the specific coordinates of the blocking tile(s) when it fails to find a path. This will provide critical context for debugging navigation loops and distinguishing between tool errors and scripted barriers.",
        "timestamp": "2025-08-22T04:04:27.249Z",
        "action_counter": 160203
      },
      {
        "commit_message": "feat: Add diagnostic output on pathfinding failure. In response to an Overwatch critique, this commit refactors the `find_path` tool to report the specific coordinates of the blocking tile(s) when it fails to find a path. This will provide critical context for debugging navigation loops and distinguishing between tool errors and scripted barriers.",
        "timestamp": "2025-08-22T04:05:24.496Z",
        "action_counter": 160204
      },
      {
        "commit_message": "fix: Add ledge traversal logic to prevent invalid paths. The previous version failed to account for one-way ledge traversal, causing it to generate invalid paths upwards and sideways onto ledges. This commit adds checks during neighbor generation to correctly treat ledges as impassable from below and from the sides, ensuring path validity.",
        "timestamp": "2025-08-22T12:56:19.110Z",
        "action_counter": 160653
      },
      {
        "commit_message": "refactor: Enhance diagnostic output on pathfinding failure. In response to an Overwatch critique, this commit refactors the `find_path` tool to provide a more descriptive failure reason when the start and end points are in completely disconnected map regions. This replaces the generic 'No path found' message, providing better context for debugging navigation failures.",
        "timestamp": "2025-08-22T15:55:53.642Z",
        "action_counter": 160801
      },
      {
        "commit_message": "feat: Add diagnostic output on pathfinding failure. In response to an Overwatch critique, this commit refactors the `find_path` tool to report the specific coordinates of the blocking tile(s) when it fails to find a path. This will provide critical context for debugging navigation loops and distinguishing between tool errors and scripted barriers.",
        "timestamp": "2025-08-22T18:28:27.919Z",
        "action_counter": 160981
      },
      {
        "commit_message": "feat: Add detailed diagnostic output on pathfinding failure. In response to an Overwatch critique, this commit refactors the tool to report not just the coordinates of blocking tiles, but also the name and type of any object on those tiles. This will provide critical context for debugging navigation failures and distinguishing between tool errors and in-game puzzles.",
        "timestamp": "2025-08-22T20:25:28.237Z",
        "action_counter": 161221
      },
      {
        "commit_message": "refactor: Improve A* robustness and ledge logic. In response to a critical Overwatch review, this commit refactors the pathfinding algorithm. The inefficient check for a neighbor's existence in the open set has been removed, making the node expansion more robust and aligned with standard A* implementations. Additionally, the ledge traversal logic has been corrected to properly handle horizontal movement restrictions, preventing the generation of invalid paths. This addresses the tool's failure to find longer, valid routes around obstacles.",
        "timestamp": "2025-08-22T20:43:59.376Z",
        "action_counter": 161252
      },
      {
        "commit_message": "fix: Correct JSON syntax in input_schema. The previous attempt to redefine the tool failed due to a missing closing brace in the 'properties' object of the JSON schema. This commit corrects the syntax error, which is a prerequisite for adding the diagnostic logging intended to debug the core pathfinding logic.",
        "timestamp": "2025-08-23T02:46:49.691Z",
        "action_counter": 162055
      },
      {
        "commit_message": "feat: Add 'teleport' to traversable tile types. The pathfinder previously failed to generate paths onto teleporter tiles because it did not recognize them as traversable. This fix adds 'teleport' to the list of valid tile types, enabling correct pathing in areas like Silph Co.",
        "timestamp": "2025-08-23T03:07:47.857Z",
        "action_counter": 162094
      },
      {
        "commit_message": "feat: Add blocking object reporting on path failure. When a path is not found due to disconnected regions, the tool now analyzes the explored area to identify and report the coordinates and name/type of the impassable tile(s) on the frontier. This provides crucial diagnostic information for debugging navigation puzzles.",
        "timestamp": "2025-08-23T03:21:16.185Z",
        "action_counter": 162121
      },
      {
        "commit_message": "feat: Add 'gate_offscreen' to traversable tile types. The pathfinder was failing to find valid paths in Silph Co. because it did not treat 'gate_offscreen' tiles as traversable, contrary to the game's exploration rules. This fix adds the tile type to the traversable list, correcting the tool's behavior and enabling navigation through areas with off-screen gates.",
        "timestamp": "2025-08-23T03:30:53.303Z",
        "action_counter": 162137
      },
      {
        "commit_message": "feat: Add 'open_gate' to traversable tile types. The pathfinder was failing to find paths through open gates because it did not recognize the tile type as traversable. This fix adds 'open_gate' to the list, enabling correct pathing in areas like Silph Co.",
        "timestamp": "2025-08-23T03:44:19.160Z",
        "action_counter": 162156
      },
      {
        "commit_message": "fix: Add explicit check to treat 'closed_gate' as impassable. The pathfinder was incorrectly generating paths through closed gates. This commit adds a specific check to ensure that any tile with the type 'closed_gate' is assigned an infinite cost, preventing it from being included in any valid path.",
        "timestamp": "2025-08-23T04:32:15.091Z",
        "action_counter": 162221
      },
      {
        "commit_message": "fix: Correct JSON syntax in input_schema. The previous attempt to redefine the tool failed due to a missing closing brace in the 'properties' object of the JSON schema. This commit corrects the syntax error, which is a prerequisite for adding the diagnostic logging intended to debug the core pathfinding logic.",
        "timestamp": "2025-08-23T14:06:08.826Z",
        "action_counter": 163025
      },
      {
        "commit_message": "feat: Add ledge traversal logic and improve failure reporting. The pathfinder now correctly handles one-way ledge jumps by modifying neighbor generation. It also provides a more explicit error message when a path is blocked by obstacles, directly addressing a core issue identified in an Overwatch critique regarding tool maintenance and diagnostic capability.",
        "timestamp": "2025-08-23T15:51:23.242Z",
        "action_counter": 163171
      },
      {
        "commit_message": "feat: Add `passable_objects` parameter to treat specific objects as traversable. This directly addresses an Overwatch critique highlighting that the tool incorrectly treats defeated trainers as impassable obstacles. This change allows the user to provide a list of coordinates containing objects (like defeated trainers) that the pathfinder should ignore, enabling path generation through them. This makes the tool more flexible and compliant with the required game logic.",
        "timestamp": "2025-08-23T17:44:28.320Z",
        "action_counter": 163322
      },
      {
        "commit_message": "feat: Add diagnostic logging to improve debugging. In response to an Overwatch critique identifying deferred tool maintenance as a critical failure, this commit adds print statements to log the tool's inputs, calculated goal positions, and final results. This will provide essential information for diagnosing future pathfinding failures, particularly in complex areas like Cerulean City.",
        "timestamp": "2025-08-23T19:06:39.614Z",
        "action_counter": 163441
      },
      {
        "commit_message": "fix: Add elevation transition logic. The tool was generating invalid paths by allowing direct movement between 'ground' and 'elevated_ground' tiles. This commit adds a check to ensure that such transitions are only possible via an intermediate 'steps' tile, fixing a critical pathfinding bug.",
        "timestamp": "2025-08-23T21:08:18.603Z",
        "action_counter": 163606
      },
      {
        "commit_message": "refactor: Improve diagnostic error message for path failures. In response to an Overwatch critique, this commit updates the default 'No path found' error message to explicitly suggest that the start and end points may be in disconnected map areas. This provides more actionable feedback for debugging navigation in complex, non-contiguous maps like the Safari Zone.",
        "timestamp": "2025-08-23T22:04:38.318Z",
        "action_counter": 163711
      },
      {
        "commit_message": "fix: Remove explicit Pikachu exclusion. The tool was hardcoded to ignore Pikachu when building its obstacle list, which prevented the `passable_objects` parameter from ever applying to it. This commit removes that exclusion, allowing Pikachu to be treated as a standard object that can be made traversable via the input parameter. This is a critical fix for navigation in areas where Pikachu blocks the path.",
        "timestamp": "2025-08-23T22:35:08.047Z",
        "action_counter": 163768
      },
      {
        "commit_message": "feat: Add extensive diagnostic logging to debug A* failures. In response to a critical Overwatch critique and repeated tool failures in Safari Zone East, this commit adds detailed print statements to trace the A* algorithm's execution. This logging will provide the necessary data to diagnose why the tool is failing on complex but valid paths, which is a higher priority than any immediate navigation.",
        "timestamp": "2025-08-23T22:59:26.307Z",
        "action_counter": 163801
      },
      {
        "commit_message": "fix: Allow pathing between ground and grass tiles. The A* algorithm was incorrectly treating transitions between 'ground' and 'grass' as invalid elevation changes, causing path failures in areas like Safari Zone East. This commit updates the validation logic to treat these two tile types as being on the same elevation level, fixing the bug.",
        "timestamp": "2025-08-23T23:01:10.190Z",
        "action_counter": 163804
      },
      {
        "commit_message": "refactor: Improve diagnostic error message on path failure. In response to an Overwatch critique, this commit updates the tool to include the names and coordinates of the first few blocking obstacles directly in the main error message string. This provides more immediate and actionable feedback when a path cannot be found.",
        "timestamp": "2025-08-23T23:27:05.874Z",
        "action_counter": 163831
      }
    ]
  },
  "get_next_switch_press": {
    "description": "Calculates the single next directional press (Up or Down) required to move the cursor one step closer to a target Pokémon in the party menu. Designed for step-by-step execution to handle the 'Party Menu Cursor Anomaly'.",
    "input_schema": {
      "type": "object",
      "properties": {
        "party_pokemon_list": {
          "type": "string"
        },
        "current_selection_name": {
          "type": "string"
        },
        "target_name": {
          "type": "string"
        }
      },
      "required": [
        "party_pokemon_list",
        "current_selection_name",
        "target_name"
      ]
    },
    "python_script": "import json\nparty_list_str = input_data['party_pokemon_list']\ncurrent_selection = input_data['current_selection_name']\ntarget = input_data['target_name']\ntry:\n    party_list = json.loads(party_list_str)\nexcept json.JSONDecodeError:\n    cleaned_str = party_list_str.replace('[', '').replace(']', '').replace('\"', '')\n    party_list = [p.strip() for p in cleaned_str.split(',')]\n\nbutton_sequence = []\nif current_selection in party_list and target in party_list:\n    current_index = party_list.index(current_selection)\n    target_index = party_list.index(target)\n    if current_index < target_index:\n        button_sequence.append(\"Down\")\n    elif current_index > target_index:\n        button_sequence.append(\"Up\")\nprint(json.dumps(button_sequence))",
    "history": [
      {
        "commit_message": "feat: Create get_next_switch_press tool to replace buggy auto_switcher. In response to an Overwatch critique, this commit replaces the unreliable `auto_switcher` with a new, single-step tool. This tool calculates only the next required directional press, making it robust against the 'Party Menu Cursor Anomaly' by allowing for re-evaluation of the cursor's position each turn. This is a critical fix to prevent future switch errors.",
        "timestamp": "2025-08-22T05:54:01.769Z",
        "action_counter": 160418
      }
    ]
  },
  "get_next_move_press": {
    "description": "Calculates the single next directional press (Up or Down) required to move the cursor one step closer to a target move in the battle menu. Designed for step-by-step execution to handle move menu cursor anomalies.",
    "input_schema": {
      "type": "object",
      "properties": {
        "pokemon_move_list": {
          "type": "string"
        },
        "current_selected_move": {
          "type": "string"
        },
        "target_move": {
          "type": "string"
        }
      },
      "required": [
        "pokemon_move_list",
        "current_selected_move",
        "target_move"
      ]
    },
    "python_script": "import json\n\ntry:\n    move_list_str = input_data['pokemon_move_list']\n    current_selection = input_data['current_selected_move']\n    target = input_data['target_move']\n\n    moves = json.loads(move_list_str)\n\n    button_sequence = []\n    if current_selection in moves and target in moves:\n        current_index = moves.index(current_selection)\n        target_index = moves.index(target)\n        if current_index < target_index:\n            button_sequence.append(\"Down\")\n        elif current_index > target_index:\n            button_sequence.append(\"Up\")\n    print(json.dumps(button_sequence))\nexcept Exception:\n    print(json.dumps([]))",
    "history": [
      {
        "commit_message": "feat: Create get_next_move_press tool to handle cursor anomalies. In response to an Overwatch critique, this commit creates a new tool to provide single-step, reliable navigation for the battle move menu. This addresses the 'Move Menu Cursor Reset Anomaly' by allowing for re-evaluation of the cursor's position each turn, replacing the unreliable `auto_attacker` for move selection.",
        "timestamp": "2025-08-22T19:07:28.223Z",
        "action_counter": 161071
      }
    ]
  },
  "exit_finder": {
    "description": "Systematically checks all warps on the current map to find valid, reachable exits using A* pathfinding. Returns a list of coordinates for all exits reachable from the player's current position.",
    "input_schema": {
      "type": "object",
      "properties": {
        "player_x": {
          "type": "string"
        },
        "player_y": {
          "type": "string"
        }
      },
      "required": [
        "player_x",
        "player_y"
      ]
    },
    "python_script": "import heapq\nimport json\nimport xml.etree.ElementTree as ET\n\ndef find_path_internal(start_coord, end_coord, width, height, grid, objects):\n    start = (start_coord['x'] - 1, start_coord['y'] - 1)\n    end = (end_coord['x'] - 1, end_coord['y'] - 1)\n    traversable_tiles = {'ground', 'grass', 'cuttable', 'steps', 'elevated_ground', 'cleared_boulder_barrier', 'teleport', 'gate_offscreen', 'open_gate'}\n\n    def is_traversable(x, y):\n        if not (0 <= x < width and 0 <= y < height): return False\n        if (x, y) in objects: return False\n        return grid[y][x] in traversable_tiles\n\n    if not is_traversable(end[0], end[1]): return None\n\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {start: 0}\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n        if current == end: return True\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not is_traversable(neighbor[0], neighbor[1]): continue\n\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score = tentative_g_score + abs(neighbor[0] - end[0]) + abs(neighbor[1] - end[1])\n                heapq.heappush(open_set, (f_score, neighbor))\n    return None\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\ngrid = [['' for _ in range(width)] for _ in range(height)]\nobjects = {}\nwarps = []\n\nfor r_idx, row_elem in enumerate(root.findall('Row')):\n    for t_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n        grid[r_idx][t_idx] = tile_elem.get('type')\n        if tile_elem.find('Object') is not None and tile_elem.find('Object').get('id-name') != 'PIKACHU':\n            objects[(t_idx, r_idx)] = True\n        if tile_elem.find('Warp') is not None:\n            warps.append({'x': t_idx + 1, 'y': r_idx + 1})\n\nplayer_coord = {'x': int(input_data['player_x']), 'y': int(input_data['player_y'])}\nreachable_exits = []\nfor warp in warps:\n    if find_path_internal(player_coord, warp, width, height, grid, objects):\n        reachable_exits.append(warp)\n\nprint(json.dumps({\"reachable_exits\": reachable_exits}))",
    "history": [
      {
        "commit_message": "feat: Create exit_finder tool to prevent getting stuck. This tool systematically checks for all valid exits from a map by analyzing reachable warps. This automates a critical navigation check, addressing a recurring issue of incorrectly assuming an area is a dead end, as identified during self-assessment.",
        "timestamp": "2025-08-23T22:28:17.309Z",
        "action_counter": 163758
      },
      {
        "commit_message": "refactor: Implement A* pathfinding to verify exit reachability. The previous version of the tool simply listed all warps on the map, regardless of whether they were actually reachable from the player's current position. This commit replaces that logic with a full A* pathfinding implementation to test the path to each warp individually. This addresses a critical flaw identified in an Overwatch critique and makes the tool's output reliable for navigation.",
        "timestamp": "2025-08-23T22:37:52.283Z",
        "action_counter": 163772
      }
    ]
  }
}