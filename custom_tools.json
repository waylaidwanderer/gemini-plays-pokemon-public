{
  "find_path": {
    "description": "Finds the shortest path between two points on the current map using BFS. It avoids walls, impassable trees, objects, and correctly handles one-way ledges.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef find_path_script(map_xml_string, start_x_str, start_y_str, end_x_str, end_y_str):\n    start_x, start_y, end_x, end_y = int(start_x_str), int(start_y_str), int(end_x_str), int(end_y_str)\n    \n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = [[None for _ in range(width)] for _ in range(height)]\n    impassable_tiles = {\"WALL\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"LEDGE\", \"WATER\"}\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            has_object = tile_elem.find('Object') is not None\n            \n            if has_object:\n                grid[y][x] = 'OBJECT_OBSTACLE'\n            elif tile_type == 'unseen':\n                grid[y][x] = 'FLOOR'\n            else:\n                grid[y][x] = tile_type\n\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n\n    if not (0 <= start_x < width and 0 <= start_y < height and 0 <= end_x < width and 0 <= end_y < height):\n        return \"Start or end coordinates are out of bounds.\"\n\n    if grid[start_y][start_x] in impassable_tiles or grid[start_y][start_x] == 'OBJECT_OBSTACLE':\n        return f\"Start tile ({start_x},{start_y}) with type {grid[start_y][start_x]} is impassable.\"\n    if grid[end_y][end_x] in impassable_tiles or grid[end_y][end_x] == 'OBJECT_OBSTACLE':\n        return f\"End tile ({end_x},{end_y}) with type {grid[end_y][end_x]} is impassable.\"\n\n    queue = deque([[start_node]])\n    visited = {start_node}\n\n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n\n        if (x, y) == end_node:\n            return f\"Path found: {path}\"\n\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = x + dx, y + dy\n\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:\n                current_tile_type = grid[y][x]\n                next_tile_type = grid[ny][nx]\n\n                can_move = next_tile_type not in impassable_tiles and next_tile_type != 'OBJECT_OBSTACLE'\n\n                if 'LEDGE' in current_tile_type:\n                    is_hop_down = 'DOWN' in current_tile_type and dy == 1\n                    is_hop_right = 'RIGHT' in current_tile_type and dx == 1\n                    is_hop_left = 'LEFT' in current_tile_type and dx == -1\n                    if is_hop_down or is_hop_right or is_hop_left:\n                        can_move = True\n                    elif any(s in current_tile_type for s in ['DOWN', 'RIGHT', 'LEFT']):\n                        can_move = False\n\n                if can_move:\n                    visited.add((nx, ny))\n                    new_path = list(path)\n                    new_path.append((nx, ny))\n                    queue.append(new_path)\n    \n    return \"No path found.\"\n\nprint(find_path_script(map_xml_string, input_data['start_x'], input_data['start_y'], input_data['end_x'], input_data['end_y']))"
  }
}