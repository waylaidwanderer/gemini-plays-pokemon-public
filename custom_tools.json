{
  "route_finder": {
    "description": "Finds a path between two maps using the World Knowledge Graph.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_map_id": {
          "type": "string"
        },
        "end_map_id": {
          "type": "string"
        }
      },
      "required": [
        "start_map_id",
        "end_map_id"
      ]
    },
    "python_script": "import json\nimport heapq\nfrom collections import defaultdict\nimport itertools\n\nworld_knowledge = json.loads(world_knowledge_graph_json_string)\nnodes = world_knowledge['nodes']\nedges = world_knowledge['edges']\n\nstart_map = input_data['start_map_id']\nend_map = input_data['end_map_id']\n\ngraph = defaultdict(list)\n\n# Add explicit edges from the knowledge graph\nfor edge in edges:\n    if edge['source_node_id'] and edge['destination_node_id']:\n        graph[edge['source_node_id']].append(edge['destination_node_id'])\n        if not edge.get('is_one_way', False):\n            graph[edge['destination_node_id']].append(edge['source_node_id'])\n\n# Group nodes by map_id\nnodes_by_map = defaultdict(list)\nfor node in nodes:\n    nodes_by_map[node['map_id']].append(node['id'])\n\n# Add implicit intra-map edges\nfor map_id, map_nodes in nodes_by_map.items():\n    if len(map_nodes) > 1:\n        for u, v in itertools.combinations(map_nodes, 2):\n            graph[u].append(v)\n            graph[v].append(u)\n\nstart_node_ids = nodes_by_map.get(start_map, [])\n\nif not start_node_ids:\n    print(f'Start node for map {start_map} not found in World Knowledge Graph.')\n    exit()\n\n# Dijkstra's algorithm to find the shortest path\nqueue = [(0, start_node_id, [start_node_id]) for start_node_id in start_node_ids]\nvisited = set()\n\nwhile queue:\n    cost, current_node_id, path = heapq.heappop(queue)\n\n    if current_node_id in visited:\n        continue\n    visited.add(current_node_id)\n\n    current_map_id = next((n['map_id'] for n in nodes if n['id'] == current_node_id), None)\n    if current_map_id == end_map:\n        path_details = []\n        for node_id in path:\n            node_info = next((n for n in nodes if n['id'] == node_id), None)\n            if node_info:\n                path_details.append(f\"{node_info['name']} ({node_info['map_id']})\")\n        print(' -> '.join(path_details))\n        exit()\n\n    for neighbor_id in graph[current_node_id]:\n        if neighbor_id not in visited:\n            new_path = path + [neighbor_id]\n            heapq.heappush(queue, (cost + 1, neighbor_id, new_path))\n\nprint(f'No path found from map {start_map} to {end_map}.')"
  },
  "path_finder": {
    "description": "A* pathfinding algorithm to find a path between two points on the current map, avoiding obstacles and impassable terrain.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef parse_coords(coord_str):\n    return tuple(map(int, coord_str.strip('()').split(',')))\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(grid, start, goal):\n    open_set = []\n    h_start = heuristic(start, goal)\n    heapq.heappush(open_set, (h_start, h_start, start)) # (f_score, h_score, node)\n    came_from = {}\n    g_score = {node: float('inf') for node in grid}\n    g_score[start] = 0\n\n    while open_set:\n        _, _, current = heapq.heappop(open_set)\n\n        if current == goal:\n            path = []\n            while current in came_from:\n                previous = came_from[current]\n                if current[0] == previous[0] + 1: path.append(\"Right\")\n                elif current[0] == previous[0] - 1: path.append(\"Left\")\n                elif current[1] == previous[1] + 1: path.append(\"Down\")\n                elif current[1] == previous[1] - 1: path.append(\"Up\")\n                current = previous\n            return path[::-1]\n\n        for neighbor_coords in grid.get(current, []):\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor_coords, float('inf')):\n                came_from[neighbor_coords] = current\n                g_score[neighbor_coords] = tentative_g_score\n                h_score = heuristic(neighbor_coords, goal)\n                f_score = tentative_g_score + h_score\n                heapq.heappush(open_set, (f_score, h_score, neighbor_coords))\n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n\n    start_node = (start_x, start_y)\n    goal_node = (end_x, end_y)\n\n    root = ET.fromstring(map_xml_string)\n    \n    tiles = {}\n    obstacle_emojis = ['â˜ ï¸', 'ðŸŽ£', 'âš”ï¸', 'ðŸ‘©â€âš•ï¸', 'ðŸ‘®', 'ðŸ§‘â€ðŸ”¬', 'ðŸ‘‹', 'ðŸ’°', 'ðŸŽ', 'ðŸ“', 'ðŸ—¿', 'â“']\n    impassable_types = ['WALL', 'WATER', 'COUNTER', 'MART_SHELF', 'BOOKSHELF', 'TV', 'RADIO', 'PC', 'TOWN_MAP', 'WINDOW', 'PAINTING', 'STATUE', 'PILLAR', 'VOID', 'BUOY', 'CUT_TREE', 'HEADBUTT_TREE']\n\n    for row_elem in root.findall('Row'):\n        for tile_elem in row_elem.findall('Tile'):\n            coords = parse_coords(tile_elem.attrib['coordinate'])\n            tile_type = tile_elem.attrib['type']\n            is_obstacle = tile_elem.find('Object') is not None\n            if not is_obstacle:\n                for marker in tile_elem.findall('Marker'):\n                    if marker.attrib.get('emoji') in obstacle_emojis:\n                        is_obstacle = True\n                        break\n            tiles[coords] = {'type': tile_type, 'is_obstacle': is_obstacle}\n\n    valid_coords = set()\n    for coords, tile_data in tiles.items():\n        if tile_data['type'] not in impassable_types and not tile_data['is_obstacle']:\n            valid_coords.add(coords)\n    \n    grid = {}\n    for coords in valid_coords:\n        grid[coords] = []\n        x, y = coords\n        \n        # Determine possible moves FROM the current tile\n        current_tile_type = tiles[coords]['type']\n        if 'FLOOR_ALLOW_HOP_DOWN' in current_tile_type or 'LEDGE' in current_tile_type:\n            possible_moves = [(0, 1)]\n        elif 'FLOOR_ALLOW_HOP_LEFT' in current_tile_type:\n            possible_moves = [(-1, 0)]\n        elif 'FLOOR_ALLOW_HOP_RIGHT' in current_tile_type:\n            possible_moves = [(1, 0)]\n        elif 'FLOOR_UP_WALL' in current_tile_type:\n             possible_moves = [] # Can't move from a one-way wall\n        else:\n            possible_moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        for dx, dy in possible_moves:\n            neighbor_coords = (x + dx, y + dy)\n            \n            if neighbor_coords not in valid_coords:\n                continue\n            \n            # Prevent moving backwards onto a one-way tile\n            neighbor_tile_type = tiles[neighbor_coords]['type']\n            if 'FLOOR_UP_WALL' in current_tile_type and dy != -1: # Trying to move from UP_WALL in wrong direction\n                continue\n            if ('LEDGE' in current_tile_type or 'FLOOR_ALLOW_HOP_DOWN' in current_tile_type) and dy != 1:\n                continue\n            if 'FLOOR_ALLOW_HOP_LEFT' in current_tile_type and dx != -1:\n                continue\n            if 'FLOOR_ALLOW_HOP_RIGHT' in current_tile_type and dx != 1:\n                continue\n\n            grid[coords].append(neighbor_coords)\n\n    path = a_star_search(grid, start_node, goal_node)\n\n    if path:\n        print(json.dumps({\"status\": \"success\", \"path\": path}))\n    else:\n        print(json.dumps({\"status\": \"failure\", \"path\": []}))\n\nexcept Exception as e:\n    print(json.dumps({\"status\": \"error\", \"message\": str(e)}))"
  }
}