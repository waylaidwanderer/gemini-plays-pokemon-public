{
  "advanced_pathfinder": {
    "description": "An advanced pathfinder that ignores most tile types to find hidden passages, but respects truly impassable tiles, objects, and closed gates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\ngrid = [['' for _ in range(width)] for _ in range(height)]\nimpassable_coords = set()\n\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.get('id')) - 1\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.get('id')) - 1\n        grid[y][x] = tile_elem.get('type')\n        obj = tile_elem.find('Object')\n        if obj is not None and obj.get('id-name') != 'Pikachu':\n            impassable_coords.add((x, y))\n\nstart_x = int(input_data['start_x']) - 1\nstart_y = int(input_data['start_y']) - 1\nend_x = int(input_data['end_x']) - 1\nend_y = int(input_data['end_y']) - 1\n\nstart_node = (start_x, start_y)\nend_node = (end_x, end_y)\n\nqueue = deque([(start_node, [start_node])])\nvisited = {start_node}\n\npath_found = False\nwhile queue:\n    (current_x, current_y), path = queue.popleft()\n\n    if (current_x, current_y) == end_node:\n        path_plan = [{'x': x + 1, 'y': y + 1} for x, y in path]\n        print(json.dumps(path_plan))\n        path_found = True\n        break\n\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        next_x, next_y = current_x + dx, current_y + dy\n\n        if 0 <= next_x < width and 0 <= next_y < height:\n            neighbor = (next_x, next_y)\n            if neighbor not in visited:\n                tile_type = grid[next_y][next_x]\n                if tile_type not in ['impassable', 'closed_gate'] and neighbor not in impassable_coords:\n                    visited.add(neighbor)\n                    new_path = path + [neighbor]\n                    queue.append((neighbor, new_path))\n\nif not path_found:\n    print(json.dumps([]))"
  },
  "exploration_planner": {
    "description": "Analyzes the map to find the closest reachable unseen tile and calculates the optimal path to an adjacent, traversable tile. It now correctly handles ledge traversal.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "traversal_type": {
          "type": "string",
          "enum": [
            "walk",
            "surf"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "traversal_type"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef exploration_planner_tool_v5():\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    grid = [['' for _ in range(width)] for _ in range(height)]\n    impassable_coords = set()\n    unseen_tiles = []\n\n    traversal_type = input_data['traversal_type']\n    walkable_types = ['water'] if traversal_type == 'surf' else ['ground', 'grass', 'open_gate', 'cleared_boulder_barrier', 'boulder_switch', 'teleport', 'hole', 'spinner_stop', 'ladder_up', 'ladder_down', 'steps', 'ledge', 'cuttable']\n\n    for r_idx, row_elem in enumerate(root.findall('Row')):\n        y = int(row_elem.get('id')) - 1\n        for c_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n            x = int(tile_elem.get('id')) - 1\n            tile_type = tile_elem.get('type')\n            grid[y][x] = tile_type\n            if tile_elem.get('seen') == 'false':\n                unseen_tiles.append((x, y))\n            if tile_elem.find('Object') is not None and (tile_elem.find('Object').get('id-name') != 'Pikachu'):\n                impassable_coords.add((x, y))\n\n    start_x, start_y = int(input_data['start_x']) - 1, int(input_data['start_y']) - 1\n    start_pos = (start_x, start_y)\n\n    if not unseen_tiles:\n        print(json.dumps({'path': [], 'reasoning': 'No unseen tiles found.'}))\n        return\n\n    all_target_adjacents = set()\n    for ux, uy in unseen_tiles:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_x, adj_y = ux + dx, uy + dy\n            if 0 <= adj_x < width and 0 <= adj_y < height and grid[adj_y][adj_x] in walkable_types and (adj_x, adj_y) not in impassable_coords:\n                all_target_adjacents.add((adj_x, adj_y))\n\n    if not all_target_adjacents:\n        print(json.dumps({'path': [], 'reasoning': 'No reachable adjacent tiles found for any unseen tiles.'}))\n        return\n\n    queue = deque([(start_pos, [start_pos])])\n    visited = {start_pos}\n\n    while queue:\n        (current_x, current_y), path = queue.popleft()\n\n        if (current_x, current_y) in all_target_adjacents:\n            path_plan = [{'x': x + 1, 'y': y + 1} for x, y in path]\n            target_x, target_y = path_plan[-1]['x'], path_plan[-1]['y']\n            reasoning = f'Path found to the nearest reachable exploration point at ({target_x}, {target_y}).'\n            print(json.dumps({'path': path_plan, 'reasoning': reasoning}))\n            return\n\n        for move_info in [((0, 1), 'Down'), ((0, -1), 'Up'), ((1, 0), 'Right'), ((-1, 0), 'Left')]:\n            (dx, dy), direction = move_info\n            next_x, next_y = current_x + dx, current_y + dy\n            if 0 <= next_x < width and 0 <= next_y < height and (next_x, next_y) not in visited:\n                current_tile_type = grid[current_y][current_x]\n                next_tile_type = grid[next_y][next_x]\n                \n                is_ledge_move = (next_tile_type == 'ledge')\n                can_traverse_ledge = (is_ledge_move and direction == 'Down')\n\n                if (next_tile_type in walkable_types and not is_ledge_move) or can_traverse_ledge:\n                    if (next_x, next_y) not in impassable_coords:\n                        visited.add((next_x, next_y))\n                        new_path = path + [(next_x, next_y)]\n                        if can_traverse_ledge:\n                            # Ledge jump lands you two tiles down\n                            if next_y + 1 < height:\n                                new_path.append((next_x, next_y + 1))\n                        queue.append(((new_path[-1][0], new_path[-1][1]), new_path))\n\n    print(json.dumps({'path': [], 'reasoning': 'Could not find a path to any reachable exploration points.'}))\n\nexploration_planner_tool_v5()"
  },
  "find_next_exploration_target": {
    "description": "Analyzes unseen tiles and reachable barriers to suggest the most logical next exploration target. Prioritizes the closest unseen tile. If none exist, it finds the closest reachable barrier based on Manhattan distance from the player's current coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "unseen_tiles_json": {
          "type": "string"
        },
        "reachable_barriers_json": {
          "type": "string"
        },
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "unseen_tiles_json",
        "reachable_barriers_json",
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import json\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nunseen_tiles = json.loads(input_data['unseen_tiles_json'])\nreachable_barriers = json.loads(input_data['reachable_barriers_json'])\n\nstart_pos = (start_x, start_y)\nnext_target = None\nmin_dist = float('inf')\nreasoning = ''\n\nif unseen_tiles:\n    for tile in unseen_tiles:\n        dist = heuristic(start_pos, (tile['x'], tile['y']))\n        if dist < min_dist:\n            min_dist = dist\n            next_target = tile\n    if next_target:\n        reasoning = f'The closest unseen tile is at ({next_target[\"x\"]}, {next_target[\"y\"]}) with a distance of {min_dist}.'\n    else:\n        reasoning = 'No unseen tiles found.'\nelif reachable_barriers:\n    for barrier in reachable_barriers:\n        dist = heuristic(start_pos, (barrier['x'], barrier['y']))\n        if dist < min_dist:\n            min_dist = dist\n            next_target = barrier\n    if next_target:\n        reasoning = f'No unseen tiles. The closest reachable barrier is at ({next_target[\"x\"]}, {next_target[\"y\"]}) with a distance of {min_dist}.'\n    else:\n        reasoning = 'No reachable barriers found.'\nelse:\n    reasoning = 'No unseen tiles or reachable barriers to suggest.'\n\nif next_target:\n    print(json.dumps({'next_target_x': next_target['x'], 'next_target_y': next_target['y'], 'reasoning': reasoning}))\nelse:\n    print(json.dumps({'next_target_x': None, 'next_target_y': None, 'reasoning': reasoning}))"
  },
  "find_path": {
    "description": "Calculates the shortest path between two points on the current map. Supports 'walk' or 'surf' traversal types. Can target the destination directly or an adjacent traversable tile.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "traversal_type": {
          "type": "string",
          "enum": [
            "walk",
            "surf"
          ]
        },
        "adjacent": {
          "type": "string",
          "enum": [
            "true",
            "false"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\ngrid = [['' for _ in range(width)] for _ in range(height)]\nimpassable_coords = set()\n\nwalk_types = ['ground', 'grass', 'open_gate', 'cleared_boulder_barrier', 'boulder_switch', 'teleport', 'hole', 'spinner_stop', 'ladder_up', 'ladder_down', 'steps']\nsurf_types = ['water']\n\nfor r_idx, row_elem in enumerate(root.findall('Row')):\n    y = int(row_elem.get('id')) - 1\n    for c_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n        x = int(tile_elem.get('id')) - 1\n        grid[y][x] = tile_elem.get('type')\n        if tile_elem.find('Object') is not None and (tile_elem.find('Object').get('id-name') != 'Pikachu'):\n            impassable_coords.add((x, y))\n\nstart_x, start_y = int(input_data['start_x']) - 1, int(input_data['start_y']) - 1\nend_x, end_y = int(input_data['end_x']) - 1, int(input_data['end_y']) - 1\ntraversal_type = input_data.get('traversal_type', 'walk')\nfind_adjacent = input_data.get('adjacent', 'false').lower() == 'true'\n\nif traversal_type == 'walk':\n    traversable_tiles = set(walk_types)\nelif traversal_type == 'surf':\n    traversable_tiles = set(surf_types)\nelse:\n    traversable_tiles = set(walk_types)\n\ntarget_nodes = []\nif find_adjacent:\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        adj_x, adj_y = end_x + dx, end_y + dy\n        if 0 <= adj_x < width and 0 <= adj_y < height and grid[adj_y][adj_x] in traversable_tiles and (adj_x, adj_y) not in impassable_coords:\n            target_nodes.append((adj_x, adj_y))\nelse:\n    if grid[end_y][end_x] in traversable_tiles:\n        target_nodes.append((end_x, end_y))\n\nif not target_nodes:\n    print(json.dumps([]))\nelse:\n    queue = deque([((start_x, start_y), [(start_x, start_y)])])\n    visited = {(start_x, start_y)}\n    path_found = False\n\n    while queue:\n        (current_x, current_y), path = queue.popleft()\n\n        if (current_x, current_y) in target_nodes:\n            path_plan = [{'x': x + 1, 'y': y + 1} for x, y in path]\n            print(json.dumps(path_plan))\n            path_found = True\n            break\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = current_x + dx, current_y + dy\n            \n            if 0 <= next_x < width and 0 <= next_y < height and (next_x, next_y) not in visited:\n                tile_type = grid[next_y][next_x]\n                \n                if tile_type in traversable_tiles and (next_x, next_y) not in impassable_coords:\n                    visited.add((next_x, next_y))\n                    queue.append(((next_x, next_y), path + [(next_x, next_y)]))\n    \n    if not path_found:\n        print(json.dumps([]))"
  }
}