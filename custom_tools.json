{
  "path_finder_plus": {
    "description": "A reliable pathfinder that correctly handles all known one-way tiles and other impassable terrain, including off-screen obstacles identified by map markers. Now includes debug output.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\nimport json\n\nclass Node:\n    def __init__(self, position, parent=None):\n        self.parent = parent\n        self.position = position\n        self.g = 0\n        self.h = 0\n        self.f = 0\n\n    def __eq__(self, other):\n        return self.position == other.position\n\n    def __lt__(self, other):\n        if self.f == other.f:\n            return self.h < other.h\n        return self.f < other.f\n\n    def __hash__(self):\n        return hash(self.position)\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef find_path(grid, start, end, all_impassable_objects, debug_info):\n    impassable_base = {\n        'WALL', 'VOID', 'WATER', 'CUT_TREE', 'COUNTER', 'BUOY', 'HEADBUTT_TREE', 'unseen',\n        'MART_SHELF', 'BOOKSHELF', 'TV', 'RADIO', 'PC', 'TOWN_MAP', 'WINDOW', 'PAINTING', 'STATUE', 'PILLAR',\n        'BED', 'TABLE', 'CHAIR'\n    }\n    warp_tiles = {'DOOR', 'CAVE', 'LADDER', 'WARP_CARPET_DOWN', 'WARP_CARPET_RIGHT', 'WARP_CARPET_LEFT'}\n    hop_down_tiles = {'LEDGE', 'FLOOR_ALLOW_HOP_DOWN', 'FLOOR_ALLOW_HOP_DOWN_OR_RIGHT'}\n    hop_left_tiles = {'FLOOR_ALLOW_HOP_LEFT'}\n    hop_right_tiles = {'FLOOR_ALLOW_HOP_RIGHT', 'FLOOR_ALLOW_HOP_DOWN_OR_RIGHT'}\n    climb_up_wall_tiles = {'FLOOR_UP_WALL'}\n\n    start_node = Node(start)\n    end_node = Node(end)\n\n    if start not in grid or grid[start]['type'] in impassable_base or start in all_impassable_objects:\n        debug_info['error'] = f\"Start position {start} is impassable. Type: {grid.get(start, {}).get('type')}. Is in objects: {start in all_impassable_objects}\"\n        return None\n    if end not in grid or (grid[end]['type'] in impassable_base and grid[end]['type'] not in warp_tiles) or (end in all_impassable_objects and grid[end]['type'] not in warp_tiles):\n        debug_info['error'] = f\"End position {end} is impassable. Type: {grid.get(end, {}).get('type')}. Is in objects: {end in all_impassable_objects}\"\n        return None\n\n    open_list = []\n    closed_set = set()\n    heapq.heappush(open_list, start_node)\n    \n    path_end_node = None\n    \n    while open_list:\n        current_node = heapq.heappop(open_list)\n\n        if current_node.position in closed_set:\n            continue\n        closed_set.add(current_node.position)\n\n        if current_node == end_node:\n            path_end_node = current_node\n            break\n        \n        for move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            next_pos = (current_node.position[0] + move[0], current_node.position[1] + move[1])\n\n            if next_pos not in grid: continue\n\n            current_type = grid[current_node.position]['type']\n            next_type = grid[next_pos]['type']\n            \n            rejection_reason = None\n            if next_type in impassable_base: rejection_reason = f\"Impassable tile type: {next_type}\"\n            elif next_pos in all_impassable_objects: rejection_reason = \"Blocked by an object\"\n            elif next_type in warp_tiles and next_pos != end: rejection_reason = \"Cannot path through warps\"\n            \n            if rejection_reason:\n                if len(debug_info.get('rejection_logs', [])) < 20:\n                    debug_info.setdefault('rejection_logs', []).append(f\"Rejected {next_pos}: {rejection_reason}\")\n                continue\n\n            valid_move = True\n            move_name = move[2]\n            if move_name == 'Up' and (next_type in hop_down_tiles or current_type in climb_up_wall_tiles):\n                valid_move = False\n            elif move_name == 'Down' and next_type in climb_up_wall_tiles:\n                valid_move = False\n            elif move_name == 'Left' and next_type in hop_right_tiles:\n                valid_move = False\n            elif move_name == 'Right' and next_type in hop_left_tiles:\n                valid_move = False\n            \n            if not valid_move: continue\n\n            child = Node(next_pos, current_node)\n            child.g = current_node.g + 1\n            child.h = heuristic(child.position, end_node.position)\n            child.f = child.g + child.h\n\n            if any(open_node for open_node in open_list if open_node == child and child.g >= open_node.g):\n                continue\n            \n            heapq.heappush(open_list, child)\n    \n    debug_info['nodes_checked'] = len(closed_set)\n    if not path_end_node:\n        debug_info['error'] = 'No path found to destination.'\n        return None\n\n    path = []\n    current = path_end_node\n    while current is not None:\n        path.append(list(current.position))\n        current = current.parent\n    \n    return path[::-1]\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    objects = set()\n    background_objects = set()\n    marked_objects = set()\n\n    blocking_emojis = {'ðŸš€', 'ðŸ‘©â€ðŸ«', 'ðŸ‘´', 'ðŸ‘¦', 'ðŸ“'}\n\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            grid[(x, y)] = {'type': tile.get('type')}\n            for obj in tile.findall('Object'):\n                if obj.get('id-name') and tile.find('Player') is None:\n                    objects.add((x, y))\n                elif obj.get('name') and not obj.get('id-name'):\n                    background_objects.add((x,y))\n            for marker in tile.findall('Marker'):\n                if marker.get('emoji') in blocking_emojis:\n                    marked_objects.add((x, y))\n\n    all_impassable_objects = objects.union(background_objects).union(marked_objects)\n\n    debug_info = {\n        'start': (start_x, start_y),\n        'end': (end_x, end_y),\n        'impassable_sprites': sorted(list(objects)),\n        'impassable_bg_objects': sorted(list(background_objects)),\n        'impassable_marked_objects': sorted(list(marked_objects)),\n        'error': None\n    }\n\n    path = find_path(grid, (start_x, start_y), (end_x, end_y), all_impassable_objects, debug_info)\n    \n    final_output = {\n        \"path\": path if path else [],\n        \"debug\": debug_info\n    }\n    print(json.dumps(final_output))\n\nexcept Exception as e:\n    import traceback\n    error_output = {\n        \"path\": [],\n        \"debug\": {\"error\": f\"An exception occurred: {str(e)}\\n{traceback.format_exc()}\"}\n    }\n    print(json.dumps(error_output))"
  },
  "route_finder": {
    "description": "Finds a path between two maps using the World Knowledge Graph.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_map_id": {
          "type": "string"
        },
        "end_map_id": {
          "type": "string"
        }
      },
      "required": [
        "start_map_id",
        "end_map_id"
      ]
    },
    "python_script": "import json\nimport heapq\nfrom collections import defaultdict\nimport itertools\n\nworld_knowledge = json.loads(world_knowledge_graph_json_string)\nnodes = world_knowledge['nodes']\nedges = world_knowledge['edges']\n\nstart_map = input_data['start_map_id']\nend_map = input_data['end_map_id']\n\ngraph = defaultdict(list)\n\n# Add explicit edges from the knowledge graph\nfor edge in edges:\n    if edge['source_node_id'] and edge['destination_node_id']:\n        graph[edge['source_node_id']].append(edge['destination_node_id'])\n        if not edge.get('is_one_way', False):\n            graph[edge['destination_node_id']].append(edge['source_node_id'])\n\n# Group nodes by map_id\nnodes_by_map = defaultdict(list)\nfor node in nodes:\n    nodes_by_map[node['map_id']].append(node['id'])\n\n# Add implicit intra-map edges\nfor map_id, map_nodes in nodes_by_map.items():\n    if len(map_nodes) > 1:\n        for u, v in itertools.combinations(map_nodes, 2):\n            graph[u].append(v)\n            graph[v].append(u)\n\nstart_node_ids = nodes_by_map.get(start_map, [])\n\nif not start_node_ids:\n    print(f'Start node for map {start_map} not found in World Knowledge Graph.')\n    exit()\n\n# Dijkstra's algorithm to find the shortest path\nqueue = [(0, start_node_id, [start_node_id]) for start_node_id in start_node_ids]\nvisited = set()\n\nwhile queue:\n    cost, current_node_id, path = heapq.heappop(queue)\n\n    if current_node_id in visited:\n        continue\n    visited.add(current_node_id)\n\n    current_map_id = next((n['map_id'] for n in nodes if n['id'] == current_node_id), None)\n    if current_map_id == end_map:\n        path_details = []\n        for node_id in path:\n            node_info = next((n for n in nodes if n['id'] == node_id), None)\n            if node_info:\n                path_details.append(f\"{node_info['name']} ({node_info['map_id']})\")\n        print(' -> '.join(path_details))\n        exit()\n\n    for neighbor_id in graph[current_node_id]:\n        if neighbor_id not in visited:\n            new_path = path + [neighbor_id]\n            heapq.heappush(queue, (cost + 1, neighbor_id, new_path))\n\nprint(f'No path found from map {start_map} to {end_map}.')"
  },
  "area_explorer": {
    "description": "Systematically explores all reachable, unseen tiles from a given starting point on the current map and returns a list of their coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef explore_area(grid, start, objects):\n    impassable_base = {\n        'WALL', 'VOID', 'WATER', 'CUT_TREE', 'COUNTER', 'BUOY', 'HEADBUTT_TREE', 'unseen',\n        'MART_SHELF', 'BOOKSHELF', 'TV', 'RADIO', 'PC', 'TOWN_MAP', 'WINDOW', 'PAINTING', 'STATUE', 'PILLAR',\n        'BED', 'TABLE', 'CHAIR'\n    }\n    warp_tiles = {'DOOR', 'CAVE', 'LADDER', 'WARP_CARPET_DOWN', 'WARP_CARPET_RIGHT', 'WARP_CARPET_LEFT'}\n    hop_down_tiles = {'LEDGE', 'FLOOR_ALLOW_HOP_DOWN', 'FLOOR_ALLOW_HOP_DOWN_OR_RIGHT'}\n    hop_left_tiles = {'FLOOR_ALLOW_HOP_LEFT'}\n    hop_right_tiles = {'FLOOR_ALLOW_HOP_RIGHT', 'FLOOR_ALLOW_HOP_DOWN_OR_RIGHT'}\n    climb_up_wall_tiles = {'FLOOR_UP_WALL'}\n\n    queue = deque([start])\n    visited = {start}\n    unseen_reachable = []\n\n    while queue:\n        current_pos = queue.popleft()\n\n        for move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            next_pos = (current_pos[0] + move[0], current_pos[1] + move[1])\n\n            if next_pos in visited or next_pos not in grid: continue\n            visited.add(next_pos)\n\n            current_type = grid[current_pos]['type']\n            next_type = grid[next_pos]['type']\n\n            if next_type in impassable_base or next_pos in objects or next_type in warp_tiles: continue\n\n            valid_move = True\n            move_name = move[2]\n            if move_name == 'Up' and (next_type in hop_down_tiles or current_type in climb_up_wall_tiles): valid_move = False\n            elif move_name == 'Down' and next_type in climb_up_wall_tiles: valid_move = False\n            elif move_name == 'Left' and next_type in hop_right_tiles: valid_move = False\n            elif move_name == 'Right' and next_type in hop_left_tiles: valid_move = False\n\n            if valid_move:\n                if grid[next_pos]['seen'] == 'false':\n                    unseen_reachable.append(list(next_pos))\n                queue.append(next_pos)\n    \n    return unseen_reachable\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    \n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    objects = set()\n\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            grid[(x, y)] = {'type': tile.get('type'), 'seen': tile.get('seen')}\n            if tile.find('Object') is not None and tile.find('Player') is None:\n                objects.add((x, y))\n\n    unseen_tiles = explore_area(grid, (start_x, start_y), objects)\n    print(json.dumps({\"unseen_reachable_tiles\": unseen_tiles}))\n\nexcept Exception as e:\n    print(json.dumps({\"error\": str(e)}))"
  }
}