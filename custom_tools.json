{
  "find_reachable_unseen_tiles": {
    "description": "Finds all unseen tiles that are adjacent to currently reachable, seen, walkable tiles.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef parse_map(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    tiles = {}\n    player_pos = None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tiles[(x, y)] = tile\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n    return tiles, player_pos, width, height\n\ndef is_obstacle_for_reachability(tile):\n    if tile is None: return True\n    tile_type = tile.attrib['type']\n    if tile_type in ['WALL', 'HEADBUTT_TREE', 'VOID', 'CUT_TREE', 'COUNTER'] or tile.find('Object') is not None or tile.find('Marker') is not None:\n        if tile.attrib.get('is-warp') == 'true': return False\n        return True\n    return False\n\ndef find_all_reachable_seen_tiles(tiles, start, width, height):\n    queue = deque([start])\n    visited = {start}\n    reachable_seen = set()\n\n    while queue:\n        node = queue.popleft()\n        reachable_seen.add(node)\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor_coord = (node[0] + dx, node[1] + dy)\n            if not (1 <= neighbor_coord[0] <= width and 1 <= neighbor_coord[1] <= height):\n                continue\n            if neighbor_coord in visited:\n                continue\n            \n            neighbor_tile = tiles.get(neighbor_coord)\n            if is_obstacle_for_reachability(neighbor_tile) or neighbor_tile.attrib['seen'] == 'false':\n                continue\n            \n            # Ledge logic\n            move_dir = ''\n            if dy == 1: move_dir = 'Down'\n            elif dy == -1: move_dir = 'Up'\n            elif dx == 1: move_dir = 'Right'\n            elif dx == -1: move_dir = 'Left'\n            current_tile_type = tiles[node].attrib.get('type')\n            neighbor_tile_type = neighbor_tile.attrib.get('type')\n            if move_dir == 'Up' and neighbor_tile_type == 'LEDGE_HOP_DOWN': continue\n            if move_dir == 'Right' and neighbor_tile_type == 'LEDGE_HOP_LEFT': continue\n            if move_dir == 'Left' and neighbor_tile_type == 'LEDGE_HOP_RIGHT': continue\n\n            visited.add(neighbor_coord)\n            queue.append(neighbor_coord)\n    return reachable_seen\n\ntry:\n    tiles, player_pos, map_width, map_height = parse_map(map_xml_string)\n    if player_pos:\n        reachable_seen = find_all_reachable_seen_tiles(tiles, player_pos, map_width, map_height)\n        explorable_frontiers = set()\n        \n        for coord in reachable_seen:\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                neighbor_coord = (coord[0] + dx, coord[1] + dy)\n                neighbor_tile = tiles.get(neighbor_coord)\n                if neighbor_tile is not None and neighbor_tile.attrib['seen'] == 'false':\n                    explorable_frontiers.add(neighbor_coord)\n        \n        output = [{'x': x, 'y': y} for x, y in explorable_frontiers]\n        print(json.dumps(output))\n    else:\n        print(json.dumps([]))\nexcept Exception as e:\n    import traceback\n    print(f'An error occurred: {e}\\n{traceback.format_exc()}')"
  },
  "find_path": {
    "description": "A general-purpose pathfinding tool using BFS. Finds a path from the player to a target coordinate, navigating around obstacles and handling impassable targets by pathing to an adjacent tile.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef parse_map(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    tiles = {}\n    player_pos = None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tiles[(x, y)] = tile\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n    return tiles, player_pos, width, height\n\ndef is_obstacle(tile):\n    if tile is None: return True\n    if tile.attrib.get('is-warp') == 'true': return False\n    tile_type = tile.attrib['type']\n    if tile_type in ['WALL', 'HEADBUTT_TREE', 'VOID', 'CUT_TREE', 'COUNTER', 'unseen'] or tile.find('Object') is not None:\n        return True\n    return False\n\ndef find_path_bfs(tiles, start, goal, width, height):\n    original_goal = goal\n    target_tile = tiles.get(goal)\n\n    if is_obstacle(target_tile):\n        potential_goals = []\n        is_unseen_target = target_tile is not None and target_tile.attrib['seen'] == 'false'\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_coord = (original_goal[0] + dx, original_goal[1] + dy)\n            adj_tile = tiles.get(adj_coord)\n            if adj_tile:\n                if is_unseen_target:\n                    if adj_tile.attrib['seen'] == 'true' and not is_obstacle(adj_tile):\n                        potential_goals.append(adj_coord)\n                else:\n                    if not is_obstacle(adj_tile):\n                        potential_goals.append(adj_coord)\n        \n        if not potential_goals:\n            return None\n        \n        potential_goals.sort(key=lambda p: abs(p[0] - start[0]) + abs(p[1] - start[1]))\n        goal = potential_goals[0]\n\n    queue = deque([[start]])\n    visited = {start}\n\n    while queue:\n        path = queue.popleft()\n        node = path[-1]\n        if node == goal:\n            return path\n        for dx, dy, move_dir in [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n            neighbor_coord = (node[0] + dx, node[1] + dy)\n            if not (1 <= neighbor_coord[0] <= width and 1 <= neighbor_coord[1] <= height):\n                continue\n            if neighbor_coord in visited:\n                continue\n            \n            neighbor_tile = tiles.get(neighbor_coord)\n            if is_obstacle(neighbor_tile):\n                continue\n            \n            current_tile = tiles.get(node)\n            current_tile_type = current_tile.attrib.get('type') if current_tile else None\n            neighbor_tile_type = neighbor_tile.attrib.get('type') if neighbor_tile else None\n\n            # Prevent moving ONTO a ledge from the wrong side\n            if move_dir == 'Up' and neighbor_tile_type == 'LEDGE_HOP_DOWN': continue\n            if move_dir == 'Right' and neighbor_tile_type == 'LEDGE_HOP_LEFT': continue\n            if move_dir == 'Left' and neighbor_tile_type == 'LEDGE_HOP_RIGHT': continue\n            \n            # Prevent moving FROM a ledge in the wrong direction\n            if move_dir == 'Up' and current_tile_type == 'LEDGE_HOP_DOWN': continue\n            if move_dir == 'Right' and current_tile_type == 'LEDGE_HOP_LEFT': continue\n            if move_dir == 'Left' and current_tile_type == 'LEDGE_HOP_RIGHT': continue\n\n            visited.add(neighbor_coord)\n            new_path = list(path)\n            new_path.append(neighbor_coord)\n            queue.append(new_path)\n    return None\n\ntry:\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    tiles, player_pos, map_width, map_height = parse_map(map_xml_string)\n    if player_pos:\n        path = find_path_bfs(tiles, player_pos, (target_x, target_y), map_width, map_height)\n        if path:\n            path_coords = [{'x': p[0], 'y': p[1]} for p in path]\n            print(json.dumps(path_coords))\n        else:\n            print(json.dumps([]))\n    else:\n        print(json.dumps([]))\nexcept Exception as e:\n    import traceback\n    print(f'An error occurred: {e}\\n{traceback.format_exc()}')"
  }
}