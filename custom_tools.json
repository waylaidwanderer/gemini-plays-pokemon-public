{
  "wkg_updater": {
    "description": "Streamlined tool to manage the World Knowledge Graph. It verifies if a node or edge already exists and, if not, directly calls `manage_world_knowledge` to add it. This is a single-step action to prevent manual errors.",
    "input_schema": {
      "type": "object",
      "properties": {
        "operation": {
          "type": "string",
          "enum": [
            "add_node",
            "add_edge"
          ]
        },
        "map_id": {
          "type": "string"
        },
        "x": {
          "type": "string"
        },
        "y": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "type": {
          "type": "string"
        },
        "tags": {
          "type": "string"
        },
        "source_map_id": {
          "type": "string"
        },
        "source_x": {
          "type": "string"
        },
        "source_y": {
          "type": "string"
        },
        "dest_map_id": {
          "type": "string"
        },
        "dest_x": {
          "type": "string"
        },
        "dest_y": {
          "type": "string"
        },
        "connection_type": {
          "type": "string"
        },
        "is_one_way": {
          "type": "string"
        },
        "destination_entry_point": {
          "type": "string"
        }
      },
      "required": [
        "operation"
      ]
    },
    "python_script": "import json\n\ndef find_node_by_coords(graph, map_id, x, y):\n    for node in graph.get('nodes', []):\n        if str(node.get('map_id')) == str(map_id) and node['coordinates']['x'] == x and node['coordinates']['y'] == y:\n            return node\n    return None\n\ndef find_edge(graph, source_id, dest_id):\n    for edge in graph.get('edges', []):\n        if (edge['source_node_id'] == source_id and edge['destination_node_id'] == dest_id) or \\\n           (edge['source_node_id'] == dest_id and edge['destination_node_id'] == source_id and not edge.get('is_one_way')):\n            return edge\n    return None\n\noperation = input_data['operation']\ngraph = json.loads(world_knowledge_graph_json_string)\n\nif operation == 'add_node':\n    map_id = input_data['map_id']\n    x = int(input_data['x'])\n    y = int(input_data['y'])\n    name = input_data['name']\n    node_type = input_data.get('type', '')\n    tags = json.loads(input_data.get('tags', '[]'))\n\n    if not find_node_by_coords(graph, map_id, x, y):\n        payload = {'map_id': map_id, 'name': name, 'coordinates': {'x': x, 'y': y}, 'type': node_type, 'tags': tags}\n        print(json.dumps({'action': 'call_tool', 'tool_name': 'manage_world_knowledge', 'tool_action': 'add_node', 'payload': json.dumps(payload)}))\n\nelif operation == 'add_edge':\n    source_node = find_node_by_coords(graph, input_data['source_map_id'], int(input_data['source_x']), int(input_data['source_y']))\n    dest_node = find_node_by_coords(graph, input_data['dest_map_id'], int(input_data['dest_x']), int(input_data['dest_y']))\n\n    if source_node and dest_node and not find_edge(graph, source_node['id'], dest_node['id']):\n        payload = {\n            'source_node_id': source_node['id'],\n            'destination_node_id': dest_node['id'],\n            'connection_type': input_data['connection_type'],\n            'source_coordinates': {'x': int(input_data['source_x']), 'y': int(input_data['source_y']), 'map_id': input_data['source_map_id']},\n            'destination_coordinates': {'x': int(input_data['dest_x']), 'y': int(input_data['dest_y']), 'map_id': input_data['dest_map_id']},\n            'is_one_way': input_data.get('is_one_way', 'false').lower() == 'true'\n        }\n        if 'destination_entry_point' in input_data and input_data['connection_type'] == 'warp':\n            payload['destination_entry_point'] = int(input_data['destination_entry_point'])\n        print(json.dumps({'action': 'call_tool', 'tool_name': 'manage_world_knowledge', 'tool_action': 'add_edge', 'payload': json.dumps(payload)}))"
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map using the Breadth-First Search (BFS) algorithm. It considers tile types (including elevation), impassable objects (excluding Pikachu), and special ledge traversal rules. The output is a JSON string containing the list of coordinates for the path.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\nimport traceback\n\ndef find_path_tool(start_x, start_y, end_x, end_y, map_xml_string):\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n\n        grid = [['' for _ in range(width + 1)] for _ in range(height + 1)]\n        \n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                tile_type = tile_elem.get('type')\n                \n                has_impassable_object = False\n                for obj in tile_elem.findall('Object'):\n                    if obj.get('id-name') != 'Pikachu':\n                        has_impassable_object = True\n                        break\n\n                if has_impassable_object:\n                    grid[y][x] = 'impassable'\n                else:\n                    grid[y][x] = tile_type\n\n        start = (int(start_x), int(start_y))\n        end = (int(end_x), int(end_y))\n\n        if not (1 <= start[0] <= width and 1 <= start[1] <= height and 1 <= end[0] <= width and 1 <= end[1] <= height):\n            print(json.dumps({\"error\": \"Start or end coordinates are out of bounds.\"}))\n            return\n\n        if grid[start[1]][start[0]] == 'impassable' or grid[end[1]][end[0]] == 'impassable':\n             print(json.dumps({\"error\": \"Start or end point is on an impassable tile.\"}))\n             return\n\n        queue = deque([start])\n        came_from = {start: None}\n        \n        loop_count = 0\n        while queue:\n            loop_count += 1\n            if loop_count > 2000: # Safety break\n                print(json.dumps({\"error\": \"BFS loop exceeded 2000 iterations, likely an infinite loop.\"}))\n                return\n\n            current = queue.popleft()\n\n            if current == end:\n                path = []\n                temp = current\n                while temp is not None:\n                    path.append({'x': temp[0], 'y': temp[1]})\n                    temp = came_from[temp]\n                print(json.dumps({\"path\": path[::-1]}))\n                return\n\n            cx, cy = current\n            current_type = grid[cy][cx]\n            \n            potential_neighbors_coords = [(cx, cy - 1), (cx, cy + 1), (cx - 1, cy), (cx + 1, cy)]\n            for nx, ny in potential_neighbors_coords:\n                if 1 <= nx <= width and 1 <= ny <= height:\n                    neighbor_coords = (nx, ny)\n                    if neighbor_coords in came_from:\n                        continue\n\n                    neighbor_type = grid[ny][nx]\n                    is_valid_move = False\n\n                    if neighbor_type == 'ledge':\n                        if ny == cy + 1:\n                            if 1 <= ny + 1 <= height and grid[ny+1][nx] not in ['impassable', 'water']:\n                                ledge_jump_target = (nx, ny + 1)\n                                if ledge_jump_target not in came_from:\n                                    came_from[ledge_jump_target] = current\n                                    queue.append(ledge_jump_target)\n                    elif neighbor_type not in ['impassable', 'water']:\n                        if current_type in ['ground', 'grass']:\n                            if neighbor_type in ['ground', 'grass', 'steps']:\n                                is_valid_move = True\n                        elif current_type == 'elevated_ground':\n                            if neighbor_type in ['elevated_ground', 'steps']:\n                                is_valid_move = True\n                        elif current_type == 'steps':\n                            if neighbor_type in ['ground', 'grass', 'elevated_ground', 'steps']:\n                                is_valid_move = True\n                        \n                        if is_valid_move:\n                            came_from[neighbor_coords] = current\n                            queue.append(neighbor_coords)\n\n        print(json.dumps({\"path\": []}))\n    except Exception as e:\n        print(json.dumps({\"error\": \"Caught exception\", \"details\": traceback.format_exc()}))\n\nfind_path_tool(input_data['start_x'], input_data['start_y'], input_data['end_x'], input_data['end_y'], map_xml_string)\n"
  }
}