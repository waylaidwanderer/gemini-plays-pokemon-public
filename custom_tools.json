{
  "slow_press": {
    "description": "Presses a sequence of buttons with a configurable delay between each press. Input 'buttons' should be a list of button names (e.g., 'A', 'B', 'Up'). 'sleep' commands in the input list are ignored to prevent errors; use the 'delay' parameter instead.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "A",
              "B",
              "Select",
              "Start",
              "Right",
              "Left",
              "Up",
              "Down",
              "R",
              "L"
            ]
          }
        },
        "delay": {
          "type": "integer",
          "default": 500,
          "description": "Delay in milliseconds between presses."
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "buttons = input_data.get('buttons', [])\ndelay = input_data.get('delay', 500)\n\nsequence = []\nfor btn in buttons:\n    # Filter out any accidentally passed sleep commands or invalid strings\n    if btn in [\"A\", \"B\", \"Select\", \"Start\", \"Right\", \"Left\", \"Up\", \"Down\", \"R\", \"L\"]:\n        sequence.append(btn)\n        sequence.append(f\"sleep {delay}\")\n\n# Remove the trailing sleep if it exists\nif sequence and sequence[-1].startswith(\"sleep\"):\n    sequence.pop()\n\nprint(json.dumps(sequence))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-20T10:42:11.488Z",
        "action_counter": 8108
      },
      {
        "commit_message": "Refined slow_press to prevent consecutive sleep errors by sanitizing input and ensuring correct interleaving of delays.",
        "timestamp": "2025-12-26T10:25:26.235Z",
        "action_counter": 19531
      }
    ]
  },
  "navigate_menu": {
    "description": "Navigates menus by holding direction buttons for a specified duration to ensure registration, with delays between inputs. Useful for the Fly map and other sticky menus.",
    "input_schema": {
      "type": "object",
      "properties": {
        "directions": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "Up",
              "Down",
              "Left",
              "Right",
              "A",
              "B",
              "Start",
              "Select"
            ]
          }
        },
        "hold_ms": {
          "type": "integer",
          "default": 150
        },
        "interval_ms": {
          "type": "integer",
          "default": 300
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": true
        }
      },
      "required": [
        "directions",
        "autopress_buttons"
      ]
    },
    "python_script": "import json\n\n# Extract arguments from input_data\ndirections = input_data.get('directions', [])\nhold_ms = input_data.get('hold_ms', 150)\ninterval_ms = input_data.get('interval_ms', 300)\nautopress_buttons = input_data.get('autopress_buttons', True)\n\n# Frame duration is approx 16ms\nframes_to_hold = max(1, int(hold_ms / 16))\n\noutput_sequence = []\n\nfor btn in directions:\n    # Hold the button\n    for _ in range(frames_to_hold):\n        output_sequence.append(btn)\n    \n    # Release/Wait\n    if interval_ms > 0:\n        output_sequence.append(f\"sleep {interval_ms}\")\n        \nprint(json.dumps(output_sequence))",
    "history": [
      {
        "commit_message": "Defined a new tool 'navigate_menu' to reliably navigate menus by holding buttons for a specific duration, addressing input registration issues in emulated menus.",
        "timestamp": "2026-01-08T03:01:39.002Z",
        "action_counter": 27437
      },
      {
        "commit_message": "Fixed `navigate_menu` to correctly extract arguments from `input_data` and execute the logic, preventing 'Unexpected end of JSON input' errors.",
        "timestamp": "2026-01-08T03:03:15.631Z",
        "action_counter": 27439
      }
    ]
  },
  "assess_reachability": {
    "description": "Performs a flood-fill BFS starting from a given coordinate to determine all reachable tiles of a specific type (e.g., WATER). Returns the bounds of the reachable area, accessible warps, and adjacent unseen tiles. Useful for determining if a path exists through a maze.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "tile_type": {
          "type": "string",
          "default": "WATER"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef assess_reachability(map_xml_string, start_x, start_y, tile_type=\"WATER\"):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = {}\n    warps = {}\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib.get('type', 'unseen')\n            is_warp = tile.attrib.get('is-warp') == 'true'\n            \n            grid[(x, y)] = t_type\n            if is_warp:\n                # Check for warp details in children\n                warp_node = tile.find('Warp')\n                entry_point = warp_node.attrib.get('entry_point') if warp_node is not None else \"?\"\n                warps[(x, y)] = entry_point\n\n    if grid.get((start_x, start_y)) != tile_type and grid.get((start_x, start_y)) != \"WHIRLPOOL\":\n        print(f\"Error: Start position ({start_x}, {start_y}) is {grid.get((start_x, start_y))}, not {tile_type}.\")\n        return\n\n    queue = deque([(start_x, start_y)])\n    visited = set([(start_x, start_y)])\n    reachable_warps = []\n    reachable_unseen_adjacents = []\n    min_x, max_x, min_y, max_y = start_x, start_x, start_y, start_y\n    \n    # Allow WHIRLPOOL as traversable for surfing if tile_type is WATER\n    traversable_types = {tile_type}\n    if tile_type == \"WATER\":\n        traversable_types.add(\"WHIRLPOOL\")\n\n    while queue:\n        cx, cy = queue.popleft()\n        \n        min_x = min(min_x, cx)\n        max_x = max(max_x, cx)\n        min_y = min(min_y, cy)\n        max_y = max(max_y, cy)\n        \n        if (cx, cy) in warps:\n            reachable_warps.append({'x': cx, 'y': cy, 'entry': warps[(cx, cy)]})\n            \n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < width and 0 <= ny < height:\n                if (nx, ny) in visited:\n                    continue\n                \n                n_type = grid.get((nx, ny), 'unseen')\n                \n                if n_type in traversable_types:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n                elif n_type == 'unseen':\n                    reachable_unseen_adjacents.append({'x': nx, 'y': ny})\n                    # Don't traverse into unseen, just mark it as a frontier\n    \n    print(f\"Reachability Analysis from ({start_x}, {start_y}) for {tile_type}:\")\n    print(f\"  Bounds: X[{min_x}-{max_x}], Y[{min_y}-{max_y}]\")\n    print(f\"  Reachable Tiles Count: {len(visited)}\")\n    print(f\"  Reachable Warps: {reachable_warps}\")\n    print(f\"  Adjacent Unseen Tiles: {len(reachable_unseen_adjacents)} (First 5: {reachable_unseen_adjacents[:5]})\")\n\nassess_reachability(map_xml_string, input_data['start_x'], input_data['start_y'], input_data.get('tile_type', 'WATER'))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-08T11:22:54.983Z",
        "action_counter": 27988
      }
    ]
  },
  "find_path_bfs": {
    "description": "Finds the shortest path from the player's current position to a target coordinate using Breadth-First Search (BFS). Parses map XML to identify walkable tiles, avoiding Walls, Water (if walking), On-screen Objects, and Off-screen Objects marked with markers. Returns a list of button presses.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "movement_mode": {
          "type": "string",
          "enum": [
            "walking",
            "surfing"
          ],
          "default": "walking"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef bfs_path(xml_string, target_x, target_y, movement_mode=\"walking\"):\n    try:\n        root = ET.fromstring(xml_string)\n    except Exception as e:\n        print(f\"Error parsing XML: {e}\")\n        return []\n\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = {}\n    start_pos = None\n    \n    # Allowed tile types\n    walkable_types = {\"FLOOR\", \"GRASS\", \"TALL_GRASS\", \"SAND\", \"CARPET\", \"DOOR\", \n                      \"WARP_CARPET_LEFT\", \"WARP_CARPET_RIGHT\", \"WARP_CARPET_UP\", \"WARP_CARPET_DOWN\",\n                      \"STAIRS\", \"CAVE\"}\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib.get('type', 'WALL')\n            \n            is_blocked = False\n            \n            # Check basic tile type\n            if t_type not in walkable_types:\n                if movement_mode == \"walking\":\n                    is_blocked = True\n                elif movement_mode == \"surfing\":\n                    if t_type != \"WATER\":\n                        is_blocked = True\n            elif movement_mode == \"surfing\":\n                # If surfing, can only move on WATER (usually)\n                if t_type != \"WATER\":\n                    is_blocked = True\n            \n            # Check Objects (On-screen sprites)\n            if not is_blocked:\n                for child in tile:\n                    if child.tag == 'Object':\n                        is_blocked = True\n                        break\n            \n            # Check Markers with object_id (Off-screen known sprites)\n            if not is_blocked:\n                for child in tile:\n                    if child.tag == 'Marker' and child.attrib.get('object_id'):\n                        is_blocked = True\n                        break\n\n            # Check has-object attribute\n            if not is_blocked and tile.attrib.get('has-object') == 'true':\n                 is_blocked = True\n\n            grid[(x, y)] = not is_blocked\n            \n            # Locate Player\n            if tile.find('Player') is not None or tile.attrib.get('has-player') == 'true':\n                start_pos = (x, y)\n                # Player tile is always walkable to start\n                grid[(x, y)] = True\n                \n    if not start_pos:\n        print(\"Error: Player not found on map.\")\n        return []\n        \n    if not grid.get((target_x, target_y), False):\n        print(f\"Error: Target {(target_x, target_y)} is blocked or invalid.\")\n        return []\n        \n    # BFS\n    queue = deque([(start_pos, [])])\n    visited = {start_pos}\n    \n    while queue:\n        current, path = queue.popleft()\n        if current == (target_x, target_y):\n            # Convert path to buttons\n            buttons = []\n            cx, cy = start_pos\n            for nx, ny in path:\n                if nx > cx: buttons.append(\"Right\")\n                elif nx < cx: buttons.append(\"Left\")\n                elif ny > cy: buttons.append(\"Down\")\n                elif ny < cy: buttons.append(\"Up\")\n                cx, cy = nx, ny\n            print(json.dumps(buttons))\n            return buttons\n            \n        cx, cy = current\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) in grid and grid[(nx, ny)] and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [(nx, ny)]))\n                \n    print(f\"Error: No path found to {(target_x, target_y)}.\")\n    return []\n\nif __name__ == \"__main__\":\n    bfs_path(map_xml_string, input_data['target_x'], input_data['target_y'], input_data.get('movement_mode', 'walking'))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-08T13:38:17.154Z",
        "action_counter": 28141
      },
      {
        "commit_message": "Fixed variable access by using `input_data` dictionary instead of assuming global variables.",
        "timestamp": "2026-01-08T13:40:06.080Z",
        "action_counter": 28143
      },
      {
        "commit_message": "Fixing JSON output error when no path is found. Now returns an empty list [] on failure instead of a plain string.",
        "timestamp": "2026-01-08T16:53:53.077Z",
        "action_counter": 28353
      },
      {
        "commit_message": "Fixed missing commit message error and refined BFS logic to handle surfing and landing correctly.",
        "timestamp": "2026-01-08T18:06:59.771Z",
        "action_counter": 28443
      },
      {
        "commit_message": "Fixed JSON output error by removing plain text error messages. Now returns an empty list [] on failure.",
        "timestamp": "2026-01-08T18:13:10.805Z",
        "action_counter": 28451
      },
      {
        "commit_message": "Refined obstacle detection to include <Object> tags and <Marker> tags with object_id, preventing pathing through NPCs.",
        "timestamp": "2026-01-08T21:34:10.018Z",
        "action_counter": 28681
      }
    ]
  },
  "execute_hunt_routine": {
    "description": "Automates the Roaming Beast hunt loop between Ecruteak City and Route 37. Handles map transitions and grass hunting sequence with appropriate delays.",
    "input_schema": {
      "type": "object",
      "properties": {
        "current_map_id": {
          "type": "string"
        },
        "player_position": {
          "type": "object",
          "properties": {
            "x": {
              "type": "integer"
            },
            "y": {
              "type": "integer"
            }
          },
          "required": [
            "x",
            "y"
          ]
        }
      },
      "required": [
        "current_map_id",
        "player_position"
      ]
    },
    "python_script": "import json\nimport sys\n\ntry:\n    # Attempt to resolve variables\n    if 'player_position' not in globals():\n        if 'input_data' in globals():\n            player_position = input_data['player_position']\n            current_map_id = input_data['current_map_id']\n        else:\n            raise ValueError(\"Arguments 'player_position' or 'current_map_id' not found in globals or input_data\")\n\n    y = player_position['y']\n    buttons = []\n    \n    if current_map_id == '4_9': # Ecruteak\n        buttons = [\"Down\"]\n    \n    elif current_map_id == '10_4': # Route 37\n        if y < 2: # At Gate\n             # Go to grass (2 steps), Wiggle, Return (2 steps), Exit (2 steps to be safe)\n             # Added an extra Up to ensure warp triggering\n             buttons = [\n                 \"Down\", \"sleep 500\", \"Down\", \"sleep 500\", \n                 \"Left\", \"sleep 500\", \"Right\", \"sleep 500\", \n                 \"Left\", \"sleep 500\", \"Right\", \"sleep 500\", \n                 \"Up\", \"sleep 500\", \"Up\", \"sleep 500\", \"Up\", \"sleep 500\", \"Up\"\n             ]\n        else: # In Grass (or deeper)\n             # Wiggle and leave\n             buttons = [\n                 \"Left\", \"sleep 500\", \"Right\", \"sleep 500\", \n                 \"Up\", \"sleep 500\", \"Up\", \"sleep 500\", \"Up\", \"sleep 500\", \"Up\"\n             ]\n             \n    print(json.dumps(buttons))\n\nexcept Exception as e:\n    print(str(e))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-08T23:05:10.322Z",
        "action_counter": 28832
      },
      {
        "commit_message": "Fixed the tool to use print() instead of return for JSON output, ensuring compatibility with autopress_buttons.",
        "timestamp": "2026-01-08T23:09:23.848Z",
        "action_counter": 28837
      },
      {
        "commit_message": "Refactored script to execute logic at top-level instead of defining a function, as the environment injects variables directly but does not call defined functions.",
        "timestamp": "2026-01-08T23:11:09.896Z",
        "action_counter": 28839
      },
      {
        "commit_message": "Updated execute_hunt_routine to include 'sleep' commands between movements. This ensures the emulator has time to process each step (walking animation) before the next input is sent, preventing skipped actions.",
        "timestamp": "2026-01-08T23:12:43.180Z",
        "action_counter": 28841
      },
      {
        "commit_message": "Added debugging to print exception message if variable resolution fails. Checks both global scope and 'input_data' dictionary.",
        "timestamp": "2026-01-08T23:13:53.180Z",
        "action_counter": 28843
      },
      {
        "commit_message": "Added an extra 'Up' command to the sequence to ensure the player successfully warps back to Ecruteak City, preventing the loop from stalling at the gate.",
        "timestamp": "2026-01-08T23:19:21.108Z",
        "action_counter": 28849
      }
    ]
  }
}