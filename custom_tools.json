{
  "navigate_fly_map_v2": {
    "description": "Navigates the Johto FLY map from a known starting city to a target city. City names: 'New Bark Town', 'Cherrygrove City', 'Violet City', 'Azalea Town', 'Goldenrod City', 'Ecruteak City', 'Olivine City', 'Cianwood City', 'Mahogany Town', 'Lake of Rage', 'Blackthorn City', 'Mt. Silver', 'Indigo Plateau'. Assumes the FLY map is already open.",
    "input_schema": {
      "properties": {
        "start_city": {
          "default": "New Bark Town",
          "type": "string"
        },
        "target_city": {
          "type": "string"
        }
      },
      "required": [
        "target_city"
      ],
      "type": "object"
    },
    "python_script": "import json\n\ndef navigate_fly_map(target_city, start_city=\"New Bark Town\"):\n    cities = [\n        \"New Bark Town\", \"Cherrygrove City\", \"Violet City\", \"Azalea Town\",\n        \"Goldenrod City\", \"Ecruteak City\", \"Olivine City\", \"Cianwood City\",\n        \"Mahogany Town\", \"Lake of Rage\", \"Blackthorn City\", \"Mt. Silver\", \"Indigo Plateau\"\n    ]\n    \n    if target_city not in cities or start_city not in cities:\n        print(json.dumps([]))\n        return\n\n    start_idx = cities.index(start_city)\n    target_idx = cities.index(target_city)\n    diff = target_idx - start_idx\n    \n    buttons = []\n    # In Crystal Johto FLY map:\n    # 'Up' moves forward in the sequence (index increases).\n    if diff > 0:\n        buttons = [\"Up\"] * diff\n    elif diff < 0:\n        buttons = [\"Down\"] * abs(diff)\n    \n    buttons.append(\"A\")\n    print(json.dumps(buttons))\n\n# The variable 'input_data' is automatically available.\nnavigate_fly_map(input_data['target_city'], input_data.get('start_city', 'New Bark Town'))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-27T03:08:24.414Z",
        "action_counter": 24583
      }
    ]
  },
  "sweep_area_v2": {
    "description": "Iteratively walks all floor tiles within a specified bounding box on the current map to trigger events or find objects. Uses BFS for robust movement between points and handles obstacles. Returns a list of button strings for the path.",
    "input_schema": {
      "type": "object",
      "properties": {
        "bottom_y": {
          "type": "integer"
        },
        "left_x": {
          "type": "integer"
        },
        "right_x": {
          "type": "integer"
        },
        "top_y": {
          "type": "integer"
        }
      },
      "required": [
        "left_x",
        "top_y",
        "right_x",
        "bottom_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        print(json.dumps([]))\n        return\n\n    # Build adjacency and walkable map\n    walkable = {}\n    start_x, start_y = -1, -1\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            t_type = tile.get('type')\n            has_obj = tile.get('has-object') == 'true'\n            \n            # Floor, grass, dirt, sand, and cut trees are generally walkable.\n            # Walls, water (without surf), and objects are not.\n            walkable_types = [\n                'FLOOR', 'TALL_GRASS', 'LONG_GRASS', 'GRASS', 'DIRT', 'SAND',\n                'CUT_TREE', 'CUT_08', 'CUT_28_GARBAGE'\n            ]\n            \n            is_walkable = t_type in walkable_types and not has_obj\n            walkable[(x, y)] = is_walkable\n            \n            if tile.find('Player') is not None:\n                start_x, start_y = x, y\n\n    if start_x == -1:\n        print(json.dumps([]))\n        return\n\n    left_x = int(input_data['left_x'])\n    top_y = int(input_data['top_y'])\n    right_x = int(input_data['right_x'])\n    bottom_y = int(input_data['bottom_y'])\n\n    # Determine targets within the bounding box\n    targets = []\n    for y in range(top_y, bottom_y + 1):\n        # Use a snake pattern for efficiency\n        if (y - top_y) % 2 == 0:\n            x_range = range(left_x, right_x + 1)\n        else:\n            x_range = range(right_x, left_x - 1, -1)\n        \n        for x in x_range:\n            if walkable.get((x, y)):\n                targets.append((x, y))\n\n    if not targets:\n        print(json.dumps([]))\n        return\n\n    def get_path(s_x, s_y, e_x, e_y):\n        if s_x == e_x and s_y == e_y:\n            return []\n            \n        q = deque([(s_x, s_y, [])])\n        visited = set([(s_x, s_y)])\n        while q:\n            cx, cy, path = q.popleft()\n            if cx == e_x and cy == e_y:\n                return path\n            for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n                nx, ny = cx + dx, cy + dy\n                if (nx, ny) in walkable and walkable[(nx, ny)] and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    q.append((nx, ny, path + [btn]))\n        return None\n\n    full_path = []\n    curr_x, curr_y = start_x, start_y\n    \n    # We want to visit EVERY target. If a target is unreachable from the current\n    # position, we skip it and move to the next.\n    for tx, ty in targets:\n        p = get_path(curr_x, curr_y, tx, ty)\n        if p:\n            full_path.extend(p)\n            curr_x, curr_y = tx, ty\n        elif curr_x == tx and curr_y == ty:\n            continue\n            \n    print(json.dumps(full_path))\n\nsolve()\n",
    "history": [
      {
        "commit_message": "Initial version of a robust area sweep tool using BFS for navigation between floor tiles.",
        "timestamp": "2025-12-27T05:49:48.091Z",
        "action_counter": 24932
      },
      {
        "commit_message": "Fixing typo 'intelligence' to 'in' and improving logic.",
        "timestamp": "2025-12-27T14:27:39.597Z",
        "action_counter": 26009
      },
      {
        "commit_message": "Fixing 'is_walkable' logic to include more tile types and cleaning up start position detection.",
        "timestamp": "2025-12-27T14:28:45.750Z",
        "action_counter": 26011
      },
      {
        "commit_message": "Adding more walkable tile types (CUT_TREE, etc.) and improving error handling.",
        "timestamp": "2025-12-27T14:30:38.821Z",
        "action_counter": 26014
      }
    ]
  },
  "get_exploration_targets": {
    "description": "Analyzes the current map XML and identifies unseen tiles that are adjacent to known walkable tiles, helping prioritize exploration.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ndef run():\n    root = ET.fromstring(map_xml_string)\n    walkable_types = ['FLOOR', 'GRASS', 'TALL_GRASS', 'LONG_GRASS', 'FLOOR_UP_WALL', 'WARP_CARPET_DOWN', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'WARP_CARPET_UP', 'DOOR', 'CAVE']\n    \n    walkable_tiles = set()\n    unseen_tiles = []\n    \n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            t_type = tile.get('type')\n            seen = tile.get('seen') == 'true'\n            \n            if seen and t_type in walkable_types:\n                walkable_tiles.add((x, y))\n            elif not seen:\n                unseen_tiles.append({'x': x, 'y': y})\n                \n    exploration_targets = []\n    for target in unseen_tiles:\n        tx, ty = target['x'], target['y']\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            if (tx + dx, ty + dy) in walkable_tiles:\n                exploration_targets.append(target)\n                break\n    \n    print(json.dumps(exploration_targets))\n\nrun()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-27T12:45:15.743Z",
        "action_counter": 25794
      }
    ]
  },
  "find_path_v5": {
    "description": "Calculates a path between two coordinates on the current map using BFS, accounting for walls, objects, and avoiding unintentional warps. Returns a JSON array of button strings. Handles landing from water and cutting trees. Uses global map_xml_string and input_data.",
    "input_schema": {
      "type": "object",
      "properties": {
        "can_cut": {
          "default": false,
          "type": "boolean"
        },
        "can_surf": {
          "default": false,
          "type": "boolean"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "nullable": true,
          "type": "integer"
        },
        "start_y": {
          "nullable": true,
          "type": "integer"
        }
      },
      "required": [
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    try:\n        # map_xml_string and input_data are global\n        start_x = input_data.get('start_x')\n        start_y = input_data.get('start_y')\n        end_x = int(input_data.get('end_x'))\n        end_y = int(input_data.get('end_y'))\n        can_surf = input_data.get('can_surf', False)\n        can_cut = input_data.get('can_cut', False)\n        \n        if not map_xml_string:\n            print(json.dumps({\"error\": \"Map XML is empty\"}))\n            return\n\n        root = ET.fromstring(map_xml_string)\n        width = int(root.attrib['width'])\n        height = int(root.attrib['height'])\n        \n        if start_x is None or start_y is None:\n            player = root.find(\".//Player/..\")\n            if player is not None:\n                start_x = int(player.attrib['id'])\n                start_y = int(player.find(\"..\").attrib['id'])\n            else:\n                print(json.dumps({\"error\": \"Start position not found\"}))\n                return\n\n        grid = {}\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                t_type = tile.attrib['type']\n                is_warp = tile.attrib.get('is-warp') == 'true'\n                has_obj = tile.attrib.get('has-object') == 'true'\n                \n                passable = True\n                if t_type in ['WALL', 'unseen', 'HEADBUTT_TREE']:\n                    passable = False\n                elif t_type == 'WATER' and not can_surf:\n                    passable = False\n                elif t_type == 'CUT_TREE' and not can_cut:\n                    passable = False\n                elif has_obj:\n                    passable = False\n                \n                # Treat warps as walls unless they are the destination\n                if is_warp and (x != end_x or y != end_y):\n                    passable = False\n                \n                # Destination is always passable\n                if x == end_x and y == end_y:\n                    passable = True\n                \n                grid[(x, y)] = passable\n\n        queue = deque([(start_x, start_y, [])])\n        visited = {(start_x, start_y)}\n        \n        while queue:\n            curr_x, curr_y, path = queue.popleft()\n            if curr_x == end_x and curr_y == end_y:\n                print(json.dumps(path))\n                return\n                \n            for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n                nx, ny = curr_x + dx, curr_y + dy\n                if 0 <= nx < width and 0 <= ny < height and grid.get((nx, ny)) and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [btn]))\n        \n        print(json.dumps({\"error\": \"Path not found\"}))\n    except Exception as e:\n        print(json.dumps({\"error\": str(e)}))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-27T18:00:32.003Z",
        "action_counter": 26449
      }
    ]
  }
}