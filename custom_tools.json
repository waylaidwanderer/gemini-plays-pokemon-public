{
  "automated_explorer": {
    "description": "Finds the nearest reachable unseen tile and generates a path to an adjacent traversable tile. Now correctly handles water traversal by checking for SURF capability and planning paths across water even when not currently surfing. Accepts a 'can_surf' parameter.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "can_surf": {
          "type": "string",
          "enum": [
            "true",
            "false"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "can_surf"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\nimport json\n\ndef find_all_reachable_and_paths(start, grid, width, height, can_surf):\n    queue = collections.deque([(start, grid.get(start, {}).get('type') == 'water')])\n    came_from = {start: None}\n    \n    while queue:\n        (current, is_surfing_state) = queue.popleft()\n        \n        for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = current[0] + move_x, current[1] + move_y\n            next_pos = (next_x, next_y)\n            \n            if not (1 <= next_x <= width and 1 <= next_y <= height):\n                continue\n            \n            if next_pos in came_from:\n                continue\n                \n            current_tile_info = grid.get(current, {})\n            next_tile_info = grid.get(next_pos, {})\n            next_tile_type = next_tile_info.get('type')\n            \n            if move_y == 1 and current_tile_info.get('type') != 'ledge' and next_tile_type == 'ledge':\n                ledge_jump_pos = (next_x, next_y + 1)\n                if ledge_jump_pos in came_from: continue\n                if grid.get(ledge_jump_pos, {}).get('type') not in ['impassable', 'unknown']:\n                    came_from[next_pos] = current\n                    came_from[ledge_jump_pos] = next_pos\n                    queue.append((ledge_jump_pos, is_surfing_state))\n                continue\n\n            impassable_types = ['impassable', 'unknown', 'closed_gate']\n            if next_tile_type == 'ledge':\n                 if current_tile_info.get('type') != 'water' and move_y != 1:\n                    continue\n            \n            if next_tile_type in impassable_types:\n                continue\n\n            if next_tile_type == 'water' and not (is_surfing_state or can_surf):\n                continue\n            \n            if next_tile_info.get('has_object') and next_tile_info.get('object_name') != 'Pikachu':\n                continue\n\n            current_elevation = 'elevated' if current_tile_info.get('type') == 'elevated_ground' else 'ground'\n            next_elevation = 'elevated' if next_tile_type == 'elevated_ground' else 'ground'\n            if current_elevation != next_elevation and current_tile_info.get('type') not in ['steps', 'ladder_up', 'ladder_down'] and next_tile_type not in ['steps', 'ladder_up', 'ladder_down']:\n                continue\n            \n            came_from[next_pos] = current\n            queue.append((next_pos, next_tile_type == 'water'))\n            \n    return came_from\n\ndef reconstruct_path(came_from, end):\n    if end not in came_from:\n        return None\n    path = []\n    current = end\n    while current is not None:\n        path.append(list(current))\n        current = came_from.get(current)\n    return path[::-1]\n\ndef main():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        start_node = (start_x, start_y)\n        can_surf = input_data['can_surf'] == 'true'\n\n        grid = {}\n        unseen_tiles = []\n\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                grid[(x, y)] = {\n                    'type': tile_elem.get('type'),\n                    'has_object': tile_elem.get('has-object') == 'true',\n                    'object_name': tile_elem.find('Object').get('id-name') if tile_elem.find('Object') is not None else None\n                }\n                if tile_elem.get('seen') == 'false':\n                    unseen_tiles.append((x, y))\n\n        if not unseen_tiles:\n            print(json.dumps({'status': 'success', 'message': 'No unseen tiles found.'}))\n            return\n\n        came_from = find_all_reachable_and_paths(start_node, grid, width, height, can_surf)\n        reachable_nodes = set(came_from.keys())\n        \n        targetable_unseen_tiles = [tile for tile in unseen_tiles if any((tile[0] + dx, tile[1] + dy) in reachable_nodes for dx, dy in [(0,1),(0,-1),(1,0),(-1,0)])]\n\n        if not targetable_unseen_tiles:\n            print(json.dumps({'status': 'error', 'message': 'No unseen tiles are adjacent to reachable areas.', 'reachable_nodes_count': len(reachable_nodes)}))\n            return\n\n        shortest_path = None\n        target_unseen = None\n        \n        sorted_targets = sorted(targetable_unseen_tiles, key=lambda t: (abs(t[0] - start_x) + abs(t[1] - start_y)))\n\n        for tile in sorted_targets:\n            best_adj_path = None\n            for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adj_x, adj_y = tile[0] + move_x, tile[1] + move_y\n                adj_pos = (adj_x, adj_y)\n                if adj_pos in reachable_nodes:\n                    path = reconstruct_path(came_from, adj_pos)\n                    if path and (best_adj_path is None or len(path) < len(best_adj_path)):\n                        best_adj_path = path\n            \n            if best_adj_path:\n                shortest_path = best_adj_path\n                target_unseen = tile\n                break\n        \n        if shortest_path:\n            print(json.dumps({'status': 'success', 'path': shortest_path, 'target_unseen_tile': target_unseen}))\n        else:\n            print(json.dumps({'status': 'error', 'message': 'Could not find a path to any adjacent tile of any reachable unseen tiles.'}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'status': 'error', 'message': f'An exception occurred: {traceback.format_exc()}'}))\n\nmain()"
  },
  "check_wkg_edge_exists": {
    "description": "Checks if a bidirectional edge exists between two nodes in the World Knowledge Graph, identified by their map IDs and coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "source_map_id": {
          "type": "string"
        },
        "source_x": {
          "type": "string"
        },
        "source_y": {
          "type": "string"
        },
        "dest_map_id": {
          "type": "string"
        },
        "dest_x": {
          "type": "string"
        },
        "dest_y": {
          "type": "string"
        }
      },
      "required": [
        "source_map_id",
        "source_x",
        "source_y",
        "dest_map_id",
        "dest_x",
        "dest_y"
      ]
    },
    "python_script": "import json\n\nwkg = json.loads(world_knowledge_graph_json_string)\nnodes = wkg['nodes']\nedges = wkg['edges']\n\nsource_map_id = input_data['source_map_id']\nsource_x = int(input_data['source_x'])\nsource_y = int(input_data['source_y'])\ndest_map_id = input_data['dest_map_id']\ndest_x = int(input_data['dest_x'])\ndest_y = int(input_data['dest_y'])\n\nsource_node_id = None\ndest_node_id = None\n\nfor node in nodes:\n    if str(node['map_id']) == source_map_id and node['coordinates']['x'] == source_x and node['coordinates']['y'] == source_y:\n        source_node_id = node['id']\n    if str(node['map_id']) == dest_map_id and node['coordinates']['x'] == dest_x and node['coordinates']['y'] == dest_y:\n        dest_node_id = node['id']\n\nif not source_node_id or not dest_node_id:\n    print(json.dumps({'exists': False, 'reason': 'One or both nodes not found in WKG.'}))\nelse:\n    edge_found = False\n    for edge in edges:\n        if (edge['source_node_id'] == source_node_id and edge['destination_node_id'] == dest_node_id) or \\\n           (edge['source_node_id'] == dest_node_id and edge['destination_node_id'] == source_node_id):\n            edge_found = True\n            break\n    print(json.dumps({'exists': edge_found}))"
  },
  "find_wkg_node_by_coords": {
    "description": "Finds a World Knowledge Graph node ID by map ID and coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "map_id": {
          "type": "string"
        },
        "x": {
          "type": "string"
        },
        "y": {
          "type": "string"
        }
      },
      "required": [
        "map_id",
        "x",
        "y"
      ]
    },
    "python_script": "import json\n\ndef find_node():\n    try:\n        wkg = json.loads(world_knowledge_graph_json_string)\n        target_map_id = input_data['map_id']\n        target_x = int(input_data['x'])\n        target_y = int(input_data['y'])\n\n        for node in wkg['nodes']:\n            if str(node['map_id']) == str(target_map_id) and node['coordinates']['x'] == target_x and node['coordinates']['y'] == target_y:\n                print(json.dumps({'status': 'success', 'node_id': node['id']}))\n                return\n        \n        print(json.dumps({'status': 'error', 'message': f'Node not found on map {target_map_id} at ({target_x}, {target_y}).'}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'status': 'error', 'message': f'An exception occurred: {traceback.format_exc()}'}))\n\nfind_node()"
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map. It now correctly handles dynamic transitions between walking and surfing by checking for the passed `can_surf` capability, and properly navigates ledges and other terrain.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "is_surfing": {
          "type": "string",
          "enum": [
            "true",
            "false"
          ]
        },
        "can_surf": {
          "type": "string",
          "enum": [
            "true",
            "false"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "is_surfing",
        "can_surf"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\nimport json\n\ndef find_path_v4():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        start = (int(input_data['start_x']), int(input_data['start_y']))\n        end = (int(input_data['end_x']), int(input_data['end_y']))\n        initial_is_surfing = input_data['is_surfing'] == 'true'\n        can_surf_in_field = input_data['can_surf'] == 'true'\n\n        grid = {}\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                grid[(x, y)] = {'type': tile_elem.get('type'), 'has_object': tile_elem.get('has-object') == 'true', 'object_name': tile_elem.find('Object').get('id-name') if tile_elem.find('Object') is not None else None}\n\n        queue = collections.deque([(start, initial_is_surfing)])\n        came_from = {(start, initial_is_surfing): None}\n        visited = {(start, initial_is_surfing)}\n        path_found = False\n        final_state = None\n\n        while queue:\n            current_pos, current_is_surfing = queue.popleft()\n\n            if current_pos == end:\n                path_found = True\n                final_state = (current_pos, current_is_surfing)\n                break\n\n            for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                next_pos = (current_pos[0] + move_x, current_pos[1] + move_y)\n\n                if not (1 <= next_pos[0] <= width and 1 <= next_pos[1] <= height):\n                    continue\n\n                next_tile_info = grid.get(next_pos, {})\n                next_tile_type = next_tile_info.get('type')\n                next_is_surfing = current_is_surfing\n\n                if next_tile_type in ['impassable', 'unknown', 'closed_gate']:\n                    continue\n                \n                if next_tile_info.get('has_object') and next_tile_info.get('object_name') != 'Pikachu':\n                    if next_pos != end:\n                        continue\n\n                if next_tile_type == 'water':\n                    if not current_is_surfing:\n                        if not can_surf_in_field:\n                            continue\n                        next_is_surfing = True\n                elif current_is_surfing:\n                    if next_tile_type != 'water':\n                        next_is_surfing = False\n\n                next_state = (next_pos, next_is_surfing)\n                if next_state in visited:\n                    continue\n\n                if next_tile_type == 'ledge':\n                    if current_is_surfing: continue\n                    if move_y == 1:\n                        ledge_jump_pos = (next_pos[0], next_pos[1] + 1)\n                        ledge_jump_state = (ledge_jump_pos, False)\n                        if ledge_jump_state in visited: continue\n                        if grid.get(ledge_jump_pos, {}).get('type') not in ['impassable', 'unknown', 'closed_gate']:\n                            visited.add((next_pos, False))\n                            visited.add(ledge_jump_state)\n                            came_from[(next_pos, False)] = (current_pos, current_is_surfing)\n                            came_from[ledge_jump_state] = (next_pos, False)\n                            queue.append(ledge_jump_state)\n                        continue\n                    else:\n                        continue\n\n                visited.add(next_state)\n                came_from[next_state] = (current_pos, current_is_surfing)\n                queue.append(next_state)\n        \n        if path_found:\n            path = []\n            current = final_state\n            while current is not None:\n                path.append(list(current[0]))\n                current = came_from.get(current)\n            print(json.dumps({\"status\": \"success\", \"path\": path[::-1]}))\n        else:\n            print(json.dumps({\"status\": \"error\", \"message\": \"No path found. The destination is on an unreachable segment of the map.\"}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({\"status\": \"error\", \"message\": f'An exception occurred: {traceback.format_exc()}'}))\n\nfind_path_v4()\n"
  },
  "pathfinding_debugger_tool": {
    "description": "Analyzes pathfinding attempts on the current map. It performs a Breadth-First Search (BFS) and prints each explored node. If no path is found, it prints the 'came_from' dictionary to show the extent of the explored area, helping to identify map segmentation or unexpected barriers.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "can_surf": {
          "type": "string",
          "enum": [
            "true",
            "false"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "can_surf"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef pathfinding_debugger_tool_script(start_x, start_y, end_x, end_y, can_surf_str):\n    start_x, start_y, end_x, end_y = int(start_x), int(start_y), int(end_x), int(end_y)\n    can_surf = can_surf_str.lower() == 'true'\n\n    try:\n        root = ET.fromstring(map_xml_string)\n    except ET.ParseError as e:\n        print(f\"XML Parse Error: {e}\")\n        return\n    \n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = [['' for _ in range(width + 1)] for _ in range(height + 1)]\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id'])\n            grid[y][x] = tile_elem\n\n    traversable_walk = ['ground', 'grass', 'cleared_boulder_barrier', 'open_gate', 'steps', 'ladder_up', 'ladder_down', 'teleport', 'hole']\n    traversable_surf = ['water']\n    \n    def is_valid(x, y):\n        return 1 <= x <= width and 1 <= y <= height\n\n    def is_traversable(x, y, is_surfing_now):\n        if not is_valid(x, y):\n            return False\n        tile = grid[y][x]\n        if tile is None or tile == '':\n            return False\n        \n        tile_type = tile.attrib.get('type', 'unknown')\n        \n        if tile.find('Object') is not None:\n            obj = tile.find('Object')\n            if obj.attrib.get('id-name') != 'PIKACHU':\n                return False\n\n        if tile_type in traversable_surf:\n            return can_surf\n        if tile_type in traversable_walk:\n            return True\n            \n        return False\n\n    def get_neighbors(x, y):\n        neighbors = []\n        is_surfing_now = grid[y][x].attrib.get('type') in traversable_surf\n        \n        for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n            nx, ny = x + dx, y + dy\n            if not is_valid(nx, ny):\n                continue\n            \n            neighbor_tile = grid[ny][nx]\n            if neighbor_tile is None or neighbor_tile == '':\n                continue\n            \n            neighbor_type = neighbor_tile.attrib.get('type', 'unknown')\n\n            if neighbor_type == 'ledge':\n                if dy == 1:\n                    if is_valid(nx, ny + 1) and is_traversable(nx, ny + 1, is_surfing_now):\n                         neighbors.append((nx, ny + 1, move))\n                continue\n\n            if is_traversable(nx, ny, is_surfing_now):\n                neighbors.append((nx, ny, move))\n\n        return neighbors\n\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n    \n    queue = deque([(start_node, [])])\n    visited = {start_node}\n    came_from = {start_node: None}\n\n    print(\"Starting pathfinding debug...\")\n    \n    path_found = False\n    while queue:\n        (current_x, current_y), path = queue.popleft()\n        \n        print(f\"Exploring: ({current_x}, {current_y})\")\n\n        if (current_x, current_y) == end_node:\n            print(\"Path found!\")\n            print(json.dumps([move for _, _, move in path]))\n            path_found = True\n            break\n            \n        for nx, ny, move in get_neighbors(current_x, current_y):\n            if (nx, ny) not in visited:\n                visited.add((nx, ny))\n                new_path = path + [( (current_x, current_y), (nx, ny), move )]\n                queue.append(((nx, ny), new_path))\n                came_from[(nx, ny)] = (current_x, current_y)\n\n    if not path_found:\n        print(\"No path found.\")\n        print(\"Explored area (came_from dictionary):\")\n        printable_came_from = {str(k): str(v) for k, v in came_from.items()}\n        print(json.dumps(printable_came_from, indent=2))\n\npathfinding_debugger_tool_script(input_data['start_x'], input_data['start_y'], input_data['end_x'], input_data['end_y'], input_data['can_surf'])"
  }
}