{
  "find_path": {
    "description": "Calculates a path from the player's current position to the target coordinates using BFS. Avoids walls and objects. Returns a JSON list of coordinate objects.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string",
          "description": "Target X coordinate"
        },
        "target_y": {
          "type": "string",
          "description": "Target Y coordinate"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "# injected imports [\"sys\", \"json\"]\n# injected variables [\"map_xml_string\", \"input_data\"]\n\nimport xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef bfs_path(xml_data, target_x, target_y):\n    root = ET.fromstring(xml_data)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n\n    grid = {}\n    objects = set()\n    player_pos = None\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tile_type = tile.attrib['type']\n            grid[(x,y)] = tile_type\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n            if tile.attrib.get('has-object') == 'true':\n                 objects.add((x,y))\n                 \n    if player_pos is None:\n        print(json.dumps({\"error\": \"Player not found\"}))\n        return\n\n    start_x, start_y = player_pos\n    walkable_types = {'FLOOR', 'GROUND', 'GRASS', 'SAND', 'CARPET', 'WARP_CARPET_DOWN', 'WARP_CARPET_UP', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'DOOR', 'STAIRS', 'STAIRCASE', 'TALL_GRASS', 'LONG_GRASS'}\n    \n    queue = deque([(start_x, start_y, [])])\n    visited = set([(start_x, start_y)])\n    found_path = None\n    \n    while queue:\n        cx, cy, path = queue.popleft()\n        if cx == target_x and cy == target_y:\n            found_path = path\n            break\n        \n        for nx, ny in [(cx, cy-1), (cx, cy+1), (cx-1, cy), (cx+1, cy)]:\n            if 0 <= nx < width and 0 <= ny < height:\n                if (nx, ny) in visited: continue\n                tile_type = grid.get((nx, ny), 'WALL')\n                is_walkable = tile_type in walkable_types\n                if (nx, ny) in objects and (nx, ny) != (target_x, target_y):\n                    is_walkable = False\n                if is_walkable:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [{'x': nx, 'y': ny}]))\n                    \n    if found_path is not None:\n        print(json.dumps([{'x': start_x, 'y': start_y}] + found_path))\n    else:\n        print(json.dumps({\"error\": \"No path found\"}))\n\ntry:\n    bfs_path(map_xml_string, int(input_data['target_x']), int(input_data['target_y']))\nexcept Exception as e:\n    print(json.dumps({\"error\": str(e)}))",
    "history": [
      {
        "commit_message": "feat: Add find_path tool using BFS for basic map navigation.",
        "timestamp": "2025-11-19T20:22:30.353Z",
        "action_counter": 92
      },
      {
        "commit_message": "feat: Add TALL_GRASS and LONG_GRASS to traversable tiles in find_path to support route navigation.",
        "timestamp": "2025-11-19T21:30:20.018Z",
        "action_counter": 196
      }
    ]
  },
  "interact_direction": {
    "description": "Turns the player to face a specified direction and then presses 'A' to interact. Useful for checking objects or NPCs without moving onto their tile.",
    "input_schema": {
      "type": "object",
      "properties": {
        "direction": {
          "type": "string",
          "enum": [
            "Up",
            "Down",
            "Left",
            "Right"
          ],
          "description": "The direction to face and interact with."
        }
      },
      "required": [
        "direction"
      ]
    },
    "python_script": "import json\ndirection = input_data['direction']\n# Output the sequence: Face direction, wait, press A\nprint(json.dumps([direction, \"sleep 500\", \"A\"]))",
    "history": [
      {
        "commit_message": "feat: Add interact_direction tool to combine facing and interacting in one turn.",
        "timestamp": "2025-11-19T20:50:03.515Z",
        "action_counter": 135
      }
    ]
  },
  "press_sequence": {
    "description": "Presses a sequence of buttons with delays. Useful for navigating menus or skipping text.",
    "input_schema": {
      "type": "object",
      "properties": {
        "sequence": {
          "type": "string",
          "description": "Comma-separated list of buttons to press (e.g., 'Down, Down, A')"
        }
      },
      "required": [
        "sequence"
      ]
    },
    "python_script": "import json\ninput_str = input_data['sequence']\nbuttons = [b.strip() for b in input_str.split(',')]\noutput = []\nfor b in buttons:\n    output.append(b)\n    output.append(\"sleep 500\")\nif output:\n    output.pop()\nprint(json.dumps(output))",
    "history": [
      {
        "commit_message": "feat: Add press_sequence tool for automated multi-step button input, enabling faster menu navigation.",
        "timestamp": "2025-11-21T17:48:29.526Z",
        "action_counter": 409
      }
    ]
  }
}