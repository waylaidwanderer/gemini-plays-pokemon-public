{
  "encounter_grinder_tool": {
    "description": "Automates pacing back and forth between two points to grind for wild encounters. Assumes a clear, straight path.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "repetitions": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "repetitions"
      ]
    },
    "python_script": "import json\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\nrepetitions = int(input_data['repetitions'])\n\npath = []\n# Determine direction\nif start_x != end_x:\n    # Horizontal movement\n    move_forward = 'Right' if end_x > start_x else 'Left'\n    move_backward = 'Left' if end_x > start_x else 'Right'\n    distance = abs(end_x - start_x)\nelse:\n    # Vertical movement\n    move_forward = 'Down' if end_y > start_y else 'Up'\n    move_backward = 'Up' if end_y > start_y else 'Down'\n    distance = abs(end_y - start_y)\n\nfor _ in range(repetitions):\n    for _ in range(distance):\n        path.append(move_forward)\n    for _ in range(distance):\n        path.append(move_backward)\n\nprint(json.dumps({'path': path}))"
  },
  "object_finder": {
    "description": "Finds the coordinates of a named NPC or item on the current map by searching its `id-name` or `name` attribute.",
    "input_schema": {
      "type": "object",
      "properties": {
        "object_name": {
          "type": "string"
        }
      },
      "required": [
        "object_name"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\n\ntry:\n    object_name_to_find = input_data['object_name']\n    root = ET.fromstring(map_xml_string)\n    \n    found_objects = []\n\n    for r in root.findall('Row'):\n        for t in r.findall('Tile'):\n            for obj in t.findall('Object'):\n                id_name = obj.get('id-name', '')\n                event_name = obj.get('name', '')\n                \n                if object_name_to_find.lower() in id_name.lower() or object_name_to_find.lower() in event_name.lower():\n                    found_objects.append({\n                        'id-name': id_name,\n                        'name': event_name,\n                        'x': int(t.get('id')),\n                        'y': int(r.get('id'))\n                    })\n\n    if found_objects:\n        print(json.dumps({'found': True, 'objects': found_objects}))\n    else:\n        print(json.dumps({'found': False, 'message': f\"Object '{object_name_to_find}' not found on the current map.\"}))\n\nexcept Exception as e:\n    print(json.dumps({'found': False, 'error': str(e)}))"
  },
  "pathfinder": {
    "description": "Calculates the shortest path on the current map using BFS. Can optionally ignore certain impassable tile types. If the destination is impassable, it will find a path to the nearest valid adjacent tile.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "ignorable_impassable_types": {
          "type": "string",
          "description": "A comma-separated string of tile types to ignore as impassable (e.g., 'closed_gate,water')."
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    ignorable_types_str = input_data.get('ignorable_impassable_types', '')\n    ignorable_types = [t.strip() for t in ignorable_types_str.split(',') if t.strip()] if ignorable_types_str else []\n\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n\n    grid = {}\n    for r in root.findall('Row'):\n        y = int(r.get('id'))\n        for t in r.findall('Tile'):\n            x = int(t.get('id'))\n            has_impassable_object = False\n            obj_node = t.find('Object')\n            if obj_node is not None and obj_node.get('id-name') != 'Pikachu':\n                has_impassable_object = True\n            grid[(x, y)] = {\n                'type': t.get('type'),\n                'has_object': has_impassable_object\n            }\n\n    impassable_set = {'impassable', 'unknown', 'water', 'closed_gate', 'impassable_fence', 'cuttable'}\n    for t in ignorable_types:\n        if t in impassable_set:\n            impassable_set.remove(t)\n\n    def is_tile_impassable(x, y):\n        tile_data = grid.get((x, y))\n        if not tile_data:\n            return True\n        return tile_data['has_object'] or tile_data['type'] in impassable_set\n\n    if is_tile_impassable(end_x, end_y):\n        found_new_target = False\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = end_x + dx, end_y + dy\n            if not is_tile_impassable(nx, ny):\n                end_x, end_y = nx, ny\n                found_new_target = True\n                break\n        if not found_new_target:\n            print(json.dumps({'path_found': False, 'error': 'No traversable tile adjacent to destination.'}))\n            exit()\n\n    queue = deque([([ (start_x, start_y) ])])\n    visited = {(start_x, start_y)}\n\n    while queue:\n        path = queue.popleft()\n        cx, cy = path[-1]\n\n        if (cx, cy) == (end_x, end_y):\n            json_path = [{'x': p[0], 'y': p[1]} for p in path]\n            print(json.dumps({'path_found': True, 'path': json_path}))\n            exit()\n\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = cx + dx, cy + dy\n\n            if not (1 <= nx <= width and 1 <= ny <= height) or (nx, ny) in visited:\n                continue\n\n            if is_tile_impassable(nx, ny):\n                continue\n            \n            current_tile_data = grid.get((cx, cy))\n            if current_tile_data['type'] == 'ledge' and (dy != 1 or dx != 0):\n                continue\n            \n            if grid.get((nx,ny))['type'] == 'ledge' and dy == -1:\n                continue\n\n            visited.add((nx, ny))\n            new_path = path + [(nx, ny)]\n            queue.append(new_path)\n\n    print(json.dumps({'path_found': False, 'path': []}))\n\nexcept Exception as e:\n    print(json.dumps({'path_found': False, 'error': str(e)}))\n"
  },
  "wkg_checker": {
    "description": "Checks the World Knowledge Graph to see if a node or edge already exists based on its key properties, preventing duplicates. Now includes a name-to-ID lookup for robustness.",
    "input_schema": {
      "type": "object",
      "properties": {
        "element_type": {
          "type": "string",
          "enum": [
            "node",
            "edge"
          ]
        },
        "map_name": {
          "type": "string"
        },
        "x": {
          "type": "string"
        },
        "y": {
          "type": "string"
        },
        "to_map_name": {
          "type": "string"
        },
        "to_x": {
          "type": "string"
        },
        "to_y": {
          "type": "string"
        }
      },
      "required": [
        "element_type",
        "map_name",
        "x",
        "y"
      ]
    },
    "python_script": "import json\n\nMAP_NAME_TO_ID = {\n    \"PALLET_TOWN\": \"0\", \"VIRIDIAN_CITY\": \"1\", \"PEWTER_CITY\": \"2\", \"CERULEAN_CITY\": \"3\", \"LAVENDER_TOWN\": \"4\",\n    \"VERMILION_CITY\": \"5\", \"CELADON_CITY\": \"6\", \"FUCHSIA_CITY\": \"7\", \"CINNABAR_ISLAND\": \"8\", \"INDIGO_PLATEAU\": \"9\",\n    \"SAFFRON_CITY\": \"10\", \"ROUTE_1\": \"12\", \"ROUTE_2\": \"13\", \"ROUTE_3\": \"14\", \"ROUTE_4\": \"15\",\n    \"ROUTE_5\": \"16\", \"ROUTE_6\": \"17\", \"ROUTE_7\": \"18\", \"ROUTE_8\": \"19\", \"ROUTE_9\": \"20\",\n    \"ROUTE_10\": \"21\", \"ROUTE_11\": \"22\", \"ROUTE_12\": \"23\", \"ROUTE_13\": \"24\", \"ROUTE_14\": \"25\",\n    \"ROUTE_15\": \"26\", \"ROUTE_16\": \"27\", \"ROUTE_17\": \"28\", \"ROUTE_18\": \"29\", \"ROUTE_19\": \"30\",\n    \"ROUTE_20\": \"31\", \"ROUTE_21\": \"32\", \"ROUTE_22\": \"33\", \"ROUTE_23\": \"34\", \"ROUTE_24\": \"35\",\n    \"ROUTE_25\": \"36\",\n    \"PLAYERS_HOUSE_1F\": \"37\", \"PLAYERS_HOUSE_2F\": \"38\", \"RIVALS_HOUSE\": \"39\", \"OAKS_LAB\": \"40\",\n    \"VIRIDIAN_POKECENTER\": \"41\", \"VIRIDIAN_MART\": \"42\", \"SCHOOL\": \"43\", \"NICKNAME_HOUSE\": \"44\",\n    \"VIRIDIAN_GYM\": \"45\", \"DIGLETTS_CAVE_ROUTE_2_ENTRANCE_HOUSE\": \"46\", \"VIRIDIAN_FOREST_NORTH_GATE\": \"47\",\n    \"ROUTE_2_TRADE_HOUSE\": \"48\", \"ROUTE_2_GATE\": \"49\", \"VIRIDIAN_FOREST_SOUTH_GATE\": \"50\",\n    \"VIRIDIAN_FOREST\": \"51\", \"PEWTER_MUSEUM_1F\": \"52\", \"PEWTER_MUSEUM_2F\": \"53\", \"PEWTER_GYM\": \"54\",\n    \"PEWTER_NIDORAN_HOUSE\": \"55\", \"PEWTER_MART\": \"56\", \"PEWTER_SPEECH_HOUSE\": \"57\", \"PEWTER_POKECENTER\": \"58\",\n    \"MT_MOON_1F\": \"59\", \"MT_MOON_B1F\": \"60\", \"MT_MOON_B2F\": \"61\", \"TRASHED_HOUSE\": \"62\",\n    \"MELANIE_HOUSE\": \"63\", \"CERULEAN_POKECENTER\": \"64\", \"CERULEAN_GYM\": \"65\", \"BIKE_SHOP\": \"66\",\n    \"CERULEAN_MART\": \"67\", \"MT_MOON_POKECENTER\": \"68\", \"CERULEAN_CAVE_2F\": \"69\",\n    \"ROUTE_5_GATE\": \"70\", \"UNDERGROUND_PATH_NORTH_ENTRANCE\": \"71\", \"DAYCARE\": \"72\",\n    \"ROUTE_6_GATE\": \"73\", \"UNDERGROUND_PATH_SOUTH_ENTRANCE\": \"74\", \"ROUTE_7_GATE\": \"76\",\n    \"UNDERGROUND_PATH_ROUTE_7_ENTRANCE\": \"77\", \"ROUTE_8_GATE\": \"79\", \"UNDERGROUND_PATH_ROUTE_8_ENTRANCE\": \"80\",\n    \"ROCK_TUNNEL_POKECENTER\": \"81\", \"ROCK_TUNNEL_1F\": \"82\", \"ROCK_TUNNEL_B1F\": \"232\",\n    \"ROUTE_11_GATE_1F\": \"84\", \"DIGLETTS_CAVE_ROUTE_11_ENTRANCE_HOUSE\": \"85\", \"ROUTE_11_GATE_2F\": \"86\",\n    \"ROUTE_12_GATE_1F\": \"87\", \"BILLS_HOUSE\": \"88\", \"VERMILION_POKECENTER\": \"89\",\n    \"POKEMON_FAN_CLUB\": \"90\", \"VERMILION_MART\": \"91\", \"VERMILION_GYM\": \"92\", \"PIDGEY_HOUSE\": \"93\",\n    \"VERMILION_DOCK\": \"94\", \"SS_ANNE_1F\": \"95\", \"SS_ANNE_2F\": \"96\", \"SS_ANNE_3F\": \"97\",\n    \"SS_ANNE_B1F\": \"98\", \"SS_ANNE_BOW\": \"99\", \"SS_ANNE_KITCHEN\": \"100\", \"SS_ANNE_CAPTAINS_ROOM\": \"101\",\n    \"SS_ANNE_1F_ROOMS\": \"102\", \"SS_ANNE_2F_ROOMS\": \"103\", \"SS_ANNE_B1F_ROOMS\": \"104\",\n    \"SS_ANNE_HALLWAY\": \"105\", \"VICTORY_ROAD_GATE\": \"106\", \"VICTORY_ROAD_1F\": \"107\",\n    \"VICTORY_ROAD_2F\": \"108\", \"VICTORY_ROAD_3F\": \"109\", \"LANCES_ROOM\": \"110\", \"POKEMON_LEAGUE\": \"111\",\n    \"HALL_OF_FAME\": \"112\", \"UNDERGROUND_PATH_NS\": \"119\", \"CHAMPIONS_ROOM\": \"120\",\n    \"UNDERGROUND_PATH_WE\": \"121\", \"CELADON_DEPT_STORE_1F\": \"122\", \"CELADON_DEPT_STORE_2F\": \"123\",\n    \"CELADON_DEPT_STORE_3F\": \"124\", \"CELADON_DEPT_STORE_4F\": \"125\", \"CELADON_DEPT_STORE_ROOF\": \"126\",\n    \"CELADON_DEPT_STORE_ELEVATOR\": \"127\", \"CELADON_MANSION_1F\": \"128\", \"CELADON_MANSION_2F\": \"129\",\n    \"CELADON_MANSION_3F\": \"130\", \"CELADON_MANSION_ROOF\": \"131\", \"CELADON_MANSION_ROOF_HOUSE\": \"132\",\n    \"CELADON_POKECENTER\": \"133\", \"CELADON_GYM\": \"134\", \"GAME_CORNER\": \"135\",\n    \"CELADON_DEPT_STORE_5F\": \"136\", \"GAME_CORNER_PRIZE_ROOM\": \"137\", \"CELADON_DINER\": \"138\",\n    \"CELADON_CHIEF_HOUSE\": \"139\", \"CELADON_HOTEL\": \"140\", \"LAVENDER_POKECENTER\": \"141\",\n    \"POKEMON_TOWER_1F\": \"142\", \"POKEMON_TOWER_2F\": \"143\", \"POKEMON_TOWER_3F\": \"144\",\n    \"POKEMON_TOWER_4F\": \"145\", \"POKEMON_TOWER_5F\": \"146\", \"POKEMON_TOWER_6F\": \"147\",\n    \"POKEMON_TOWER_7F\": \"148\", \"MR_FUJIS_HOUSE\": \"149\", \"LAVENDER_MART\": \"150\",\n    \"FUCHSIA_MART\": \"151\", \"FUCHSIA_POKECENTER\": \"152\", \"SAFARI_ZONE_ENTRANCE\": \"153\",\n    \"FUCHSIA_GYM\": \"154\", \"FUCHSIA_MEETING_ROOM\": \"155\", \"SEAFOAM_ISLANDS_1F\": \"156\",\n    \"SEAFOAM_ISLANDS_B1F\": \"157\", \"SEAFOAM_ISLANDS_B2F\": \"158\", \"SEAFOAM_ISLANDS_B3F\": \"159\",\n    \"SEAFOAM_ISLANDS_B4F\": \"160\", \"VERMILION_TRADE_HOUSE\": \"196\", \"FUCHSIA_BILLS_GRANDFATHERS_HOUSE\": \"161\",\n    \"FUCHSIA_GOOD_ROD_HOUSE\": \"162\", \"POKEMON_MANSION_1F\": \"163\", \"POKEMON_MANSION_2F\": \"164\",\n    \"POKEMON_MANSION_3F\": \"165\", \"POKEMON_MANSION_B1F\": \"166\", \"CINNABAR_GYM\": \"167\",\n    \"CINNABAR_LAB_ENTRANCE\": \"168\", \"CINNABAR_LAB_LOBBY\": \"169\", \"CINNABAR_LAB_MEETING_ROOM\": \"170\",\n    \"CINNABAR_LAB_EXPERIMENT_ROOM\": \"171\", \"CINNABAR_POKECENTER\": \"172\", \"CINNABAR_MART\": \"173\",\n    \"CINNABAR_GYM_VOLCANO\": \"174\", \"INDIGO_PLATEAU_LOBBY\": \"175\", \"POWER_PLANT\": \"176\",\n    \"ROUTE_12_GATE_2F\": \"195\", \"ROUTE_15_GATE_1F\": \"177\", \"ROUTE_15_GATE_2F\": \"178\",\n    \"ROUTE_16_GATE_2F\": \"187\", \"ROUTE_18_GATE_1F\": \"179\", \"ROUTE_18_GATE_2F\": \"198\",\n    \"SAFFRON_MART\": \"180\", \"SILPH_CO_1F\": \"181\", \"SAFFRON_POKECENTER\": \"182\",\n    \"MR_PSYCHICS_HOUSE\": \"183\", \"ROUTE_11_GATE_1F\": \"84\", \"ROUTE_11_GATE_2F\": \"86\",\n    \"ROUTE_12_GATE_1F\": \"87\", \"ROUTE_16_GATE_1F\": \"186\", \"ROUTE_16_FLY_HOUSE\": \"188\",\n    \"ROUTE_19_GATE_1F\": \"189\", \"ROUTE_19_GATE_2F\": \"190\", \"WARDENS_HOUSE\": \"191\",\n    \"SAFARI_ZONE_CENTER\": \"192\", \"SAFARI_ZONE_EAST\": \"193\", \"SAFARI_ZONE_NORTH\": \"194\",\n    \"SAFARI_ZONE_WEST\": \"195\", \"DIGLETTS_CAVE\": \"197\", \"ROCKET_HIDEOUT_B1F\": \"199\",\n    \"ROCKET_HIDEOUT_B2F\": \"200\", \"ROCKET_HIDEOUT_B3F\": \"201\", \"ROCKET_HIDEOUT_B4F\": \"202\",\n    \"ROCKET_HIDEOUT_ELEVATOR\": \"203\", \"COPYCATS_HOUSE_1F\": \"204\", \"COPYCATS_HOUSE_2F\": \"205\",\n    \"TRAINER_FAN_CLUB\": \"206\", \"SILPH_CO_2F\": \"207\", \"SILPH_CO_3F\": \"208\",\n    \"SILPH_CO_4F\": \"209\", \"SILPH_CO_5F\": \"210\", \"SILPH_CO_6F\": \"211\", \"SILPH_CO_7F\": \"212\",\n    \"SILPH_CO_8F\": \"213\", \"SILPH_CO_9F\": \"233\", \"SILPH_CO_10F\": \"234\", \"SILPH_CO_11F\": \"235\",\n    \"SILPH_CO_ELEVATOR\": \"236\", \"NAME_RATERS_HOUSE\": \"229\", \"CERULEAN_BADGE_HOUSE\": \"230\", \"ROCK_TUNNEL_B1F\": \"232\"\n}\n\ndef get_map_id(map_identifier):\n    if isinstance(map_identifier, str) and not map_identifier.isdigit():\n        return MAP_NAME_TO_ID.get(map_identifier.upper(), map_identifier)\n    return map_identifier\n\ndef find_node_id(nodes, map_id, x, y):\n    for node in nodes:\n        if str(node.get('map_id')) == str(map_id) and node.get('coordinates', {}).get('x') == x and node.get('coordinates', {}).get('y') == y:\n            return node.get('id')\n    return None\n\ntry:\n    wkg = json.loads(world_knowledge_graph_json_string)\n    nodes = wkg.get('nodes', [])\n    edges = wkg.get('edges', [])\n    \n    element_type = input_data['element_type']\n    map_name = get_map_id(input_data['map_name'])\n    x = int(input_data['x'])\n    y = int(input_data['y'])\n    \n    found = False\n\n    if element_type == 'node':\n        if find_node_id(nodes, map_name, x, y) is not None:\n            found = True\n            \n    elif element_type == 'edge':\n        to_map_name = get_map_id(input_data.get('to_map_name'))\n        to_x = int(input_data.get('to_x'))\n        to_y = int(input_data.get('to_y'))\n        \n        source_node_id = find_node_id(nodes, map_name, x, y)\n        dest_node_id = find_node_id(nodes, to_map_name, to_x, to_y)\n        \n        if source_node_id and dest_node_id:\n            for edge in edges:\n                s_id = edge.get('source_node_id')\n                d_id = edge.get('destination_node_id')\n                \n                is_direct_match = (s_id == source_node_id and d_id == dest_node_id)\n                is_reverse_match = (not edge.get('is_one_way', False) and s_id == dest_node_id and d_id == source_node_id)\n                \n                if is_direct_match or is_reverse_match:\n                    found = True\n                    break\n    \n    print(json.dumps({'exists': found}))\n\nexcept Exception as e:\n    print(json.dumps({'exists': False, 'error': str(e)}))\n"
  },
  "wkg_inspector": {
    "description": "Inspects the World Knowledge Graph to find all incoming and outgoing connections for a given map_id, returning a structured JSON object.",
    "input_schema": {
      "type": "object",
      "properties": {
        "map_id": {
          "type": "string"
        }
      },
      "required": [
        "map_id"
      ]
    },
    "python_script": "import json\nwkg = json.loads(world_knowledge_graph_json_string)\nnodes = wkg.get('nodes', [])\nedges = wkg.get('edges', [])\ntarget_map_id = input_data['map_id']\nconnections = {'incoming': [], 'outgoing': []}\ndef get_node_details(node_id):\n    for node in nodes:\n        if node.get('id') == node_id:\n            return {'name': node.get('name'), 'map_id': node.get('map_id'), 'coordinates': node.get('coordinates'), 'tags': node.get('tags', [])}\n    return None\nfor edge in edges:\n    source_node_id = edge.get('source_node_id')\n    dest_node_id = edge.get('destination_node_id')\n    source_node = get_node_details(source_node_id)\n    dest_node = get_node_details(dest_node_id)\n    if not source_node or not dest_node:\n        continue\n    connection_details = {'type': edge.get('connection_type'), 'source': source_node, 'destination': dest_node, 'is_one_way': edge.get('is_one_way', False)}\n    if source_node['map_id'] == target_map_id and dest_node['map_id'] != target_map_id:\n        connections['outgoing'].append(connection_details)\n    elif dest_node['map_id'] == target_map_id and source_node['map_id'] != target_map_id:\n        connections['incoming'].append(connection_details)\nprint(json.dumps(connections, indent=2))"
  }
}