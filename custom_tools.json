{
  "puzzle_solver": {
    "description": "Solves Sokoban-style boulder puzzles. Takes optional start coordinates, but requires goal coordinates for the final boulder position. It uses a Breadth-First Search algorithm to find the optimal sequence of moves.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer",
          "nullable": true
        },
        "start_y": {
          "type": "integer",
          "nullable": true
        },
        "goal_x": {
          "type": "integer"
        },
        "goal_y": {
          "type": "integer"
        }
      },
      "required": [
        "goal_x",
        "goal_y"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\n\n# Parse map data\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\n\nwalls = set()\nboulders = []\nplayer_start = None\n\nfor r_idx, row_elem in enumerate(root.findall('Row')):\n    y = r_idx + 1\n    for t_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n        x = t_idx + 1\n        tile_type = tile_elem.get('type')\n        if tile_type == 'WALL':\n            walls.add((x, y))\n        if tile_elem.find('Object[@id-name=\"BOULDER\"]') is not None:\n            boulders.append((x, y))\n        if tile_elem.find('Player') is not None:\n            player_start = (x, y)\n\n# Override start position if provided\nif 'start_x' in input_data and input_data['start_x'] is not None:\n    player_start = (int(input_data['start_x']), int(input_data['start_y']))\n\ngoal_pos = (int(input_data['goal_x']), int(input_data['goal_y']))\n\n# --- BFS Solver ---\ninitial_state = (player_start, tuple(sorted(boulders)))\nqueue = collections.deque([(initial_state, [])])\nvisited = {initial_state}\n\npath_found = False\nwhile queue:\n    (current_player, current_boulders), path = queue.popleft()\n\n    # Check for goal state\n    if goal_pos in current_boulders:\n        print(f\"Solution found: {path}\")\n        path_found = True\n        break\n\n    # Explore neighbors\n    for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n        next_player_pos = (current_player[0] + dx, current_player[1] + dy)\n\n        # Simple move (no push)\n        if next_player_pos not in walls and next_player_pos not in current_boulders:\n            new_state = (next_player_pos, current_boulders)\n            if new_state not in visited:\n                visited.add(new_state)\n                queue.append((new_state, path + [move]))\n            continue\n\n        # Boulder push\n        if next_player_pos in current_boulders:\n            boulder_to_push = next_player_pos\n            next_boulder_pos = (boulder_to_push[0] + dx, boulder_to_push[1] + dy)\n\n            if next_boulder_pos not in walls and next_boulder_pos not in current_boulders:\n                new_boulders = list(current_boulders)\n                new_boulders.remove(boulder_to_push)\n                new_boulders.append(next_boulder_pos)\n                new_boulders_tuple = tuple(sorted(new_boulders))\n                \n                new_state = (next_player_pos, new_boulders_tuple)\n                if new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, path + [f\"Push {move}\"])) \n\nif not path_found:\n    print(\"No solution found.\")"
  },
  "pathfinder": {
    "description": "Finds the shortest path between two points on the current map using the A* algorithm. It considers specified traversable tiles and avoids obstacles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "traversable_tiles": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "traversable_tiles"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\ndef parse_map_and_objects(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    grid = [['' for _ in range(width + 1)] for _ in range(height + 1)]\n    impassable_objects = set()\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id'])\n            grid[y][x] = tile_elem.attrib['type']\n            if tile_elem.find('Object') is not None:\n                impassable_objects.add((x, y))\n    return grid, impassable_objects\n\ndef find_path(start_x, start_y, end_x, end_y, traversable_tiles_list, map_xml):\n    grid, impassable_objects = parse_map_and_objects(map_xml)\n    traversable_tiles = set(traversable_tiles_list)\n    start = (start_x, start_y)\n    end = (end_x, end_y)\n    \n    open_list = [(0, start)]\n    came_from = {}\n    g_score = {start: 0}\n    f_score = {start: abs(start[0] - end[0]) + abs(start[1] - end[1])}\n\n    while open_list:\n        _, current = heapq.heappop(open_list)\n        if current == end:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            return path[::-1]\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            nx, ny = neighbor\n\n            if not (0 <= ny < len(grid) and 0 <= nx < len(grid[0])):\n                continue\n            \n            if grid[ny][nx] not in traversable_tiles or neighbor in impassable_objects:\n                continue\n\n            tentative_g_score = g_score[current] + 1\n            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + abs(nx - end[0]) + abs(ny - end[1])\n                if neighbor not in [i[1] for i in open_list]:\n                    heapq.heappush(open_list, (f_score[neighbor], neighbor))\n    return None\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\ntraversable_tiles = input_data['traversable_tiles']\n\npath = find_path(start_x, start_y, end_x, end_y, traversable_tiles, map_xml_string)\nif path:\n    print(f\"Path found: {path}\")\nelse:\n    print(\"No path found.\")"
  },
  "sokoban_solver": {
    "description": "Solves complex Sokoban-style boulder puzzles with multiple boulders. It models the player and all boulders as a combined state and uses a Breadth-First Search algorithm to find the shortest sequence of pushes to clear a path for the player to a target destination.",
    "input_schema": {
      "type": "object",
      "properties": {
        "player_start_x": {
          "type": "integer"
        },
        "player_start_y": {
          "type": "integer"
        },
        "player_goal_x": {
          "type": "integer"
        },
        "player_goal_y": {
          "type": "integer"
        }
      },
      "required": [
        "player_start_x",
        "player_start_y",
        "player_goal_x",
        "player_goal_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef parse_map_for_sokoban(xml_string):\n    root = ET.fromstring(xml_string)\n    impassable = set()\n    boulders = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id'])\n            if tile_elem.attrib['type'] not in ['FLOOR']:\n                impassable.add((x, y))\n            obj_elem = tile_elem.find('Object')\n            if obj_elem is not None:\n                obj_id_name = obj_elem.attrib.get('id-name')\n                if obj_id_name == 'BOULDER':\n                    boulder_id = int(obj_elem.attrib['id'])\n                    boulders[boulder_id] = (x, y)\n                else:\n                    impassable.add((x, y))\n    return impassable, boulders\n\ndef get_player_path(start, end, impassable, all_boulders_pos_tuple):\n    queue = deque([[start]])\n    visited = {start}\n    temp_impassable = impassable.union(set(all_boulders_pos_tuple))\n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n        if (x, y) == end:\n            return path[1:]\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) not in visited and (nx, ny) not in temp_impassable:\n                visited.add((nx, ny))\n                new_path = list(path)\n                new_path.append((nx, ny))\n                queue.append(new_path)\n    return None\n\nplayer_start = (int(input_data['player_start_x']), int(input_data['player_start_y']))\nplayer_goal = (int(input_data['player_goal_x']), int(input_data['player_goal_y']))\nimpassable_tiles, initial_boulders = parse_map_for_sokoban(map_xml_string)\ninitial_boulder_state = tuple(sorted(initial_boulders.items()))\n\nqueue = deque([(player_start, initial_boulder_state, [])])\nvisited_states = set([(player_start, initial_boulder_state)])\n\nsolution_found = False\nwhile queue:\n    player_pos, current_boulder_state_tuple, path = queue.popleft()\n    current_boulders_dict = dict(current_boulder_state_tuple)\n\n    if get_player_path(player_pos, player_goal, impassable_tiles, tuple(current_boulders_dict.values())) is not None:\n        print(f\"Solution found: {path}\")\n        solution_found = True\n        break\n\n    for boulder_id, boulder_pos in current_boulder_state_tuple:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            push_spot = (boulder_pos[0] - dx, boulder_pos[1] - dy)\n            new_boulder_pos = (boulder_pos[0] + dx, boulder_pos[1] + dy)\n\n            if new_boulder_pos in impassable_tiles or new_boulder_pos in current_boulders_dict.values():\n                continue\n\n            player_path_to_push = get_player_path(player_pos, push_spot, impassable_tiles, tuple(current_boulders_dict.values()))\n\n            if player_path_to_push:\n                new_player_pos = boulder_pos\n                next_boulders_dict = current_boulders_dict.copy()\n                next_boulders_dict[boulder_id] = new_boulder_pos\n                next_boulder_state_tuple = tuple(sorted(next_boulders_dict.items()))\n                new_state = (new_player_pos, next_boulder_state_tuple)\n\n                if new_state not in visited_states:\n                    visited_states.add(new_state)\n                    new_path = list(path)\n                    for move_coord in player_path_to_push:\n                        new_path.append({'type': 'move', 'coord': move_coord})\n                    push_direction = (dx, dy)\n                    new_path.append({'type': 'push', 'boulder_id': boulder_id, 'direction': push_direction})\n                    queue.append((new_player_pos, next_boulder_state_tuple, new_path))\n\nif not solution_found:\n    print(\"No solution found.\")"
  }
}