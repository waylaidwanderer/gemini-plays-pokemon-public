{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "inventory_navigator_tool": {
    "description": "Calculates the optimal number of button presses (Up/Down) to navigate from a current selection to a target item in a list-based menu. This version correctly handles non-wrapping menus and provides a warning for long scrolls.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory_list": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "current_selection": {
          "type": "string"
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "inventory_list",
        "current_selection",
        "target_item"
      ]
    },
    "python_script": "import json\ntry:\n    inventory = json.loads(input_data['inventory_list'])\n    current_item = input_data['current_selection']\n    target_item = input_data['target_item']\n\n    if current_item not in inventory or target_item not in inventory:\n        print(json.dumps({'error': 'Item not found in inventory list.'}))\n    else:\n        current_idx = inventory.index(current_item)\n        target_idx = inventory.index(target_item)\n        \n        response = {}\n        if current_idx == target_idx:\n            response = {'direction': 'NONE', 'presses': 0}\n        elif target_idx > current_idx:\n            presses = target_idx - current_idx\n            response = {'direction': 'DOWN', 'presses': presses}\n        else: # target_idx < current_idx\n            presses = current_idx - target_idx\n            response = {'direction': 'UP', 'presses': presses}\n\n        if response.get('presses', 0) > 4:\n            response['note'] = 'Warning: This is a long scroll. Press Down in increments of 4 to navigate pages more effectively.'\n        \n        print(json.dumps(response))\nexcept Exception as e:\n    print(json.dumps({'error': str(e), 'type': type(e).__name__}))"
  },
  "mansion_puzzle_solver": {
    "description": "Analyzes the Pokemon Mansion's gate and switch puzzles. It takes the map XML and identifies switches, gates, and positional triggers to calculate the optimal sequence of actions to explore the entire floor. (v2)",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef parse_map_xml(xml_string):\n    root = ET.fromstring(xml_string)\n    grid, width, height = {}, int(root.get('width')), int(root.get('height'))\n    switches, gates, warps = {}, {}, []\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tile_type = tile.get('type')\n            is_warp = tile.get('is-warp') == 'true'\n            grid[(x, y)] = {'type': tile_type, 'is_warp': is_warp}\n            if is_warp: warps.append((x,y))\n            obj = tile.find('Object')\n            if obj is not None and obj.get('name') and 'Switch' in obj.get('name'):\n                switches[(x, y)] = 'toggle'\n            if 'gate' in tile_type:\n                gates[(x, y)] = tile_type\n    return grid, width, height, switches, gates, warps\n\ndef get_neighbors(pos, width, height):\n    x, y = pos\n    neighbors = []\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nx, ny = x + dx, y + dy\n        if 1 <= nx <= width and 1 <= ny <= height: neighbors.append((nx, ny))\n    return neighbors\n\ndef solve_mansion_2f(grid, width, height, start_pos, target_pos):\n    # Hardcoded logic for Pokemon Mansion 2F (map_id 214)\n    switch_pos = (3, 12)\n    trigger_1_pos = (11, 10)\n    trigger_2_pos = (21, 13)\n    west_gates = [(10, 5), (10, 6)]\n    east_gates = [(19, 9), (20, 9)]\n    south_gates = [(8, 23), (8, 24)] # Hypothetical based on map layout\n\n    # State: (player_pos, west_open, east_open, south_open)\n    q = deque([(start_pos, False, True, False, [])]) # Initial state based on current observation\n    visited = set([(start_pos, False, True, False)])\n\n    while q:\n        pos, w_open, e_open, s_open, path = q.popleft()\n        if pos == target_pos: return path\n        if len(path) > 75: continue\n\n        # Movement\n        for neighbor in get_neighbors(pos, width, height):\n            tile_type = grid[neighbor]['type']\n            is_passable = tile_type in ['ground', 'open_gate']\n            if (neighbor in west_gates and w_open) or (neighbor in east_gates and e_open) or (neighbor in south_gates and s_open):\n                is_passable = True\n            if grid[neighbor].get('is_warp'): is_passable = True\n\n            if is_passable:\n                next_path = path + [neighbor]\n                nw_open, ne_open, ns_open = w_open, e_open, s_open\n                if neighbor == trigger_1_pos:\n                    nw_open, ne_open = False, True\n                if neighbor == trigger_2_pos:\n                    ne_open = True\n                \n                state = (neighbor, nw_open, ne_open, ns_open)\n                if state not in visited:\n                    visited.add(state)\n                    q.append((neighbor, nw_open, ne_open, ns_open, next_path))\n\n        # Switch Interaction (must be adjacent to (3,12) and facing it)\n        if abs(pos[0] - switch_pos[0]) + abs(pos[1] - switch_pos[1]) == 1:\n            next_path = path + [f'PRESS_SWITCH_{switch_pos}']\n            # Rule: Switch toggles the southern gates\n            ns_open_toggled = not s_open\n            state = (pos, w_open, e_open, ns_open_toggled)\n            if state not in visited:\n                visited.add(state)\n                q.append((pos, w_open, e_open, ns_open_toggled, next_path))\n\n    return ['No solution found by v2 solver.']\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    grid, width, height, _, _, _ = parse_map_xml(map_xml_string)\n    solution = solve_mansion_2f(grid, width, height, (start_x, start_y), (target_x, target_y))\n    print(json.dumps(solution))\nexcept Exception as e:\n    import traceback\n    print(json.dumps([f'Error: {str(e)}', traceback.format_exc()]))"
  },
  "check_tile_walkable": {
    "description": "A diagnostic tool to check if a specific tile is walkable and print its properties for debugging.",
    "input_schema": {
      "type": "object",
      "properties": {
        "x": {
          "type": "string"
        },
        "y": {
          "type": "string"
        }
      },
      "required": [
        "x",
        "y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ndef is_walkable(x, y, grid, movement_mode='walking', ignore_npc_ids=[]):\n    tile = grid.get((x, y))\n    print(f\"Checking tile ({x}, {y})\")\n    if not tile:\n        print(\"Result: False (Tile not in grid)\")\n        return False\n    if tile.get('seen') == 'false':\n        print(\"Result: False (Tile not seen)\")\n        return False\n    \n    tile_type = tile.get('type')\n    print(f\"  - Type: {tile_type}\")\n    if tile_type in ['impassable', 'boulder_barrier', 'closed_gate']:\n        print(f\"Result: False (Impassable type: {tile_type})\")\n        return False\n\n    obj_element = tile.find('Object')\n    if obj_element is not None:\n        obj_id_name = obj_element.get('id-name')\n        obj_id_str = obj_element.get('id')\n        obj_name = obj_element.get('name')\n        print(f\"  - Found Object: id-name='{obj_id_name}', id='{obj_id_str}', name='{obj_name}'\")\n\n        if obj_id_str and obj_id_str.isdigit():\n            obj_id = int(obj_id_str)\n            if obj_id in ignore_npc_ids:\n                print(\"  - Object is in ignore_npc_ids. Treating as walkable.\")\n                pass\n            elif obj_id_name != 'PIKACHU':\n                print(\"Result: False (Blocked by non-Pikachu NPC)\")\n                return False\n        elif obj_name and not obj_id_name:\n            print(\"Result: False (Blocked by background object)\")\n            return False\n\n    if movement_mode == 'walking':\n        if tile_type == 'water':\n            print(\"Result: False (Walking on water)\")\n            return False\n    elif movement_mode == 'surfing':\n        if tile_type not in ['water', 'ground', 'grass', 'steps', 'elevated_ground', 'cleared_boulder_barrier', 'open_gate', 'gate_offscreen']:\n            print(f\"Result: False (Cannot surf on type: {tile_type})\")\n            return False\n    \n    print(\"Result: True (Walkable)\")\n    return True\n\nmap_xml_string = globals().get('map_xml_string', '')\nif not map_xml_string:\n    print(json.dumps({'error': 'map_xml_string not found'}))\nelse:\n    try:\n        root = ET.fromstring(map_xml_string)\n        grid = {}\n        for row in root.findall('Row'):\n            y_coord = int(row.get('id'))\n            for tile_node in row.findall('Tile'):\n                x_coord = int(tile_node.get('id'))\n                grid[(x_coord, y_coord)] = tile_node\n\n        x_to_check = int(input_data['x'])\n        y_to_check = int(input_data['y'])\n\n        tile_xml = grid.get((x_to_check, y_to_check))\n        if tile_xml is not None:\n            print(f\"XML for tile ({x_to_check}, {y_to_check}):\")\n            print(ET.tostring(tile_xml, encoding='unicode'))\n        else:\n            print(f\"No XML found for tile ({x_to_check}, {y_to_check}).\")\n\n        walkable_status = is_walkable(x_to_check, y_to_check, grid)\n        print(f\"Final determination for ({x_to_check}, {y_to_check}): {'Walkable' if walkable_status else 'Not Walkable'}\")\n\n    except Exception as e:\n        print(json.dumps({'error': f'An unexpected error occurred: {e}'}))"
  }
}