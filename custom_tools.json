{
  "master_navigator": {
    "description": "A consolidated navigation tool that handles pathfinding, exploration targeting, and maze navigation. It can find a path to a specific coordinate, identify the best exploration target, or navigate a known maze.",
    "input_schema": {
      "type": "object",
      "properties": {
        "mode": {
          "type": "string",
          "enum": [
            "pathfind",
            "explore"
          ]
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer",
          "nullable": true
        },
        "end_y": {
          "type": "integer",
          "nullable": true
        },
        "traversable_tiles": {
          "type": "string"
        }
      },
      "required": [
        "mode",
        "start_x",
        "start_y",
        "traversable_tiles"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef run():\n    mode = input_data['mode']\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    traversable_tile_types = json.loads(input_data['traversable_tiles'])\n\n    is_exploration = input_data.get('is_exploration', 'false').lower() == 'true'\n    if is_exploration and 'unseen' not in traversable_tile_types:\n        traversable_tile_types.append('unseen')\n\n    if mode == 'explore':\n        explore_map(start_x, start_y, traversable_tile_types)\n    elif mode == 'pathfind':\n        end_x = int(input_data['end_x'])\n        end_y = int(input_data['end_y'])\n        find_path(start_x, start_y, end_x, end_y, traversable_tile_types, is_exploration)\n\ndef get_impassable_tiles(traversable_tile_types, is_exploration):\n    impassable = set()\n    root = ET.fromstring(map_xml_string)\n    for row in root.findall('Row'):\n        for tile in row.findall('Tile'):\n            x, y = int(tile.get('id')), int(row.get('id'))\n            tile_type = tile.get('type')\n            if tile_type not in traversable_tile_types:\n                impassable.add((x, y))\n            if tile.find('Object') is not None:\n                impassable.add((x, y))\n    return impassable, int(root.get('width')), int(root.get('height'))\n\ndef find_path(start_x, start_y, end_x, end_y, traversable_tile_types, is_exploration):\n    impassable, map_width, map_height = get_impassable_tiles(traversable_tile_types, is_exploration)\n    start_node, end_node = (start_x, start_y), (end_x, end_y)\n\n    target_destinations = []\n    if end_node in impassable:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_node = (end_node[0] + dx, end_node[1] + dy)\n            if adj_node not in impassable and 1 <= adj_node[0] <= map_width and 1 <= adj_node[1] <= map_height:\n                 target_destinations.append(adj_node)\n        if not target_destinations:\n            print(json.dumps({'status': 'FAIL', 'reason': 'Destination and all adjacent tiles are impassable.'}))\n            return\n    else:\n        target_destinations.append(end_node)\n\n    queue = deque([[start_node]])\n    visited = {start_node}\n\n    while queue:\n        path = queue.popleft()\n        node = path[-1]\n        if node in target_destinations:\n            print(json.dumps({'status': 'SUCCESS', 'path': [{'x': x, 'y': y} for x, y in path]}))\n            return\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (node[0] + dx, node[1] + dy)\n            if 1 <= neighbor[0] <= map_width and 1 <= neighbor[1] <= map_height and neighbor not in visited and neighbor not in impassable:\n                visited.add(neighbor)\n                new_path = list(path)\n                new_path.append(neighbor)\n                queue.append(new_path)\n\n    print(json.dumps({'status': 'FAIL', 'reason': 'No path found.'}))\n\ndef explore_map(start_x, start_y, traversable_tile_types):\n    impassable, map_width, map_height = get_impassable_tiles(traversable_tile_types, True)\n    root = ET.fromstring(map_xml_string)\n    unseen_tiles = set()\n    for row in root.findall('Row'):\n        for tile in row.findall('Tile'):\n            if tile.get('seen') == 'false':\n                unseen_tiles.add((int(tile.get('id')), int(row.get('id'))))\n    if not unseen_tiles:\n        print(json.dumps({'status': 'FAIL', 'reason': 'No unseen tiles on the map.'}))\n        return\n\n    queue = deque([[ (start_x, start_y) ]])\n    visited = { (start_x, start_y) }\n    closest_unseen = None\n    min_path_len = float('inf')\n\n    while queue:\n        path = queue.popleft()\n        node = path[-1]\n        if node in unseen_tiles:\n            if len(path) < min_path_len:\n                min_path_len = len(path)\n                closest_unseen = path[-1]\n        \n        # Continue search even after finding one to ensure it's the closest\n        if len(path) > min_path_len + 5: # Optimization to stop searching too far\n            continue\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (node[0] + dx, node[1] + dy)\n            if 1 <= neighbor[0] <= map_width and 1 <= neighbor[1] <= map_height and neighbor not in visited and neighbor not in impassable:\n                visited.add(neighbor)\n                new_path = list(path)\n                new_path.append(neighbor)\n                queue.append(new_path)\n\n    if closest_unseen:\n        print(json.dumps({'status': 'SUCCESS', 'target': {'x': closest_unseen[0], 'y': closest_unseen[1]}}))\n    else:\n        print(json.dumps({'status': 'FAIL', 'reason': 'No reachable unseen tiles found.'}))\n\nrun()"
  }
}