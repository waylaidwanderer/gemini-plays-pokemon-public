{
  "find_path": {
    "description": "Finds a path from a start to an end coordinate on the current map using the A* algorithm. Returns a list of coordinates as a JSON string.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef find_path_logic(map_xml_string, start_x, start_y, end_x, end_y):\n    root = ET.fromstring(map_xml_string)\n    IMPASSABLE_TILES = {\"WALL\", \"WATER\", \"HEADBUTT_TREE\", \"CUT_TREE\"}\n    grid = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            has_object = tile_elem.find('Object') is not None and tile_elem.find('Player') is None\n            grid[(x, y)] = {'type': tile_type, 'has_object': has_object}\n\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n    open_set = []\n    heapq.heappush(open_set, (0, start_node))\n    came_from = {}\n    g_score = {start_node: 0}\n    f_score = {start_node: abs(start_node[0] - end_node[0]) + abs(start_node[1] - end_node[1])}\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n        if current == end_node:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start_node)\n            return path[::-1]\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if neighbor not in grid:\n                continue\n\n            current_tile_info = grid.get(current)\n            neighbor_tile_info = grid.get(neighbor)\n\n            if not neighbor_tile_info or neighbor_tile_info['has_object']:\n                continue\n            \n            current_type = current_tile_info['type']\n            neighbor_type = neighbor_tile_info['type']\n            \n            if neighbor_type == \"LEDGE_HOP_DOWN\" and dy != 1: continue\n            if neighbor_type == \"LEDGE_HOP_RIGHT\" and dx != 1: continue\n            if neighbor_type == \"LEDGE_HOP_LEFT\" and dx == 1: continue\n            if current_type == \"LEDGE_HOP_DOWN\" and dy == -1: continue\n            if current_type == \"LEDGE_HOP_RIGHT\" and dx == -1: continue\n            if current_type == \"LEDGE_HOP_LEFT\" and dx == -1: continue\n            if neighbor_tile_info['type'] in IMPASSABLE_TILES: continue\n\n            tentative_g_score = g_score.get(current, float('inf')) + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + abs(neighbor[0] - end_node[0]) + abs(neighbor[1] - end_node[1])\n                if neighbor not in [i[1] for i in open_set]:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    return None\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\npath = find_path_logic(map_xml_string, start_x, start_y, end_x, end_y)\nif path:\n    print(json.dumps([{\"x\": p[0], \"y\": p[1]} for p in path]))\nelse:\n    print(\"No path found.\")\n",
    "history": [
      {
        "commit_message": "feat: Create initial find_path tool. Implements A* algorithm to find a path between two points on the current map. It correctly handles impassable tiles (WALL, WATER, HEADBUTT_TREE), objects as obstacles, and one-way ledge mechanics (LEDGE_HOP_DOWN, LEDGE_HOP_RIGHT) based on documented behavior. This tool is essential for automating navigation and avoiding manual pathing errors.",
        "timestamp": "2025-11-19T23:33:00.811Z",
        "action_counter": 156
      },
      {
        "commit_message": "fix: Add CUT_TREE to impassable tiles. The pathfinder was incorrectly trying to route through CUT_TREE tiles, which are impassable without the Cut HM. This fix prevents this error and ensures more accurate pathing.",
        "timestamp": "2025-11-19T23:51:30.209Z",
        "action_counter": 202
      },
      {
        "commit_message": "fix: Add LEDGE_HOP_LEFT to one-way tile logic. The pathfinder was attempting to move through left-facing ledges from the wrong direction. This fix ensures it correctly treats these tiles as one-way traversal points.",
        "timestamp": "2025-11-19T23:56:37.667Z",
        "action_counter": 212
      }
    ]
  }
}