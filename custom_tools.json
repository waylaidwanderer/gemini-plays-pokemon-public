{
  "boulder_pusher_tool": {
    "description": "Automates pushing a boulder in a straight line. Assumes the player is already in position to start the first push. Outputs a list of button presses.",
    "input_schema": {
      "type": "object",
      "properties": {
        "boulder_start_x": {
          "type": "string"
        },
        "boulder_start_y": {
          "type": "string"
        },
        "boulder_end_x": {
          "type": "string"
        },
        "boulder_end_y": {
          "type": "string"
        }
      },
      "required": [
        "boulder_start_x",
        "boulder_start_y",
        "boulder_end_x",
        "boulder_end_y"
      ]
    },
    "python_script": "import json\n\nstart_x, start_y = int(input_data['boulder_start_x']), int(input_data['boulder_start_y'])\nend_x, end_y = int(input_data['boulder_end_x']), int(input_data['boulder_end_y'])\n\nbuttons = []\n\nif start_x == end_x: # Vertical push\n    direction = 'Up' if end_y < start_y else 'Down'\n    num_pushes = abs(start_y - end_y)\n    # Player does not move after a vertical push, so we must manually reposition.\n    for i in range(num_pushes):\n        buttons.append(direction) # Push\n        if i < num_pushes - 1: # Don't reposition after the last push\n            buttons.append(direction) # Reposition\nelif start_y == end_y: # Horizontal push\n    direction = 'Left' if end_x < start_x else 'Right'\n    num_pushes = abs(start_x - end_x)\n    # Player moves into the boulder's old space automatically. No reposition needed.\n    for _ in range(num_pushes):\n        buttons.append(direction) # Push\nelse:\n    print(json.dumps({'error': 'Boulder path must be a straight line.'}))\n    exit()\n\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "feat: Create boulder_pusher_tool to automate linear boulder pushing. This tool will significantly improve efficiency when solving puzzles that require moving a boulder along a long, straight corridor, by replacing a multi-turn, manual process with a single, automated tool call.",
        "timestamp": "2025-08-03T17:23:26.526Z",
        "action_counter": 119242
      },
      {
        "commit_message": "feat: Create boulder_pusher_tool to automate linear boulder pushing. This tool will significantly improve efficiency when solving puzzles that require moving a boulder along a long, straight corridor, by replacing a multi-turn, manual process with a single, automated tool call.",
        "timestamp": "2025-08-03T17:44:07.834Z",
        "action_counter": 119282
      },
      {
        "commit_message": "feat: Create boulder_pusher_tool to automate linear boulder pushing. This tool will significantly improve efficiency when solving puzzles that require moving a boulder along a long, straight corridor, by replacing a multi-turn, manual process with a single, automated tool call.",
        "timestamp": "2025-08-03T17:50:13.513Z",
        "action_counter": 119294
      },
      {
        "commit_message": "refactor(boulder_pusher_tool): Overhaul script to output a direct list of button presses instead of a high-level action plan. This enables full automation of linear pushes in a single turn, fixing the previous issue that required manual step-by-step execution and caused looping warnings. The new logic generates a sequence of 'push' and 'reposition' moves.",
        "timestamp": "2025-08-03T17:58:36.488Z",
        "action_counter": 119305
      },
      {
        "commit_message": "refactor(boulder_pusher_tool): Differentiate vertical and horizontal push logic. The previous version used the same repositioning logic for both, which is incorrect. The new script correctly models the game mechanic where the player does not move after a vertical push (requiring a manual reposition step) but does move after a horizontal push (no reposition needed). This is a critical fix for reliable puzzle automation.",
        "timestamp": "2025-08-03T19:40:10.254Z",
        "action_counter": 119471
      },
      {
        "commit_message": "fix(boulder_pusher_tool): Correctly implement vertical push repositioning. The previous fix attempt failed as the script was identical. This version correctly adds a repositioning move after each vertical push, but not after the final one, accurately modeling the game mechanic and ensuring reliable automation.",
        "timestamp": "2025-08-03T19:43:03.937Z",
        "action_counter": 119477
      },
      {
        "commit_message": "fix(boulder_pusher_tool): Correctly implement vertical push repositioning. The previous script was identical to the flawed one. This version ensures a repositioning move is added after each vertical push except the last, accurately modeling the game mechanic and ensuring reliable automation.",
        "timestamp": "2025-08-03T19:48:40.642Z",
        "action_counter": 119491
      }
    ]
  },
  "get_complete_puzzle_state": {
    "description": "A wrapper tool that gathers all necessary data for the puzzle_strategist_agent. It parses the map XML to find the player's position, all boulders, switches, and barriers, and a comprehensive list of all impassable tiles, including objects like defeated trainers.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\npuzzle_state = {\n    \"player_pos\": {},\n    \"boulders\": [],\n    \"switches\": [],\n    \"barriers\": [],\n    \"impassable_tiles\": []\n}\n\nroot = ET.fromstring(map_xml_string)\nimpassable_types = ['impassable', 'boulder_barrier', 'closed_gate']\n\nfor row in root.findall('Row'):\n    y = int(row.get('id'))\n    for tile in row.findall('Tile'):\n        x = int(tile.get('id'))\n        coord = {'x': x, 'y': y}\n\n        if tile.find('Player') is not None:\n            puzzle_state[\"player_pos\"] = coord\n\n        if tile.find('Boulder') is not None:\n            puzzle_state[\"boulders\"].append(coord)\n        if tile.get('type') == 'boulder_switch':\n            puzzle_state[\"switches\"].append(coord)\n        if tile.get('type') == 'boulder_barrier':\n            puzzle_state[\"barriers\"].append(coord)\n\n        is_impassable = False\n        if tile.get('type') in impassable_types:\n            is_impassable = True\n        \n        for obj in tile.findall('Object'):\n            if obj.get('id-name') != 'Pikachu':\n                is_impassable = True\n                break\n        \n        if is_impassable:\n            puzzle_state[\"impassable_tiles\"].append(coord)\n\nprint(json.dumps(puzzle_state))",
    "history": [
      {
        "commit_message": "feat: Create get_complete_puzzle_state tool. This automates the data gathering process for the puzzle_strategist_agent, preventing user error. It combines the functionality of get_puzzle_elements and get_impassable_coords, ensuring a complete and accurate dataset is always provided to the agent for strategic planning.",
        "timestamp": "2025-08-03T05:08:52.744Z",
        "action_counter": 118100
      }
    ]
  },
  "log_summarizer": {
    "description": "Summarizes a long log file, focusing on the beginning and end, to prevent truncation when passing it to another agent.",
    "input_schema": {
      "type": "object",
      "properties": {
        "log_text": {
          "type": "string"
        },
        "max_chars": {
          "type": "string"
        }
      },
      "required": [
        "log_text",
        "max_chars"
      ]
    },
    "python_script": "import json\n\nlog_text = input_data['log_text']\nmax_chars = int(input_data.get('max_chars', 8000))\n\nif len(log_text) <= max_chars:\n    print(log_text)\nelse:\n    half_chars = (max_chars - 50) // 2\n    start = log_text[:half_chars]\n    end = log_text[-half_chars:]\n    summary = f\"{start}\\n\\n... (log truncated, see original tool output for full text) ...\\n\\n{end}\"\n    print(summary)",
    "history": [
      {
        "commit_message": "feat: Create log_summarizer tool. This tool will prevent log truncation issues when passing verbose tool output to debugger agents, which was a critical failure identified in the last overwatch critique. This is a necessary step to break the current unproductive debugging loop.",
        "timestamp": "2025-08-05T13:18:24.116Z",
        "action_counter": 122522
      },
      {
        "commit_message": "feat: Create log_summarizer tool. This tool will prevent log truncation issues when passing verbose tool output to debugger agents, which was a critical failure identified in the last overwatch critique. This is a necessary step to break the current unproductive debugging loop.",
        "timestamp": "2025-08-05T15:11:16.035Z",
        "action_counter": 122635
      }
    ]
  },
  "multi_boulder_pusher": {
    "description": "Automates a sequence of boulder pushes, including repositioning. Assumes the player is in position for the first push. Input is a JSON string of push actions (e.g., [{'direction': 'RIGHT', 'count': 5}, {'direction': 'DOWN', 'count': 3}]). This tool is a work-in-progress and may not handle all complex repositioning correctly.",
    "input_schema": {
      "type": "object",
      "properties": {
        "actions": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "direction": {
                "type": "string",
                "enum": [
                  "UP",
                  "DOWN",
                  "LEFT",
                  "RIGHT"
                ]
              },
              "count": {
                "type": "string"
              }
            },
            "required": [
              "direction",
              "count"
            ]
          }
        }
      },
      "required": [
        "actions"
      ]
    },
    "python_script": "import json\n\nactions_str = input_data.get('actions', '[]')\ntry:\n    actions = json.loads(actions_str)\nexcept json.JSONDecodeError:\n    print(json.dumps({\"error\": \"Invalid JSON format for actions.\"}))\n    return\n\nbutton_presses = []\n\nfor action in actions:\n    direction = action.get('direction')\n    try:\n        count = int(action.get('count', 0))\n    except (ValueError, TypeError):\n        count = 0\n\n    if direction and count > 0:\n        if direction in ['LEFT', 'RIGHT']:\n            for _ in range(count):\n                button_presses.append(direction)\n        elif direction in ['UP', 'DOWN']:\n            reposition_move = 'DOWN' if direction == 'UP' else 'UP'\n            for i in range(count):\n                button_presses.append(direction)\n                if i < count - 1:\n                    button_presses.append(reposition_move)\n\nprint(json.dumps({\"button_presses\": button_presses}))",
    "history": [
      {
        "commit_message": "feat: Create multi_boulder_pusher tool. This tool automates sequences of boulder pushes as suggested by the Overwatch critique. It's a foundational version that handles basic linear sequences and vertical push repositioning, intended to streamline puzzle execution and be refined later.",
        "timestamp": "2025-08-05T22:12:42.740Z",
        "action_counter": 123095
      }
    ]
  }
}