{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "inventory_scanner": {
    "description": "Scans the player's inventory list for a target item and returns whether it was found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory_list": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "inventory_list",
        "target_item"
      ]
    },
    "python_script": "import json\n\ntry:\n    inventory_list = json.loads(input_data['inventory_list'])\n    target_item = input_data['target_item']\n    found = False\n    for item in inventory_list:\n        if target_item.lower() in item.lower():\n            found = True\n            break\n    print(f'Item found: {found}')\nexcept Exception as e:\n    print(f'An error occurred: {e}')"
  },
  "pathfinder": {
    "description": "Calculates the shortest path from the player's current position to a target coordinate on the current map. This version uses a stateful (walk/surf) A* algorithm to correctly handle paths that require transitioning between land and water.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\ndef pathfinder_func(map_xml_string, input_data):\n    print(\"Pathfinder v6.0 (Stateful A*) starting...\", flush=True)\n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n    except (ValueError, KeyError) as e:\n        print(f\"Pathfinder v6.0 Error: Invalid input data. {e}\", flush=True)\n        return\n\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.get('width'))\n    map_height = int(root.get('height'))\n    \n    player_pos = None\n    player_tile_type = None\n    for row_elem in root.findall('Row'):\n        for tile_elem in row_elem.findall('Tile'):\n            if tile_elem.get('has-player') == 'true':\n                player_pos = (int(tile_elem.get('id')), int(row_elem.get('id')))\n                player_tile_type = tile_elem.get('type')\n                break\n        if player_pos:\n            break\n\n    if not player_pos:\n        print('Pathfinder v6.0 Error: Player position not found.', flush=True)\n        return\n\n    print(f\"Player at {player_pos} ({player_tile_type}), Target at ({target_x}, {target_y})\", flush=True)\n    \n    start_state = 'surf' if player_tile_type == 'water' else 'walk'\n\n    grid = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            is_pikachu = tile_elem.find(\"./Object[@id-name='Pikachu']\") is not None\n            has_object = tile_elem.find('Object') is not None\n            is_warp = tile_elem.get('is-warp') == 'true'\n            \n            is_impassable = False\n            impassable_types = ['impassable', 'boulder_barrier', 'closed_gate', 'unknown']\n            if tile_type in impassable_types or (has_object and not is_pikachu):\n                is_impassable = True\n            \n            if is_warp and (x, y) != (target_x, target_y):\n                is_impassable = True\n            \n            grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n\n    start_node = (player_pos[0], player_pos[1], start_state)\n    end_pos = (target_x, target_y)\n\n    if grid.get(end_pos, {'impassable': True})['impassable']:\n        print(f\"Target {end_pos} is not traversable. Finding adjacent tile.\", flush=True)\n        original_end = end_pos\n        potential_targets = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_pos = (original_end[0] + dx, original_end[1] + dy)\n            if adj_pos in grid and not grid[adj_pos]['impassable']:\n                potential_targets.append(adj_pos)\n        \n        if potential_targets:\n            # Find the closest adjacent target to the player\n            potential_targets.sort(key=lambda p: heuristic(player_pos, p))\n            end_pos = potential_targets[0]\n            print(f\"New target found: {end_pos}\", flush=True)\n        else:\n            print('Pathfinder v6.0 Error: Path not found. Target is impassable and has no traversable adjacent tiles.', flush=True)\n            return\n\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    open_set = []\n    heapq.heappush(open_set, (0, start_node))\n    came_from = {}\n    g_score = {start_node: 0}\n    f_score = {start_node: heuristic(player_pos, end_pos)}\n\n    while open_set:\n        _, current_node = heapq.heappop(open_set)\n        current_x, current_y, current_state = current_node\n        current_pos = (current_x, current_y)\n\n        if current_pos == end_pos:\n            path = []\n            while current_node in came_from:\n                path.append((current_node[0], current_node[1]))\n                current_node = came_from[current_node]\n            path.append(player_pos)\n            final_path_str = ','.join([f'({p[0]},{p[1]})' for p in path[::-1]])\n            print(f'Path: [{final_path_str}]', flush=True)\n            print(\"Pathfinder v6.0 finished.\", flush=True)\n            return\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor_pos = (current_x + dx, current_y + dy)\n\n            if not (1 <= neighbor_pos[0] <= map_width and 1 <= neighbor_pos[1] <= map_height):\n                continue\n            \n            neighbor_data = grid.get(neighbor_pos)\n            if not neighbor_data or neighbor_data['impassable']:\n                continue\n\n            neighbor_type = neighbor_data['type']\n            \n            if neighbor_type == 'ledge':\n                if dy == 1 and current_y == neighbor_pos[1] - 1:\n                    actual_neighbor_pos = (neighbor_pos[0], neighbor_pos[1] + 1)\n                    if actual_neighbor_pos in grid and not grid[actual_neighbor_pos]['impassable']:\n                        tentative_g_score = g_score[current_node] + 1\n                        actual_neighbor_node = (actual_neighbor_pos[0], actual_neighbor_pos[1], 'walk')\n                        if tentative_g_score < g_score.get(actual_neighbor_node, float('inf')):\n                            came_from[actual_neighbor_node] = current_node\n                            g_score[actual_neighbor_node] = tentative_g_score\n                            f_score[actual_neighbor_node] = tentative_g_score + heuristic(actual_neighbor_pos, end_pos)\n                            heapq.heappush(open_set, (f_score[actual_neighbor_node], actual_neighbor_node))\n                continue\n\n            next_state = current_state\n            is_land = neighbor_type != 'water'\n            \n            if current_state == 'walk' and not is_land:\n                next_state = 'surf'\n            elif current_state == 'surf' and is_land:\n                next_state = 'walk'\n            \n            neighbor_node = (neighbor_pos[0], neighbor_pos[1], next_state)\n            tentative_g_score = g_score[current_node] + 1\n\n            if tentative_g_score < g_score.get(neighbor_node, float('inf')):\n                came_from[neighbor_node] = current_node\n                g_score[neighbor_node] = tentative_g_score\n                f_score[neighbor_node] = tentative_g_score + heuristic(neighbor_pos, end_pos)\n                heapq.heappush(open_set, (f_score[neighbor_node], neighbor_node))\n\n    print('Pathfinder v6.0 Error: Path not found.', flush=True)\n    print(\"Pathfinder v6.0 finished.\", flush=True)\n\npathfinder_func(map_xml_string, input_data)"
  },
  "spinner_maze_solver": {
    "description": "Finds the shortest path in a spinner maze. It parses the map_xml_string, builds a graph including spinner traversals, and uses A* to find the path from the player's position to a target coordinate. This version corrects a critical bug in the A* implementation that caused timeouts.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\ndef spinner_maze_solver_v3(map_xml_string, input_data):\n    print(\"Spinner Maze Solver v3.0 (Final Fix) starting...\", flush=True)\n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n    except (ValueError, KeyError) as e:\n        print(f\"Solver v3.0 Error: Invalid input data. {e}\", flush=True)\n        return\n\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.get('width'))\n    map_height = int(root.get('height'))\n    \n    player_pos = None\n    for row_elem in root.findall('Row'):\n        for tile_elem in row_elem.findall('Tile'):\n            if tile_elem.get('has-player') == 'true':\n                player_pos = (int(tile_elem.get('id')), int(row_elem.get('id')))\n                break\n        if player_pos:\n            break\n\n    if not player_pos:\n        print('Solver v3.0 Error: Player position not found.', flush=True)\n        return\n\n    adj = {}\n    grid = [[0 for _ in range(map_width + 1)] for _ in range(map_height + 1)]\n    \n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            pos = (x, y)\n            tile_type = tile_elem.get('type')\n            has_object = tile_elem.find('Object') is not None\n\n            impassable_types = ['impassable', 'boulder_barrier', 'closed_gate', 'unknown']\n            if tile_type in impassable_types or has_object:\n                grid[y][x] = 1\n            else:\n                grid[y][x] = 0\n\n            adj.setdefault(pos, [])\n            spinner_elem = tile_elem.find('Spinner')\n            if spinner_elem is not None:\n                end_coord_str = spinner_elem.get('end-coordinate')\n                if end_coord_str:\n                    try:\n                        cleaned_str = end_coord_str.strip('() ')\n                        end_x, end_y = map(int, cleaned_str.split(','))\n                        end_pos = (end_x, end_y)\n                        adj[pos].append(end_pos)\n                    except ValueError:\n                        pass # Ignore parse errors\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                neighbor = (x + dx, y + dy)\n                if 1 <= neighbor[0] <= map_width and 1 <= neighbor[1] <= map_height:\n                     adj[pos].append(neighbor)\n\n    start = player_pos\n    end = (target_x, target_y)\n\n    if grid[end[1]][end[0]] == 1:\n        print(f\"Target {end} is not traversable. Finding adjacent tile.\", flush=True)\n        original_end = end\n        found_new_target = False\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_x, adj_y = original_end[0] + dx, original_end[1] + dy\n            if 1 <= adj_x <= map_width and 1 <= adj_y <= map_height and grid[adj_y][adj_x] == 0:\n                end = (adj_x, adj_y)\n                found_new_target = True\n                break\n        if not found_new_target:\n            print('Solver v3.0 Error: Target is impassable and has no traversable adjacent tiles.', flush=True)\n            return\n\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = { (c,r): float('inf') for r in range(map_height + 2) for c in range(map_width + 2) }\n    g_score[start] = 0\n    f_score = { (c,r): float('inf') for r in range(map_height + 2) for c in range(map_width + 2) }\n    f_score[start] = heuristic(start, end)\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == end:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            final_path_str = ','.join([f'({p[0]},{p[1]})' for p in path[::-1]])\n            print(f'Path: [{final_path_str}]', flush=True)\n            print(\"Solver v3.0 finished.\", flush=True)\n            return\n\n        for neighbor in adj.get(current, []):\n            if grid[neighbor[1]][neighbor[0]] == 1:\n                continue\n\n            tentative_g_score = g_score[current] + 1\n\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                # This is the corrected line\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + heuristic(neighbor, end)\n                heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    print('Solver v3.0 Error: Path not found.', flush=True)\n    print(\"Solver v3.0 finished.\", flush=True)\n\nspinner_maze_solver_v3(map_xml_string, input_data)"
  },
  "pokemon_locator": {
    "description": "Scans a provided JSON list of Pokémon strings from a PC box to check if a target Pokémon (by nickname or species) is present.",
    "input_schema": {
      "type": "object",
      "properties": {
        "pokemon_in_box": {
          "type": "string"
        },
        "target_pokemon": {
          "type": "string"
        }
      },
      "required": [
        "pokemon_in_box",
        "target_pokemon"
      ]
    },
    "python_script": "import json\n\npokemon_in_box_str = input_data.get('pokemon_in_box', '[]')\ntarget_pokemon = input_data.get('target_pokemon', '').upper()\n\ntry:\n    pokemon_in_box = json.loads(pokemon_in_box_str)\n    if not isinstance(pokemon_in_box, list):\n        raise TypeError(\"Input is not a list.\")\nexcept (json.JSONDecodeError, TypeError) as e:\n    print(f\"Error: Could not parse the 'pokemon_in_box' input as a valid JSON list of strings. Details: {e}\")\nelse:\n    found = False\n    for pokemon_string in pokemon_in_box:\n        if target_pokemon in str(pokemon_string).upper():\n            found = True\n            break\n\n    if found:\n        print(f\"Found '{input_data['target_pokemon']}' in the current box.\")\n    else:\n        print(f\"Did not find '{input_data['target_pokemon']}' in the current box.\")"
  }
}