{
  "deterministic_battle_strategist": {
    "description": "A deterministic, non-LLM tool that analyzes battle state and recommends the next action (FIGHT/RUN) and move. A reliable backup for the simple_battle_strategist agent.",
    "input_schema": {
      "type": "object",
      "properties": {
        "my_pokemon_level": {
          "type": "integer"
        },
        "my_pokemon_hp_current": {
          "type": "integer"
        },
        "my_pokemon_hp_max": {
          "type": "integer"
        },
        "opponent_pokemon_name": {
          "type": "string"
        },
        "opponent_pokemon_level": {
          "type": "integer",
          "nullable": true
        },
        "move_1_name": {
          "type": "string"
        },
        "move_1_pp_current": {
          "type": "integer"
        },
        "move_2_name": {
          "type": "string",
          "nullable": true
        },
        "move_2_pp_current": {
          "type": "integer",
          "nullable": true
        },
        "move_3_name": {
          "type": "string",
          "nullable": true
        },
        "move_3_pp_current": {
          "type": "integer",
          "nullable": true
        },
        "move_4_name": {
          "type": "string",
          "nullable": true
        },
        "move_4_pp_current": {
          "type": "integer",
          "nullable": true
        },
        "current_objective": {
          "type": "string",
          "enum": [
            "TRAINING",
            "TRAVELING"
          ]
        },
        "battle_type": {
          "type": "string",
          "enum": [
            "WILD",
            "TRAINER"
          ]
        }
      },
      "required": [
        "my_pokemon_level",
        "my_pokemon_hp_current",
        "my_pokemon_hp_max",
        "opponent_pokemon_name",
        "move_1_name",
        "move_1_pp_current",
        "current_objective",
        "battle_type"
      ]
    },
    "python_script": "import json\n\n# --- Knowledge Base ---\nKNOWN_POKEMON_TYPES = {\n    'BEEDRILL': ['Bug', 'Poison'], 'BELLSPROUT': ['Grass', 'Poison'], 'CATERPIE': ['Bug'],\n    'CLEFAIRY': ['Normal'], 'CROCONAW': ['Water'], 'DUNSPARCE': ['Normal'], 'EKANS': ['Poison'], 'GASTLY': ['Ghost', 'Poison'],\n    'GEODUDE': ['Rock', 'Ground'], 'HOOTHOOT': ['Normal', 'Flying'], 'HOPPIP': ['Grass', 'Flying'],\n    'JIGGLYPUFF': ['Normal'], 'KAKUNA': ['Bug', 'Poison'], 'LEDYBA': ['Bug', 'Flying'], 'MEOWTH': ['Normal'], 'METAPOD': ['Bug'], 'MILTANK': ['Normal'], 'ODDISH': ['Grass', 'Poison'],\n    'ONIX': ['Rock', 'Ground'], 'PARAS': ['Bug', 'Grass'], 'PIDGEY': ['Normal', 'Flying'], 'POLIWAG': ['Water'],\n    'PSYDUCK': ['Water'], 'RATTATA': ['Normal'], 'SANDSHREW': ['Ground'], 'SCYTHER': ['Bug', 'Flying'],\n    'SENTRET': ['Normal'], 'SLOWPOKE': ['Water', 'Psychic'], 'SNUBBULL': ['Normal'],\n    'SPEAROW': ['Normal', 'Flying'], 'SPINARAK': ['Bug', 'Poison'], 'VENONAT': ['Bug', 'Poison'], 'VULPIX': ['Fire'], 'WEEDLE': ['Bug', 'Poison'], 'WOOPER': ['Water', 'Ground'],\n    'ZUBAT': ['Poison', 'Flying']\n}\n\nKNOWN_MOVE_TYPES = {\n    'TACKLE': 'Normal', 'QUICK ATTACK': 'Normal', 'EMBER': 'Fire', 'FLAME WHEEL': 'Fire',\n    'HIDDEN POWER': 'Psychic', 'LEER': 'Normal', 'GROWL': 'Normal', 'CHARM': 'Normal', 'CUT': 'Normal'\n}\n\nSTATUS_MOVES = {'LEER', 'GROWL', 'CHARM'}\n\nTYPE_CHART = {\n    'Fire': {'super_effective': ['Bug', 'Grass'], 'not_very_effective': ['Water', 'Fire', 'Rock', 'Ground'], 'no_effect': []},\n    'Ground': {'super_effective': ['Fire'], 'not_very_effective': [], 'no_effect': []},\n    'Normal': {'super_effective': [], 'not_very_effective': ['Rock', 'Ground'], 'no_effect': ['Ghost']},\n    'Psychic': {'super_effective': [], 'not_very_effective': ['Bug'], 'no_effect': []}\n}\n\n# --- Input Parsing ---\nmy_level = int(input_data['my_pokemon_level'])\nopponent_name = input_data['opponent_pokemon_name']\nopponent_level_str = input_data.get('opponent_pokemon_level')\nopponent_level = int(opponent_level_str) if opponent_level_str and opponent_level_str != 'null' else None\nobjective = input_data['current_objective']\nbattle_type = input_data['battle_type']\nmy_hp_current = int(input_data['my_pokemon_hp_current'])\nmy_hp_max = int(input_data['my_pokemon_hp_max'])\n\nmoves_input = [\n    (input_data.get('move_1_name'), input_data.get('move_1_pp_current')),\n    (input_data.get('move_2_name'), input_data.get('move_2_pp_current')),\n    (input_data.get('move_3_name'), input_data.get('move_3_pp_current')),\n    (input_data.get('move_4_name'), input_data.get('move_4_pp_current'))\n]\n\nmoves = [(name, int(pp)) for name, pp in moves_input if name and pp is not None]\n\n# --- Logic ---\nif battle_type == 'TRAINER':\n    pass\nelif objective == 'TRAINING':\n    if (my_hp_current / my_hp_max) < 0.25:\n        print(json.dumps({'action': 'RUN', 'move_to_use': None}))\n        exit()\nelse: # Traveling\n    if opponent_level is not None and my_level >= opponent_level + 20:\n        pass # Fall through to fight\n    elif opponent_level is None:\n        pass # Level unknown, fall through to effectiveness check\n    else:\n        print(json.dumps({'action': 'RUN', 'move_to_use': None}))\n        exit()\n\n# --- Move Selection ---\nopponent_types = KNOWN_POKEMON_TYPES.get(opponent_name, [])\n\nscored_moves = []\nfor name, pp in moves:\n    if pp == 0 or name in STATUS_MOVES:\n        continue\n\n    move_type = KNOWN_MOVE_TYPES.get(name)\n    if not move_type or not opponent_types:\n        effectiveness = 1.0\n    else:\n        effectiveness = 1.0\n        chart = TYPE_CHART.get(move_type, {})\n        for opp_type in opponent_types:\n            if opp_type in chart.get('super_effective', []): effectiveness *= 2.0\n            if opp_type in chart.get('not_very_effective', []): effectiveness *= 0.5\n            if opp_type in chart.get('no_effect', []): effectiveness *= 0.0\n    \n    scored_moves.append({'name': name, 'pp': pp, 'effectiveness': effectiveness})\n\nif not scored_moves:\n    print(json.dumps({'action': 'RUN', 'move_to_use': None}))\n    exit()\n\nbest_move = sorted(scored_moves, key=lambda x: (x['effectiveness'], x['pp']), reverse=True)[0]\n\nif objective == 'TRAVELING' and best_move['effectiveness'] <= 0.5:\n    print(json.dumps({'action': 'RUN', 'move_to_use': None}))\n    exit()\n\nprint(json.dumps({'action': 'FIGHT', 'move_to_use': best_move['name']}))\n",
    "history": [
      {
        "commit_message": "feat: Create deterministic battle strategist. This tool replaces the unreliable simple_battle_strategist agent, which has been failing due to server errors. It uses a hardcoded type chart and logic to provide a stable and consistent source of battle advice, directly addressing a critical system critique.",
        "timestamp": "2025-11-03T18:25:45.289Z",
        "action_counter": 17503
      },
      {
        "commit_message": "fix: Correctly filter status moves. The previous version had a flawed check that failed to exclude status moves like LEER, causing it to give incorrect battle advice. This commit introduces a dedicated `STATUS_MOVES` set and adds a clear check (`if name in STATUS_MOVES`) to the move evaluation loop, ensuring that only damaging moves are considered. This resolves the critical logic bug.",
        "timestamp": "2025-11-03T18:29:57.269Z",
        "action_counter": 17510
      },
      {
        "commit_message": "fix: Handle null opponent level in wild battles. The script was crashing with a ValueError when `opponent_pokemon_level` was the string 'null'. This commit adds an explicit check for 'null' before attempting integer conversion, preventing the crash and allowing the tool to function correctly in wild encounters where the opponent's level is not displayed.",
        "timestamp": "2025-11-03T19:50:14.395Z",
        "action_counter": 17599
      },
      {
        "commit_message": "feat: Add Sandshrew type and improve run logic. The tool previously recommended fighting a Sandshrew with a Fire-type because it lacked type information and its run logic was too simple. This commit adds 'SANDSHREW' to the `KNOWN_POKEMON_TYPES` dictionary and introduces a new check to automatically run from wild battles when traveling if the best available move is not very effective. This improves strategic decision-making and prevents wasting resources on unfavorable encounters.",
        "timestamp": "2025-11-03T20:58:14.951Z",
        "action_counter": 17685
      },
      {
        "commit_message": "fix: Prevent automatic run when opponent level is unknown. The previous logic would default to 'RUN' during wild encounters where the opponent's level is not displayed, bypassing the more nuanced type-effectiveness check. This commit adds a specific condition to handle `opponent_level` being `None`, allowing the script to fall through to the effectiveness logic and make a more intelligent decision. This resolves the critical failure where the tool recommended running from a battle with a clear type advantage.",
        "timestamp": "2025-11-03T21:39:18.957Z",
        "action_counter": 17743
      },
      {
        "commit_message": "feat: Add Sentret type information. The tool previously failed to identify Sentret as a Normal-type, leading to incorrect move suggestions. This commit adds the correct type data to the knowledge base, resolving the critical failure.",
        "timestamp": "2025-11-07T11:35:18.556Z",
        "action_counter": 25738
      },
      {
        "commit_message": "feat: Add Meowth type information and CUT move type. The tool previously failed to identify Meowth as a Normal-type and did not know CUT was a Normal-type move, leading to incorrect move suggestions. This commit adds the correct type data to the knowledge base, resolving the critical failure.",
        "timestamp": "2025-11-07T12:02:09.021Z",
        "action_counter": 25786
      },
      {
        "commit_message": "feat: Add Snubbull type information. The tool previously failed to identify Snubbull as a Normal-type, leading to incorrect move suggestions. This commit adds the correct type data to the knowledge base, resolving the critical failure.",
        "timestamp": "2025-11-07T12:06:41.622Z",
        "action_counter": 25791
      },
      {
        "commit_message": "feat: Add Jigglypuff type information. The tool previously failed to identify Jigglypuff as a Normal-type, leading to incorrect move suggestions. This commit adds the correct type data to the knowledge base, resolving the critical failure.",
        "timestamp": "2025-11-07T12:18:46.258Z",
        "action_counter": 25807
      },
      {
        "commit_message": "feat: Add Normal-type PokÃ©mon from Goldenrod Gym. The tool failed to identify Meowth, Snubbull, Jigglypuff, Clefairy, and Miltank as Normal-types during the Goldenrod Gym challenge. This commit adds their type information to the knowledge base, resolving these critical failures and improving future battle strategy.",
        "timestamp": "2025-11-07T12:26:47.489Z",
        "action_counter": 25817
      },
      {
        "commit_message": "feat: Add Slowpoke type information. The tool previously failed to identify Slowpoke as a Water/Psychic-type, leading to incorrect move suggestions. This commit adds the correct type data to the knowledge base, resolving this critical failure.",
        "timestamp": "2025-11-07T13:15:22.597Z",
        "action_counter": 25892
      }
    ]
  },
  "find_reachable_unseen_tiles": {
    "description": "Parses the map XML to find unseen tiles and runs a robust pathfinding check for each one to determine which are actually reachable from the player's current position. Returns a list of reachable unseen coordinates.",
    "input_schema": {},
    "python_script": "import sys\nimport json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef find_reachable_unseen_tiles(map_xml_string):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    player_pos = None\n    grid = {}\n    unseen_tiles = []\n    \n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            grid[(x, y)] = tile_elem\n            if tile_elem.find('Player') is not None:\n                player_pos = (x, y)\n            if tile_elem.get('seen') == 'false':\n                unseen_tiles.append((x, y))\n\n    if not player_pos or not unseen_tiles:\n        print(json.dumps([]))\n        return\n\n    impassable_tile_types = {\n        'WALL', 'WATER', 'VOID', 'PC', 'TV', 'COUNTER', 'BOOKSHELF', \n        'TOWN_MAP', 'POKEDEX', 'RADIO', 'PILLAR', 'MART_SHELF', \n        'INCENSE_BURNER', 'CUT_TREE', 'HEADBUTT_TREE'\n    }\n\n    frontier_tiles = set()\n    for unseen_pos in unseen_tiles:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_pos = (unseen_pos[0] + dx, unseen_pos[1] + dy)\n            adj_tile = grid.get(adj_pos)\n            if adj_tile and adj_tile.get('seen') == 'true' and adj_tile.get('type') not in impassable_tile_types:\n                frontier_tiles.add(unseen_pos)\n                break\n    \n    queue = deque([player_pos])\n    reachable_from_player = {player_pos}\n\n    while queue:\n        x, y = queue.popleft()\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = x + dx, y + dy\n\n            if not (1 <= next_x <= width and 1 <= next_y <= height): continue\n            if (next_x, next_y) in reachable_from_player: continue\n\n            tile = grid.get((next_x, next_y))\n            if not tile: continue\n            \n            tile_type = tile.get('type')\n            has_non_player_object = tile.find('Object') is not None and tile.find('Player') is None\n            \n            if tile_type in impassable_tile_types: continue\n            if has_non_player_object: continue\n            \n            current_tile = grid.get((x,y))\n            if not current_tile: continue\n            current_tile_type = current_tile.get('type')\n            \n            if current_tile_type == 'LEDGE_HOP_DOWN' and dy != 1: continue\n            if current_tile_type == 'LEDGE_HOP_LEFT' and dx != -1: continue\n            if current_tile_type == 'LEDGE_HOP_RIGHT' and dx != 1: continue\n\n            if tile_type == 'LEDGE_HOP_DOWN' and dy == -1: continue\n            if tile_type == 'LEDGE_HOP_LEFT' and dx == 1: continue\n            if tile_type == 'LEDGE_HOP_RIGHT' and dx == -1: continue\n\n            reachable_from_player.add((next_x, next_y))\n            queue.append((next_x, next_y))\n\n    truly_reachable_unseen = sorted(list(frontier_tiles.intersection(reachable_from_player)))\n    \n    print(json.dumps([{'x': x, 'y': y} for x, y in truly_reachable_unseen]))\n\nfind_reachable_unseen_tiles(map_xml_string)",
    "history": [
      {
        "commit_message": "feat: Create tool to find reachable unseen tiles. This tool automates the analysis of the 'Potentially Reachable Unseen Tiles' alert by parsing the map, identifying unseen tiles adjacent to known traversable areas, and then running a pathfinding check from the player's position to confirm reachability. This resolves a major strategic bottleneck by turning a vague system alert into a concrete list of actionable exploration targets.",
        "timestamp": "2025-11-08T15:54:36.893Z",
        "action_counter": 28534
      },
      {
        "commit_message": "feat: Create tool to find reachable unseen tiles. This tool automates the analysis of the 'Potentially Reachable Unseen Tiles' alert by parsing the map, identifying unseen tiles adjacent to known traversable areas, and then running a pathfinding check from the player's position to confirm reachability. This resolves a major strategic bottleneck by turning a vague system alert into a concrete list of actionable exploration targets.",
        "timestamp": "2025-11-08T16:24:49.677Z",
        "action_counter": 28585
      },
      {
        "commit_message": "fix: Integrate robust pathfinding logic. The tool was incorrectly identifying unseen tiles as reachable because its adjacency check did not account for complex obstacles like ledges, water, or impassable objects. This commit replaces the faulty logic with the proven pathfinding algorithm from the path_and_execute tool. Now, each unseen tile's reachability is confirmed with a full path check from the player's position, resolving the critical failure where the tool provided false exploration targets.",
        "timestamp": "2025-11-08T20:10:37.867Z",
        "action_counter": 28981
      },
      {
        "commit_message": "fix: Overhaul logic to prevent timeouts on large maps. The previous implementation attempted to pathfind to every single unseen tile, which was computationally infeasible on large, open maps like the National Park. This commit introduces a multi-step approach: 1. It identifies a 'frontier' of unseen tiles that are directly adjacent to already seen, traversable tiles. 2. It performs a single, efficient BFS from the player's position to map out all reachable tiles. 3. It takes the intersection of these two sets to find the final list of truly reachable unseen tiles. This drastically reduces the computational load and resolves the critical timeout failure.",
        "timestamp": "2025-11-08T21:10:10.880Z",
        "action_counter": 29106
      },
      {
        "commit_message": "fix: Integrate robust pathfinding logic. The tool was incorrectly identifying unseen tiles as reachable because its adjacency check did not account for complex obstacles like NPCs, walls, or one-way tiles. This commit replaces the faulty logic with the proven, robust pathfinding algorithm from the `path_and_execute_v2` tool. Now, a single BFS is run from the player's position to map all truly reachable tiles, and this is intersected with the potential unseen 'frontier' tiles. This ensures the tool only outputs unseen tiles that are verifiably reachable, resolving the critical failure where it provided false exploration targets.",
        "timestamp": "2025-11-09T08:17:19.021Z",
        "action_counter": 30315
      }
    ]
  },
  "path_and_execute_v2": {
    "description": "Generates a path to a target coordinate. Replaces the broken path_and_execute tool.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport sys\nfrom collections import deque\n\ndef path_and_execute(target_x_str, target_y_str):\n    target_x = int(target_x_str)\n    target_y = int(target_y_str)\n\n    try:\n        root = ET.fromstring(map_xml_string)\n    except ET.ParseError as e:\n        print(f\"Error parsing map_xml_string: {e}\", file=sys.stderr)\n        return\n\n    map_width = int(root.get('width'))\n    map_height = int(root.get('height'))\n    \n    player_pos = None\n    grid = {}\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            grid[(x, y)] = tile_elem\n            if tile_elem.find('Player') is not None:\n                player_pos = (x, y)\n\n    if not player_pos:\n        print(\"Player position not found on the map.\", file=sys.stderr)\n        return\n\n    start_x, start_y = player_pos\n\n    impassable_tile_types = {\n        'WALL', 'WATER', 'VOID', 'PC', 'TV', 'COUNTER', 'BOOKSHELF', \n        'TOWN_MAP', 'POKEDEX', 'RADIO', 'PILLAR', 'MART_SHELF', \n        'INCENSE_BURNER', 'CUT_TREE', 'HEADBUTT_TREE'\n    }\n    \n    target_impassable_types = impassable_tile_types.union({'WARP_CARPET_RIGHT', 'WARP_CARPET_LEFT', 'WARP_CARPET_UP', 'WARP_CARPET_DOWN', 'DOOR', 'CAVE', 'LADDER'})\n\n\n    original_target_coords = (target_x, target_y)\n    target_tile = grid.get((target_x, target_y))\n    target_is_impassable = False\n    \n    if target_tile is not None:\n        tile_type = target_tile.get('type')\n        seen = target_tile.get('seen') == 'true'\n        has_non_player_object = target_tile.find('Object') is not None and target_tile.find('Player') is None\n        \n        if tile_type in target_impassable_types or has_non_player_object or not seen:\n            target_is_impassable = True\n\n    if target_is_impassable:\n        found_new_target = False\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = original_target_coords[0] + dx, original_target_coords[1] + dy\n            if (nx, ny) == player_pos:\n                continue\n            if 1 <= nx <= map_width and 1 <= ny <= map_height:\n                adj_tile = grid.get((nx, ny))\n                if adj_tile is not None:\n                    adj_type = adj_tile.get('type')\n                    adj_seen = adj_tile.get('seen') == 'true'\n                    adj_has_object = adj_tile.find('Object') is not None\n                    if adj_type not in impassable_tile_types and not adj_has_object and adj_seen:\n                        target_x, target_y = nx, ny\n                        found_new_target = True\n                        break\n        if not found_new_target:\n            print(f\"Target ({original_target_coords[0]}, {original_target_coords[1]}) is impassable and no valid adjacent tile found.\", file=sys.stderr)\n            return\n\n    queue = deque([(start_x, start_y)])\n    visited = set([(start_x, start_y)])\n    parent_map = { (start_x, start_y): None }\n\n    path_found = False\n    while queue:\n        x, y = queue.popleft()\n\n        if (x, y) == (target_x, target_y):\n            path = []\n            curr = (x, y)\n            while curr is not None:\n                path.append(curr)\n                curr = parent_map[curr]\n            path.reverse()\n            path_of_moves = path[1:]\n            print(json.dumps([{\"x\": px, \"y\": py} for px, py in path_of_moves]))\n            path_found = True\n            break\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = x + dx, y + dy\n\n            if not (1 <= next_x <= map_width and 1 <= next_y <= map_height):\n                continue\n            if (next_x, next_y) in visited:\n                continue\n\n            tile = grid.get((next_x, next_y))\n            if tile is None:\n                continue\n            \n            tile_type = tile.get('type')\n            seen = tile.get('seen') == 'true'\n            has_non_player_object = tile.find('Object') is not None and tile.find('Player') is None\n            \n            is_target_tile = (next_x, next_y) == (target_x, target_y)\n\n            if not seen and not is_target_tile:\n                continue\n            if tile_type in impassable_tile_types:\n                continue\n            if has_non_player_object:\n                continue\n\n            current_tile = grid.get((x, y))\n            if current_tile is None: continue\n            current_tile_type = current_tile.get('type')\n\n            if current_tile_type == 'LEDGE_HOP_DOWN' and dy != 1:\n                 continue\n            if current_tile_type == 'LEDGE_HOP_LEFT' and dx != -1:\n                 continue\n            if current_tile_type == 'LEDGE_HOP_RIGHT' and dx != 1:\n                 continue\n\n            if tile_type == 'LEDGE_HOP_DOWN' and dy == -1:\n                continue\n            if tile_type == 'LEDGE_HOP_LEFT' and dx == 1:\n                continue\n            if tile_type == 'LEDGE_HOP_RIGHT' and dx == -1:\n                continue\n\n            visited.add((next_x, next_y))\n            parent_map[(next_x, next_y)] = (x, y)\n            queue.append((next_x, next_y))\n    \n    if not path_found:\n        print(f\"No path found to ({target_x}, {target_y}) from ({start_x}, {start_y})\", file=sys.stderr)\n\npath_and_execute(input_data['target_x'], input_data['target_y'])",
    "history": [
      {
        "commit_message": "feat: Create v2 of pathfinding tool to break debugging loop. The original `path_and_execute` is fundamentally broken and cannot be updated. This new tool implements the proven-working script from `run_code` diagnostics to provide a reliable navigation command, directly addressing a critical process failure identified by overwatch.",
        "timestamp": "2025-11-09T08:50:14.589Z",
        "action_counter": 30374
      },
      {
        "commit_message": "fix: Prevent pathfinder from selecting player's start tile as an alternative target. The tool was failing when the target was impassable and the only valid adjacent tile was the one the player was already standing on. This commit adds a check to explicitly ignore the player's starting position when searching for a new target, resolving the critical failure that produced empty or incorrect paths.",
        "timestamp": "2025-11-09T10:12:37.884Z",
        "action_counter": 30507
      },
      {
        "commit_message": "fix: Add warp tile types to impassable target list. The tool was failing to path to warps because it treated them as valid destinations, but the tiles themselves are not pathable. This commit adds all known warp tile types to a separate list used only for checking the final target, forcing the algorithm to find a valid adjacent tile. This resolves the critical pathfinding failure.",
        "timestamp": "2025-11-09T11:57:09.418Z",
        "action_counter": 30663
      },
      {
        "commit_message": "fix: Add comprehensive ledge navigation logic. The pathfinder previously failed to route over one-way ledges. This commit introduces directional checks for all `LEDGE_HOP` tile types, allowing movement *off* a ledge in the correct direction and preventing movement *onto* a ledge from the wrong direction. This resolves the critical pathfinding failure on routes with complex ledge puzzles.",
        "timestamp": "2025-11-09T12:39:50.330Z",
        "action_counter": 30721
      }
    ]
  },
  "path_and_execute_v3": {
    "description": "Generates a path to a target coordinate, with an option to ignore specific object IDs (e.g., non-blocking NPCs).",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        },
        "ignore_object_ids": {
          "type": "string",
          "description": "A JSON string of a list of object IDs to ignore as obstacles."
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport sys\nfrom collections import deque\n\ndef path_and_execute(target_x_str, target_y_str, ignore_object_ids_str):\n    target_x = int(target_x_str)\n    target_y = int(target_y_str)\n    \n    ignore_ids = set()\n    if ignore_object_ids_str:\n        try:\n            ignore_ids = set(json.loads(ignore_object_ids_str))\n        except (json.JSONDecodeError, TypeError):\n            pass\n\n    try:\n        root = ET.fromstring(map_xml_string)\n    except ET.ParseError as e:\n        return f\"Error parsing map_xml_string: {e}\"\n\n    map_width = int(root.get('width'))\n    map_height = int(root.get('height'))\n    \n    player_pos = None\n    grid = {}\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            grid[(x, y)] = tile_elem\n            if tile_elem.find('Player') is not None:\n                player_pos = (x, y)\n\n    if not player_pos:\n        print(\"Player position not found on the map.\")\n        return\n\n    start_x, start_y = player_pos\n\n    impassable_tile_types = {\n        'WALL', 'WATER', 'VOID', 'PC', 'TV', 'COUNTER', 'BOOKSHELF', \n        'TOWN_MAP', 'POKEDEX', 'RADIO', 'PILLAR', 'MART_SHELF', \n        'INCENSE_BURNER', 'CUT_TREE', 'HEADBUTT_TREE'\n    }\n\n    original_target_coords = (target_x, target_y)\n    target_tile = grid.get((target_x, target_y))\n    target_is_impassable = False\n    \n    if target_tile is not None:\n        tile_type = target_tile.get('type')\n        seen = target_tile.get('seen') == 'true'\n        object_elem = target_tile.find('Object')\n        has_non_player_object = False\n        if object_elem is not None and target_tile.find('Player') is None:\n            obj_id_str = object_elem.get('id')\n            if not (obj_id_str and int(obj_id_str) in ignore_ids):\n                has_non_player_object = True\n        \n        if tile_type in impassable_tile_types or has_non_player_object or not seen:\n            target_is_impassable = True\n\n    if target_is_impassable:\n        found_new_target = False\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = original_target_coords[0] + dx, original_target_coords[1] + dy\n            if 0 <= nx < map_width and 0 <= ny < map_height:\n                adj_tile = grid.get((nx, ny))\n                if adj_tile is not None:\n                    adj_type = adj_tile.get('type')\n                    adj_seen = adj_tile.get('seen') == 'true'\n                    adj_obj_elem = adj_tile.find('Object')\n                    adj_has_object = False\n                    if adj_obj_elem is not None:\n                         obj_id_str = adj_obj_elem.get('id')\n                         if not (obj_id_str and int(obj_id_str) in ignore_ids):\n                            adj_has_object = True\n                    if adj_type not in impassable_tile_types and not adj_has_object and adj_seen:\n                        target_x, target_y = nx, ny\n                        found_new_target = True\n                        break\n        if not found_new_target:\n            print(f\"Target ({original_target_coords[0]}, {original_target_coords[1]}) is impassable and no valid adjacent tile found.\")\n            return\n\n    queue = deque([(start_x, start_y)])\n    visited = set([(start_x, start_y)])\n    parent_map = { (start_x, start_y): None }\n\n    while queue:\n        x, y = queue.popleft()\n\n        if (x, y) == (target_x, target_y):\n            path = []\n            curr = (x, y)\n            while curr is not None:\n                path.append(curr)\n                curr = parent_map[curr]\n            path.reverse()\n            path_of_moves = path[1:]\n            print(json.dumps([{\"x\": px, \"y\": py} for px, py in path_of_moves]))\n            return\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = x + dx, y + dy\n\n            if not (0 <= next_x < map_width and 0 <= next_y < map_height): continue\n            if (next_x, next_y) in visited: continue\n\n            tile = grid.get((next_x, next_y))\n            if tile is None: continue\n            \n            tile_type = tile.get('type')\n            seen = tile.get('seen') == 'true'\n            object_elem = tile.find('Object')\n            has_non_player_object = False\n            if object_elem is not None and tile.find('Player') is None:\n                obj_id_str = object_elem.get('id')\n                if not (obj_id_str and int(obj_id_str) in ignore_ids):\n                    has_non_player_object = True\n            \n            is_target_tile = (next_x, next_y) == (target_x, target_y)\n\n            if not seen and not is_target_tile: continue\n            if tile_type in impassable_tile_types: continue\n            if has_non_player_object: continue\n\n            current_tile = grid.get((x, y))\n            if current_tile is None: continue\n            current_tile_type = current_tile.get('type')\n\n            if current_tile_type == 'LEDGE_HOP_DOWN' and dy != 1: continue\n            if current_tile_type == 'LEDGE_HOP_LEFT' and dx != -1: continue\n            if current_tile_type == 'LEDGE_HOP_RIGHT' and dx != 1: continue\n\n            if tile_type == 'LEDGE_HOP_DOWN' and dy == -1: continue\n            if tile_type == 'LEDGE_HOP_LEFT' and dx == 1: continue\n            if tile_type == 'LEDGE_HOP_RIGHT' and dx == -1: continue\n            if tile_type == 'FLOOR_UP_WALL' and dy == 1: continue\n\n            visited.add((next_x, next_y))\n            parent_map[(next_x, next_y)] = (x, y)\n            queue.append((next_x, next_y))\n\n    print(f\"No path found to ({target_x}, {target_y}) from ({start_x}, {start_y})\")\n\npath_and_execute(input_data['target_x'], input_data['target_y'], input_data.get('ignore_object_ids'))",
    "history": [
      {
        "commit_message": "feat: Add `ignore_object_ids` parameter. This allows the pathfinder to treat specified object IDs as traversable, resolving a critical failure where it was blocked by non-hostile, dialogue-only NPCs. The parameter is a JSON string of a list of integers.",
        "timestamp": "2025-11-09T09:44:25.515Z",
        "action_counter": 30458
      },
      {
        "commit_message": "refactor: Add extensive debug logging to diagnose pathing failure. The tool is failing to find a simple, verifiable path. This commit adds print statements to the BFS loop to trace the algorithm's state and identify why valid neighbor tiles are being rejected.",
        "timestamp": "2025-11-09T15:52:46.499Z",
        "action_counter": 31015
      },
      {
        "commit_message": "fix: Correct critical coordinate system mismatch. The tool was using 1-based indexing for bounds checking (e.g., 1 to width), while the map data is 0-based (0 to width-1). This caused the pathfinder to incorrectly reject valid coordinates at the map's edge, such as y=0, as 'out of bounds'. This commit updates all boundary checks to use the correct 0-based indexing, resolving the persistent pathfinding failures.",
        "timestamp": "2025-11-09T15:54:23.913Z",
        "action_counter": 31018
      },
      {
        "commit_message": "fix: Add logic for FLOOR_UP_WALL tile. The pathfinder was failing because it did not account for the one-way nature of FLOOR_UP_WALL tiles. This commit adds a condition to prevent the algorithm from planning a path that moves down onto this tile type, resolving the critical navigation failure.",
        "timestamp": "2025-11-09T17:01:28.370Z",
        "action_counter": 31108
      }
    ]
  },
  "auto_clear_dialogue": {
    "description": "A tool to automatically press 'A' to clear any on-screen dialogue, like phone calls. Should be set to autopress.",
    "input_schema": {},
    "python_script": "import json\nprint(json.dumps(['A'] * 20))",
    "history": [
      {
        "commit_message": "feat: Create tool to automate clearing dialogue boxes. This tool will repeatedly press the 'A' button to speed through unwanted dialogue, such as nuisance phone calls, improving gameplay efficiency.",
        "timestamp": "2025-11-09T16:45:00.036Z",
        "action_counter": 31087
      }
    ]
  }
}