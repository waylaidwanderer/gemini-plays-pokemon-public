{
  "find_path": {
    "description": "Finds a path from a start to an end coordinate on the current map using the A* algorithm.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef find_path_logic(map_xml_string, start_x, start_y, end_x, end_y):\n    root = ET.fromstring(map_xml_string)\n    IMPASSABLE_TILES = {\"WALL\", \"WATER\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"COUNTER\", \"TV\", \"BOOKSHELF\", \"RADIO\", \"TOWN_MAP\", \"WINDOW\", \"PC\"}\n    \n    grid = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            has_object = tile_elem.find('Object') is not None and tile_elem.find('Player') is None\n            is_impassable = tile_type in IMPASSABLE_TILES or has_object or tile_type == 'unseen'\n            grid[(x, y)] = not is_impassable\n\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n\n    if not grid.get(end_node, False):\n        found_alternate = False\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            temp_end = (end_node[0] + dx, end_node[1] + dy)\n            if grid.get(temp_end, False):\n                end_node = temp_end\n                found_alternate = True\n                break\n        if not found_alternate:\n            return None\n\n    g_score = {node: float('inf') for node in grid}\n    g_score[start_node] = 0\n    f_score = {node: float('inf') for node in grid}\n    f_score[start_node] = heuristic(start_node, end_node)\n\n    open_set = [(f_score[start_node], start_node)]\n    came_from = {}\n    open_set_hash = {start_node}\n\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        open_set_hash.remove(current)\n\n        if current == end_node:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start_node)\n            return path[::-1]\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not grid.get(neighbor, False):\n                continue\n\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + heuristic(neighbor, end_node)\n                if neighbor not in open_set_hash:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n                    open_set_hash.add(neighbor)\n    return None\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\npath = find_path_logic(map_xml_string, start_x, start_y, end_x, end_y)\nif path:\n    print(json.dumps([{\"x\": p[0], \"y\": p[1]} for p in path]))\nelse:\n    print(\"No path found.\")\n",
    "history": [
      {
        "commit_message": "feat: Re-implement find_path tool from scratch. This is a complete rewrite of the A* algorithm to establish a simple, correct, and reliable foundation for navigation. This version handles basic impassable tiles and objects but omits complex logic for ledges and other special tiles, which will be added back incrementally after this core logic is proven to be stable. This action is a direct response to repeated tool failures and strategic critiques.",
        "timestamp": "2025-11-21T16:47:36.389Z",
        "action_counter": 4881
      },
      {
        "commit_message": "fix: Re-commit find_path tool. A debug trace via run_code confirmed the algorithm's logic is correct. The previous failure was likely due to a transient error during the initial tool definition. This commit re-establishes the known-good code to ensure reliable pathfinding.",
        "timestamp": "2025-11-21T16:49:59.218Z",
        "action_counter": 4886
      },
      {
        "commit_message": "fix: Add 'PC' to the set of impassable tiles. The pathfinder was incorrectly treating PC tiles as traversable, causing it to get stuck in an alcove in the Pokecenter2F. This fix correctly blocks paths through PCs.",
        "timestamp": "2025-11-21T17:02:02.801Z",
        "action_counter": 4915
      },
      {
        "commit_message": "refactor: Complete rewrite of the A* algorithm. The previous implementation had a persistent, subtle bug causing intermittent failures. This version is a textbook implementation, focusing on core correctness and removing complex logic like ledge handling for now. This establishes a reliable foundation to build upon.",
        "timestamp": "2025-11-21T17:03:13.635Z",
        "action_counter": 4917
      },
      {
        "commit_message": "fix: Correct A* open_set initialization. The open_set was being initialized with an f_score of 0 instead of the correct heuristic value, causing the algorithm to fail on complex paths. This fix ensures the starting node is correctly prioritized.",
        "timestamp": "2025-11-21T17:04:12.483Z",
        "action_counter": 4919
      },
      {
        "commit_message": "fix: Correct g_score lookup in A* algorithm. The g_score for the current node was being retrieved with a default value, which could lead to incorrect path costs. This fix ensures the g_score is always retrieved directly from the dictionary, preventing this potential bug.",
        "timestamp": "2025-11-21T17:11:15.358Z",
        "action_counter": 4933
      },
      {
        "commit_message": "fix: Correct g_score lookup in A* algorithm. The g_score for the current node was still being retrieved with a default value, which was incorrect and caused pathing failures. This fix ensures the g_score is always retrieved directly from the dictionary.",
        "timestamp": "2025-11-21T17:15:48.132Z",
        "action_counter": 4942
      }
    ]
  },
  "find_reachable_unseen_tiles": {
    "description": "Analyzes the current map to find all 'unseen' tiles that are adjacent to traversable tiles and reachable from the player's current position. Returns a list of coordinates for these tiles.",
    "input_schema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\nroot = ET.fromstring(map_xml_string)\nIMPASSABLE_TILES = {\"WALL\", \"WATER\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"COUNTER\", \"TV\", \"BOOKSHELF\", \"RADIO\", \"TOWN_MAP\", \"WINDOW\", \"PC\"}\n\ngrid = {}\nunseen_tiles = []\nplayer_start = None\n\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.get('id'))\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.get('id'))\n        tile_type = tile_elem.get('type')\n        \n        if tile_elem.find('Player') is not None:\n            player_start = (x, y)\n        \n        if tile_type == 'unseen':\n            unseen_tiles.append((x, y))\n        \n        has_object = tile_elem.find('Object') is not None and tile_elem.find('Player') is None\n        is_impassable = tile_type in IMPASSABLE_TILES or has_object\n        grid[(x, y)] = not is_impassable\n\nif not player_start:\n    print(json.dumps([]))\nelse:\n    potential_targets = set()\n    for ux, uy in unseen_tiles:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (ux + dx, uy + dy)\n            if grid.get(neighbor, False):\n                potential_targets.add(neighbor)\n\n    reachable_unseen_coords = set()\n    for target in potential_targets:\n        queue = deque([player_start])\n        visited = {player_start}\n        path_found = False\n        \n        while queue:\n            current_pos = queue.popleft()\n            \n            if current_pos == target:\n                path_found = True\n                break\n                \n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n                if grid.get(next_pos, False) and next_pos not in visited:\n                    visited.add(next_pos)\n                    queue.append(next_pos)\n        \n        if path_found:\n            tx, ty = target\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                neighbor = (tx + dx, ty + dy)\n                if neighbor in unseen_tiles:\n                    reachable_unseen_coords.add(neighbor)\n\n    print(json.dumps(sorted(list(reachable_unseen_coords))))",
    "history": [
      {
        "commit_message": "feat: Create tool to find reachable unseen tiles. This tool automates the process of identifying explorable areas by parsing the map, finding all unseen tiles, and using a BFS pathfinder to determine which ones are currently reachable from the player's position. This directly addresses a recurring system suggestion and will improve exploration efficiency.",
        "timestamp": "2025-11-21T18:40:14.393Z",
        "action_counter": 5140
      }
    ]
  }
}