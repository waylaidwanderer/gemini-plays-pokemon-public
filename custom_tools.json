{
  "object_finder": {
    "description": "Finds a specific map object by its ID and returns its coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "object_id": {
          "type": "string"
        }
      },
      "required": [
        "object_id"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntarget_id = input_data['object_id']\nroot = ET.fromstring(map_xml_string)\nfound = False\nfor row in root.findall('Row'):\n    y = row.get('id')\n    for tile in row.findall('Tile'):\n        x = tile.get('id')\n        for obj in tile.findall('Object'):\n            if obj.get('id') == target_id:\n                print(json.dumps({'x': x, 'y': y}))\n                found = True\n                break\n        if found:\n            break\n    if found:\n        break\n\nif not found:\n    print(json.dumps({'error': 'Object not found on screen.'}))"
  },
  "warp_scanner": {
    "description": "Scans the current map XML and returns the coordinates of all warp tiles that do not have a map marker.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    unmarked_warps = []\n    for row_elem in root.findall('Row'):\n        for tile_elem in row_elem.findall('Tile'):\n            is_warp = tile_elem.find('Warp') is not None\n            has_marker = tile_elem.find('Marker') is not None\n            \n            if is_warp and not has_marker:\n                x = int(tile_elem.get('id'))\n                y = int(row_elem.get('id'))\n                unmarked_warps.append([x, y])\n                \n    print(json.dumps({\"unmarked_warps\": unmarked_warps, \"error\": None}))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({\"unmarked_warps\": [], \"error\": f\"An exception occurred: {str(e)}\\n{traceback.format_exc()}\"}))"
  },
  "pathfinder_v23": {
    "description": "A stateful pathfinder that finds routes across land and water. Can be configured to avoid water if Surf is unavailable.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string",
          "nullable": true
        },
        "end_y": {
          "type": "string",
          "nullable": true
        },
        "can_surf": {
          "type": "boolean",
          "default": true
        },
        "avoid_coords": {
          "type": "array",
          "items": {
            "type": "array",
            "items": {
              "type": "integer"
            }
          },
          "nullable": true
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport heapq\n\ndef parse_map(map_xml_string):\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    all_impassable_coords = set()\n    impassable_marker_emojis = {'üìç', 'üöÄ', 'üë¶', 'üë©‚Äçüè´', 'üë¥', '‚öîÔ∏è', 'üí∞', 'üé£', 'üòé', 'üéÅ', '‚ùì', 'ü§ì', 'üö´'}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            grid[(x, y)] = {'type': tile_elem.get('type')}\n            if tile_elem.find('Object') is not None:\n                all_impassable_coords.add((x, y))\n            for marker_elem in tile_elem.findall('Marker'):\n                if marker_elem.get('emoji') in impassable_marker_emojis:\n                    all_impassable_coords.add((x, y))\n    return grid, all_impassable_coords\n\ndef get_neighbors_with_state(grid, pos, is_surfing_now, can_surf_ability):\n    neighbors = []\n    (x, y) = pos\n    current_type = grid.get(pos, {}).get('type')\n    traversable_land = {'FLOOR', 'LADDER', 'STAIRCASE', 'DOOR', 'CAVE', 'GRASS', 'TALL_GRASS', 'LONG_GRASS', 'WARP_CARPET_RIGHT', 'WARP_CARPET_LEFT', 'WARP_CARPET_DOWN'}\n    impassable_types = {\n        'WALL', 'HEADBUTT_TREE', 'PILLAR', 'BOOKSHELF', 'TV', 'RADIO', 'TOWN_MAP', 'WINDOW', 'STATUE', 'TABLE', 'CHAIR', 'BIRD', \n        'MART_SHELF', 'BUOY', 'PC', 'LINK_CABLE', 'TRADE_MACHINE', 'INCENSE_BURNER', 'COUNTER', 'ROOF', 'CHIMNEY', 'SIGN', \n        'FLOWER', 'TREE_TOP', 'WATER_EDGE_UP', 'WATER_EDGE_DOWN', 'WATER_EDGE_LEFT', 'WATER_EDGE_RIGHT', 'VOID', 'PIT', 'CUT_TREE'\n    }\n    if not can_surf_ability:\n        impassable_types.add('WATER')\n\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n        next_pos = (x + dx, y + dy)\n        if next_pos not in grid:\n            continue\n        \n        next_type = grid[next_pos]['type']\n        if next_type in impassable_types:\n            continue\n\n        # Ledge logic\n        if next_type == 'LEDGE_HOP_DOWN' and dy == -1: continue # Can't move UP onto a DOWN ledge\n        if current_type == 'LEDGE_HOP_DOWN' and dy != 1: continue # Can only move DOWN off a DOWN ledge\n        if next_type == 'FLOOR_UP_WALL' and current_type not in ['FLOOR_UP_WALL'] and dy != -1: continue\n\n        cost = 1\n        if is_surfing_now:\n            if next_type in traversable_land or next_type == 'LEDGE_HOP_DOWN':\n                neighbors.append((next_pos, False, cost + 1))\n            elif next_type == 'WATER':\n                neighbors.append((next_pos, True, cost))\n        else:  # Not surfing\n            if next_type in traversable_land or (current_type == 'FLOOR_UP_WALL' and next_type in traversable_land) or next_type == 'LEDGE_HOP_DOWN':\n                neighbors.append((next_pos, False, cost))\n            elif next_type == 'WATER' and can_surf_ability:\n                neighbors.append((next_pos, True, cost + 1))\n    return neighbors\n\ndef find_path_astar_stateful(grid, start, end, all_impassable, avoid_coords_set, can_surf_ability):\n    start_type = grid.get(start, {}).get('type')\n    start_is_surfing = (start_type == 'WATER')\n    \n    open_set = [(0, start, start_is_surfing)]\n    came_from = {}\n    g_score = {(start, start_is_surfing): 0}\n\n    while open_set:\n        _, current_pos, is_surfing = heapq.heappop(open_set)\n\n        if current_pos == end:\n            path = []\n            state = (current_pos, is_surfing)\n            while state in came_from:\n                path.append(state[0])\n                state = came_from[state]\n            path.append(start)\n            return path[::-1], None\n\n        for neighbor_pos, next_is_surfing, cost in get_neighbors_with_state(grid, current_pos, is_surfing, can_surf_ability):\n            if neighbor_pos in all_impassable or neighbor_pos in avoid_coords_set:\n                continue\n\n            tentative_g_score = g_score.get((current_pos, is_surfing), float('inf')) + cost\n            if tentative_g_score < g_score.get((neighbor_pos, next_is_surfing), float('inf')):\n                came_from[(neighbor_pos, next_is_surfing)] = (current_pos, is_surfing)\n                g_score[(neighbor_pos, next_is_surfing)] = tentative_g_score\n                f_score = tentative_g_score + abs(neighbor_pos[0] - end[0]) + abs(neighbor_pos[1] - end[1])\n                heapq.heappush(open_set, (f_score, neighbor_pos, next_is_surfing))\n                \n    return None, f'No path found from {start} to {end}.'\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    can_surf_ability = str(input_data.get('can_surf', 'true')).lower() == 'true'\n    avoid_coords_raw = json.loads(input_data.get('avoid_coords', '[]'))\n    avoid_coords_set = set(tuple(c) for c in avoid_coords_raw) if avoid_coords_raw else set()\n    grid, all_impassable = parse_map(map_xml_string)\n    start_pos = (start_x, start_y)\n\n    end_x_str = input_data.get('end_x')\n    end_y_str = input_data.get('end_y')\n\n    if end_x_str is None or end_y_str is None:\n        path, error = None, 'explore_unseen is not yet supported.'\n    else:\n        end_pos = (int(end_x_str), int(end_y_str))\n        path, error = find_path_astar_stateful(grid, start_pos, end_pos, all_impassable, avoid_coords_set, can_surf_ability)\n\n    path_coords = [[p[0], p[1]] for p in path] if path else []\n    print(json.dumps({'path': path_coords, 'error': error}))\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'path': [], 'error': f'An exception occurred: {str(e)}\\n{traceback.format_exc()}'}))"
  }
}