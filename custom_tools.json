{
  "find_adjacent_traversable_tiles": {
    "description": "Takes a target coordinate and finds all adjacent (non-diagonal) tiles that are traversable, returning them as a list of coordinates. This is useful for finding valid spots to stand when trying to interact with an object or NPC.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntry:\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n\n    root = ET.fromstring(map_xml_string)\n    \n    impassable_types = {\n        'WALL', 'VOID', 'WATER', 'BOOKSHELF', 'COUNTER', 'CUT_TREE',\n        'HEADBUTT_TREE', 'MART_SHELF', 'PC', 'PILLAR', 'RADIO', 'TOWN_MAP',\n        'TV', 'WINDOW'\n    }\n\n    grid = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            has_object = tile_elem.find('Object') is not None\n            \n            is_impassable = (tile_type in impassable_types) or has_object\n            grid[(x, y)] = not is_impassable\n\n    adjacent_traversable = []\n    for dx, dy, direction in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n        nx, ny = target_x + dx, target_y + dy\n        neighbor_coord = (nx, ny)\n\n        if grid.get(neighbor_coord, False):\n            adjacent_traversable.append({'x': nx, 'y': ny, 'direction_from_target': direction})\n            \n    print(json.dumps(adjacent_traversable))\n\nexcept Exception as e:\n    print(json.dumps({\"error\": str(e)}))",
    "history": [
      {
        "commit_message": "feat: Create tool to find valid interaction spots. This tool, `find_adjacent_traversable_tiles`, replaces the functionality of the deleted `hypothesis_generator` agent. It deterministically parses the map XML to find all valid, traversable tiles adjacent to a target coordinate. This provides a reliable method for generating testable puzzle hypotheses and directly addresses the system critique regarding the faulty agent.",
        "timestamp": "2025-10-31T11:18:33.232Z",
        "action_counter": 10203
      }
    ]
  },
  "generate_path_plan": {
    "description": "Generates a sequence of coordinates to navigate from the player's current position to a target coordinate.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        },
        "object_locations_json": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\nimport json\nimport sys\n\ndef find_path_to_target_bfs(start_x_str, start_y_str, target_x_str, target_y_str, object_locations_json_str, map_xml_string):\n    start_x, start_y = int(start_x_str), int(start_y_str)\n    target_x, target_y = int(target_x_str), int(target_y_str)\n\n    try:\n        root = ET.fromstring(map_xml_string)\n    except ET.ParseError:\n        print(json.dumps([]))\n        return\n\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    map_id = root.get('id')\n\n    grid = [[1 for _ in range(width)] for _ in range(height)]\n    impassable_types = {'WALL', 'WATER', 'COUNTER', 'MART_SHELF', 'PC', 'TV', 'BOOKSHELF', 'RADIO', 'TOWN_MAP', 'WINDOW', 'CUT_TREE', 'HEADBUTT_TREE'}\n    warp_types = {'CAVE', 'DOOR', 'STAIRCASE', 'LADDER', 'WARP_CARPET_DOWN', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT'}\n    ledge_types = {'LEDGE_HOP_DOWN', 'LEDGE_HOP_LEFT', 'LEDGE_HOP_RIGHT'}\n    floor_up_wall_type = 'FLOOR_UP_WALL'\n    \n    tile_data = {}\n    for row_elem in root.findall('Row'):\n        y_xml = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x_xml = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            \n            if 0 <= x_xml < width and 0 <= y_xml < height:\n                tile_data[(x_xml, y_xml)] = tile_type\n                if tile_type not in impassable_types and tile_type not in warp_types:\n                    grid[y_xml][x_xml] = 0\n\n    if object_locations_json_str and object_locations_json_str != 'null':\n        try:\n            object_locations = json.loads(object_locations_json_str)\n            if isinstance(object_locations, dict):\n                for obj_id, coords in object_locations.items():\n                    if isinstance(coords, list) and len(coords) == 2:\n                        ox, oy = int(coords[0]), int(coords[1])\n                        if 0 <= ox < width and 0 <= oy < height:\n                            grid[oy][ox] = 1\n        except (json.JSONDecodeError, TypeError): pass\n\n    if not (0 <= start_x < width and 0 <= start_y < height and 0 <= target_x < width and 0 <= target_y < height):\n        print(json.dumps([]))\n        return\n\n    queue = collections.deque([[(start_x, start_y)]])\n    visited = {(start_x, start_y)}\n\n    final_target = (target_x, target_y)\n    if grid[target_y][target_x] == 1:\n        adj_tiles = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = target_x + dx, target_y + dy\n            if 0 <= nx < width and 0 <= ny < height and grid[ny][nx] == 0:\n                adj_tiles.append((nx, ny))\n        if not adj_tiles:\n            print(json.dumps([]))\n            return\n        adj_tiles.sort(key=lambda p: (p[0] - start_x)**2 + (p[1] - start_y)**2)\n        final_target = adj_tiles[0]\n    \n    if (start_x, start_y) == final_target:\n        print(json.dumps([{\"x\": start_x, \"y\": start_y}]))\n        return\n\n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n\n        if (x, y) == final_target:\n            print(json.dumps([{\"x\": px, \"y\": py} for px, py in path]))\n            return\n\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = x + dx, y + dy\n            neighbor = (nx, ny)\n\n            if not (0 <= nx < width and 0 <= ny < height) or neighbor in visited or grid[ny][nx] == 1:\n                continue\n\n            current_tile_type = tile_data.get((x, y))\n            neighbor_tile_type = tile_data.get(neighbor)\n\n            # Prevent moving onto a ledge from a non-ledge tile (i.e., you can't jump \"up\" a ledge)\n            if neighbor_tile_type in ledge_types and current_tile_type not in ledge_types:\n                continue\n\n            # If standing on a ledge, only allow movement in the specified direction\n            if current_tile_type in ledge_types:\n                if (current_tile_type == 'LEDGE_HOP_DOWN' and dy != 1) or \\\n                   (current_tile_type == 'LEDGE_HOP_LEFT' and dx != -1) or \\\n                   (current_tile_type == 'LEDGE_HOP_RIGHT' and dx != 1):\n                    continue\n\n            if map_id == '3_37': # Union Cave 1F\n                if (current_tile_type == floor_up_wall_type and dy == -1) or (neighbor_tile_type == floor_up_wall_type and dy == 1):\n                    continue\n            elif map_id in ['10_9', '10_1']: # Route 32\n                 if current_tile_type != floor_up_wall_type and neighbor_tile_type == floor_up_wall_type and dy == 1:\n                     continue\n            elif map_id in ['3_38', '3_78']: # Union Cave B1F, Dark Cave\n                 if current_tile_type != floor_up_wall_type and neighbor_tile_type == floor_up_wall_type and dy == 1:\n                     continue\n\n            visited.add(neighbor)\n            new_path = list(path)\n            new_path.append(neighbor)\n            queue.append(new_path)\n\n    print(json.dumps([]))",
    "history": [
      {
        "commit_message": "feat: Re-create generate_path_plan tool. This commit re-defines the core pathfinding tool after it was deleted. It uses the last known working version of the ledge traversal logic, which is the more verbose, de-consolidated version that was proven to be functional. This addresses the critical need for a reliable navigation tool.",
        "timestamp": "2025-11-02T19:29:49.139Z",
        "action_counter": 15692
      },
      {
        "commit_message": "fix: Overhaul ledge traversal logic. The previous implementation was flawed, incorrectly blocking valid moves and allowing invalid ones. This commit replaces it with two distinct, clearer rules: one to completely forbid moving from a non-ledge to a ledge tile (climbing up), and another to restrict movement from a ledge tile to its specified direction. This correctly models the one-way obstacle behavior and resolves the critical pathfinding failure on Route 29.",
        "timestamp": "2025-11-02T19:32:45.321Z",
        "action_counter": 15696
      },
      {
        "commit_message": "fix: Overhaul ledge traversal logic. The previous implementation was flawed, incorrectly blocking valid moves and allowing invalid ones. This commit replaces it with two distinct, clearer rules: one to completely forbid moving from a non-ledge to a ledge tile (climbing up), and another to restrict movement from a ledge tile to its specified direction. This correctly models the one-way obstacle behavior and resolves the critical pathfinding failure on Route 29.",
        "timestamp": "2025-11-02T19:33:43.977Z",
        "action_counter": 15697
      }
    ]
  }
}