{
  "maze_solver": {
    "description": "Solves invisible arrow tile mazes. It simulates movement from a starting point and explores the maze using a Breadth-First Search, returning the sequence of directional inputs to reach a target coordinate. It requires the map XML and a list of known arrow tile behaviors.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "arrow_tiles_json": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "arrow_tiles_json"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef parse_map(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    grid = [['' for _ in range(width + 2)] for _ in range(height + 2)]\n    impassable_types = ['WALL', 'COUNTER', 'MART_SHELF', 'PC', 'BOOKSHELF', 'HEADBUTT_TREE', 'CUT_TREE', 'TV', 'TOWN_MAP', 'WINDOW', 'RADIO', 'ROCK', 'BUOY', 'VOID']\n    \n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            \n            is_impassable = tile_type in impassable_types\n            if tile_elem.find('Object') is not None:\n                is_impassable = True\n\n            grid[y][x] = '#' if is_impassable else '.'\n            \n    return grid, width, height\n\ndef solve_maze(grid, width, height, start_x, start_y, end_x, end_y, move_outcomes):\n    q = deque([((start_x, start_y), [])])\n    visited = { (start_x, start_y) }\n    \n    while q:\n        (current_x, current_y), path = q.popleft()\n\n        if (current_x, current_y) == (end_x, end_y):\n            return path\n\n        moves = {'Up': (0, -1), 'Down': (0, 1), 'Left': (-1, 0), 'Right': (1, 0)}\n        \n        for move_name, (dx, dy) in moves.items():\n            start_pos_key = f\"{current_x},{current_y}\"\n            \n            if start_pos_key in move_outcomes and move_name in move_outcomes[start_pos_key]:\n                final_x, final_y = move_outcomes[start_pos_key][move_name]\n\n                if (final_x, final_y) not in visited:\n                    visited.add((final_x, final_y))\n                    new_path = path + [move_name]\n                    q.append(((final_x, final_y), new_path))\n\n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    arrow_tiles_json = input_data['arrow_tiles_json']\n    \n    move_outcomes = json.loads(arrow_tiles_json)\n\n    grid, width, height = parse_map(map_xml_string)\n\n    path = solve_maze(grid, width, height, start_x, start_y, end_x, end_y, move_outcomes)\n\n    if path:\n        print(json.dumps({\"status\": \"success\", \"path\": path}))\n    else:\n        print(json.dumps({\"status\": \"failure\", \"message\": \"No path found with the provided tile data. More exploration may be needed.\"}))\n\nexcept Exception as e:\n    print(json.dumps({\"status\": \"error\", \"message\": str(e)}))"
  },
  "pathfinder": {
    "description": "Finds the shortest path on the current map using A*. It automatically detects and avoids impassable tiles (including water if SURF is not available) and ALL on-screen objects/NPCs, regardless of their state. It can also path to a tile adjacent to an impassable destination. This version includes improved logic for handling one-way ledges and a more robust A* implementation.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "can_surf": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "\nimport xml.etree.ElementTree as ET\nimport heapq\nimport json\nimport itertools\n\nclass Node:\n    def __init__(self, parent=None, position=None):\n        self.parent = parent\n        self.position = position\n        self.g = 0\n        self.h = 0\n        self.f = 0\n\n    def __eq__(self, other):\n        return self.position == other.position\n\n    def __hash__(self):\n        return hash(self.position)\n\ndef astar(grid, start, end, width, height, impassable_tiles):\n    start_node = Node(None, (start[0]-1, start[1]-1))\n    end_node = Node(None, (end[0]-1, end[1]-1))\n    open_list = []\n    closed_list = set()\n    counter = itertools.count()\n    heapq.heappush(open_list, (start_node.f, next(counter), start_node))\n\n    while open_list:\n        _, _, current_node = heapq.heappop(open_list)\n\n        if current_node.position in closed_list:\n            continue\n\n        if current_node == end_node:\n            path = []\n            current = current_node\n            while current is not None:\n                path.append((current.position[0] + 1, current.position[1] + 1))\n                current = current.parent\n            return path[::-1]\n\n        closed_list.add(current_node.position)\n\n        for move_direction, new_position in [('Up', (0, -1)), ('Down', (0, 1)), ('Left', (-1, 0)), ('Right', (1, 0))]:\n            node_position = (current_node.position[0] + new_position[0], current_node.position[1] + new_position[1])\n            \n            if not (0 <= node_position[1] < height and 0 <= node_position[0] < width):\n                continue\n\n            if node_position in closed_list:\n                continue\n\n            next_tile_type = grid[node_position[1]][node_position[0]][0]\n            next_tile_has_object = grid[node_position[1]][node_position[0]][1]\n\n            if next_tile_type in impassable_tiles or next_tile_has_object:\n                continue\n\n            current_tile_type = grid[current_node.position[1]][current_node.position[0]][0]\n\n            if current_tile_type == 'LEDGE_HOP_DOWN' and move_direction == 'Up':\n                continue\n            if current_tile_type == 'FLOOR_UP_WALL' and move_direction == 'Down':\n                continue\n            if current_tile_type == 'LEDGE_HOP_UP' and move_direction == 'Down':\n                continue\n            if current_tile_type == 'LEDGE_HOP_LEFT' and move_direction == 'Right':\n                continue\n            if current_tile_type == 'LEDGE_HOP_RIGHT' and move_direction == 'Left':\n                continue\n\n            if next_tile_type != current_tile_type:\n                if next_tile_type == 'LEDGE_HOP_DOWN' and move_direction != 'Down':\n                    continue\n                if next_tile_type == 'FLOOR_UP_WALL' and move_direction != 'Up':\n                    continue\n                if next_tile_type == 'LEDGE_HOP_UP' and move_direction != 'Up':\n                    continue\n                if next_tile_type == 'LEDGE_HOP_LEFT' and move_direction != 'Left':\n                    continue\n                if next_tile_type == 'LEDGE_HOP_RIGHT' and move_direction != 'Right':\n                    continue\n\n            child = Node(current_node, node_position)\n            child.g = current_node.g + 1\n            child.h = abs(child.position[0] - end_node.position[0]) + abs(child.position[1] - end_node.position[1])\n            child.f = child.g + child.h\n            heapq.heappush(open_list, (child.f, next(counter), child))\n            \n    return None\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.attrib['width'])\nheight = int(root.attrib['height'])\ngrid = [[('', False) for _ in range(width)] for _ in range(height)]\n\nimpassable_tiles = {'WALL', 'COUNTER', 'BOOKSHELF', 'PC', 'MART_SHELF', 'TV', 'TOWN_MAP', 'WINDOW', 'ROCK', 'BUOY', 'VOID', 'HEADBUTT_TREE', 'CUT_TREE', 'unseen'}\ncan_surf_str = input_data.get('can_surf', 'false')\nif not isinstance(can_surf_str, str) or can_surf_str.lower() != 'true':\n    impassable_tiles.add('WATER')\n\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.attrib['id'])\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.attrib['id'])\n        tile_type = tile_elem.attrib.get('type')\n        has_object = tile_elem.attrib.get('has-object') == 'true'\n        grid[y-1][x-1] = (tile_type, has_object)\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nstart = (start_x, start_y)\noriginal_end = (end_x, end_y)\n\npotential_ends = []\n\nif not (1 <= original_end[1] <= height and 1 <= original_end[0] <= width):\n    adj_target = None\n    if original_end[1] == 0 and 1 <= original_end[0] <= width:\n        adj_target = (original_end[0], 1)\n    elif original_end[1] == height + 1 and 1 <= original_end[0] <= width:\n        adj_target = (original_end[0], height)\n    elif original_end[0] == 0 and 1 <= original_end[1] <= height:\n        adj_target = (1, original_end[1])\n    elif original_end[0] == width + 1 and 1 <= original_end[1] <= height:\n        adj_target = (width, original_end[1])\n\n    if adj_target:\n        adj_tile_type, adj_tile_has_object = grid[adj_target[1]-1][adj_target[0]-1]\n        if adj_tile_type not in impassable_tiles and not adj_tile_has_object:\n            potential_ends.append(adj_target)\nelse:\n    end_tile_type, end_tile_has_object = grid[original_end[1]-1][original_end[0]-1]\n    if end_tile_type in impassable_tiles or end_tile_has_object:\n        for move_direction, new_position in [('Up', (0, -1)), ('Down', (0, 1)), ('Left', (-1, 0)), ('Right', (1, 0))]:\n            adj_pos = (original_end[0] + new_position[0], original_end[1] + new_position[1])\n            if 1 <= adj_pos[1] <= height and 1 <= adj_pos[0] <= width:\n                adj_tile_type, adj_tile_has_object = grid[adj_pos[1]-1][adj_pos[0]-1]\n                if adj_tile_type not in impassable_tiles and not adj_tile_has_object and adj_pos != start:\n                    potential_ends.append(adj_pos)\n    else:\n        potential_ends.append(original_end)\n\nif not potential_ends:\n    print(json.dumps({\"error\": \"Destination is blocked and no adjacent tiles are free.\"}))\n    exit()\n\nall_paths = []\nfor end_pos in potential_ends:\n    path = astar(grid, start, end_pos, width, height, impassable_tiles)\n    if path:\n        all_paths.append(path)\n\nif all_paths:\n    shortest_path = min(all_paths, key=len)\n    path_coords = [{\"x\": p[0], \"y\": p[1]} for p in shortest_path]\n    print(json.dumps({\"path\": path_coords}))\nelse:\n    print(json.dumps({\"error\": \"No path found.\"}))\n"
  },
  "puzzle_solver": {
    "description": "Solves Sokoban-style boulder puzzles. Takes optional start coordinates, but requires goal coordinates for the final boulder position. It uses a Breadth-First Search algorithm to find the optimal sequence of moves.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer",
          "nullable": true
        },
        "start_y": {
          "type": "integer",
          "nullable": true
        },
        "goal_x": {
          "type": "integer"
        },
        "goal_y": {
          "type": "integer"
        }
      },
      "required": [
        "goal_x",
        "goal_y"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\n\n# Parse map data\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\n\nwalls = set()\nboulders = []\nplayer_start = None\n\nfor r_idx, row_elem in enumerate(root.findall('Row')):\n    y = r_idx + 1\n    for t_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n        x = t_idx + 1\n        tile_type = tile_elem.get('type')\n        if tile_type == 'WALL':\n            walls.add((x, y))\n        if tile_elem.find('Object[@id-name=\"BOULDER\"]') is not None:\n            boulders.append((x, y))\n        if tile_elem.find('Player') is not None:\n            player_start = (x, y)\n\n# Override start position if provided\nif 'start_x' in input_data and input_data['start_x'] is not None:\n    player_start = (int(input_data['start_x']), int(input_data['start_y']))\n\ngoal_pos = (int(input_data['goal_x']), int(input_data['goal_y']))\n\n# --- BFS Solver ---\ninitial_state = (player_start, tuple(sorted(boulders)))\nqueue = collections.deque([(initial_state, [])])\nvisited = {initial_state}\n\npath_found = False\nwhile queue:\n    (current_player, current_boulders), path = queue.popleft()\n\n    # Check for goal state\n    if goal_pos in current_boulders:\n        print(f\"Solution found: {path}\")\n        path_found = True\n        break\n\n    # Explore neighbors\n    for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n        next_player_pos = (current_player[0] + dx, current_player[1] + dy)\n\n        # Simple move (no push)\n        if next_player_pos not in walls and next_player_pos not in current_boulders:\n            new_state = (next_player_pos, current_boulders)\n            if new_state not in visited:\n                visited.add(new_state)\n                queue.append((new_state, path + [move]))\n            continue\n\n        # Boulder push\n        if next_player_pos in current_boulders:\n            boulder_to_push = next_player_pos\n            next_boulder_pos = (boulder_to_push[0] + dx, boulder_to_push[1] + dy)\n\n            if next_boulder_pos not in walls and next_boulder_pos not in current_boulders:\n                new_boulders = list(current_boulders)\n                new_boulders.remove(boulder_to_push)\n                new_boulders.append(next_boulder_pos)\n                new_boulders_tuple = tuple(sorted(new_boulders))\n                \n                new_state = (next_player_pos, new_boulders_tuple)\n                if new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, path + [f\"Push {move}\"])) \n\nif not path_found:\n    print(\"No solution found.\")"
  },
  "sokoban_solver": {
    "description": "Solves complex Sokoban-style boulder puzzles with multiple boulders. It models the player and all boulders as a combined state and uses a Breadth-First Search algorithm to find the shortest sequence of pushes to clear a path for the player to a target destination.",
    "input_schema": {
      "type": "object",
      "properties": {
        "player_start_x": {
          "type": "integer"
        },
        "player_start_y": {
          "type": "integer"
        },
        "player_goal_x": {
          "type": "integer"
        },
        "player_goal_y": {
          "type": "integer"
        }
      },
      "required": [
        "player_start_x",
        "player_start_y",
        "player_goal_x",
        "player_goal_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\n# --- Helper Functions ---\ndef parse_map_xml(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    grid = [['' for _ in range(width)] for _ in range(height)]\n    boulders = []\n    player_pos = None\n\n    for y, row_elem in enumerate(root.findall('Row')):\n        for x, tile_elem in enumerate(row_elem.findall('Tile')):\n            grid[y][x] = tile_elem.attrib['type']\n            if tile_elem.find('Player') is not None:\n                player_pos = (x, y)\n            if tile_elem.find('Object[@id-name=\"BOULDER\"]') is not None:\n                boulders.append((x, y))\n    return grid, tuple(sorted(boulders)), player_pos, width, height\n\ndef is_valid_move(grid, x, y, width, height):\n    return 0 <= x < width and 0 <= y < height and grid[y][x] not in ['WALL', 'COUNTER', 'PC', 'MART_SHELF', 'ROCK_SMASH_BOULDER', 'TREE']\n\n# --- Main Solver Logic ---\n\n# Parse Inputs\nplayer_start_x = int(input_data['player_start_x']) - 1\nplayer_start_y = int(input_data['player_start_y']) - 1\nplayer_goal_x = int(input_data['player_goal_x']) - 1\nplayer_goal_y = int(input_data['player_goal_y']) - 1\n\n# Parse Map\ngrid, initial_boulders, _, width, height = parse_map_xml(map_xml_string)\n\n# BFS Initialization\ninitial_state = ((player_start_x, player_start_y), initial_boulders)\nqueue = deque([(initial_state, [])])\nvisited = {initial_state}\n\npath_found = False\n\nwhile queue:\n    (current_pos, current_boulders), path = queue.popleft()\n    px, py = current_pos\n\n    if (px, py) == (player_goal_x, player_goal_y):\n        print(f'{{\"status\": \"success\", \"path\": {path}}}')\n        path_found = True\n        break\n\n    for move, (dx, dy) in {'Up': (0, -1), 'Down': (0, 1), 'Left': (-1, 0), 'Right': (1, 0)}.items():\n        nx, ny = px + dx, py + dy\n\n        if not is_valid_move(grid, nx, ny, width, height):\n            continue\n\n        # Case 1: Move to an empty space\n        if (nx, ny) not in current_boulders:\n            new_state = ((nx, ny), current_boulders)\n            if new_state not in visited:\n                visited.add(new_state)\n                queue.append((new_state, path + [move]))\n            continue\n\n        # Case 2: Push a boulder\n        boulder_to_push = (nx, ny)\n        push_to_x, push_to_y = nx + dx, ny + dy\n\n        if is_valid_move(grid, push_to_x, push_to_y, width, height) and (push_to_x, push_to_y) not in current_boulders:\n            new_boulders = list(current_boulders)\n            new_boulders.remove(boulder_to_push)\n            new_boulders.append((push_to_x, push_to_y))\n            new_boulders_tuple = tuple(sorted(new_boulders))\n\n            # Player moves into the boulder's old spot\n            new_player_pos = (nx, ny)\n            new_state = (new_player_pos, new_boulders_tuple)\n\n            if new_state not in visited:\n                visited.add(new_state)\n                # The action is a 'Push' followed by the direction\n                queue.append((new_state, path + [f'Push {move}']))\n\nif not path_found:\n    print('{\"status\": \"failure\", \"reason\": \"No solution found\"}')"
  }
}