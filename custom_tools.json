{
  "find_path": {
    "description": "Finds the shortest path between two points on the current map using BFS. It avoids walls, impassable trees, objects, and correctly handles one-way ledges.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef find_path_script(map_xml_string, start_x_str, start_y_str, end_x_str, end_y_str):\n    start_x, start_y, end_x, end_y = int(start_x_str), int(start_y_str), int(end_x_str), int(end_y_str)\n    \n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = [[None for _ in range(width)] for _ in range(height)]\n    impassable_tiles = {\"WALL\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"LEDGE\", \"WATER\"}\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            has_object = tile_elem.find('Object') is not None\n            \n            if has_object:\n                grid[y][x] = 'OBJECT_OBSTACLE'\n            elif tile_type == 'unseen':\n                grid[y][x] = 'FLOOR'\n            else:\n                grid[y][x] = tile_type\n\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n\n    if not (0 <= start_x < width and 0 <= start_y < height and 0 <= end_x < width and 0 <= end_y < height):\n        return \"Start or end coordinates are out of bounds.\"\n\n    if grid[start_y][start_x] in impassable_tiles or grid[start_y][start_x] == 'OBJECT_OBSTACLE':\n        return f\"Start tile ({start_x},{start_y}) with type {grid[start_y][start_x]} is impassable.\"\n    if grid[end_y][end_x] in impassable_tiles or grid[end_y][end_x] == 'OBJECT_OBSTACLE':\n        return f\"End tile ({end_x},{end_y}) with type {grid[end_y][end_x]} is impassable.\"\n\n    queue = deque([[start_node]])\n    visited = {start_node}\n\n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n\n        if (x, y) == end_node:\n            return f\"Path found: {path}\"\n\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = x + dx, y + dy\n\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:\n                current_tile_type = grid[y][x]\n                next_tile_type = grid[ny][nx]\n\n                can_move = next_tile_type not in impassable_tiles and next_tile_type != 'OBJECT_OBSTACLE'\n\n                if 'LEDGE' in current_tile_type:\n                    is_hop_down = 'DOWN' in current_tile_type and dy == 1\n                    is_hop_right = 'RIGHT' in current_tile_type and dx == 1\n                    is_hop_left = 'LEFT' in current_tile_type and dx == -1\n                    if is_hop_down or is_hop_right or is_hop_left:\n                        can_move = True\n                    elif any(s in current_tile_type for s in ['DOWN', 'RIGHT', 'LEFT']):\n                        can_move = False\n\n                if can_move:\n                    visited.add((nx, ny))\n                    new_path = list(path)\n                    new_path.append((nx, ny))\n                    queue.append(new_path)\n    \n    return \"No path found.\"\n\nprint(find_path_script(map_xml_string, input_data['start_x'], input_data['start_y'], input_data['end_x'], input_data['end_y']))"
  },
  "path_master": {
    "description": "Finds the shortest path on the current map using BFS. Avoids impassable static tiles and objects. **Warning: Does not account for moving NPCs and may fail.**",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef find_path_bfs(map_xml_string, start_x, start_y, end_x, end_y):\n    root = ET.fromstring(map_xml_string)\n    impassable_types = {'WALL', 'COUNTER', 'MART_SHELF', 'BOOKSHELF', 'TV', 'RADIO', 'VOID', 'BUOY', 'TOWN_MAP', 'WINDOW', 'PC', 'TRADE_MACHINE', 'HEADBUTT_TREE', 'CUT_TREE', 'WATER'}\n    grid = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id'])\n            tile_type = tile_elem.attrib.get('type')\n            has_object = tile_elem.find('Object') is not None\n            is_impassable = tile_type in impassable_types or has_object\n            grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n\n    if start_node not in grid or grid[start_node]['impassable']:\n        return f'Error: Start point ({start_x},{start_y}) is invalid or blocked.'\n    if end_node not in grid:\n        return f'Error: End point ({end_x},{end_y}) is invalid.'\n\n    queue = deque([[start_node]])\n    visited = {start_node}\n\n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n\n        if (x, y) == end_node:\n            return path\n\n        potential_moves = []\n        current_tile_type = grid.get((x,y), {}).get('type', '')\n        \n        if 'LEDGE' in current_tile_type:\n            if 'RIGHT' in current_tile_type: potential_moves.append((x + 1, y))\n            elif 'LEFT' in current_tile_type: potential_moves.append((x - 1, y))\n            else: potential_moves.append((x, y + 1))\n        else:\n            potential_moves = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n\n        for move in potential_moves:\n            mx, my = move\n            if (mx, my) in grid and (mx, my) not in visited:\n                if grid[(mx, my)]['impassable']:\n                    continue\n                \n                target_tile_type = grid.get((mx,my), {}).get('type', '')\n                if my < y and 'LEDGE' in target_tile_type:\n                    continue\n\n                visited.add((mx, my))\n                new_path = list(path)\n                new_path.append((mx, my))\n                queue.append(new_path)\n    \n    return 'Error: No path found.'\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nresult_path = find_path_bfs(map_xml_string, start_x, start_y, end_x, end_y)\n\nif isinstance(result_path, list):\n    moves = []\n    for i in range(len(result_path) - 1):\n        x1, y1 = result_path[i]\n        x2, y2 = result_path[i+1]\n        if x2 > x1: moves.append('Right')\n        elif x2 < x1: moves.append('Left')\n        elif y2 > y1: moves.append('Down')\n        elif y2 < y1: moves.append('Up')\n    print(moves)\n    print('Warning: This path does not account for moving NPCs and may fail.')\nelse:\n    print(result_path)"
  }
}