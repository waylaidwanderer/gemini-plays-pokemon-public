{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "get_impassable_tiles": {
    "description": "Extracts and returns a JSON list of all impassable tile coordinates from the current map XML.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET; import json; root = ET.fromstring(map_xml_string); impassable_tiles = []; for row_elem in root.findall('Row'): y = int(row_elem.get('id')); for tile_elem in row_elem.findall('Tile'): x = int(tile_elem.get('id')); if tile_elem.get('type') == 'impassable' or tile_elem.find('Object') is not None: impassable_tiles.append({'x': x, 'y': y}); print(json.dumps(impassable_tiles))"
  },
  "find_path_v4": {
    "description": "A robust A* pathfinding tool to find a path from a start to an end coordinate. It handles ledges, impassable objects, and can path to a tile adjacent to an impassable destination. Now includes an optional 'ignore_npc_ids' parameter to treat specific NPCs as passable.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "movement_mode": {
          "type": "string",
          "enum": [
            "walking",
            "surfing"
          ]
        },
        "ignore_npc_ids": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "movement_mode"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport heapq\n\ndef parse_map_xml(xml_string, ignore_ids):\n    root = ET.fromstring(xml_string)\n    grid = {}\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tile_type = tile.get('type')\n            object_element = tile.find('Object')\n            has_object = False\n            is_pikachu = False\n            if object_element is not None:\n                obj_id_str = object_element.get('id')\n                if obj_id_str is not None and obj_id_str.isdigit():\n                    obj_id = int(obj_id_str)\n                    if obj_id not in ignore_ids:\n                        has_object = True\n                        if object_element.get('id-name') == 'Pikachu':\n                            is_pikachu = True\n                else: # Handle cases where object has no ID, treat as impassable\n                    has_object = True\n            grid[(x, y)] = {'type': tile_type, 'has_object': has_object, 'is_pikachu': is_pikachu}\n    return grid, width, height\n\ndef is_walkable(tile_data, movement_mode, for_destination=False):\n    if not tile_data: return False\n    walkable_types = ['ground', 'grass', 'steps', 'elevated_ground', 'ladder_up', 'ladder_down', 'hole', 'open_gate', 'gate_offscreen', 'teleport', 'spinner_stop']\n    surfable_types = ['water']\n    if for_destination:\n        walkable_types.extend(['cuttable', 'boulder_switch'])\n    if movement_mode == 'walking':\n        return tile_data.get('type') in walkable_types\n    elif movement_mode == 'surfing':\n        return tile_data.get('type') in surfable_types\n    return False\n\ndef get_neighbors(current_pos, grid, width, height, movement_mode):\n    x, y = current_pos\n    neighbors = []\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nx, ny = x + dx, y + dy\n        if not (1 <= nx <= width and 1 <= ny <= height): continue\n        current_tile_data = grid.get((x, y), {})\n        next_tile_data = grid.get((nx, ny), {})\n        if current_tile_data.get('type') == 'ledge':\n            if dx == 0 and dy == 1:\n                final_y = ny + 1\n                if 1 <= final_y <= height:\n                    landing_tile_data = grid.get((nx, final_y), {})\n                    if is_walkable(landing_tile_data, movement_mode) and not (landing_tile_data.get('has_object') and not landing_tile_data.get('is_pikachu')):\n                        neighbors.append((nx, final_y))\n            continue\n        if is_walkable(next_tile_data, movement_mode):\n            if not (next_tile_data.get('has_object') and not next_tile_data.get('is_pikachu')):\n                neighbors.append((nx, ny))\n    return neighbors\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef find_path_astar(grid, width, height, start, end, movement_mode):\n    original_end = end\n    target_tile_data = grid.get(end)\n    if not target_tile_data or not is_walkable(target_tile_data, movement_mode, for_destination=True) or (target_tile_data.get('has_object') and not target_tile_data.get('is_pikachu')):\n        possible_ends = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_x, adj_y = original_end[0] + dx, original_end[1] + dy\n            adj_tile_data = grid.get((adj_x, adj_y))\n            if adj_tile_data and is_walkable(adj_tile_data, movement_mode) and not (adj_tile_data.get('has_object') and not adj_tile_data.get('is_pikachu')):\n                heapq.heappush(possible_ends, (heuristic(start, (adj_x, adj_y)), (adj_x, adj_y)))\n        if not possible_ends:\n            return None\n        end = heapq.heappop(possible_ends)[1]\n\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {pos: float('inf') for pos in grid}\n    g_score[start] = 0\n    f_score = {pos: float('inf') for pos in grid}\n    f_score[start] = heuristic(start, end)\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n        if current == end:\n            path = []\n            temp = current\n            while temp in came_from:\n                path.append(temp)\n                temp = came_from[temp]\n            path.append(start)\n            return path[::-1]\n        for neighbor in get_neighbors(current, grid, width, height, movement_mode):\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, end)\n                if neighbor not in [i[1] for i in open_set]:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    movement_mode = input_data['movement_mode']\n    ignore_npc_ids_str = input_data.get('ignore_npc_ids', '')\n    ignore_ids = [int(id_str) for id_str in ignore_npc_ids_str.split(',') if id_str.strip().isdigit()]\n\n    grid, width, height = parse_map_xml(map_xml_string, ignore_ids)\n    path = find_path_astar(grid, width, height, (start_x, start_y), (end_x, end_y), movement_mode)\n\n    if path:\n        final_path = []\n        for i in range(len(path)):\n            if i > 0 and path[i-1][0] == path[i][0] and path[i][1] - path[i-1][1] == 2 and grid.get((path[i][0], path[i][1]-1), {}).get('type') == 'ledge':\n                final_path.append({'x': str(path[i][0]), 'y': str(path[i][1] - 1)})\n            final_path.append({'x': str(path[i][0]), 'y': str(path[i][1])})\n        print(json.dumps(final_path))\n    else:\n        print(json.dumps([]))\nexcept Exception as e:\n    print(json.dumps([{'error': str(e), 'type': type(e).__name__}]))"
  }
}