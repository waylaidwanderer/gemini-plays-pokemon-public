{
  "mash_a": {
    "description": "Presses the 'A' button 8 times in a row. Useful for quickly advancing dialogue or spamming the first attack in battles.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "python_script": "print('[\"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\"]')",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T02:05:26.666Z",
        "action_counter": 92
      },
      {
        "commit_message": "Fixed sandbox error and ensured the tool returns a valid list of buttons.",
        "timestamp": "2026-01-17T07:39:14.105Z",
        "action_counter": 575
      }
    ]
  },
  "patrol_grass": {
    "description": "Moves the player Left and Right to search for wild Pokemon, and presses A to handle battle introductions.",
    "input_schema": {},
    "python_script": "import json\ncmds = [\"Left\", \"Right\", \"Left\", \"Right\", \"A\", \"A\", \"A\", \"A\"]\nprint(json.dumps(cmds))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T02:06:33.549Z",
        "action_counter": 93
      }
    ]
  },
  "scan_surroundings": {
    "description": "Scans the Mental Map around the player and returns the type and coordinates of nearby tiles. Useful for identifying walls, ledges, and navigable paths without walking into them.",
    "input_schema": {
      "type": "object",
      "properties": {
        "radius": {
          "type": "integer",
          "description": "The radius of tiles to scan around the player. Defaults to 2."
        }
      },
      "required": [
        "radius"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    player_pos = None\n    \n    # Find player position\n    for row in root.findall(\"Row\"):\n        for tile in row.findall(\"Tile\"):\n            if tile.find(\"Player\") is not None:\n                player_pos = (int(tile.get(\"id\")), int(row.get(\"id\")))\n                break\n        if player_pos: break\n\n    if not player_pos:\n        print(\"Error: Player not found in Mental Map.\")\n    else:\n        px, py = player_pos\n        radius = input_data.get('radius', 2)\n        map_id = root.get('id')\n        print(f\"Scanning radius {radius} around {player_pos} on map {map_id}:\")\n        \n        for y in range(py - radius, py + radius + 1):\n            row = root.find(f\"./Row[@id='{y}']\")\n            if row is not None:\n                row_str = \"\"\n                for x in range(px - radius, px + radius + 1):\n                    tile = row.find(f\"./Tile[@id='{x}']\")\n                    if tile is not None:\n                        t_type = tile.get(\"type\")\n                        row_str += f\"[{x},{y}: {t_type}] \"\n                    else:\n                        row_str += f\"[{x},{y}: N/A] \"\n                print(row_str)\n            else:\n                print(f\"Row {y} not found.\")\n\nexcept Exception as e:\n    print(f\"Error executing scan_surroundings: {e}\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T03:27:06.196Z",
        "action_counter": 213
      }
    ]
  },
  "check_path_connectivity": {
    "description": "Checks if a path exists between coordinates in the Mental Map, respecting obstacles and ledges. Useful for checking if you are trapped or if a route is valid.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "target_min_x": {
          "type": "integer"
        },
        "autopress_buttons": {
          "type": "boolean"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\nmap_xml = map_xml_string\nstart_x = input_data['start_x']\nstart_y = input_data['start_y']\ntarget_x = input_data.get('target_x')\ntarget_y = input_data.get('target_y')\ntarget_min_x = input_data.get('target_min_x')\nautopress = input_data.get('autopress_buttons', False)\n\nroot = ET.fromstring(map_xml)\ngrid = {}\n\n# Heuristic lists based on observations\nimpassable = {'TYPE_2889', 'TYPE_a82', 'TYPE_4e8c', 'TYPE_5519', 'TYPE_a336', 'TYPE_f133'} \nledges = {\n    'TYPE_80fc': (0, 1), # Down\n    'TYPE_fed7': (0, 1), # Down\n    'TYPE_c453': (1, 0), # Right\n    'TYPE_a339': (-1, 0) # Left\n}\n\nfor row in root.findall('Row'):\n    y = int(row.get('id'))\n    for tile in row.findall('Tile'):\n        x = int(tile.get('id'))\n        t_type = tile.get('type')\n        grid[(x, y)] = t_type\n\nstart = (start_x, start_y)\nqueue = deque([(start, [])])\nvisited = {start}\n\nfound_path = None\n\nwhile queue:\n    (cx, cy), path = queue.popleft()\n    \n    # Check success\n    if target_x is not None and target_y is not None:\n        if cx == target_x and cy == target_y:\n            found_path = path + [(cx, cy)]\n            break\n    elif target_min_x is not None:\n        if cx >= target_min_x:\n            found_path = path + [(cx, cy)]\n            break\n    \n    # Neighbors\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nx, ny = cx + dx, cy + dy\n        \n        if (nx, ny) not in grid: continue\n        tile_type = grid[(nx, ny)]\n        \n        if tile_type == 'unseen': continue \n        if tile_type in impassable: continue\n        \n        # Ledge Logic\n        if tile_type in ledges:\n            req_dx, req_dy = ledges[tile_type]\n            # Must approach from correct direction\n            if dx == req_dx and dy == req_dy:\n                # Jump over the ledge tile\n                lx, ly = nx + dx, ny + dy # Landing spot\n                # Check landing spot\n                if (lx, ly) in grid and grid[(lx, ly)] not in impassable and grid[(lx, ly)] != 'unseen':\n                    if (lx, ly) not in visited:\n                        visited.add((lx, ly))\n                        # Path tracks steps: current -> ledge tile -> landing tile\n                        queue.append(((lx, ly), path + [(cx, cy), (nx, ny)]))\n            continue # Cannot traverse ledge otherwise\n        \n        # Normal tile\n        if (nx, ny) not in visited:\n            visited.add((nx, ny))\n            queue.append(((nx, ny), path + [(cx, cy)]))\n            \nif found_path:\n    if autopress:\n        buttons = []\n        i = 0\n        while i < len(found_path) - 1:\n            curr = found_path[i]\n            next_step = found_path[i+1]\n            \n            dx = next_step[0] - curr[0]\n            dy = next_step[1] - curr[1]\n            \n            btn = \"\"\n            if dx == 1: btn = \"Right\"\n            elif dx == -1: btn = \"Left\"\n            elif dy == 1: btn = \"Down\"\n            elif dy == -1: btn = \"Up\"\n            \n            buttons.append(btn)\n            \n            # Check if next_step was a ledge, if so we auto-jumped to i+2\n            t_type = grid.get(next_step)\n            if t_type in ledges:\n                i += 2\n            else:\n                i += 1\n        print(json.dumps(buttons))\n    else:\n        print(f\"Path found! Length: {len(found_path)}\")\n        print(f\"Steps: {found_path}\")\nelse:\n    if autopress:\n        print(json.dumps([]))\n    else:\n        print(\"No path found.\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T04:38:25.635Z",
        "action_counter": 310
      },
      {
        "commit_message": "Fixed autopress_buttons support by returning JSON list of buttons.",
        "timestamp": "2026-01-17T05:14:56.870Z",
        "action_counter": 363
      }
    ]
  },
  "find_nearest_unseen": {
    "description": "Finds the nearest 'unseen' tile in the Mental Map to the current player position. Useful for systematically clearing fog of war.",
    "input_schema": {
      "type": "object",
      "properties": {
        "player_x": {
          "type": "integer"
        },
        "player_y": {
          "type": "integer"
        }
      },
      "required": [
        "player_x",
        "player_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport math\n\nmap_xml = map_xml_string\npx = input_data['player_x']\npy = input_data['player_y']\n\nroot = ET.fromstring(map_xml)\nunseen_tiles = []\n\nfor row in root.findall('Row'):\n    y = int(row.get('id'))\n    for tile in row.findall('Tile'):\n        t_type = tile.get('type')\n        if t_type == 'unseen':\n            x = int(tile.get('id'))\n            dist = math.sqrt((x - px)**2 + (y - py)**2)\n            unseen_tiles.append({'x': x, 'y': y, 'dist': dist})\n\nif not unseen_tiles:\n    print(\"No unseen tiles found.\")\nelse:\n    # Sort by distance\n    unseen_tiles.sort(key=lambda t: t['dist'])\n    nearest = unseen_tiles[0]\n    print(f\"Nearest unseen tile is at ({nearest['x']}, {nearest['y']}) with distance {nearest['dist']:.2f}\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T05:16:24.634Z",
        "action_counter": 364
      }
    ]
  },
  "mash_a_fixed": {
    "description": "Presses the 'A' button 8 times in a row. Useful for quickly advancing dialogue or spamming the first attack in battles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "autopress_buttons"
      ]
    },
    "python_script": "print([\"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\"])",
    "history": [
      {
        "commit_message": "Re-defining tool to attempt to trigger sandbox re-initialization after 'container not running' error.",
        "timestamp": "2026-01-17T11:31:30.337Z",
        "action_counter": 931
      }
    ]
  },
  "bfs_check_path": {
    "description": "Checks if a path exists between two points using BFS on the Mental Map. Returns True/False and the path length.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y",
        "autopress_buttons"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef bfs_path(xml_string, start, target):\n    try:\n        root = ET.fromstring(xml_string)\n        rows = {int(r.get('id')): r for r in root.findall('Row')}\n        \n        # Parse map to find walkable tiles\n        walkable = set()\n        for y, row in rows.items():\n            for tile in row.findall('Tile'):\n                # Heuristic: TYPE_3fe2 (Floor), TYPE_80fc (Grass) are usually walkable.\n                # Adjust this list based on game knowledge.\n                t_type = tile.get('type')\n                if t_type in [\"TYPE_3fe2\", \"TYPE_80fc\", \"TYPE_a336\", \"TYPE_a339\"]: \n                    walkable.add((int(tile.get('id')), y))\n        \n        start_tuple = (start['x'], start['y'])\n        target_tuple = (target['x'], target['y'])\n        \n        if start_tuple not in walkable:\n            print(f\"Start {start_tuple} is not a known walkable tile.\")\n            # Depending on strictness, might return False or try anyway\n            \n        if target_tuple not in walkable:\n            print(f\"Target {target_tuple} is not a known walkable tile.\")\n            return False, 0\n\n        queue = deque([(start_tuple, 0)])\n        visited = {start_tuple}\n        \n        while queue:\n            curr, dist = queue.popleft()\n            if curr == target_tuple:\n                return True, dist\n            \n            x, y = curr\n            neighbors = [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]\n            for nx, ny in neighbors:\n                if (nx, ny) in walkable and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append(((nx, ny), dist + 1))\n                    \n        return False, 0\n        \n    except Exception as e:\n        print(f\"Error parsing map or pathfinding: {e}\")\n        return False, 0\n\n# Expects map_xml_string to be available in the global scope (injected by system)\n# Tool arguments provided in input_data variable\nstart = {'x': input_data['start_x'], 'y': input_data['start_y']}\ntarget = {'x': input_data['target_x'], 'y': input_data['target_y']}\n\nexists, length = bfs_path(map_xml_string, start, target)\nprint(f\"Path exists: {exists}, Length: {length}\")\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T13:46:49.913Z",
        "action_counter": 1128
      },
      {
        "commit_message": "Initial definition of BFS pathfinding tool to check connectivity on the Mental Map.",
        "timestamp": "2026-01-17T18:35:27.285Z",
        "action_counter": 1502
      }
    ]
  },
  "run_from_battle": {
    "description": "Automates the sequence to run from a wild Pokemon battle (Down -> Right -> A).",
    "input_schema": {},
    "python_script": "print('[\"Down\", \"Right\", \"A\"]')",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T14:26:27.544Z",
        "action_counter": 1176
      }
    ]
  }
}