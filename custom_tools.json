{
  "boulder_pusher_tool": {
    "description": "Automates pushing a boulder in a straight line. Assumes the player is already in position to start the first push. Outputs a list of button presses.",
    "input_schema": {
      "type": "object",
      "properties": {
        "boulder_start_x": {
          "type": "string"
        },
        "boulder_start_y": {
          "type": "string"
        },
        "boulder_end_x": {
          "type": "string"
        },
        "boulder_end_y": {
          "type": "string"
        }
      },
      "required": [
        "boulder_start_x",
        "boulder_start_y",
        "boulder_end_x",
        "boulder_end_y"
      ]
    },
    "python_script": "import json\n\nstart_x, start_y = int(input_data['boulder_start_x']), int(input_data['boulder_start_y'])\nend_x, end_y = int(input_data['boulder_end_x']), int(input_data['boulder_end_y'])\n\nbuttons = []\n\nif start_x == end_x: # Vertical push\n    direction = 'Up' if end_y < start_y else 'Down'\n    num_pushes = abs(start_y - end_y)\n    # Player does not move after a vertical push, so we must manually reposition.\n    for i in range(num_pushes):\n        buttons.append(direction) # Push\n        if i < num_pushes - 1: # Don't reposition after the last push\n            buttons.append(direction) # Reposition\nelif start_y == end_y: # Horizontal push\n    direction = 'Left' if end_x < start_x else 'Right'\n    num_pushes = abs(start_x - end_x)\n    # Player moves into the boulder's old space automatically. No reposition needed.\n    for _ in range(num_pushes):\n        buttons.append(direction) # Push\nelse:\n    print(json.dumps({'error': 'Boulder path must be a straight line.'}))\n    exit()\n\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "feat: Create boulder_pusher_tool to automate linear boulder pushing. This tool will significantly improve efficiency when solving puzzles that require moving a boulder along a long, straight corridor, by replacing a multi-turn, manual process with a single, automated tool call.",
        "timestamp": "2025-08-03T17:23:26.526Z",
        "action_counter": 119242
      },
      {
        "commit_message": "feat: Create boulder_pusher_tool to automate linear boulder pushing. This tool will significantly improve efficiency when solving puzzles that require moving a boulder along a long, straight corridor, by replacing a multi-turn, manual process with a single, automated tool call.",
        "timestamp": "2025-08-03T17:44:07.834Z",
        "action_counter": 119282
      },
      {
        "commit_message": "feat: Create boulder_pusher_tool to automate linear boulder pushing. This tool will significantly improve efficiency when solving puzzles that require moving a boulder along a long, straight corridor, by replacing a multi-turn, manual process with a single, automated tool call.",
        "timestamp": "2025-08-03T17:50:13.513Z",
        "action_counter": 119294
      },
      {
        "commit_message": "refactor(boulder_pusher_tool): Overhaul script to output a direct list of button presses instead of a high-level action plan. This enables full automation of linear pushes in a single turn, fixing the previous issue that required manual step-by-step execution and caused looping warnings. The new logic generates a sequence of 'push' and 'reposition' moves.",
        "timestamp": "2025-08-03T17:58:36.488Z",
        "action_counter": 119305
      },
      {
        "commit_message": "refactor(boulder_pusher_tool): Differentiate vertical and horizontal push logic. The previous version used the same repositioning logic for both, which is incorrect. The new script correctly models the game mechanic where the player does not move after a vertical push (requiring a manual reposition step) but does move after a horizontal push (no reposition needed). This is a critical fix for reliable puzzle automation.",
        "timestamp": "2025-08-03T19:40:10.254Z",
        "action_counter": 119471
      },
      {
        "commit_message": "fix(boulder_pusher_tool): Correctly implement vertical push repositioning. The previous fix attempt failed as the script was identical. This version correctly adds a repositioning move after each vertical push, but not after the final one, accurately modeling the game mechanic and ensuring reliable automation.",
        "timestamp": "2025-08-03T19:43:03.937Z",
        "action_counter": 119477
      },
      {
        "commit_message": "fix(boulder_pusher_tool): Correctly implement vertical push repositioning. The previous script was identical to the flawed one. This version ensures a repositioning move is added after each vertical push except the last, accurately modeling the game mechanic and ensuring reliable automation.",
        "timestamp": "2025-08-03T19:48:40.642Z",
        "action_counter": 119491
      }
    ]
  },
  "gem_pathfinder_v2": {
    "description": "A new, rebuilt A* pathfinding tool. This version is designed from the ground up to be more reliable, with a specific focus on correctly handling elevation changes via 'steps' and other connector tiles. It treats objects as impassable obstacles, unless explicitly ignored. It now supports a surfing mode.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        },
        "ignorable_coords": {
          "type": "string",
          "nullable": true
        },
        "is_surfing": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\nclass AStar:\n    def __init__(self, map_xml_string):\n        self.root = ET.fromstring(map_xml_string)\n        self.width = int(self.root.get('width'))\n        self.height = int(self.root.get('height'))\n        \n        self.tile_map = {}\n        parsed_tiles = {}\n        for row_node in self.root:\n            if row_node.tag != 'Row': continue\n            y = int(row_node.get('id'))\n            for tile_node in row_node:\n                if tile_node.tag != 'Tile': continue\n                x = int(tile_node.get('id'))\n                parsed_tiles[(x, y)] = tile_node\n        \n        for y in range(1, self.height + 1):\n            for x in range(1, self.width + 1):\n                if (x, y) in parsed_tiles:\n                    self.tile_map[(x, y)] = parsed_tiles[(x, y)]\n                else:\n                    default_tile = ET.Element('Tile')\n                    default_tile.set('type', 'ground')\n                    self.tile_map[(x, y)] = default_tile\n\n        self.player_pos = self._get_player_pos()\n        self.elevation_map = {\n            'ground': 0, 'grass': 0, 'steps': 1, 'boulder_switch': 1,\n            'cleared_boulder_barrier': 1, 'ladder_up': 1, 'ladder_down': 1, 'elevated_ground': 2\n        }\n\n    def _get_tile(self, x, y):\n        return self.tile_map.get((x, y))\n\n    def _get_player_pos(self):\n        for (x, y), tile_node in self.tile_map.items():\n            if tile_node.find('Player') is not None:\n                return x, y\n        return None\n\n    def _get_impassable_objects(self, ignorable_coords_str):\n        objects = set()\n        ignorable = []\n        if ignorable_coords_str and ignorable_coords_str.lower() != 'null':\n            try: \n                ignorable_data = json.loads(ignorable_coords_str)\n                if isinstance(ignorable_data, list):\n                    ignorable = [(d['x'], d['y']) for d in ignorable_data if isinstance(d, dict) and 'x' in d and 'y' in d]\n            except (json.JSONDecodeError, TypeError): pass\n        \n        for (x, y), t in self.tile_map.items():\n            if (x, y) in ignorable: continue\n            if t.get('type') in {'impassable', 'boulder_barrier'}: \n                objects.add((x, y))\n            elif t.find(\"Object[@id!='15']\") is not None: \n                objects.add((x, y))\n            elif t.find('Boulder') is not None: \n                objects.add((x, y))\n        return objects\n\n    def is_traversable(self, current_pos, neighbor_pos, traversable_tiles, impassable_objects, end_node):\n        n_x, n_y = neighbor_pos\n        \n        if (n_x, n_y) in impassable_objects and (n_x, n_y) != end_node:\n            return False\n\n        neighbor_tile = self._get_tile(n_x, n_y)\n        if not neighbor_tile:\n            return False\n\n        neighbor_type = neighbor_tile.get('type')\n        if neighbor_type == 'impassable' and (n_x, n_y) != end_node:\n            return False\n\n        if neighbor_pos != end_node and neighbor_type not in traversable_tiles and neighbor_type != 'ledge':\n            return False\n\n        current_tile = self._get_tile(current_pos[0], current_pos[1])\n        current_type = current_tile.get('type')\n\n        if neighbor_type == 'ledge':\n            return n_y > current_pos[1]\n\n        current_elev = self.elevation_map.get(current_type, -1)\n        neighbor_elev = self.elevation_map.get(neighbor_type, -1)\n        \n        if abs(current_elev - neighbor_elev) > 1:\n            return False\n        if neighbor_elev > current_elev and current_type not in {'steps', 'ladder_up', 'ladder_down', 'cleared_boulder_barrier'}:\n            return False\n        if current_elev > neighbor_elev and neighbor_type not in {'steps', 'ladder_up', 'ladder_down', 'cleared_boulder_barrier'}:\n             return False\n\n        return True\n\n    def _search(self, start_node, end_node, impassable, traversable_tiles):\n        open_list, counter, closed_set, came_from, g_score = [], 0, set(), {start_node: None}, {start_node: 0}\n        heapq.heappush(open_list, (0, counter, start_node))\n        \n        while open_list:\n            _, _, current = heapq.heappop(open_list)\n            if current in closed_set: continue\n            closed_set.add(current)\n\n            if current == end_node:\n                path = []\n                _curr = end_node\n                while _curr: path.append(_curr); _curr = came_from.get(_curr)\n                path.reverse()\n                return path\n\n            for neighbor in [(current[0]-1, current[1]), (current[0]+1, current[1]), (current[0], current[1]-1), (current[0], current[1]+1)]:\n                if not (1 <= neighbor[0] <= self.width and 1 <= neighbor[1] <= self.height): continue\n                if self.is_traversable(current, neighbor, traversable_tiles, impassable, end_node):\n                    tentative_g = g_score.get(current, float('inf')) + 1\n                    if tentative_g < g_score.get(neighbor, float('inf')):\n                        came_from[neighbor], g_score[neighbor] = current, tentative_g\n                        h = abs(neighbor[0] - end_node[0]) + abs(neighbor[1] - end_node[1])\n                        counter += 1\n                        heapq.heappush(open_list, (tentative_g + h, counter, neighbor))\n        return None\n\n    def find_path(self, target_x, target_y, ignorable_coords_str=None, is_surfing=False):\n        if not self.player_pos: return print(json.dumps({\"error\": \"Player position not found.\"}))\n        \n        traversable_tiles = {'ground', 'grass', 'elevated_ground', 'steps', 'cleared_boulder_barrier', 'boulder_switch', 'ladder_up', 'ladder_down'}\n        if is_surfing: traversable_tiles.add('water')\n        \n        start_node, end_node = self.player_pos, (int(target_x), int(target_y))\n        \n        impassable_pass1 = self._get_impassable_objects(ignorable_coords_str)\n        effective_end_node = end_node\n        \n        if end_node in impassable_pass1:\n            potential_goals = []\n            for neighbor in [(end_node[0]-1, end_node[1]), (end_node[0]+1, end_node[1]), (end_node[0], end_node[1]-1), (end_node[0], end_node[1]+1)]:\n                if (1 <= neighbor[0] <= self.width and 1 <= neighbor[1] <= self.height) and (neighbor not in impassable_pass1):\n                    neighbor_tile = self._get_tile(neighbor[0], neighbor[1])\n                    if neighbor_tile is not None and neighbor_tile.get('type') in traversable_tiles:\n                         potential_goals.append(neighbor)\n            if not potential_goals: \n                return print(json.dumps({\"error\": \"No traversable tile adjacent to the impassable destination.\"}))\n            potential_goals.sort(key=lambda p: abs(p[0] - start_node[0]) + abs(p[1] - start_node[1]))\n            effective_end_node = potential_goals[0]\n\n        path = self._search(start_node, effective_end_node, impassable_pass1, traversable_tiles)\n\n        if path is None:\n            boulders = []\n            for (x, y), t in self.tile_map.items():\n                if t.find('Boulder') is not None:\n                    boulders.append({'x': x, 'y': y})\n            \n            if boulders:\n                all_ignorable_coords = boulders\n                if ignorable_coords_str and ignorable_coords_str.lower() != 'null':\n                    try:\n                        user_ignorable = json.loads(ignorable_coords_str)\n                        if isinstance(user_ignorable, list):\n                            all_ignorable_coords.extend(user_ignorable)\n                    except (json.JSONDecodeError, TypeError): pass\n                \n                impassable_pass2 = self._get_impassable_objects(json.dumps(all_ignorable_coords))\n                path = self._search(start_node, effective_end_node, impassable_pass2, traversable_tiles)\n\n        if path:\n            return print(json.dumps([{'x': p[0], 'y': p[1]} for p in path]))\n        else:\n            return print(json.dumps({\"error\": \"No path found.\"}))\n\ntry:\n    pathfinder = AStar(map_xml_string)\n    pathfinder.find_path(input_data['target_x'], input_data['target_y'], input_data.get('ignorable_coords'), input_data.get('is_surfing') == 'true')\nexcept Exception as e:\n    print(json.dumps({\"error\": f\"An unexpected error occurred: {str(e)}\"}))",
    "history": [
      {
        "commit_message": "feat: Recreate pathfinder with verbose logging. The previous tool was deleted to break an update loop. This new version is defined from scratch and includes extensive (but commented out) print statements for debugging, as mandated by Overwatch critique, to diagnose any future pathing failures.",
        "timestamp": "2025-08-06T03:44:02.536Z",
        "action_counter": 123461
      },
      {
        "commit_message": "refactor(gem_pathfinder_v2): Implement two-pass system based on debugger agent's diagnosis. The first pass treats all obstacles as impassable. If it fails, a second pass is initiated which re-classifies all boulders as ignorable. This allows the tool to find paths that require moving boulders, fixing the critical flaw where it would incorrectly report 'no path found' in solvable puzzle rooms.",
        "timestamp": "2025-08-06T04:49:08.593Z",
        "action_counter": 123544
      }
    ]
  },
  "get_complete_puzzle_state": {
    "description": "A wrapper tool that gathers all necessary data for the puzzle_strategist_agent. It parses the map XML to find the player's position, all boulders, switches, and barriers, and a comprehensive list of all impassable tiles, including objects like defeated trainers.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\npuzzle_state = {\n    \"player_pos\": {},\n    \"boulders\": [],\n    \"switches\": [],\n    \"barriers\": [],\n    \"impassable_tiles\": []\n}\n\nroot = ET.fromstring(map_xml_string)\nimpassable_types = ['impassable', 'boulder_barrier', 'closed_gate']\n\nfor row in root.findall('Row'):\n    y = int(row.get('id'))\n    for tile in row.findall('Tile'):\n        x = int(tile.get('id'))\n        coord = {'x': x, 'y': y}\n\n        if tile.find('Player') is not None:\n            puzzle_state[\"player_pos\"] = coord\n\n        if tile.find('Boulder') is not None:\n            puzzle_state[\"boulders\"].append(coord)\n        if tile.get('type') == 'boulder_switch':\n            puzzle_state[\"switches\"].append(coord)\n        if tile.get('type') == 'boulder_barrier':\n            puzzle_state[\"barriers\"].append(coord)\n\n        is_impassable = False\n        if tile.get('type') in impassable_types:\n            is_impassable = True\n        \n        for obj in tile.findall('Object'):\n            if obj.get('id-name') != 'Pikachu':\n                is_impassable = True\n                break\n        \n        if is_impassable:\n            puzzle_state[\"impassable_tiles\"].append(coord)\n\nprint(json.dumps(puzzle_state))",
    "history": [
      {
        "commit_message": "feat: Create get_complete_puzzle_state tool. This automates the data gathering process for the puzzle_strategist_agent, preventing user error. It combines the functionality of get_puzzle_elements and get_impassable_coords, ensuring a complete and accurate dataset is always provided to the agent for strategic planning.",
        "timestamp": "2025-08-03T05:08:52.744Z",
        "action_counter": 118100
      }
    ]
  },
  "log_summarizer": {
    "description": "Summarizes a long log file, focusing on the beginning and end, to prevent truncation when passing it to another agent.",
    "input_schema": {
      "type": "object",
      "properties": {
        "log_text": {
          "type": "string"
        },
        "max_chars": {
          "type": "string"
        }
      },
      "required": [
        "log_text",
        "max_chars"
      ]
    },
    "python_script": "import json\n\nlog_text = input_data['log_text']\nmax_chars = int(input_data.get('max_chars', 8000))\n\nif len(log_text) <= max_chars:\n    print(log_text)\nelse:\n    half_chars = (max_chars - 50) // 2\n    start = log_text[:half_chars]\n    end = log_text[-half_chars:]\n    summary = f\"{start}\\n\\n... (log truncated, see original tool output for full text) ...\\n\\n{end}\"\n    print(summary)",
    "history": [
      {
        "commit_message": "feat: Create log_summarizer tool. This tool will prevent log truncation issues when passing verbose tool output to debugger agents, which was a critical failure identified in the last overwatch critique. This is a necessary step to break the current unproductive debugging loop.",
        "timestamp": "2025-08-05T13:18:24.116Z",
        "action_counter": 122522
      },
      {
        "commit_message": "feat: Create log_summarizer tool. This tool will prevent log truncation issues when passing verbose tool output to debugger agents, which was a critical failure identified in the last overwatch critique. This is a necessary step to break the current unproductive debugging loop.",
        "timestamp": "2025-08-05T15:11:16.035Z",
        "action_counter": 122635
      }
    ]
  },
  "multi_boulder_pusher": {
    "description": "Automates a sequence of boulder pushes, including repositioning. Assumes the player is in position for the first push. Input is a JSON string of push actions (e.g., [{'direction': 'RIGHT', 'count': 5}, {'direction': 'DOWN', 'count': 3}]). This tool is a work-in-progress and may not handle all complex repositioning correctly.",
    "input_schema": {
      "type": "object",
      "properties": {
        "actions": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "direction": {
                "type": "string",
                "enum": [
                  "UP",
                  "DOWN",
                  "LEFT",
                  "RIGHT"
                ]
              },
              "count": {
                "type": "string"
              }
            },
            "required": [
              "direction",
              "count"
            ]
          }
        }
      },
      "required": [
        "actions"
      ]
    },
    "python_script": "import json\n\nactions_str = input_data.get('actions', '[]')\ntry:\n    actions = json.loads(actions_str)\nexcept json.JSONDecodeError:\n    print(json.dumps({\"error\": \"Invalid JSON format for actions.\"}))\n    return\n\nbutton_presses = []\n\nfor action in actions:\n    direction = action.get('direction')\n    try:\n        count = int(action.get('count', 0))\n    except (ValueError, TypeError):\n        count = 0\n\n    if direction and count > 0:\n        if direction in ['LEFT', 'RIGHT']:\n            for _ in range(count):\n                button_presses.append(direction)\n        elif direction in ['UP', 'DOWN']:\n            reposition_move = 'DOWN' if direction == 'UP' else 'UP'\n            for i in range(count):\n                button_presses.append(direction)\n                if i < count - 1:\n                    button_presses.append(reposition_move)\n\nprint(json.dumps({\"button_presses\": button_presses}))",
    "history": [
      {
        "commit_message": "feat: Create multi_boulder_pusher tool. This tool automates sequences of boulder pushes as suggested by the Overwatch critique. It's a foundational version that handles basic linear sequences and vertical push repositioning, intended to streamline puzzle execution and be refined later.",
        "timestamp": "2025-08-05T22:12:42.740Z",
        "action_counter": 123095
      }
    ]
  }
}