{
  "find_closest_unseen_tile": {
    "description": "Finds the closest reachable unseen tile and a reachable adjacent tile to pathfind to. This version correctly handles player movement state (walking/surfing) and various tile types.",
    "input_schema": {
      "type": "object",
      "properties": {
        "party_data": {
          "type": "string"
        },
        "movement_state": {
          "type": "string"
        }
      },
      "required": [
        "party_data",
        "movement_state"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport collections\nimport heapq\n\ndef parse_party_data(party_data_str):\n    try:\n        party_data = json.loads(party_data_str)\n        hms_known = set()\n        # The input is a dictionary with a 'party' key\n        for pokemon in party_data.get('party', []):\n            for move in pokemon.get('moves', []):\n                if isinstance(move, dict):\n                    move_name = move.get('name', '').upper()\n                    if move_name == 'CUT':\n                        hms_known.add('cut')\n                    elif move_name == 'SURF':\n                        hms_known.add('surf')\n        return hms_known\n    except (json.JSONDecodeError, TypeError):\n        return set()\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(start, goal, grid, map_width, map_height, hms_known, movement_state):\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {start: 0}\n    f_score = {start: heuristic(start, goal)}\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == goal:\n            return True\n\n        current_tile_info = grid.get(current, {})\n        is_on_ledge = current_tile_info.get('type') == 'ledge'\n        \n        if is_on_ledge:\n            neighbors = [(current[0], current[1] + 1)]\n        else:\n            neighbors = [(current[0] + dx, current[1] + dy) for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]]\n\n        for neighbor in neighbors:\n            if not (1 <= neighbor[0] <= map_width and 1 <= neighbor[1] <= map_height):\n                continue\n\n            neighbor_info = grid.get(neighbor, {})\n            neighbor_type = neighbor_info.get('type')\n            is_neighbor_impassable = neighbor_info.get('impassable', True)\n            \n            if is_neighbor_impassable:\n                continue\n            \n            if neighbor_type == 'ledge' and current[1] != neighbor[1] - 1:\n                continue\n\n            is_neighbor_water = neighbor_type == 'water'\n            is_neighbor_cuttable = neighbor_type == 'cuttable'\n\n            can_move = False\n            if movement_state == 'surfing':\n                if is_neighbor_water or not is_neighbor_impassable:\n                    can_move = True\n            else: # walking\n                if is_neighbor_water:\n                    if 'surf' in hms_known:\n                        can_move = True\n                elif is_neighbor_cuttable:\n                    if 'cut' in hms_known:\n                        can_move = True\n                else:\n                    can_move = True\n            \n            if not can_move:\n                continue\n\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    return False\n\ntry:\n    party_data_str = input_data['party_data']\n    movement_state = input_data['movement_state']\n    hms = parse_party_data(party_data_str)\n    \n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.attrib['width'])\n    map_height = int(root.attrib['height'])\n\n    player_pos = None\n    unseen_tiles = []\n    grid = {}\n\n    for tile in root.findall('.//Tile'):\n        x, y = int(tile.get('id')), int(tile.get('coordinate').split(',')[1].strip(')'))\n        tile_type = tile.get('type')\n        obj = tile.find('Object')\n        is_impassable_obj = obj is not None and obj.get('id-name') != 'Pikachu'\n        is_impassable_tile = tile_type in ['impassable', 'boulder_barrier', 'closed_gate', 'unknown']\n        \n        grid[(x, y)] = {\n            'type': tile_type,\n            'impassable': is_impassable_tile or is_impassable_obj\n        }\n\n        if tile.get('seen') != 'true':\n            unseen_tiles.append((x, y))\n        if tile.find('Player') is not None:\n            player_pos = (x, y)\n\n    if not player_pos:\n        print(json.dumps({'error': 'Player not found.'}))\n    else:\n        reachable_unseen = []\n        for ux, uy in unseen_tiles:\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adj_tile = (ux + dx, uy + dy)\n                if not (1 <= adj_tile[0] <= map_width and 1 <= adj_tile[1] <= map_height):\n                    continue\n                \n                adj_info = grid.get(adj_tile, {})\n                if adj_info.get('impassable') or adj_info.get('type') == 'unknown':\n                    continue\n                \n                if a_star_search(player_pos, adj_tile, grid, map_width, map_height, hms, movement_state):\n                    dist = heuristic(player_pos, adj_tile)\n                    reachable_unseen.append({'unseen': (ux, uy), 'adj': adj_tile, 'dist': dist})\n                    break\n\n        if not reachable_unseen:\n            print(json.dumps({'message': 'No reachable unseen tiles found.'}))\n        else:\n            closest = min(reachable_unseen, key=lambda x: x['dist'])\n            print(json.dumps({\n                'closest_reachable_unseen_tile': {'x': closest['unseen'][0], 'y': closest['unseen'][1]},\n                'adjacent_tile': {'x': closest['adj'][0], 'y': closest['adj'][1]}\n            }))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))",
    "history": [
      {
        "commit_message": "fix: Correctly parse party_data JSON. The tool was failing because it was trying to iterate over a JSON string directly. This commit fixes the `parse_party_data` function to correctly load the JSON string into a dictionary and then access the 'party' key, resolving the `AttributeError: 'str' object has no attribute 'get'`.",
        "timestamp": "2025-07-23T09:13:01.065Z",
        "action_counter": 94954
      }
    ]
  },
  "reachable_shoreline_finder": {
    "description": "Analyzes the map_xml_string to identify all reachable water-adjacent ground tiles from the player's current position. This version correctly handles elevation changes via 'steps' tiles.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\n\nroot = ET.fromstring(map_xml_string)\nmap_width = int(root.attrib['width'])\nmap_height = int(root.attrib['height'])\n\ngrid = {}\nplayer_start = None\n\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.attrib['id'])\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.attrib['id'])\n        tile_type = tile_elem.attrib['type']\n        has_object = tile_elem.find('Object') is not None\n        \n        is_impassable = tile_type in ['impassable', 'boulder_barrier', 'closed_gate', 'unknown'] or has_object\n        if has_object and tile_elem.find('Object').attrib.get('id-name') == 'Pikachu':\n            is_impassable = False\n\n        grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n        if tile_elem.find('Player') is not None:\n            player_start = (x, y)\n\nif not player_start:\n    print(\"Error: Player position not found.\")\nelse:\n    queue = collections.deque([player_start])\n    visited = {player_start}\n    \n    # Walkable tiles for BFS. This is the key fix.\n    walkable_types = ['ground', 'elevated_ground', 'steps', 'grass', 'cleared_boulder_barrier', 'boulder_switch', 'open_gate', 'gate_offscreen']\n\n    while queue:\n        cx, cy = queue.popleft()\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            neighbor_coord = (nx, ny)\n            \n            if 1 <= nx <= map_width and 1 <= ny <= map_height and neighbor_coord not in visited:\n                neighbor_tile = grid.get(neighbor_coord, {})\n                if not neighbor_tile.get('impassable') and neighbor_tile.get('type') in walkable_types:\n                    visited.add(neighbor_coord)\n                    queue.append(neighbor_coord)\n\n    shoreline_tiles = []\n    land_types_for_surfing = ['ground', 'elevated_ground', 'steps', 'grass'] # Tiles you can stand on to initiate Surf\n\n    for x, y in sorted(list(visited)):\n        current_tile = grid.get((x,y), {})\n        if current_tile.get('type') in land_types_for_surfing:\n            is_shore = False\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 1 <= nx <= map_width and 1 <= ny <= map_height:\n                    if grid.get((nx, ny), {}).get('type') == 'water':\n                        is_shore = True\n                        break\n            if is_shore:\n                shoreline_tiles.append((x, y))\n\n    if shoreline_tiles:\n        print(f\"Reachable shoreline tiles found: {shoreline_tiles}\")\n    else:\n        print(\"No reachable shoreline tiles found from the current position.\")"
  },
  "gem_pathfinder": {
    "description": "A new, robust pathfinding tool that can handle all known tile types, ledges, surfing, spinners, ignorable objects, elevation, and can path to adjacent tiles if the target is impassable.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        },
        "party_data": {
          "type": "string"
        },
        "hazard_coords": {
          "type": "string",
          "nullable": true
        },
        "ignorable_coords": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "target_x",
        "target_y",
        "party_data"
      ]
    },
    "python_script": "# injected imports [\"sys\", \"json\"]\n# injected variables [\"map_xml_string\", \"input_data\"]\n\nimport xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef find_path(map_xml_string, target_x, target_y, party_data_str, hazard_coords_str=None, ignorable_coords_str=None):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = [['' for _ in range(width + 1)] for _ in range(height + 1)]\n    elevations = [[0 for _ in range(width + 1)] for _ in range(height + 1)]\n    spinner_data = {}\n    objects = set()\n    start_x, start_y = -1, -1\n\n    ignorable_coords = set()\n    if ignorable_coords_str:\n        try:\n            coords = json.loads(ignorable_coords_str)\n            for c in coords:\n                ignorable_coords.add(tuple(c))\n        except (json.JSONDecodeError, TypeError):\n            pass\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            grid[y][x] = tile_type\n\n            if tile_elem.get('has-player') == 'true':\n                start_x, start_y = x, y\n\n            if (x, y) not in ignorable_coords:\n                if tile_elem.find('Object') is not None or tile_elem.find('Boulder') is not None:\n                    obj_elem = tile_elem.find('Object')\n                    boulder_elem = tile_elem.find('Boulder')\n                    if (obj_elem is not None and obj_elem.get('id-name') != 'Pikachu') or boulder_elem is not None:\n                        objects.add((x, y))\n\n            if tile_type == 'elevated_ground':\n                elevations[y][x] = 1\n            \n            spinner_elem = tile_elem.find('Spinner')\n            if spinner_elem is not None and 'end-coordinate' in spinner_elem.attrib:\n                end_coord_str = spinner_elem.get('end-coordinate').replace('(', '').replace(')', '')\n                end_x, end_y = map(int, end_coord_str.split(','))\n                spinner_data[(x, y)] = (end_x, end_y)\n    \n    if start_x == -1:\n        return \"Player tile not found in map XML.\"\n\n    party_data = json.loads(party_data_str)\n    party_list = party_data.get('party', [])\n    can_surf = any(move.get('name') == 'SURF' for p in party_list for move in p.get('moves', []))\n    \n    hazard_coords = set()\n    if hazard_coords_str:\n        try:\n            hazards = json.loads(hazard_coords_str)\n            for h in hazards:\n                hazard_coords.add(tuple(h))\n        except (json.JSONDecodeError, TypeError):\n            pass\n\n    traversable_walking = ['ground', 'grass', 'steps', 'cleared_boulder_barrier', 'hole', 'spinner_stop', 'open_gate', 'gate_offscreen', 'elevated_ground', 'ladder_up', 'ladder_down']\n    traversable_surfing = ['water']\n\n    is_target_impassable = (\n        grid[target_y][target_x] not in traversable_walking and\n        grid[target_y][target_x] not in traversable_surfing and\n        not grid[target_y][target_x].startswith('spinner')\n    ) or (target_x, target_y) in objects\n\n    original_target_x, original_target_y = target_x, target_y\n    destination_tiles = []\n\n    if is_target_impassable:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_x, adj_y = target_x + dx, target_y + dy\n            if 1 <= adj_x <= width and 1 <= adj_y <= height:\n                adj_tile_type = grid[adj_y][adj_x]\n                if (adj_tile_type in traversable_walking or adj_tile_type in traversable_surfing or adj_tile_type.startswith('spinner')) and (adj_x, adj_y) not in objects:\n                    destination_tiles.append((adj_x, adj_y))\n    else:\n        destination_tiles.append((target_x, target_y))\n\n    if not destination_tiles:\n        return \"No traversable tile adjacent to the impassable target.\"\n\n    open_set = []\n    heapq.heappush(open_set, (0, (start_x, start_y)))\n    came_from = {}\n    g_score = {(x, y): float('inf') for x in range(width + 2) for y in range(height + 2)}\n    g_score[(start_x, start_y)] = 0\n    f_score = {(x, y): float('inf') for x in range(width + 2) for y in range(height + 2)}\n    f_score[(start_x, start_y)] = min(abs(start_x - dx) + abs(start_y - dy) for dx, dy in destination_tiles)\n\n    final_destination = None\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current in destination_tiles:\n            final_destination = current\n            break\n\n        x, y = current\n        current_tile_type = grid[y][x]\n        \n        neighbors = []\n        if current in spinner_data:\n            neighbors.append(spinner_data[current])\n        else:\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 1 <= nx <= width and 1 <= ny <= height:\n                    if current_tile_type != 'ledge' and grid[ny][nx] == 'ledge' and dy == 1:\n                        if 1 <= ny + 1 <= height:\n                            neighbors.append((nx, ny + 1))\n                    elif not (current_tile_type == 'ledge' and dy == -1):\n                        neighbors.append((nx, ny))\n        \n        for neighbor in neighbors:\n            nx, ny = neighbor\n            \n            if not (1 <= nx <= width and 1 <= ny <= height):\n                continue\n            \n            if (nx, ny) in hazard_coords or (nx, ny) in objects:\n                continue\n\n            neighbor_tile_type = grid[ny][nx]\n\n            current_movement_state = 'surfing' if current_tile_type == 'water' else 'walking'\n            is_traversable = False\n            if current_movement_state == 'walking':\n                if neighbor_tile_type in traversable_walking or neighbor_tile_type.startswith('spinner'):\n                    is_traversable = True\n                elif neighbor_tile_type == 'water' and can_surf and current_tile_type in ['ground', 'steps']:\n                    is_traversable = True\n            elif current_movement_state == 'surfing':\n                if neighbor_tile_type in traversable_surfing:\n                    is_traversable = True\n                elif neighbor_tile_type in traversable_walking:\n                    is_traversable = True\n            \n            current_elevation = elevations[y][x]\n            neighbor_elevation = elevations[ny][nx]\n            if abs(current_elevation - neighbor_elevation) > 0 and current_tile_type != 'steps' and neighbor_tile_type != 'steps':\n                is_traversable = False\n            \n            if is_traversable:\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = tentative_g_score + min(abs(nx - dx) + abs(ny - dy) for dx, dy in destination_tiles)\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    \n    if final_destination:\n        path = []\n        current = final_destination\n        while current in came_from:\n            path.append(current)\n            current = came_from[current]\n        path.append((start_x, start_y))\n        \n        reconstructed_path = path[::-1]\n        if is_target_impassable:\n            reconstructed_path.append((original_target_x, original_target_y))\n        \n        return reconstructed_path\n    \n    return None\n\ntry:\n    path = find_path(map_xml_string, int(input_data['target_x']), int(input_data['target_y']), input_data['party_data'], input_data.get('hazard_coords'), input_data.get('ignorable_coords'))\n    \n    if isinstance(path, list):\n        path_coords = [{'x': x, 'y': y} for x, y in path]\n        print(json.dumps(path_coords))\n    elif path is None:\n        print(json.dumps([{'error': 'path not found'}]))\n    else:\n        print(json.dumps([{'error': path}]))\n\nexcept Exception as e:\n    print(json.dumps([{'error': str(e)}]))\n",
    "history": [
      {
        "commit_message": "feat: Create new unified pathfinder 'gem_pathfinder'. This tool is a complete rewrite, consolidating all previously developed logic (ledges, surfing, spinners, elevation, ignorable objects) into a single, robust tool. It also introduces a critical new feature: if the target tile is impassable, it will find a path to the nearest reachable adjacent tile. This is a direct response to the persistent failures on Route 23 and the overwatch critique, representing a decisive action to restore core navigation capabilities.",
        "timestamp": "2025-07-23T11:15:27.975Z",
        "action_counter": 95191
      },
      {
        "commit_message": "fix: Remove faulty 'is_land_to_land' optimization. This check prevented the algorithm from exploring water tiles if the start and end points were both on land, causing it to fail on maps like Route 23 where surfing is a mandatory bridge between two land areas. Removing this allows the pathfinder to correctly find paths that require surfing.",
        "timestamp": "2025-07-23T11:17:26.254Z",
        "action_counter": 95194
      }
    ]
  }
}