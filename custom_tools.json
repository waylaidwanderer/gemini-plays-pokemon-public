{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "inventory_navigator_tool": {
    "description": "Calculates the optimal number of button presses (Up/Down) to navigate from a current selection to a target item in a list-based menu. This version correctly handles non-wrapping menus and provides a warning for long scrolls.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory_list": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "current_selection": {
          "type": "string"
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "inventory_list",
        "current_selection",
        "target_item"
      ]
    },
    "python_script": "import json\ntry:\n    inventory = json.loads(input_data['inventory_list'])\n    current_item = input_data['current_selection']\n    target_item = input_data['target_item']\n\n    if current_item not in inventory or target_item not in inventory:\n        print(json.dumps({'error': 'Item not found in inventory list.'}))\n    else:\n        current_idx = inventory.index(current_item)\n        target_idx = inventory.index(target_item)\n        \n        response = {}\n        if current_idx == target_idx:\n            response = {'direction': 'NONE', 'presses': 0}\n        elif target_idx > current_idx:\n            presses = target_idx - current_idx\n            response = {'direction': 'DOWN', 'presses': presses}\n        else: # target_idx < current_idx\n            presses = current_idx - target_idx\n            response = {'direction': 'UP', 'presses': presses}\n\n        if response.get('presses', 0) > 4:\n            response['note'] = 'Warning: This is a long scroll. Press Down in increments of 4 to navigate pages more effectively.'\n        \n        print(json.dumps(response))\nexcept Exception as e:\n    print(json.dumps({'error': str(e), 'type': type(e).__name__}))"
  },
  "check_tile_walkable": {
    "description": "A diagnostic tool to check if a specific tile is walkable and print its properties for debugging.",
    "input_schema": {
      "type": "object",
      "properties": {
        "x": {
          "type": "string"
        },
        "y": {
          "type": "string"
        }
      },
      "required": [
        "x",
        "y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\nx_to_check = int(input_data['x'])\ny_to_check = int(input_data['y'])\n\nroot = ET.fromstring(map_xml_string)\ntile_found = False\nfor row in root.findall('Row'):\n    for tile in row.findall('Tile'):\n        coord_str = tile.get('coordinate')\n        if not coord_str: continue\n        coords = coord_str.strip('()').split(',')\n        x = int(coords[0].strip())\n        y = int(coords[1].strip())\n        if x == x_to_check and y == y_to_check:\n            tile_found = True\n            attributes = tile.attrib\n            children = {child.tag: child.attrib for child in tile}\n            print(json.dumps({'found': True, 'attributes': attributes, 'children': children}))\n            break\n    if tile_found:\n        break\n\nif not tile_found:\n    print(json.dumps({'found': False, 'message': f'Tile at ({x_to_check},{y_to_check}) not found in XML.'}))"
  },
  "pathfinder": {
    "description": "A robust A* pathfinding tool that finds the shortest path between two points on the current map. It correctly handles all known tile types, including impassable objects, ledges, and offscreen gates. This is a computational tool for navigation.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\nclass Node:\n    def __init__(self, parent=None, position=None):\n        self.parent = parent\n        self.position = position\n        self.g = 0\n        self.h = 0\n        self.f = 0\n\n    def __eq__(self, other):\n        return self.position == other.position\n\n    def __lt__(self, other):\n        return self.f < other.f\n\n    def __hash__(self):\n        return hash(self.position)\n\ndef is_walkable(tile, from_pos, to_pos):\n    if tile is None:\n        return False\n\n    tile_type = tile.get('type')\n    x, y = to_pos\n    from_x, from_y = from_pos\n\n    if tile.find('Object') is not None:\n        obj = tile.find('Object')\n        if obj.get('id-name') == 'Pikachu':\n            pass\n        else:\n            return False\n\n    if tile_type in ['impassable', 'unknown', 'closed_gate', 'boulder_barrier', 'gate_offscreen']:\n        return False\n\n    if tile_type == 'ledge':\n        if from_y == y - 1 and from_x == x:\n            return True\n        else:\n            return False\n\n    return True\n\ndef get_landing_tile(tile, from_pos, to_pos):\n    if tile.get('type') == 'ledge':\n        x, y = to_pos\n        from_x, from_y = from_pos\n        if from_y == y - 1 and from_x == x:\n            return (x, y + 1)\n    return to_pos\n\ndef astar(map_xml_string, start, end):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    tile_map = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_map[(x, y)] = tile_elem\n\n    start_node = Node(None, start)\n    end_node = Node(None, end)\n\n    open_list = []\n    closed_set = set()\n\n    heapq.heappush(open_list, start_node)\n\n    while len(open_list) > 0:\n        current_node = heapq.heappop(open_list)\n        closed_set.add(current_node.position)\n\n        if current_node.position == end_node.position:\n            path = []\n            current = current_node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            return path[::-1]\n\n        children = []\n        for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            node_position = (current_node.position[0] + new_position[0], current_node.position[1] + new_position[1])\n\n            if not (1 <= node_position[0] <= width and 1 <= node_position[1] <= height):\n                continue\n            \n            target_tile = tile_map.get(node_position)\n            if not is_walkable(target_tile, current_node.position, node_position):\n                continue\n            \n            actual_node_position = get_landing_tile(target_tile, current_node.position, node_position)\n\n            new_node = Node(current_node, actual_node_position)\n            children.append(new_node)\n\n        for child in children:\n            if child.position in closed_set:\n                continue\n\n            child.g = current_node.g + 1\n            child.h = ((child.position[0] - end_node.position[0]) ** 2) + ((child.position[1] - end_node.position[1]) ** 2)\n            child.f = child.g + child.h\n\n            if any(open_node for open_node in open_list if child == open_node and child.g >= open_node.g):\n                continue\n\n            heapq.heappush(open_list, child)\n\n    return None\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\ntarget_x = int(input_data['target_x'])\ntarget_y = int(input_data['target_y'])\n\npath = astar(map_xml_string, (start_x, start_y), (target_x, target_y))\n\nif path:\n    path_str = ','.join([f'{x},{y}' for x, y in path])\n    print(f\"Path found: {path_str}\")\nelse:\n    print(\"No path found.\")"
  }
}