{
  "automated_explorer": {
    "description": "Finds the nearest reachable unseen tile and generates a path to an adjacent traversable tile. Now correctly handles water traversal with SURF, defeated trainers, and uses robust pathfinding logic.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\nimport json\n\ndef find_all_reachable_and_paths(start, grid, width, height, is_surfing_state):\n    queue = collections.deque([start])\n    came_from = {start: None}\n    \n    while queue:\n        current = queue.popleft()\n        \n        for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = current[0] + move_x, current[1] + move_y\n            next_pos = (next_x, next_y)\n            \n            if not (1 <= next_x <= width and 1 <= next_y <= height):\n                continue\n            \n            if next_pos in came_from:\n                continue\n                \n            current_tile_info = grid.get(current, {})\n            next_tile_info = grid.get(next_pos, {})\n            next_tile_type = next_tile_info.get('type')\n            \n            if move_y == 1 and current_tile_info.get('type') != 'ledge' and next_tile_type == 'ledge':\n                ledge_jump_pos = (next_x, next_y + 1)\n                if ledge_jump_pos in came_from: continue\n                if grid.get(ledge_jump_pos, {}).get('type') not in ['impassable', 'unknown']:\n                    came_from[next_pos] = current\n                    came_from[ledge_jump_pos] = next_pos\n                    queue.append(ledge_jump_pos)\n                continue\n\n            impassable_types = ['impassable', 'unknown']\n            if current_tile_info.get('type') != 'water':\n                 impassable_types.append('ledge')\n            \n            if next_tile_type in impassable_types:\n                continue\n\n            if next_tile_type == 'water' and not is_surfing_state:\n                continue\n            \n            if next_tile_info.get('has_object') and next_tile_info.get('object_name') != 'Pikachu' and not next_tile_info.get('is_defeated_trainer', False):\n                continue\n\n            current_elevation = 'elevated' if current_tile_info.get('type') == 'elevated_ground' else 'ground'\n            next_elevation = 'elevated' if next_tile_type == 'elevated_ground' else 'ground'\n            if current_elevation != next_elevation and current_tile_info.get('type') not in ['steps', 'ladder_up', 'ladder_down'] and next_tile_type not in ['steps', 'ladder_up', 'ladder_down']:\n                continue\n            \n            came_from[next_pos] = current\n            queue.append(next_pos)\n            \n    return came_from\n\ndef reconstruct_path(came_from, end):\n    if end not in came_from:\n        return None\n    path = []\n    current = end\n    while current is not None:\n        path.append(list(current))\n        current = came_from.get(current)\n    return path[::-1]\n\ndef main():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        start_node = (start_x, start_y)\n\n        grid = {}\n        unseen_tiles = []\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                is_defeated = any(marker.get('emoji') == '☠️' for marker in tile_elem.findall('Marker'))\n                grid[(x, y)] = {\n                    'type': tile_elem.get('type'),\n                    'has_object': tile_elem.get('has-object') == 'true',\n                    'object_name': tile_elem.find('Object').get('id-name') if tile_elem.find('Object') is not None else None,\n                    'is_defeated_trainer': is_defeated\n                }\n                if tile_elem.get('seen') == 'false':\n                    unseen_tiles.append((x, y))\n\n        is_surfing_state = grid.get(start_node, {}).get('type') == 'water'\n\n        if not unseen_tiles:\n            print(json.dumps({'status': 'success', 'message': 'No unseen tiles found.'}))\n            return\n\n        came_from = find_all_reachable_and_paths(start_node, grid, width, height, is_surfing_state)\n        reachable_nodes = set(came_from.keys())\n        \n        targetable_unseen_tiles = [tile for tile in unseen_tiles if any((tile[0] + dx, tile[1] + dy) in reachable_nodes for dx, dy in [(0,1),(0,-1),(1,0),(-1,0)])]\n\n        if not targetable_unseen_tiles:\n            print(json.dumps({'status': 'error', 'message': 'No unseen tiles are adjacent to reachable areas.', 'reachable_nodes_count': len(reachable_nodes)}))\n            return\n\n        shortest_path = None\n        target_unseen = None\n        \n        sorted_targets = sorted(targetable_unseen_tiles, key=lambda t: (abs(t[0] - start_x) + abs(t[1] - start_y)))\n\n        for tile in sorted_targets:\n            best_adj_path = None\n            for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adj_x, adj_y = tile[0] + move_x, tile[1] + move_y\n                adj_pos = (adj_x, adj_y)\n                if adj_pos in reachable_nodes:\n                    path = reconstruct_path(came_from, adj_pos)\n                    if path and (best_adj_path is None or len(path) < len(best_adj_path)):\n                        best_adj_path = path\n            \n            if best_adj_path:\n                shortest_path = best_adj_path\n                target_unseen = tile\n                break\n        \n        if shortest_path:\n            print(json.dumps({'status': 'success', 'path': shortest_path, 'target_unseen_tile': target_unseen}))\n        else:\n            print(json.dumps({'status': 'error', 'message': 'Could not find a path to any adjacent tile of any reachable unseen tiles.'}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'status': 'error', 'message': f'An exception occurred: {traceback.format_exc()}'}))\n\nmain()"
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map using the Breadth-First Search (BFS) algorithm. It considers tile types (including elevation, water), impassable objects (excluding Pikachu), and special ledge traversal rules. It now detects and reports if a destination is on an unreachable map segment. The output is a JSON string containing the path or debug info.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\nimport json\n\ndef find_path():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        start = (int(input_data['start_x']), int(input_data['start_y']))\n        end = (int(input_data['end_x']), int(input_data['end_y']))\n\n        grid = {}\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                object_name = None\n                if has_object:\n                    obj_elem = tile_elem.find('Object')\n                    if obj_elem is not None:\n                        object_name = obj_elem.get('id-name')\n                grid[(x, y)] = {'type': tile_type, 'has_object': has_object, 'object_name': object_name}\n\n        queue = collections.deque([start])\n        came_from = {start: None}\n\n        while queue:\n            current = queue.popleft()\n            if current == end:\n                break\n\n            for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                next_x, next_y = current[0] + move_x, current[1] + move_y\n                next_pos = (next_x, next_y)\n\n                if not (1 <= next_x <= width and 1 <= next_y <= height) or next_pos in came_from:\n                    continue\n\n                current_tile_info = grid.get(current, {})\n                next_tile_info = grid.get(next_pos, {})\n                next_tile_type = next_tile_info.get('type')\n\n                if next_tile_type in ['impassable', 'unknown']:\n                    continue\n\n                if next_tile_info.get('has_object') and next_tile_info.get('object_name') != 'Pikachu':\n                    if next_pos != end:\n                        continue\n                \n                if next_tile_type == 'ledge':\n                    if move_y == 1:\n                        ledge_jump_pos = (next_x, next_y + 1)\n                        if ledge_jump_pos in came_from: continue\n                        if grid.get(ledge_jump_pos, {}).get('type') not in ['impassable', 'unknown']:\n                            came_from[next_pos] = current\n                            came_from[ledge_jump_pos] = next_pos\n                            queue.append(ledge_jump_pos)\n                        continue\n                    else:\n                        continue\n\n                current_is_elevated = current_tile_info.get('type') == 'elevated_ground'\n                next_is_elevated = next_tile_info.get('type') == 'elevated_ground'\n                if current_is_elevated != next_is_elevated:\n                    if not (current_tile_info.get('type') in ['steps', 'ladder_up', 'ladder_down'] or next_tile_type in ['steps', 'ladder_up', 'ladder_down']):\n                        continue\n                \n                came_from[next_pos] = current\n                queue.append(next_pos)\n\n        if end in came_from:\n            path = []\n            current = end\n            while current is not None:\n                path.append(list(current))\n                current = came_from.get(current)\n            print(json.dumps({\"status\": \"success\", \"path\": path[::-1]}))\n        else:\n            print(json.dumps({\"status\": \"error\", \"message\": \"No path found. The destination is on an unreachable segment of the map.\"}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({\"status\": \"error\", \"message\": f'An exception occurred: {traceback.format_exc()}'}))\n\nfind_path()"
  },
  "wkg_edge_payload_generator": {
    "description": "A helper tool that generates the correct JSON payload for adding an edge to the World Knowledge Graph. It finds the required node IDs based on map and coordinate inputs, and correctly includes source/destination coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "source_map_id": {
          "type": "string"
        },
        "source_x": {
          "type": "string"
        },
        "source_y": {
          "type": "string"
        },
        "dest_map_id": {
          "type": "string"
        },
        "dest_x": {
          "type": "string"
        },
        "dest_y": {
          "type": "string"
        },
        "connection_type": {
          "type": "string"
        },
        "is_one_way": {
          "type": "string"
        },
        "destination_entry_point": {
          "type": "string"
        }
      },
      "required": [
        "source_map_id",
        "source_x",
        "source_y",
        "dest_map_id",
        "dest_x",
        "dest_y"
      ]
    },
    "python_script": "import json\n\ndef main():\n    try:\n        wkg = json.loads(world_knowledge_graph_json_string)\n        nodes = wkg.get('nodes', [])\n\n        source_map_id = input_data['source_map_id']\n        source_x = int(input_data['source_x'])\n        source_y = int(input_data['source_y'])\n        dest_map_id = input_data['dest_map_id']\n        dest_x = int(input_data['dest_x'])\n        dest_y = int(input_data['dest_y'])\n        connection_type = input_data.get('connection_type', 'map_edge')\n        is_one_way_str = input_data.get('is_one_way', 'false').lower()\n        is_one_way = is_one_way_str == 'true'\n        dest_entry_point_str = input_data.get('destination_entry_point')\n\n        source_node_id = None\n        dest_node_id = None\n\n        for node in nodes:\n            if node['map_id'] == source_map_id and node['coordinates']['x'] == source_x and node['coordinates']['y'] == source_y:\n                source_node_id = node['id']\n            if node['map_id'] == dest_map_id and node['coordinates']['x'] == dest_x and node['coordinates']['y'] == dest_y:\n                dest_node_id = node['id']\n            if source_node_id and dest_node_id:\n                break\n\n        if not source_node_id or not dest_node_id:\n            print(json.dumps({\"status\": \"error\", \"message\": \"One or both nodes not found in World Knowledge Graph.\"}))\n            return\n\n        payload = {\n            \"source_node_id\": source_node_id,\n            \"destination_node_id\": dest_node_id,\n            \"connection_type\": connection_type,\n            \"source_coordinates\": {\"map_id\": source_map_id, \"x\": source_x, \"y\": source_y},\n            \"destination_coordinates\": {\"map_id\": dest_map_id, \"x\": dest_x, \"y\": dest_y},\n            \"is_one_way\": is_one_way\n        }\n\n        if dest_entry_point_str and dest_entry_point_str.isdigit():\n            payload[\"destination_entry_point\"] = int(dest_entry_point_str)\n\n        print(json.dumps(payload))\n    except Exception as e:\n        print(json.dumps({\"status\": \"error\", \"message\": f\"An error occurred: {str(e)}\"}))\n\nmain()\n"
  },
  "wkg_pathfinder": {
    "description": "Calculates the shortest path between two maps in the World Knowledge Graph, returning a sequence of map IDs and warp coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_map_id": {
          "type": "string"
        },
        "end_map_id": {
          "type": "string"
        }
      },
      "required": [
        "start_map_id",
        "end_map_id"
      ]
    },
    "python_script": "import json\nimport collections\n\nstart_map_id = input_data['start_map_id']\nend_map_id = input_data['end_map_id']\n\nwkg = json.loads(world_knowledge_graph_json_string)\nnodes = {node['id']: node for node in wkg.get('nodes', [])}\nedges = wkg.get('edges', [])\n\nadj = collections.defaultdict(list)\nfor edge in edges:\n    source_node = nodes.get(edge['source_node_id'])\n    dest_node = nodes.get(edge['destination_node_id'])\n    if source_node and dest_node:\n        source_map = source_node['map_id']\n        dest_map = dest_node['map_id']\n        \n        adj[source_map].append({\n            \"to_map\": dest_map,\n            \"warp_coords\": edge['source_coordinates'],\n            \"arrival_coords\": edge['destination_coordinates']\n        })\n        if not edge.get('is_one_way', False):\n            adj[dest_map].append({\n                \"to_map\": source_map,\n                \"warp_coords\": edge['destination_coordinates'],\n                \"arrival_coords\": edge['source_coordinates']\n            })\n\nqueue = collections.deque([(start_map_id, [])])\nvisited = {start_map_id}\n\npath_found = None\n\nwhile queue:\n    current_map, path = queue.popleft()\n    \n    if current_map == end_map_id:\n        path_found = path\n        break\n        \n    if current_map in adj:\n        for edge_info in adj[current_map]:\n            neighbor_map = edge_info['to_map']\n            if neighbor_map not in visited:\n                visited.add(neighbor_map)\n                new_path = path + [edge_info]\n                queue.append((neighbor_map, new_path))\n\nif path_found is not None:\n    formatted_path = []\n    last_map = start_map_id\n    for step in path_found:\n        formatted_path.append({\n            \"from_map\": last_map,\n            \"to_map\": step[\"to_map\"],\n            \"warp_coords\": step[\"warp_coords\"]\n        })\n        last_map = step[\"to_map\"]\n    \n    print(json.dumps({\"status\": \"success\", \"path\": formatted_path}))\nelse:\n    print(json.dumps({\"status\": \"error\", \"message\": \"No path found between the specified maps.\"}))\n"
  }
}