{
  "puzzle_solver": {
    "description": "Solves state-based puzzles, like boulder mazes, by finding a sequence of moves from a start to a goal state. It uses a breadth-first search algorithm.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer",
          "nullable": true
        },
        "start_y": {
          "type": "integer",
          "nullable": true
        },
        "goal_x": {
          "type": "integer"
        },
        "goal_y": {
          "type": "integer"
        }
      },
      "required": [
        "goal_x",
        "goal_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef solve_boulder_puzzle(start_pos, goal_pos, initial_boulders, walls, width, height):\n    queue = deque([(start_pos, initial_boulders, [])])\n    visited = set([(start_pos, tuple(sorted(initial_boulders)))])\n\n    while queue:\n        (player_x, player_y), boulders, path = queue.popleft()\n\n        if (player_x, player_y) == goal_pos:\n            return path\n\n        for move_x, move_y, move_dir in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            next_x, next_y = player_x + move_x, player_y + move_y\n\n            if not (0 <= next_x < width and 0 <= next_y < height) or (next_x, next_y) in walls:\n                continue\n\n            boulder_at_next = (next_x, next_y) in boulders\n            if boulder_at_next:\n                push_to_x, push_to_y = next_x + move_x, next_y + move_y\n                if not (0 <= push_to_x < width and 0 <= push_to_y < height) or (push_to_x, push_to_y) in walls or (push_to_x, push_to_y) in boulders:\n                    continue\n                \n                new_boulders = set(boulders)\n                new_boulders.remove((next_x, next_y))\n                new_boulders.add((push_to_x, push_to_y))\n                new_boulders_tuple = tuple(sorted(list(new_boulders)))\n                \n                new_player_pos = (next_x, next_y)\n                state = (new_player_pos, new_boulders_tuple)\n                if state not in visited:\n                    visited.add(state)\n                    new_path = path + [f'Push boulder at ({next_x},{next_y}) {move_dir}']\n                    queue.append((new_player_pos, new_boulders, new_path))\n            else:\n                new_player_pos = (next_x, next_y)\n                state = (new_player_pos, tuple(sorted(boulders)))\n                if state not in visited:\n                    visited.add(state)\n                    new_path = path + [move_dir]\n                    queue.append((new_player_pos, boulders, new_path))\n    return None\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n\n    walls = set()\n    boulders = set()\n    player_pos = None\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id')) - 1\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id')) - 1\n            tile_type = tile_elem.get('type')\n            if tile_type in ['WALL', 'VOID']:\n                walls.add((x, y))\n            \n            obj = tile_elem.find('Object')\n            if obj is not None:\n                obj_name = obj.get('id-name')\n                if obj_name == 'BOULDER':\n                    boulders.add((x, y))\n                elif obj_name != 'PLAYER':\n                    walls.add((x, y))\n            \n            if tile_elem.find('Player') is not None:\n                player_pos = (x, y)\n\n    start_x_str = input_data.get('start_x')\n    start_y_str = input_data.get('start_y')\n    end_x = int(input_data['goal_x'])\n    end_y = int(input_data['goal_y'])\n\n    if start_x_str and start_y_str:\n        start_pos = (int(start_x_str), int(start_y_str))\n    elif player_pos:\n        start_pos = player_pos\n    else:\n        raise ValueError(\"Player position not found in map XML and no start coordinates provided.\")\n\n    goal_pos = (end_x, end_y)\n    \n    solution = solve_boulder_puzzle(start_pos, goal_pos, frozenset(boulders), walls, width, height)\n    \n    if solution:\n        print(json.dumps({\"status\": \"success\", \"solution\": solution}))\n    else:\n        print(json.dumps({\"status\": \"failure\", \"reason\": \"No solution found.\"}))\n\nexcept Exception as e:\n    print(json.dumps({\"status\": \"error\", \"message\": str(e)}))\n"
  },
  "pathfinder": {
    "description": "Finds the shortest path between two points on the current map using the A* algorithm. It considers specified traversable tiles and avoids obstacles. It can now path to a tile adjacent to an impassable destination.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "traversable_tiles": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "traversable_tiles"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\nimport json\n\nclass AStar:\n    def __init__(self, map_xml, traversable_tiles):\n        self.root = ET.fromstring(map_xml)\n        self.width = int(self.root.get('width'))\n        self.height = int(self.root.get('height'))\n        self.traversable_tiles = set(traversable_tiles)\n        self.walls = set()\n        self.objects = set()\n        self.ledges = {}\n\n        for row_elem in self.root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.find('Object') is not None\n\n                if has_object:\n                    self.objects.add((x, y))\n                \n                if tile_type in ['FLOOR_UP_WALL', 'LEDGE']:\n                    self.ledges[(x, y)] = (x, y + 1)\n                \n                if tile_type not in self.traversable_tiles:\n                    self.walls.add((x,y))\n\n    def heuristic(self, a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def get_neighbors(self, pos):\n        x, y = pos\n        neighbors = []\n        \n        if pos in self.ledges:\n            nx, ny = self.ledges[pos]\n            if (nx, ny) not in self.walls and (nx, ny) not in self.objects:\n                neighbors.append(((nx, ny), 1))\n            return neighbors\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            neighbor_pos = (nx, ny)\n\n            if 1 <= nx <= self.width and 1 <= ny <= self.height:\n                if neighbor_pos in self.walls or neighbor_pos in self.objects:\n                    continue\n                \n                if neighbor_pos in self.ledges and pos != (neighbor_pos[0], neighbor_pos[1] - 1):\n                    continue\n\n                neighbors.append((neighbor_pos, 1))\n        return neighbors\n\n    def find_path_internal(self, start, end):\n        open_set = [(0, start)]\n        came_from = {}\n        g_score = {start: 0}\n        f_score = {start: self.heuristic(start, end)}\n\n        while open_set:\n            _, current = heapq.heappop(open_set)\n\n            if current == end:\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(start)\n                return path[::-1]\n\n            for neighbor, cost in self.get_neighbors(current):\n                tentative_g_score = g_score[current] + cost\n                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = tentative_g_score + self.heuristic(neighbor, end)\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n        return None\n\n    def find_path(self, start, end):\n        path = self.find_path_internal(start, end)\n        if path:\n            return path\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_x, adj_y = end[0] + dx, end[1] + dy\n            adj_pos = (adj_x, adj_y)\n            if adj_pos not in self.walls and adj_pos not in self.objects and adj_pos not in self.ledges:\n                path_adj = self.find_path_internal(start, adj_pos)\n                if path_adj:\n                    return path_adj\n        \n        return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    traversable = json.loads(input_data['traversable_tiles'])\n\n    astar = AStar(map_xml_string, traversable)\n    path = astar.find_path((start_x, start_y), (end_x, end_y))\n\n    if path:\n        print(json.dumps(path))\n    else:\n        print(\"No path found.\")\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")"
  }
}