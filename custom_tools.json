{
  "mash_a": {
    "description": "Presses the 'A' button 8 times in a row. Useful for quickly advancing dialogue or spamming the first attack in battles.",
    "input_schema": {},
    "python_script": "import json\nprint(json.dumps([\"A\" for _ in range(8)]))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T02:05:26.666Z",
        "action_counter": 92
      }
    ]
  },
  "patrol_grass": {
    "description": "Moves the player Left and Right to search for wild Pokemon, and presses A to handle battle introductions.",
    "input_schema": {},
    "python_script": "import json\ncmds = [\"Left\", \"Right\", \"Left\", \"Right\", \"A\", \"A\", \"A\", \"A\"]\nprint(json.dumps(cmds))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T02:06:33.549Z",
        "action_counter": 93
      }
    ]
  },
  "scan_surroundings": {
    "description": "Scans the Mental Map around the player and returns the type and coordinates of nearby tiles. Useful for identifying walls, ledges, and navigable paths without walking into them.",
    "input_schema": {
      "type": "object",
      "properties": {
        "radius": {
          "type": "integer",
          "description": "The radius of tiles to scan around the player. Defaults to 2."
        }
      },
      "required": [
        "radius"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    player_pos = None\n    \n    # Find player position\n    for row in root.findall(\"Row\"):\n        for tile in row.findall(\"Tile\"):\n            if tile.find(\"Player\") is not None:\n                player_pos = (int(tile.get(\"id\")), int(row.get(\"id\")))\n                break\n        if player_pos: break\n\n    if not player_pos:\n        print(\"Error: Player not found in Mental Map.\")\n    else:\n        px, py = player_pos\n        radius = input_data.get('radius', 2)\n        map_id = root.get('id')\n        print(f\"Scanning radius {radius} around {player_pos} on map {map_id}:\")\n        \n        for y in range(py - radius, py + radius + 1):\n            row = root.find(f\"./Row[@id='{y}']\")\n            if row is not None:\n                row_str = \"\"\n                for x in range(px - radius, px + radius + 1):\n                    tile = row.find(f\"./Tile[@id='{x}']\")\n                    if tile is not None:\n                        t_type = tile.get(\"type\")\n                        row_str += f\"[{x},{y}: {t_type}] \"\n                    else:\n                        row_str += f\"[{x},{y}: N/A] \"\n                print(row_str)\n            else:\n                print(f\"Row {y} not found.\")\n\nexcept Exception as e:\n    print(f\"Error executing scan_surroundings: {e}\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T03:27:06.196Z",
        "action_counter": 213
      }
    ]
  },
  "check_path_connectivity": {
    "description": "Checks if a path exists between coordinates in the Mental Map, respecting obstacles and ledges. Useful for checking if you are trapped or if a route is valid.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "target_min_x": {
          "type": "integer"
        },
        "autopress_buttons": {
          "type": "boolean"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\nmap_xml = map_xml_string\nstart_x = input_data['start_x']\nstart_y = input_data['start_y']\ntarget_x = input_data.get('target_x')\ntarget_y = input_data.get('target_y')\ntarget_min_x = input_data.get('target_min_x')\nautopress = input_data.get('autopress_buttons', False)\n\nroot = ET.fromstring(map_xml)\ngrid = {}\n\n# Heuristic lists based on observations\nimpassable = {'TYPE_2889', 'TYPE_a82', 'TYPE_4e8c', 'TYPE_5519', 'TYPE_a336', 'TYPE_f133'} \nledges = {\n    'TYPE_80fc': (0, 1), # Down\n    'TYPE_fed7': (0, 1), # Down\n    'TYPE_c453': (1, 0), # Right\n    'TYPE_a339': (-1, 0) # Left\n}\n\nfor row in root.findall('Row'):\n    y = int(row.get('id'))\n    for tile in row.findall('Tile'):\n        x = int(tile.get('id'))\n        t_type = tile.get('type')\n        grid[(x, y)] = t_type\n\nstart = (start_x, start_y)\nqueue = deque([(start, [])])\nvisited = {start}\n\nfound_path = None\n\nwhile queue:\n    (cx, cy), path = queue.popleft()\n    \n    # Check success\n    if target_x is not None and target_y is not None:\n        if cx == target_x and cy == target_y:\n            found_path = path + [(cx, cy)]\n            break\n    elif target_min_x is not None:\n        if cx >= target_min_x:\n            found_path = path + [(cx, cy)]\n            break\n    \n    # Neighbors\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nx, ny = cx + dx, cy + dy\n        \n        if (nx, ny) not in grid: continue\n        tile_type = grid[(nx, ny)]\n        \n        if tile_type == 'unseen': continue \n        if tile_type in impassable: continue\n        \n        # Ledge Logic\n        if tile_type in ledges:\n            req_dx, req_dy = ledges[tile_type]\n            # Must approach from correct direction\n            if dx == req_dx and dy == req_dy:\n                # Jump over the ledge tile\n                lx, ly = nx + dx, ny + dy # Landing spot\n                # Check landing spot\n                if (lx, ly) in grid and grid[(lx, ly)] not in impassable and grid[(lx, ly)] != 'unseen':\n                    if (lx, ly) not in visited:\n                        visited.add((lx, ly))\n                        # Path tracks steps: current -> ledge tile -> landing tile\n                        queue.append(((lx, ly), path + [(cx, cy), (nx, ny)]))\n            continue # Cannot traverse ledge otherwise\n        \n        # Normal tile\n        if (nx, ny) not in visited:\n            visited.add((nx, ny))\n            queue.append(((nx, ny), path + [(cx, cy)]))\n            \nif found_path:\n    if autopress:\n        buttons = []\n        i = 0\n        while i < len(found_path) - 1:\n            curr = found_path[i]\n            next_step = found_path[i+1]\n            \n            dx = next_step[0] - curr[0]\n            dy = next_step[1] - curr[1]\n            \n            btn = \"\"\n            if dx == 1: btn = \"Right\"\n            elif dx == -1: btn = \"Left\"\n            elif dy == 1: btn = \"Down\"\n            elif dy == -1: btn = \"Up\"\n            \n            buttons.append(btn)\n            \n            # Check if next_step was a ledge, if so we auto-jumped to i+2\n            t_type = grid.get(next_step)\n            if t_type in ledges:\n                i += 2\n            else:\n                i += 1\n        print(json.dumps(buttons))\n    else:\n        print(f\"Path found! Length: {len(found_path)}\")\n        print(f\"Steps: {found_path}\")\nelse:\n    if autopress:\n        print(json.dumps([]))\n    else:\n        print(\"No path found.\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T04:38:25.635Z",
        "action_counter": 310
      },
      {
        "commit_message": "Fixed autopress_buttons support by returning JSON list of buttons.",
        "timestamp": "2026-01-17T05:14:56.870Z",
        "action_counter": 363
      }
    ]
  }
}