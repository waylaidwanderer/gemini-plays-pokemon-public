{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "inventory_navigator_tool": {
    "description": "Calculates the optimal number of button presses (Up/Down) to navigate from a current selection to a target item in a list-based menu. This version correctly handles non-wrapping menus and provides a warning for long scrolls.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory_list": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "current_selection": {
          "type": "string"
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "inventory_list",
        "current_selection",
        "target_item"
      ]
    },
    "python_script": "import json\ntry:\n    inventory = json.loads(input_data['inventory_list'])\n    current_item = input_data['current_selection']\n    target_item = input_data['target_item']\n\n    if current_item not in inventory or target_item not in inventory:\n        print(json.dumps({'error': 'Item not found in inventory list.'}))\n    else:\n        current_idx = inventory.index(current_item)\n        target_idx = inventory.index(target_item)\n        \n        response = {}\n        if current_idx == target_idx:\n            response = {'direction': 'NONE', 'presses': 0}\n        elif target_idx > current_idx:\n            presses = target_idx - current_idx\n            response = {'direction': 'DOWN', 'presses': presses}\n        else: # target_idx < current_idx\n            presses = current_idx - target_idx\n            response = {'direction': 'UP', 'presses': presses}\n\n        if response.get('presses', 0) > 4:\n            response['note'] = 'Warning: This is a long scroll. Press Down in increments of 4 to navigate pages more effectively.'\n        \n        print(json.dumps(response))\nexcept Exception as e:\n    print(json.dumps({'error': str(e), 'type': type(e).__name__}))"
  },
  "pathfinder": {
    "description": "A robust A* pathfinding tool that finds the shortest path between two points on the current map. It correctly handles impassable targets by finding a path to an adjacent walkable tile. Now with corrected priority queue logic for optimal pathing.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef find_path(start_x_str, start_y_str, target_x_str, target_y_str, xml_string):\n    start_x, start_y, target_x, target_y = int(start_x_str), int(start_y_str), int(target_x_str), int(target_y_str)\n\n    try:\n        root = ET.fromstring(xml_string)\n    except ET.ParseError as e:\n        print(json.dumps({\"error\": f\"Error parsing XML: {e}\"}))\n        return\n\n    grid = {}\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tile_type = tile.get('type')\n            has_object = tile.get('has-object') == 'true'\n            is_impassable_object = False\n            if has_object:\n                obj = tile.find('Object')\n                if obj is not None:\n                    obj_id_name = obj.get('id-name')\n                    if obj_id_name and obj_id_name != 'PIKACHU':\n                        is_impassable_object = True\n\n            walkable = tile_type in ['ground', 'grass', 'steps', 'elevated_ground', 'cleared_boulder_barrier', 'open_gate', 'ladder_up', 'ladder_down', 'spinner_stop'] and not is_impassable_object\n            grid[(x, y)] = walkable\n\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def get_neighbors(pos):\n        x, y = pos\n        neighbors = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 1 <= nx <= width and 1 <= ny <= height:\n                next_tile_type = root.find(f\".//Tile[@coordinate='({nx}, {ny})']\").get('type')\n                if dy == -1 and next_tile_type == 'ledge': continue\n                if dx != 0 and next_tile_type == 'ledge': continue\n                if dy == 1 and next_tile_type == 'ledge':\n                    if 1 <= ny + 1 <= height:\n                        neighbors.append((nx, ny + 1))\n                    continue\n                neighbors.append((nx, ny))\n        return neighbors\n\n    start_node = (start_x, start_y)\n    target_node = (target_x, target_y)\n    \n    if not grid.get(target_node, False):\n        valid_targets = []\n        for nx, ny in get_neighbors(target_node):\n            if grid.get((nx, ny), False):\n                valid_targets.append((nx, ny))\n        \n        if not valid_targets:\n            print(json.dumps({\"error\": \"Target is unreachable and has no walkable adjacent tiles.\"}))\n            return\n            \n        valid_targets.sort(key=lambda t: heuristic(start_node, t))\n        target_node = valid_targets[0]\n\n    open_set = []\n    heapq.heappush(open_set, (0, start_node))\n    came_from = {}\n    g_score = {pos: float('inf') for pos in grid}\n    g_score[start_node] = 0\n    f_score = {pos: float('inf') for pos in grid}\n    f_score[start_node] = heuristic(start_node, target_node)\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == target_node:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start_node)\n            path.reverse()\n            formatted_path = [{\"x\": p[0], \"y\": p[1]} for p in path]\n            print(json.dumps({\"path\": formatted_path}))\n            return\n\n        for neighbor in get_neighbors(current):\n            if not grid.get(neighbor, False):\n                continue\n\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, target_node)\n                if (f_score[neighbor], neighbor) not in open_set:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    print(json.dumps({\"error\": \"No path found.\"}))\n\nfind_path(input_data['start_x'], input_data['start_y'], input_data['target_x'], input_data['target_y'], map_xml_string)"
  },
  "map_connectivity_analyzer_tool": {
    "description": "Analyzes the current map XML to check for connectivity between two points using a Breadth-First Search. This tool is for confirming if an area is isolated on the current map.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef is_walkable(tile):\n    walkable_types = ['ground', 'grass', 'steps', 'elevated_ground', 'cleared_boulder_barrier', 'open_gate', 'ladder_up', 'ladder_down', 'teleport', 'hole', 'spinner_up', 'spinner_down', 'spinner_left', 'spinner_right', 'spinner_stop']\n    if tile.get('type') in walkable_types:\n        if tile.find('Object') is None:\n            return True\n    return False\n\ntry:\n    map_root = ET.fromstring(map_xml_string)\n    width = int(map_root.get('width'))\n    height = int(map_root.get('height'))\n    \n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n\n    grid = [[None for _ in range(width + 1)] for _ in range(height + 1)]\n    for row_elem in map_root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            grid[y][x] = tile_elem\n\n    start_node = (start_x, start_y)\n    target_node = (target_x, target_y)\n\n    if not (1 <= start_x <= width and 1 <= start_y <= height and 1 <= target_x <= width and 1 <= target_y <= height):\n        print(\"Error: Coordinates are out of map bounds.\")\n    else:\n        queue = deque([start_node])\n        visited = {start_node}\n        connected = False\n\n        while queue:\n            current_x, current_y = queue.popleft()\n\n            if (current_x, current_y) == target_node:\n                connected = True\n                break\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                next_x, next_y = current_x + dx, current_y + dy\n                \n                if 1 <= next_x <= width and 1 <= next_y <= height:\n                    neighbor_tile = grid[next_y][next_x]\n                    if neighbor_tile is not None and (next_x, next_y) not in visited and is_walkable(neighbor_tile):\n                        visited.add((next_x, next_y))\n                        queue.append((next_x, next_y))\n        \n        if connected:\n            print(f\"Connectivity confirmed: Path exists between ({start_x},{start_y}) and ({target_x},{target_y}).\")\n        else:\n            print(f\"Connectivity not found: Path does not exist between ({start_x},{start_y}) and ({target_x},{target_y}).\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")"
  },
  "path_planner": {
    "description": "A combined pathfinding and path conversion tool. Takes start and target coordinates and directly outputs a JSON-formatted path plan. Now correctly handles 'gate_offscreen' tiles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef find_and_convert_path(start_x, start_y, target_x, target_y, map_xml_string):\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    objects = set()\n\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            grid[(x, y)] = tile.get('type')\n            if tile.find('Object') is not None and tile.find('Object').get('id-name') != 'Pikachu':\n                objects.add((x, y))\n\n    def is_walkable(x, y):\n        if (x, y) not in grid:\n            return False\n        if (x, y) in objects:\n            return False\n        tile_type = grid.get((x,y))\n        walkable_types = [\n            'ground', 'grass', 'steps', 'elevated_ground', \n            'cleared_boulder_barrier', 'open_gate', 'ladder_up', \n            'ladder_down', 'hole', 'spinner_stop', 'teleport'\n        ]\n        is_walkable_type = tile_type in walkable_types or 'spinner' in tile_type\n        return is_walkable_type\n\n    def get_neighbors(x, y):\n        print(f'DEBUG: Getting neighbors for ({x}, {y})') # DEBUG\n        neighbors = []\n        for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) not in grid:\n                continue\n            \n            print(f'DEBUG: Checking neighbor ({nx},{ny}) from ({x},{y}). Type: {grid.get((nx,ny))}') # DEBUG\n            if grid.get((nx, ny)) == 'ledge' and dy == 1 and grid.get((x,y)) != 'ledge':\n                if is_walkable(nx, ny + 1):\n                    neighbors.append((nx, ny + 1, 'Down'))\n                continue\n            if is_walkable(nx, ny):\n                neighbors.append((nx, ny, move))\n        return neighbors\n\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    start_node = (start_x, start_y)\n    \n    target_nodes = set()\n    if is_walkable(target_x, target_y):\n        target_nodes.add((target_x, target_y))\n    else:\n        for dx, dy, _ in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            adj_x, adj_y = target_x + dx, target_y + dy\n            is_adj_walkable = is_walkable(adj_x, adj_y)\n            print(f'DEBUG: Checking target neighbor ({adj_x}, {adj_y}): walkable={is_adj_walkable}') # DEBUG\n            if is_adj_walkable:\n                target_nodes.add((adj_x, adj_y))\n\n    print(f'DEBUG: Target nodes identified: {target_nodes}') # DEBUG\n    if not target_nodes:\n        print(json.dumps([]))\n        return\n\n    open_set = []\n    heapq.heappush(open_set, (0, start_node))\n    came_from = {}\n    g_score = {start_node: 0}\n    f_score = {start_node: min(heuristic(start_node, t) for t in target_nodes)}\n\n    path_found = False\n    while open_set:\n        _, current = heapq.heappop(open_set)\n        print(f'DEBUG: Visiting node: {current}') # DEBUG\n\n        if current in target_nodes:\n            path_moves = []\n            temp = current\n            while temp in came_from:\n                prev, move = came_from[temp]\n                path_moves.append(move)\n                temp = prev\n            \n            moves = path_moves[::-1]\n            x, y = start_x, start_y\n            coordinates = [{'x': x, 'y': y}]\n            move_map = {'Up': (0, -1), 'Down': (0, 1), 'Left': (-1, 0), 'Right': (1, 0)}\n\n            for move in moves:\n                if move in move_map:\n                    dx, dy = move_map[move]\n                    x += dx\n                    y += dy\n                    coordinates.append({'x': x, 'y': y})\n            print(json.dumps(coordinates))\n            path_found = True\n            break\n\n        for neighbor_x, neighbor_y, move in get_neighbors(current[0], current[1]):\n            neighbor = (neighbor_x, neighbor_y)\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = (current, move)\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + min(heuristic(neighbor, t) for t in target_nodes)\n                heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    if not path_found:\n        print('DEBUG: Path not found. Printing came_from dictionary.') # DEBUG\n        print(f'DEBUG: {came_from}') # DEBUG\n        print(json.dumps([]))\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    find_and_convert_path(start_x, start_y, target_x, target_y, map_xml_string)\nexcept Exception as e:\n    print(f'Error executing path_planner: {e}')"
  }
}