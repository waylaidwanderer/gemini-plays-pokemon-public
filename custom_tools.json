{
  "deterministic_battle_strategist": {
    "description": "A deterministic, non-LLM tool that analyzes battle state and recommends the next action (FIGHT/RUN) and move. Now includes STAB calculation for improved accuracy.",
    "input_schema": {
      "type": "object",
      "properties": {
        "my_pokemon_name": {
          "type": "string"
        },
        "my_pokemon_level": {
          "type": "integer"
        },
        "my_pokemon_hp_current": {
          "type": "integer"
        },
        "my_pokemon_hp_max": {
          "type": "integer"
        },
        "opponent_pokemon_name": {
          "type": "string"
        },
        "opponent_pokemon_level": {
          "type": "integer",
          "nullable": true
        },
        "move_1_name": {
          "type": "string"
        },
        "move_1_pp_current": {
          "type": "integer"
        },
        "move_2_name": {
          "type": "string",
          "nullable": true
        },
        "move_2_pp_current": {
          "type": "integer",
          "nullable": true
        },
        "move_3_name": {
          "type": "string",
          "nullable": true
        },
        "move_3_pp_current": {
          "type": "integer",
          "nullable": true
        },
        "move_4_name": {
          "type": "string",
          "nullable": true
        },
        "move_4_pp_current": {
          "type": "integer",
          "nullable": true
        },
        "current_objective": {
          "type": "string",
          "enum": [
            "TRAINING",
            "TRAVELING"
          ]
        },
        "battle_type": {
          "type": "string",
          "enum": [
            "WILD",
            "TRAINER"
          ]
        }
      },
      "required": [
        "my_pokemon_name",
        "my_pokemon_level",
        "my_pokemon_hp_current",
        "my_pokemon_hp_max",
        "opponent_pokemon_name",
        "move_1_name",
        "move_1_pp_current",
        "current_objective",
        "battle_type"
      ]
    },
    "python_script": "import json\n\n# --- Data Initialization ---\n\nPOKEMON_TYPES = {\n    'RATTATA': ['Normal'], 'SENTRET': ['Normal'], 'PIDGEY': ['Normal', 'Flying'], 'HOOTHOOT': ['Normal', 'Flying'], 'PIDGEOTTO': ['Normal', 'Flying'],\n    'GEODUDE': ['Rock', 'Ground'], 'ZUBAT': ['Poison', 'Flying'], 'GOLBAT': ['Poison', 'Flying'], 'BELLSPROUT': ['Grass', 'Poison'], 'EKANS': ['Poison'],\n    'GASTLY': ['Ghost', 'Poison'], 'HAUNTER': ['Ghost', 'Poison'], 'SLOWPOKE': ['Water', 'Psychic'], 'MAGIKARP': ['Water'], 'WEEDLE': ['Bug', 'Poison'],\n    'KAKUNA': ['Bug', 'Poison'], 'CATERPIE': ['Bug'], 'METAPOD': ['Bug'], 'PARAS': ['Bug', 'Grass'], 'SPINARAK': ['Bug', 'Poison'],\n    'CYNDAQUIL': ['Fire'], 'QUILAVA': ['Fire'], 'TYPHLOSION': ['Fire'], 'VULPIX': ['Fire'], 'GROWLITHE': ['Fire'], 'PONYTA': ['Fire'], 'MAGMAR': ['Fire'],\n    'TENTACOOL': ['Water', 'Poison'], 'TENTACRUEL': ['Water', 'Poison'], 'KRABBY': ['Water'], 'POLIWAG': ['Water'], 'POLIWHIRL': ['Water'], 'MARILL': ['Water'], 'MANTINE': ['Water', 'Flying'], 'SHELLDER': ['Water'],\n    'SANDSHREW': ['Ground'], 'NIDORAN♂': ['Poison'], 'NIDORINO': ['Poison'],\n    'ABRA': ['Psychic'], 'DROWZEE': ['Psychic'],\n    'TOGEPI': ['Normal'], 'UNOWN': ['Psychic']\n}\n\nMOVE_DATA = {\n    'TACKLE': {'type': 'Normal', 'power': 35, 'accuracy': 95},\n    'SCRATCH': {'type': 'Normal', 'power': 40, 'accuracy': 100},\n    'QUICK ATTACK': {'type': 'Normal', 'power': 40, 'accuracy': 100},\n    'STRENGTH': {'type': 'Normal', 'power': 80, 'accuracy': 100},\n    'CUT': {'type': 'Normal', 'power': 50, 'accuracy': 95},\n    'EMBER': {'type': 'Fire', 'power': 40, 'accuracy': 100},\n    'FLAME WHEEL': {'type': 'Fire', 'power': 60, 'accuracy': 100},\n    'WATER GUN': {'type': 'Water', 'power': 40, 'accuracy': 100},\n    'SURF': {'type': 'Water', 'power': 95, 'accuracy': 100},\n    'BUBBLEBEAM': {'type': 'Water', 'power': 65, 'accuracy': 100},\n    'PECK': {'type': 'Flying', 'power': 35, 'accuracy': 100},\n    'GUST': {'type': 'Flying', 'power': 40, 'accuracy': 100},\n    'ROCK THROW': {'type': 'Rock', 'power': 50, 'accuracy': 90},\n    'MUD-SLAP': {'type': 'Ground', 'power': 20, 'accuracy': 100},\n    'DIG': {'type': 'Ground', 'power': 60, 'accuracy': 100},\n    'POISON STING': {'type': 'Poison', 'power': 15, 'accuracy': 100},\n    'LICK': {'type': 'Ghost', 'power': 20, 'accuracy': 100},\n    'CONFUSION': {'type': 'Psychic', 'power': 50, 'accuracy': 100},\n    'LEECH SEED': {'type': 'Grass', 'power': 0, 'accuracy': 90},\n    'VINE WHIP': {'type': 'Grass', 'power': 35, 'accuracy': 100},\n    'ABSORB': {'type': 'Grass', 'power': 20, 'accuracy': 100},\n    'FURY CUTTER': {'type': 'Bug', 'power': 10, 'accuracy': 95},\n    'TWINEEDLE': {'type': 'Bug', 'power': 25, 'accuracy': 100},\n    'HEADBUTT': {'type': 'Normal', 'power': 70, 'accuracy': 100}\n}\n\nTYPE_EFFECTIVENESS = {\n    'Normal': {'Rock': 0.5, 'Ghost': 0, 'Steel': 0.5},\n    'Fire': {'Fire': 0.5, 'Water': 0.5, 'Grass': 2, 'Ice': 2, 'Bug': 2, 'Rock': 0.5, 'Dragon': 0.5, 'Steel': 2},\n    'Water': {'Fire': 2, 'Water': 0.5, 'Grass': 0.5, 'Ground': 2, 'Rock': 2, 'Dragon': 0.5},\n    'Electric': {'Water': 2, 'Electric': 0.5, 'Grass': 0.5, 'Ground': 0, 'Flying': 2, 'Dragon': 0.5},\n    'Grass': {'Fire': 0.5, 'Water': 2, 'Grass': 0.5, 'Poison': 0.5, 'Ground': 2, 'Flying': 0.5, 'Bug': 0.5, 'Rock': 2, 'Dragon': 0.5, 'Steel': 0.5},\n    'Ice': {'Fire': 0.5, 'Water': 0.5, 'Grass': 2, 'Ice': 0.5, 'Ground': 2, 'Flying': 2, 'Dragon': 2, 'Steel': 0.5},\n    'Fighting': {'Normal': 2, 'Ice': 2, 'Poison': 0.5, 'Flying': 0.5, 'Psychic': 0.5, 'Bug': 0.5, 'Rock': 2, 'Ghost': 0, 'Dark': 2, 'Steel': 2},\n    'Poison': {'Grass': 2, 'Poison': 0.5, 'Ground': 0.5, 'Rock': 0.5, 'Ghost': 0.5, 'Steel': 0},\n    'Ground': {'Fire': 2, 'Electric': 2, 'Grass': 0.5, 'Poison': 2, 'Flying': 0, 'Bug': 0.5, 'Rock': 2, 'Steel': 2},\n    'Flying': {'Electric': 0.5, 'Grass': 2, 'Fighting': 2, 'Bug': 2, 'Rock': 0.5, 'Steel': 0.5},\n    'Psychic': {'Fighting': 2, 'Poison': 2, 'Psychic': 0.5, 'Dark': 0, 'Steel': 0.5},\n    'Bug': {'Fire': 0.5, 'Grass': 2, 'Fighting': 0.5, 'Poison': 0.5, 'Flying': 0.5, 'Psychic': 2, 'Ghost': 0.5, 'Dark': 2, 'Steel': 0.5},\n    'Rock': {'Fire': 2, 'Ice': 2, 'Fighting': 0.5, 'Ground': 0.5, 'Flying': 2, 'Bug': 2, 'Steel': 0.5},\n    'Ghost': {'Normal': 0, 'Psychic': 2, 'Ghost': 2, 'Dark': 0.5},\n    'Dragon': {'Dragon': 2, 'Steel': 0.5},\n    'Dark': {'Fighting': 0.5, 'Psychic': 2, 'Ghost': 2, 'Dark': 0.5},\n    'Steel': {'Fire': 0.5, 'Water': 0.5, 'Electric': 0.5, 'Ice': 2, 'Rock': 2, 'Steel': 0.5}\n}\n\n# --- Helper Functions ---\n\ndef get_effectiveness(move_type, opponent_types):\n    if not opponent_types: return 1\n    effectiveness = 1\n    for opp_type in opponent_types:\n        effectiveness *= TYPE_EFFECTIVENESS.get(move_type, {}).get(opp_type, 1)\n    return effectiveness\n\n# --- Main Logic ---\n\ndef decide_battle_action():\n    # Input parsing\n    my_pkmn_name = input_data.get('my_pokemon_name', '').upper()\n    opponent_pkmn_name = input_data.get('opponent_pokemon_name', '').upper()\n    battle_type = input_data.get('battle_type', 'WILD')\n    current_objective = input_data.get('current_objective', 'TRAVELING')\n    my_hp_current = int(input_data.get('my_pokemon_hp_current', 0))\n    my_hp_max = int(input_data.get('my_pokemon_hp_max', 1))\n    my_level = int(input_data.get('my_pokemon_level', 1))\n    opponent_level_str = input_data.get('opponent_pokemon_level')\n    opponent_level = int(opponent_level_str) if opponent_level_str and opponent_level_str.isdigit() else 1\n\n    # Decision: RUN or FIGHT\n    if battle_type == 'WILD':\n        if current_objective == 'TRAVELING' and my_level >= opponent_level + 5:\n            print(json.dumps({'action': 'RUN', 'move': None}))\n            return\n        if my_hp_current / my_hp_max < 0.2: # Flee if low HP in wild battle\n            print(json.dumps({'action': 'RUN', 'move': None}))\n            return\n\n    # Decision: FIGHT - select best move\n    my_types = POKEMON_TYPES.get(my_pkmn_name)\n    opponent_types = POKEMON_TYPES.get(opponent_pkmn_name)\n\n    moves = []\n    for i in range(1, 5):\n        move_name = input_data.get(f'move_{i}_name')\n        pp_current = input_data.get(f'move_{i}_pp_current')\n        if move_name and pp_current is not None and int(pp_current) > 0:\n            moves.append(move_name.upper())\n\n    best_move = None\n    max_damage = -1\n\n    if not moves:\n        print(json.dumps({'action': 'FIGHT', 'move': 'STRUGGLE'}))\n        return\n\n    for move_name in moves:\n        move_info = MOVE_DATA.get(move_name)\n        if not move_info: continue\n\n        power = move_info['power']\n        move_type = move_info['type']\n        effectiveness = get_effectiveness(move_type, opponent_types)\n        \n        stab = 1.5 if my_types and move_type in my_types else 1\n        \n        # Simple damage calculation\n        damage = power * effectiveness * stab\n\n        if damage > max_damage:\n            max_damage = damage\n            best_move = move_name.title()\n\n    if not best_move:\n        # Fallback to the first available move if no data is found\n        best_move = moves[0].title()\n\n    print(json.dumps({'action': 'FIGHT', 'move': best_move}))\n\n# --- Execution ---\ndecide_battle_action()\n",
    "history": [
      {
        "commit_message": "feat: Create deterministic battle strategist. This tool replaces the unreliable simple_battle_strategist agent, which has been failing due to server errors. It uses a hardcoded type chart and logic to provide a stable and consistent source of battle advice, directly addressing a critical system critique.",
        "timestamp": "2025-11-03T18:25:45.289Z",
        "action_counter": 17503
      },
      {
        "commit_message": "fix: Correctly filter status moves. The previous version had a flawed check that failed to exclude status moves like LEER, causing it to give incorrect battle advice. This commit introduces a dedicated `STATUS_MOVES` set and adds a clear check (`if name in STATUS_MOVES`) to the move evaluation loop, ensuring that only damaging moves are considered. This resolves the critical logic bug.",
        "timestamp": "2025-11-03T18:29:57.269Z",
        "action_counter": 17510
      },
      {
        "commit_message": "fix: Handle null opponent level in wild battles. The script was crashing with a ValueError when `opponent_pokemon_level` was the string 'null'. This commit adds an explicit check for 'null' before attempting integer conversion, preventing the crash and allowing the tool to function correctly in wild encounters where the opponent's level is not displayed.",
        "timestamp": "2025-11-03T19:50:14.395Z",
        "action_counter": 17599
      },
      {
        "commit_message": "feat: Add Sandshrew type and improve run logic. The tool previously recommended fighting a Sandshrew with a Fire-type because it lacked type information and its run logic was too simple. This commit adds 'SANDSHREW' to the `KNOWN_POKEMON_TYPES` dictionary and introduces a new check to automatically run from wild battles when traveling if the best available move is not very effective. This improves strategic decision-making and prevents wasting resources on unfavorable encounters.",
        "timestamp": "2025-11-03T20:58:14.951Z",
        "action_counter": 17685
      },
      {
        "commit_message": "fix: Prevent automatic run when opponent level is unknown. The previous logic would default to 'RUN' during wild encounters where the opponent's level is not displayed, bypassing the more nuanced type-effectiveness check. This commit adds a specific condition to handle `opponent_level` being `None`, allowing the script to fall through to the effectiveness logic and make a more intelligent decision. This resolves the critical failure where the tool recommended running from a battle with a clear type advantage.",
        "timestamp": "2025-11-03T21:39:18.957Z",
        "action_counter": 17743
      },
      {
        "commit_message": "feat: Add Sentret type information. The tool previously failed to identify Sentret as a Normal-type, leading to incorrect move suggestions. This commit adds the correct type data to the knowledge base, resolving the critical failure.",
        "timestamp": "2025-11-07T11:35:18.556Z",
        "action_counter": 25738
      },
      {
        "commit_message": "feat: Add Meowth type information and CUT move type. The tool previously failed to identify Meowth as a Normal-type and did not know CUT was a Normal-type move, leading to incorrect move suggestions. This commit adds the correct type data to the knowledge base, resolving the critical failure.",
        "timestamp": "2025-11-07T12:02:09.021Z",
        "action_counter": 25786
      },
      {
        "commit_message": "feat: Add Snubbull type information. The tool previously failed to identify Snubbull as a Normal-type, leading to incorrect move suggestions. This commit adds the correct type data to the knowledge base, resolving the critical failure.",
        "timestamp": "2025-11-07T12:06:41.622Z",
        "action_counter": 25791
      },
      {
        "commit_message": "feat: Add Jigglypuff type information. The tool previously failed to identify Jigglypuff as a Normal-type, leading to incorrect move suggestions. This commit adds the correct type data to the knowledge base, resolving the critical failure.",
        "timestamp": "2025-11-07T12:18:46.258Z",
        "action_counter": 25807
      },
      {
        "commit_message": "feat: Add Normal-type Pokémon from Goldenrod Gym. The tool failed to identify Meowth, Snubbull, Jigglypuff, Clefairy, and Miltank as Normal-types during the Goldenrod Gym challenge. This commit adds their type information to the knowledge base, resolving these critical failures and improving future battle strategy.",
        "timestamp": "2025-11-07T12:26:47.489Z",
        "action_counter": 25817
      },
      {
        "commit_message": "feat: Add Slowpoke type information. The tool previously failed to identify Slowpoke as a Water/Psychic-type, leading to incorrect move suggestions. This commit adds the correct type data to the knowledge base, resolving this critical failure.",
        "timestamp": "2025-11-07T13:15:22.597Z",
        "action_counter": 25892
      },
      {
        "commit_message": "refactor: Prioritize power and accuracy in move selection. The tool was recommending low-power, low-accuracy moves like CUT in trivial wild battles, leading to inefficiency. This commit refactors the move knowledge base and updates the sorting logic to prioritize moves based on effectiveness, then power, then accuracy. This resolves the critical failure where the tool made suboptimal choices that wasted time.",
        "timestamp": "2025-11-10T11:39:48.836Z",
        "action_counter": 33151
      },
      {
        "commit_message": "feat: Add Ariados type information. The tool failed to identify Ariados as a Bug/Poison type, leading to a suboptimal move recommendation. This commit adds the correct type data, resolving the failure and improving future battle strategy.",
        "timestamp": "2025-11-10T12:34:37.151Z",
        "action_counter": 33227
      },
      {
        "commit_message": "feat: Add Magnemite type data and Fire vs. Steel effectiveness. The tool failed to identify Magnemite's Steel typing, leading it to recommend a Normal-type move instead of the super-effective Fire-type move. This commit adds Magnemite to the knowledge base and updates the type chart to correctly handle the Fire vs. Steel matchup, resolving the critical failure.",
        "timestamp": "2025-11-10T14:20:51.758Z",
        "action_counter": 33392
      },
      {
        "commit_message": "feat: Add Gyarados type information. The tool failed to identify Gyarados as a Water/Flying type, which would have led to a suboptimal move recommendation. This commit adds the correct type data, resolving the failure and improving future battle strategy.",
        "timestamp": "2025-11-13T06:04:07.012Z",
        "action_counter": 38975
      },
      {
        "commit_message": "feat: Add Mantine type information. The tool previously failed to identify Mantine as a Water/Flying type, which would have led to a suboptimal move recommendation. This commit adds the correct type data, resolving the failure and improving future battle strategy.",
        "timestamp": "2025-11-13T06:17:29.172Z",
        "action_counter": 38999
      },
      {
        "commit_message": "feat: Add STAB calculation. The tool was suggesting suboptimal moves by ignoring the Same-Type Attack Bonus. This commit adds logic to check the user's Pokémon type and apply a 1.5x damage multiplier for STAB moves, resolving a critical logic failure.",
        "timestamp": "2025-11-13T11:11:58.424Z",
        "action_counter": 39391
      },
      {
        "commit_message": "feat: Add STAB calculation and Primeape data. The tool was suggesting suboptimal moves by ignoring the Same-Type Attack Bonus. This commit adds logic to check the user's Pokémon type and apply a 1.5x damage multiplier for STAB moves, and adds Primeape to the type database, resolving a critical logic failure.",
        "timestamp": "2025-11-13T11:51:41.268Z",
        "action_counter": 39422
      },
      {
        "commit_message": "feat: Add Mantine type information. The tool previously failed to identify Mantine as a Water/Flying type, which would have led to a suboptimal move recommendation. This commit adds the correct type data, resolving the failure and improving future battle strategy.",
        "timestamp": "2025-11-14T10:03:09.335Z",
        "action_counter": 41254
      },
      {
        "commit_message": "feat: Add Tentacruel type information. The tool lacked data for Tentacruel, which would have led to a suboptimal move recommendation. This commit adds the correct Water/Poison typing, resolving the potential failure and improving future battle strategy.",
        "timestamp": "2025-11-14T10:18:59.741Z",
        "action_counter": 41279
      },
      {
        "commit_message": "feat: Add Spinarak type data. The tool lacked data for Spinarak, which could have led to a suboptimal move recommendation in the National Park. This commit adds the correct Bug/Poison typing, improving future battle strategy.",
        "timestamp": "2025-11-14T18:06:36.042Z",
        "action_counter": 41945
      },
      {
        "commit_message": "fix: Handle empty opponent_pokemon_level in wild battles. The tool was crashing when encountering a wild Pokémon because it attempted to convert an empty string for the opponent's level into an integer. This commit adds a check to default the level to '1' if the input string is empty, resolving the critical failure and also adds Pidgeotto to the pokemon type database.",
        "timestamp": "2025-11-14T19:23:04.007Z",
        "action_counter": 42046
      },
      {
        "commit_message": "feat: Add DIG to move knowledge base. The tool was recommending suboptimal moves like STRENGTH against Fire-types because it lacked data for the super-effective move DIG. This commit adds the correct Ground type, power, and accuracy for DIG, resolving this critical logic failure.",
        "timestamp": "2025-11-15T01:44:38.317Z",
        "action_counter": 42714
      },
      {
        "commit_message": "feat: Add Marill type data. The tool lacked data for Marill, causing it to recommend a suboptimal move based on raw power instead of type effectiveness. This commit adds the correct Water typing, resolving the critical failure.",
        "timestamp": "2025-11-15T01:57:53.189Z",
        "action_counter": 42739
      },
      {
        "commit_message": "feat: Add Poliwhirl type and Bubblebeam move data. The tool was missing critical data for the current battle, which would have led to a suboptimal move recommendation. This commit adds the correct Water typing for Poliwhirl and the power/accuracy data for Bubblebeam, resolving the failure.",
        "timestamp": "2025-11-15T02:46:25.979Z",
        "action_counter": 42837
      },
      {
        "commit_message": "feat: Add Shellder type and Tackle move data. The tool lacked data for Shellder, which could have led to suboptimal move recommendations. This commit adds the correct Water typing for the Pokémon and the Normal type, power, and accuracy for the move Tackle, improving future battle strategy.",
        "timestamp": "2025-11-15T06:14:38.194Z",
        "action_counter": 43201
      }
    ]
  },
  "list_reachable_unseen_tiles": {
    "description": "Performs a search from the player's current position to find all reachable tiles and then returns a list of all 'unseen' tiles that are adjacent to any of those reachable tiles.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef list_unseen():\n    try:\n        root = ET.fromstring(map_xml_string)\n    except ET.ParseError:\n        print(json.dumps({'error': 'Failed to parse map XML.'}))\n        return\n\n    player_pos = None\n    player_tile_type = None\n    grid = {}\n    all_x, all_y = [], []\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        all_y.append(y)\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            all_x.append(x)\n            grid[(x, y)] = tile_elem\n            if tile_elem.find('Player') is not None:\n                player_pos = (x, y)\n                player_tile_type = tile_elem.get('type')\n\n    if not player_pos:\n        print(json.dumps({'error': 'Player position not found.'}))\n        return\n\n    min_x, max_x = min(all_x), max(all_x)\n    min_y, max_y = min(all_y), max(all_y)\n\n    impassable_tile_types = {\n        'WALL', 'VOID', 'PC', 'TV', 'COUNTER', 'BOOKSHELF', 'WINDOW',\n        'TOWN_MAP', 'POKEDEX', 'RADIO', 'PILLAR', 'MART_SHELF',\n        'INCENSE_BURNER', 'CUT_TREE', 'HEADBUTT_TREE', 'BUOY', 'unseen', 'WHIRLPOOL'\n    }\n    if player_tile_type != 'WATER':\n        impassable_tile_types.add('WATER')\n\n    queue = deque([player_pos])\n    reachable_tiles = {player_pos}\n    \n    while queue:\n        (x, y) = queue.popleft()\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = x + dx, y + dy\n            neighbor = (next_x, next_y)\n            \n            if not (min_x <= next_x <= max_x and min_y <= next_y <= max_y) or neighbor in reachable_tiles:\n                continue\n\n            tile = grid.get(neighbor)\n            if tile is None or tile.get('type') in impassable_tile_types or tile.get('has-object') == 'true':\n                continue\n\n            # Ledge logic\n            current_tile = grid.get((x,y))\n            tile_type = tile.get('type')\n            current_tile_type = current_tile.get('type')\n            if tile_type == 'LEDGE_HOP_DOWN' and dy == -1: continue\n            if tile_type == 'LEDGE_HOP_LEFT' and dx == 1: continue\n            if tile_type == 'LEDGE_HOP_RIGHT' and dx == -1: continue\n            if current_tile_type == 'LEDGE_HOP_DOWN' and dy == -1: continue\n            if current_tile_type == 'LEDGE_HOP_LEFT' and dx == 1: continue\n            if current_tile_type == 'LEDGE_HOP_RIGHT' and dx == -1: continue\n            if tile_type == 'FLOOR_UP_WALL' and dy == 1: continue\n\n            reachable_tiles.add(neighbor)\n            queue.append(neighbor)\n\n    adjacent_unseen = set()\n    for (x, y) in reachable_tiles:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor_pos = (x + dx, y + dy)\n            neighbor_tile = grid.get(neighbor_pos)\n            if neighbor_tile is not None and neighbor_tile.get('type') == 'unseen':\n                adjacent_unseen.add(neighbor_pos)\n    \n    print(json.dumps(sorted(list(adjacent_unseen))))\n\nlist_unseen()",
    "history": [
      {
        "commit_message": "feat: Create list_reachable_unseen_tiles tool. This tool addresses a persistent system alert and a need identified during self-assessment for more systematic exploration. It performs a BFS from the player's position to find all reachable tiles, then identifies and returns a list of all 'unseen' tiles adjacent to this reachable area. This will enable more comprehensive map clearing than the previous 'plan_next_exploration_step' tool.",
        "timestamp": "2025-11-15T09:15:46.492Z",
        "action_counter": 43505
      }
    ]
  },
  "plan_path_to_target": {
    "description": "Generates a path to a target coordinate. NOTE: This tool only PLANS the path. You must set `buttons_to_press` to `['path']` to execute it. This version correctly treats all objects as impassable obstacles, finds an adjacent tile if the target is blocked, reads map markers to avoid off-screen obstacles, avoids pathing through warp tiles, dynamically handles water traversal, and now dynamically detects map boundaries to correctly handle negative coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef find_path():\n    try:\n        root = ET.fromstring(map_xml_string)\n    except ET.ParseError:\n        print(json.dumps({'error': 'Failed to parse map XML.'}))\n        return\n\n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n    except (ValueError, KeyError) as e:\n        print(json.dumps({'error': f'Invalid input data: {e}'}))\n        return\n\n    player_pos = None\n    player_tile_type = None\n    grid = {}\n    all_obstacles = set()\n    \n    all_x = []\n    all_y = []\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        all_y.append(y)\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            all_x.append(x)\n            grid[(x, y)] = tile_elem\n            if tile_elem.find('Player') is not None:\n                player_pos = (x, y)\n                player_tile_type = tile_elem.get('type')\n            if tile_elem.get('has-object') == 'true':\n                all_obstacles.add((x, y))\n            for marker in tile_elem.findall('Marker'):\n                all_obstacles.add((x, y))\n    \n    if not all_x or not all_y:\n        print(json.dumps({'error': 'Map data is empty.'}))\n        return\n        \n    min_x, max_x = min(all_x), max(all_x)\n    min_y, max_y = min(all_y), max(all_y)\n\n    if not player_pos:\n        print(json.dumps({'error': 'Player position not found.'}))\n        return\n\n    impassable_tile_types = {\n        'WALL', 'VOID', 'PC', 'TV', 'COUNTER', 'BOOKSHELF', 'WINDOW',\n        'TOWN_MAP', 'POKEDEX', 'RADIO', 'PILLAR', 'MART_SHELF',\n        'INCENSE_BURNER', 'CUT_TREE', 'HEADBUTT_TREE', 'BUOY', 'unseen', 'WHIRLPOOL'\n    }\n    \n    if player_tile_type != 'WATER':\n        impassable_tile_types.add('WATER')\n\n    queue = deque([(player_pos, [])])\n    visited = {player_pos}\n    \n    target_is_impassable = False\n    target_tile = grid.get((target_x, target_y))\n    if target_tile is not None:\n        if (target_tile.get('type') in impassable_tile_types or (target_x, target_y) in all_obstacles):\n            target_is_impassable = True\n    else: \n        target_is_impassable = True\n    \n    path_found = False\n    while queue:\n        (x, y), path = queue.popleft()\n\n        if not target_is_impassable and (x, y) == (target_x, target_y):\n            print(json.dumps(path + [{'x': x, 'y': y}]))\n            path_found = True\n            break\n        \n        if target_is_impassable:\n            for dx_adj, dy_adj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                if (x + dx_adj, y + dy_adj) == (target_x, target_y):\n                    print(json.dumps(path + [{'x': x, 'y': y}]))\n                    path_found = True\n                    break\n            if path_found:\n                break\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = x + dx, y + dy\n            neighbor = (next_x, next_y)\n            \n            if not (min_x <= next_x <= max_x and min_y <= next_y <= max_y):\n                continue\n            if neighbor in visited:\n                continue\n\n            tile = grid.get(neighbor)\n            if tile is None:\n                continue\n            \n            tile_type = tile.get('type')\n            is_obstacle = neighbor in all_obstacles\n            \n            if tile_type in impassable_tile_types:\n                continue\n            if is_obstacle:\n                continue\n            \n            if tile.find('Warp') is not None and neighbor != (target_x, target_y):\n                continue\n\n            current_tile = grid.get((x, y))\n            if current_tile is None: continue\n            current_tile_type = current_tile.get('type')\n\n            if tile_type == 'LEDGE_HOP_DOWN' and dy == -1: continue\n            if tile_type == 'LEDGE_HOP_LEFT' and dx == 1: continue\n            if tile_type == 'LEDGE_HOP_RIGHT' and dx == -1: continue\n            if current_tile_type == 'LEDGE_HOP_DOWN' and dy == -1: continue\n            if current_tile_type == 'LEDGE_HOP_LEFT' and dx == 1: continue\n            if current_tile_type == 'LEDGE_HOP_RIGHT' and dx == -1: continue\n            if tile_type == 'FLOOR_UP_WALL' and dy == -1: continue\n\n            visited.add(neighbor)\n            new_path = path + [{'x': x, 'y': y}]\n            queue.append((neighbor, new_path))\n    \n    if not path_found:\n        print(json.dumps({'error': 'No path found.'}))\n    \nfind_path()\n",
    "history": [
      {
        "commit_message": "refactor: Rename tool to plan_path_to_target for clarity. The previous name 'path_and_execute_v3' was misleading, as the tool only generates a path plan, it does not execute it. This was the root cause of a multi-turn hallucination loop. The description has also been updated to explicitly state that `buttons_to_press` must be set to `['path']` to follow the generated route.",
        "timestamp": "2025-11-15T08:20:07.805Z",
        "action_counter": 43411
      },
      {
        "commit_message": "feat: Add map marker parsing to avoid obstacles. The tool was critically failing by pathing into off-screen obstacles like defeated trainers because it only considered objects currently visible. This commit adds logic to parse all <Marker> tags from the map XML and add their coordinates to the set of impassable obstacles, resolving this long-standing failure.",
        "timestamp": "2025-11-15T08:56:50.564Z",
        "action_counter": 43473
      },
      {
        "commit_message": "fix: Correct ledge logic for FLOOR_UP_WALL tiles. The previous implementation incorrectly blocked downward movement onto these tiles, treating them as climbable walls instead of ledges you jump down from. This critical error made it impossible to find paths in areas with ledges, such as Cianwood City. This commit corrects the check to block upward movement (dy == -1), resolving the pathfinding failure.",
        "timestamp": "2025-11-15T19:55:35.826Z",
        "action_counter": 44379
      }
    ]
  },
  "pokemon_nicknamer": {
    "description": "Automates the process of nicknaming a Pokémon. Takes a desired nickname as a string and outputs the sequence of button presses to enter it on the nicknaming screen. Handles switching between UPPER and lower case keyboards.",
    "input_schema": {
      "type": "object",
      "properties": {
        "nickname": {
          "type": "string"
        }
      },
      "required": [
        "nickname"
      ]
    },
    "python_script": "import json\n\ndef generate_nickname_buttons(nickname):\n    upper_layout = {\n        'A': (0, 0), 'B': (1, 0), 'C': (2, 0), 'D': (3, 0), 'E': (4, 0), 'F': (5, 0), 'G': (6, 0), 'H': (7, 0), 'I': (8, 0),\n        'J': (0, 1), 'K': (1, 1), 'L': (2, 1), 'M': (3, 1), 'N': (4, 1), 'O': (5, 1), 'P': (6, 1), 'Q': (7, 1), 'R': (8, 1),\n        'S': (0, 2), 'T': (1, 2), 'U': (2, 2), 'V': (3, 2), 'W': (4, 2), 'X': (5, 2), 'Y': (6, 2), 'Z': (7, 2),\n        '-': (0, 3), '?': (1, 3), '!': (2, 3), '/': (3, 3), '.': (4, 3), ',': (5, 3),\n        'lower': (0, 4), 'DEL': (7, 4), 'END': (8, 4)\n    }\n    lower_layout = {\n        'a': (0, 0), 'b': (1, 0), 'c': (2, 0), 'd': (3, 0), 'e': (4, 0), 'f': (5, 0), 'g': (6, 0), 'h': (7, 0), 'i': (8, 0),\n        'j': (0, 1), 'k': (1, 1), 'l': (2, 1), 'm': (3, 1), 'n': (4, 1), 'o': (5, 1), 'p': (6, 1), 'q': (7, 1), 'r': (8, 1),\n        's': (0, 2), 't': (1, 2), 'u': (2, 2), 'v': (3, 2), 'w': (4, 2), 'x': (5, 2), 'y': (6, 2), 'z': (7, 2),\n        '×': (0, 3), '(': (1, 3), ')': (2, 3), ':': (3, 3), ';': (4, 3), '[': (5, 3), ']': (6, 3), '<PK>': (7, 3), '<MN>': (8, 3),\n        'UPPER': (0, 4), 'DEL': (7, 4), 'END': (8, 4)\n    }\n\n    buttons = []\n    cursor_pos = (0, 0) # Start at 'A'\n    is_lower = False\n\n    for char in nickname:\n        target_layout = lower_layout if char.islower() else upper_layout\n        target_case_button = 'lower' if not is_lower and char.islower() else 'UPPER' if is_lower and char.isupper() else None\n\n        if target_case_button:\n            case_pos = upper_layout[target_case_button] if not is_lower else lower_layout[target_case_button]\n            dx = case_pos[0] - cursor_pos[0]\n            dy = case_pos[1] - cursor_pos[1]\n            buttons.extend(['Right'] * dx if dx > 0 else ['Left'] * -dx)\n            buttons.extend(['Down'] * dy if dy > 0 else ['Up'] * -dy)\n            buttons.append('A')\n            cursor_pos = case_pos\n            is_lower = not is_lower\n        \n        current_layout = lower_layout if is_lower else upper_layout\n        if char not in current_layout:\n            continue\n\n        target_pos = current_layout[char]\n        dx = target_pos[0] - cursor_pos[0]\n        dy = target_pos[1] - cursor_pos[1]\n        buttons.extend(['Right'] * dx if dx > 0 else ['Left'] * -dx)\n        buttons.extend(['Down'] * dy if dy > 0 else ['Up'] * -dy)\n        buttons.append('A')\n        cursor_pos = target_pos\n\n    end_pos = lower_layout['END'] if is_lower else upper_layout['END']\n    dx = end_pos[0] - cursor_pos[0]\n    dy = end_pos[1] - cursor_pos[1]\n    buttons.extend(['Right'] * dx if dx > 0 else ['Left'] * -dx)\n    buttons.extend(['Down'] * dy if dy > 0 else ['Up'] * -dy)\n    buttons.append('A')\n\n    print(json.dumps(buttons))\n\ntry:\n    generate_nickname_buttons(input_data['nickname'])\nexcept Exception as e:\n    print(json.dumps({'error': str(e)}))\n",
    "history": [
      {
        "commit_message": "feat: Create pokemon_nicknamer tool. This tool automates the tedious and error-prone process of manually entering a Pokémon's nickname. It takes a string as input and generates the full sequence of button presses, including handling case changes, to enter the name and confirm. This directly addresses an overwatch critique and improves overall gameplay efficiency.",
        "timestamp": "2025-11-13T00:55:14.257Z",
        "action_counter": 38464
      },
      {
        "commit_message": "fix: Overhaul nicknamer logic to fix critical failures. The previous version generated incorrect and excessively long button sequences, causing repeated failures to enter names correctly and leading to unintended actions in the overworld. This commit completely rewrites the script to use a coordinate-based keyboard layout and calculate precise movement paths between characters. It now correctly handles case switching and, most importantly, terminates the button sequence immediately after pressing 'END'. This resolves the long-standing critical bug identified by overwatch.",
        "timestamp": "2025-11-14T10:46:42.366Z",
        "action_counter": 41318
      }
    ]
  },
  "wait_for_event": {
    "description": "A tool that does nothing, effectively passing a turn. Used to test for time-based events or wait out cutscenes.",
    "input_schema": {},
    "python_script": "print(\"Waiting for one turn.\")",
    "history": [
      {
        "commit_message": "feat: Create wait_for_event tool. This tool allows me to test for time-based events by passing a turn without any game input, as suggested by the puzzle_solver_agent for the CianwoodLugiaSpeechHouse puzzle.",
        "timestamp": "2025-11-15T14:11:40.484Z",
        "action_counter": 43948
      },
      {
        "commit_message": "feat: Create wait_for_event tool. This tool allows me to test for time-based events by passing a turn without any game input, as suggested by the puzzle_solver_agent for the CianwoodLugiaSpeechHouse puzzle.",
        "timestamp": "2025-11-15T15:01:50.413Z",
        "action_counter": 44000
      }
    ]
  }
}