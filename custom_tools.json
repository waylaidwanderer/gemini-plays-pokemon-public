{
  "menu_navigator_refined_v2": {
    "description": "Presses a sequence of buttons to navigate menus or interact with objects. Bypasses directional/action button restrictions. Returns a JSON array of button strings. Refined for efficiency. v2.1",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "# v2.1 - Simplified button return\nimport json\nprint(json.dumps(input_data['buttons']))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-15T18:51:18.021Z",
        "action_counter": 49463
      },
      {
        "commit_message": "Fixing sandbox errors by redefining the tool with the required commit message. Simplified logic for returning button array.",
        "timestamp": "2026-01-15T23:08:32.011Z",
        "action_counter": 49743
      },
      {
        "commit_message": "Fixing sandbox issues by adding a version comment. Simplified logic for returning button array. v2.1",
        "timestamp": "2026-01-15T23:19:09.791Z",
        "action_counter": 49754
      }
    ]
  },
  "find_path_v9": {
    "description": "Finds a path using BFS on the current map XML, handling walls, objects, warps (DOOR), and obstacles identified by markers. Returns a JSON array of button strings. v9.9.1.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "type": "boolean"
        },
        "avoid_labels": {
          "default": [
            "rock",
            "blocked"
          ],
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "treat_unseen_as_traversable": {
          "default": true,
          "type": "boolean"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ],
      "type": "object"
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef find_path(map_xml_string, target_x, target_y, input_data):\n    try:\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        return {\"error\": f\"Failed to parse map XML: {str(e)}\"}\n        \n    grid = {}\n    player_pos = None\n    player_start_on_water = False\n    avoid_labels = input_data.get('avoid_labels', ['rock', 'blocked'])\n    treat_unseen_as_traversable = input_data.get('treat_unseen_as_traversable', True)\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            seen = tile.attrib['seen'] == 'true'\n            has_object = tile.attrib.get('has-object') == 'true'\n            \n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n                if t_type == 'WATER':\n                    player_start_on_water = True\n            \n            if not seen:\n                if treat_unseen_as_traversable:\n                    grid[(x, y)] = 'FLOOR'\n                else:\n                    grid[(x, y)] = 'WALL'\n                continue\n\n            is_blocked_by_marker = False\n            for marker in tile.findall('Marker'):\n                label = marker.text.lower()\n                if any(word in label for word in avoid_labels):\n                    is_blocked_by_marker = True\n            \n            if t_type in ['WALL', 'BUOY', 'DOOR'] or has_object or is_blocked_by_marker:\n                grid[(x, y)] = 'WALL'\n            elif t_type == 'WATER':\n                grid[(x, y)] = 'WATER'\n            elif t_type == 'LEDGE_HOP_DOWN':\n                grid[(x, y)] = 'LEDGE'\n            elif t_type == 'FLOOR_UP_WALL':\n                grid[(x, y)] = 'UP_WALL'\n            else:\n                grid[(x, y)] = 'FLOOR'\n\n    if player_pos is None:\n        return {\"error\": \"Player position not found in XML\"}\n\n    goal = (target_x, target_y)\n    \n    # BFS state: (x, y), surfing, path\n    queue = deque([(player_pos, player_start_on_water, [])])\n    visited = {(player_pos, player_start_on_water)}\n    \n    while queue:\n        (x, y), surfing, path = queue.popleft()\n        \n        if (x, y) == goal:\n            return path[:50]\n        \n        if len(path) >= 250: continue\n        \n        for dx, dy, action in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) not in grid or grid[(nx, ny)] == 'WALL': continue\n            \n            target = grid[(nx, ny)]\n            new_path = list(path)\n            \n            if not surfing and target == 'WATER':\n                new_path.extend([action, 'A', 'sleep 500', 'A', 'sleep 500', 'A'])\n                new_surfing = True\n            elif surfing and target != 'WATER':\n                new_path.append(action)\n                new_surfing = False\n            else:\n                new_path.append(action)\n                new_surfing = surfing\n            \n            if target == 'LEDGE' and action != 'Down': continue\n            if target == 'UP_WALL' and action == 'Down': continue\n            \n            if (nx, ny, new_surfing) not in visited:\n                visited.add((nx, ny, new_surfing))\n                queue.append(((nx, ny), new_surfing, new_path))\n                \n    return []\n\ntry:\n    tx = int(input_data['target_x'])\n    ty = int(input_data['target_y'])\n    result = find_path(map_xml_string, tx, ty, input_data)\n    print(json.dumps(result))\nexcept Exception as e:\n    print(json.dumps({\"error\": str(e)}))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-16T02:55:59.273Z",
        "action_counter": 50041
      },
      {
        "commit_message": "Refined find_path_v9 to include the 'root' variable within the script context and added robust error handling for map parsing. Also added logic to handle the goal tile's collision type more flexibly if it is a known floor-equivalent. v9.2.",
        "timestamp": "2026-01-16T02:58:37.668Z",
        "action_counter": 50044
      },
      {
        "commit_message": "Refined find_path_v9 to v9.3: Fixed 'root' and 'input_data' scoping issues, optimized BFS for large maps, and improved handling of the goal tile's collision state. Added explicit check for the Player's position within the script context.",
        "timestamp": "2026-01-16T03:00:22.154Z",
        "action_counter": 50046
      },
      {
        "commit_message": "Refined find_path_v9 to v9.4: Fixed scoping issues with 'root' and 'input_data', optimized BFS, and added logic to treat tiles marked with 'cut' as traversable for path planning purposes. v9.4.",
        "timestamp": "2026-01-16T03:03:00.648Z",
        "action_counter": 50048
      },
      {
        "commit_message": "Refined find_path_v9 to v9.4: Fixed scoping issues, added support for land/surf transitions, and improved obstacle marker handling. Optimized BFS for multi-modal travel.",
        "timestamp": "2026-01-16T03:09:30.900Z",
        "action_counter": 50054
      },
      {
        "commit_message": "Refined find_path_v9 to v9.5: Added logic to automatically insert 'A', 'sleep 500', 'A', 'sleep 500', 'A' when transitioning from land to water (to start surfing). Added a 50-button safety cap to prevent harness errors. Improved marker-based obstacle avoidance.",
        "timestamp": "2026-01-16T03:12:26.792Z",
        "action_counter": 50056
      },
      {
        "commit_message": "Refined find_path_v9 to v9.6: Optimized marker-based obstacle detection by removing overly broad keywords like 'wall' and 'ledge' which were incorrectly blocking traversable tiles like UP_WALLs. Now specifically targets 'rock' and 'blocked'. Also improved land/surf transition logic to ensure the 'A' button sequence is only used when moving INTO water from land. v9.6.",
        "timestamp": "2026-01-16T03:15:06.697Z",
        "action_counter": 50058
      },
      {
        "commit_message": "Refined find_path_v9 to v9.7: Added logic to detect if the player starts on a WATER tile and sets the initial BFS 'surfing' state correctly. This fixes pathfinding issues when starting from the water. v9.7.",
        "timestamp": "2026-01-16T03:18:15.814Z",
        "action_counter": 50062
      },
      {
        "commit_message": "Refined find_path_v9 to v9.8: Added path truncation to 50 buttons to respect safety limits, improved land/surf transition logic, and ensured the tool returns an empty array instead of null if no path is found. Optimized BFS memory usage.",
        "timestamp": "2026-01-16T03:20:56.515Z",
        "action_counter": 50065
      },
      {
        "commit_message": "Refined find_path_v9 to v9.9: Parameterized obstacle detection keywords, added a max_path_length constraint to prevent infinite loops, and improved land/surf transition logic. The tool now correctly handles starting on water and ensures the 'A' button sequence is only used when moving INTO water from land. Returns an empty list if no path is found instead of null. v9.9.",
        "timestamp": "2026-01-16T03:25:26.837Z",
        "action_counter": 50071
      },
      {
        "commit_message": "Refined find_path_v9 to v9.9: Parameterized obstacle detection keywords, added a max_path_length constraint to prevent infinite loops, and improved land/surf transition logic. The tool now correctly handles starting on water and ensures the 'A' button sequence is only used when moving INTO water from land. Returns an empty list if no path is found instead of null. v9.9.",
        "timestamp": "2026-01-16T03:26:25.328Z",
        "action_counter": 50073
      },
      {
        "commit_message": "Refined find_path_v9 to v9.9: Increased BFS depth to 250 for long island loops, optimized land/surf transition logic, and improved marker detection to ensure one-way tiles are not incorrectly blocked. v9.9.",
        "timestamp": "2026-01-16T03:31:51.431Z",
        "action_counter": 50079
      },
      {
        "commit_message": "Refined find_path_v9 to v9.9.1: Added 'treat_unseen_as_traversable' parameter (defaulting to True) to allow the BFS to find paths through unexplored areas. This is essential for long-range navigation where parts of the route are not yet visible. Parameterized avoidance keywords and improved land/surf transition logic. v9.9.1.",
        "timestamp": "2026-01-16T03:36:57.722Z",
        "action_counter": 50084
      }
    ]
  },
  "path_analyzer": {
    "description": "Finds a path using BFS on the current map XML, handling one-way ledges (LEDGE_HOP_DOWN), slopes (FLOOR_UP_WALL), and water. Returns a JSON array of button strings. v3.1",
    "input_schema": {
      "properties": {
        "allow_water": {
          "default": false,
          "type": "boolean"
        },
        "autopress_buttons": {
          "default": false,
          "type": "boolean"
        },
        "ignore_objects": {
          "default": false,
          "type": "boolean"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y",
        "autopress_buttons"
      ],
      "type": "object"
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\nimport sys\n\ndef find_path(xml_str, start_x, start_y, target_x, target_y, ignore_objects=False, allow_water=False):\n    try:\n        root = ET.fromstring(xml_str)\n    except Exception:\n        return []\n        \n    grid = {}\n    traversable_types = ['FLOOR', 'DOOR', 'LEDGE_HOP_DOWN', 'FLOOR_UP_WALL', 'WARP_CARPET_DOWN', 'unseen']\n    if allow_water:\n        traversable_types.append('WATER')\n        \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tile_type = tile.attrib['type']\n            has_object = tile.attrib.get('has-object') == 'true'\n            traversable = tile_type in traversable_types\n            if not ignore_objects and has_object:\n                traversable = False\n            grid[(x, y)] = (traversable, tile_type)\n\n    queue = deque([(start_x, start_y, [])])\n    visited = set([(start_x, start_y)])\n    \n    while queue:\n        cx, cy, path = queue.popleft()\n        if (cx, cy) == (target_x, target_y):\n            return path\n            \n        _, curr_ttype = grid.get((cx, cy), (False, 'WALL'))\n        \n        for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) in grid:\n                traversable, target_ttype = grid[(nx, ny)]\n                can_move = False\n                if traversable:\n                    # Entering target tile\n                    if target_ttype == 'LEDGE_HOP_DOWN':\n                        if move == 'Down': can_move = True\n                    elif target_ttype == 'FLOOR_UP_WALL':\n                        if move == 'Up': can_move = True\n                    else:\n                        can_move = True\n                        \n                    # Leaving current tile\n                    if curr_ttype == 'LEDGE_HOP_DOWN' and move != 'Down':\n                        can_move = False\n                    if curr_ttype == 'FLOOR_UP_WALL' and move not in ['Up', 'Down']:\n                        can_move = False\n                \n                if can_move and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [move]))\n    return []\n\nraw_input = sys.stdin.read()\nif not raw_input:\n    print(json.dumps([]))\n    sys.exit(0)\n\ntry:\n    input_data = json.loads(raw_input)\n    path = find_path(map_xml_string, int(input_data['start_x']), int(input_data['start_y']), int(input_data['target_x']), int(input_data['target_y']), input_data.get('ignore_objects', False), input_data.get('allow_water', False))\n    print(json.dumps(path))\nexcept Exception:\n    print(json.dumps([]))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-16T05:15:05.934Z",
        "action_counter": 50221
      },
      {
        "commit_message": "Initial creation of path_analyzer tool.",
        "timestamp": "2026-01-16T06:26:27.167Z",
        "action_counter": 50342
      },
      {
        "commit_message": "Refined input handling in path_analyzer to prevent JSONDecodeError. Added sys.stdin.read() check.",
        "timestamp": "2026-01-16T06:28:11.692Z",
        "action_counter": 50348
      },
      {
        "commit_message": "Fixed path_analyzer to return an empty array instead of null when no path is found, preventing tool execution errors.",
        "timestamp": "2026-01-16T06:33:16.036Z",
        "action_counter": 50360
      },
      {
        "commit_message": "Added allow_water parameter and fixed input_data handling.",
        "timestamp": "2026-01-16T06:38:17.802Z",
        "action_counter": 50368
      },
      {
        "commit_message": "Fixed missing input_data definition in path_analyzer.",
        "timestamp": "2026-01-16T06:38:37.665Z",
        "action_counter": 50369
      },
      {
        "commit_message": "Refined traversal logic for ledges and slopes in path_analyzer.",
        "timestamp": "2026-01-16T06:40:42.264Z",
        "action_counter": 50372
      },
      {
        "commit_message": "Updated path_analyzer to treat 'unseen' tiles as traversable for planning purposes.",
        "timestamp": "2026-01-16T06:46:52.048Z",
        "action_counter": 50377
      },
      {
        "commit_message": "Refined traversal logic for ledges and slopes in path_analyzer v3.1.",
        "timestamp": "2026-01-16T06:52:21.698Z",
        "action_counter": 50384
      },
      {
        "commit_message": "Refined traversal logic for ledges and slopes in path_analyzer v3.1.",
        "timestamp": "2026-01-16T06:57:42.816Z",
        "action_counter": 50392
      }
    ]
  },
  "unseen_finder_v1": {
    "description": "Finds reachable unseen tiles (‚ùì) and returns a list of targets sorted by distance. v1.0",
    "input_schema": {
      "type": "object",
      "properties": {
        "current_x": {
          "type": "integer"
        },
        "current_y": {
          "type": "integer"
        }
      },
      "required": [
        "current_x",
        "current_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef find_reachable_unseen(xml_str, start_x, start_y):\n    root = ET.fromstring(xml_str)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            t_type = tile.get('type')\n            seen = tile.get('seen') == 'true'\n            is_walkable = t_type in ['FLOOR', 'TALL_GRASS', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'WARP_CARPET_UP', 'WARP_CARPET_DOWN', 'DOOR']\n            if tile.find('Object') is not None:\n                is_walkable = False\n            grid[(x, y)] = {'walkable': is_walkable, 'seen': seen}\n\n    queue = deque([(start_x, start_y, 0)])\n    visited = set([(start_x, start_y)])\n    reachable_unseen = []\n    \n    while queue:\n        x, y, dist = queue.popleft()\n        \n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:\n                tile_info = grid.get((nx, ny))\n                if tile_info:\n                    if tile_info['seen']:\n                        if tile_info['walkable']:\n                            visited.add((nx, ny))\n                            queue.append((nx, ny, dist + 1))\n                    else:\n                        reachable_unseen.append({\"x\": nx, \"y\": ny, \"distance\": dist + 1})\n                        visited.add((nx, ny))\n\n    reachable_unseen.sort(key=lambda x: x['distance'])\n    return reachable_unseen[:10]\n\nprint(json.dumps(find_reachable_unseen(map_xml_string, input_data['current_x'], input_data['current_y'])))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-16T07:57:24.824Z",
        "action_counter": 50491
      }
    ]
  },
  "fly_to_city_v2": {
    "description": "Automatically navigates the menu and Fly map to a specified city. Assumes starting from the overworld. v2.0",
    "input_schema": {
      "type": "object",
      "properties": {
        "current_city": {
          "type": "string",
          "enum": [
            "NEW_BARK",
            "CHERRYGROVE",
            "VIOLET",
            "AZALEA",
            "GOLDENROD",
            "ECRUTEAK",
            "OLIVINE",
            "CIANWOOD",
            "MAHOGANY",
            "BLACKTHORN",
            "INDIGO_PLATEAU"
          ]
        },
        "target_city": {
          "type": "string",
          "enum": [
            "NEW_BARK",
            "CHERRYGROVE",
            "VIOLET",
            "AZALEA",
            "GOLDENROD",
            "ECRUTEAK",
            "OLIVINE",
            "CIANWOOD",
            "MAHOGANY",
            "BLACKTHORN",
            "INDIGO_PLATEAU"
          ]
        }
      },
      "required": [
        "current_city",
        "target_city"
      ]
    },
    "python_script": "import json\n\noffsets = {\n    'NEW_BARK': (14, 10),\n    'CHERRYGROVE': (11, 10),\n    'VIOLET': (11, 7),\n    'AZALEA': (8, 12),\n    'GOLDENROD': (5, 9),\n    'ECRUTEAK': (8, 6),\n    'OLIVINE': (5, 6),\n    'CIANWOOD': (1, 6),\n    'MAHOGANY': (11, 6),\n    'BLACKTHORN': (14, 6),\n    'INDIGO_PLATEAU': (14, 4)\n}\n\ntarget_city = input_data['target_city'].upper()\ncurrent_city = input_data['current_city'].upper()\n\nt_x, t_y = offsets[target_city]\nc_x, c_y = offsets[current_city]\n\ndx = t_x - c_x\ndy = t_y - c_y\n\n# Sequence: B's to exit menus, Start, Up x 8 (to reach Pokedex), Down (to Pokemon), A, Up (from slot 1 to slot 6), A, A (select Fly)\nbuttons = ['B', 'B', 'B', 'B', 'B', 'Start', 'Up', 'Up', 'Up', 'Up', 'Up', 'Up', 'Up', 'Up', 'Down', 'A', 'Up', 'A', 'A', 'sleep 1000']\n\nif dx < 0:\n    buttons += ['Left'] * abs(dx)\nelif dx > 0:\n    buttons += ['Right'] * dx\n\nif dy < 0:\n    buttons += ['Up'] * abs(dy)\nelif dy > 0:\n    buttons += ['Down'] * dy\n\nbuttons += ['A']\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-16T08:22:32.866Z",
        "action_counter": 50528
      }
    ]
  }
}