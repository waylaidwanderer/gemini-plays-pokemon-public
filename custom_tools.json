{
  "face_and_interact": {
    "description": "Turns the player to face a specified direction and immediately interacts (presses A). If the player is already facing that direction, it simply presses A to avoid unnecessary movement/collisions.",
    "input_schema": {
      "type": "object",
      "properties": {
        "direction": {
          "type": "string",
          "enum": [
            "Up",
            "Down",
            "Left",
            "Right"
          ]
        },
        "current_facing": {
          "type": "string",
          "enum": [
            "up",
            "down",
            "left",
            "right"
          ]
        }
      },
      "required": [
        "direction",
        "current_facing"
      ]
    },
    "python_script": "import json\ndirection = input_data['direction'].title()\ncurrent_facing = input_data['current_facing'].title()\n\nbuttons = []\nif direction != current_facing:\n    buttons.append(direction)\n    buttons.append(\"sleep 500\")\n\nbuttons.append(\"A\")\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "feat: Add face_and_interact tool to combine turning and interacting into a single action, improving efficiency for NPC and object interactions.",
        "timestamp": "2025-11-20T00:01:17.923Z",
        "action_counter": 167
      },
      {
        "commit_message": "fix: prevent unnecessary movement when already facing target. Requires `current_facing` argument.",
        "timestamp": "2025-11-20T00:11:34.994Z",
        "action_counter": 181
      },
      {
        "commit_message": "fix: prevent unnecessary movement when already facing target. Requires `current_facing` argument.",
        "timestamp": "2025-11-20T00:17:07.925Z",
        "action_counter": 186
      }
    ]
  },
  "find_interaction_point": {
    "description": "Calculates the best adjacent tile to stand on to interact with a specific map object. Supports searching by `object_id` (for sprites) or `object_name` (for background objects). Returns the target coordinates (x, y) and the direction to face.",
    "input_schema": {
      "type": "object",
      "properties": {
        "object_id": {
          "type": "integer",
          "nullable": true,
          "description": "The ID of the target object (for sprites)."
        },
        "object_name": {
          "type": "string",
          "nullable": true,
          "description": "The name of the target object (for background objects)."
        },
        "player_x": {
          "type": "integer",
          "description": "Current player X coordinate."
        },
        "player_y": {
          "type": "integer",
          "description": "Current player Y coordinate."
        }
      },
      "required": [
        "player_x",
        "player_y"
      ]
    },
    "python_script": "# injected imports [\"sys\", \"json\"]\n# injected variables [\"map_xml_string\", \"input_data\"]\n\nimport xml.etree.ElementTree as ET\nimport math\nimport json\n\nmap_data = ET.fromstring(map_xml_string)\nplayer_x = int(input_data['player_x'])\nplayer_y = int(input_data['player_y'])\n\noid = input_data.get('object_id')\ntarget_id = int(oid) if oid is not None and str(oid).lower() != 'none' and str(oid) != '' else -1\n\noname = input_data.get('object_name')\ntarget_name = str(oname) if oname is not None and str(oname).lower() != 'none' else None\n\ntarget_x = -1\ntarget_y = -1\nfound = False\n\n# Find target object\nfor row in map_data.findall('Row'):\n    y = int(row.get('id'))\n    for tile in row.findall('Tile'):\n        x = int(tile.get('id'))\n        if tile.get('has-object') == 'true':\n            for obj in tile.findall('Object'):\n                # Check ID\n                if target_id != -1 and obj.get('id') and int(obj.get('id')) == target_id:\n                    target_x = x\n                    target_y = y\n                    found = True\n                    break\n                # Check Name\n                if target_name:\n                    name = obj.get('name')\n                    id_name = obj.get('id-name')\n                    if (name and name == target_name) or (id_name and id_name == target_name):\n                        target_x = x\n                        target_y = y\n                        found = True\n                        break\n        if found: break\n    if found: break\n\nif not found:\n    print(json.dumps({\"error\": f\"Object not found. ID: {target_id}, Name: {target_name}\"}))\n    exit()\n\n# Directions: (dx, dy, face_direction)\ndirections = [\n    (0, -1, \"Down\"),  # Above target, face Down\n    (0, 1, \"Up\"),     # Below target, face Up\n    (-1, 0, \"Right\"), # Left of target, face Right\n    (1, 0, \"Left\")    # Right of target, face Left\n]\n\nbest_spot = None\nmin_dist = float('inf')\n\nfor dx, dy, face in directions:\n    nx, ny = target_x + dx, target_y + dy\n    \n    # Check bounds and traversability\n    is_traversable = False\n    for row in map_data.findall('Row'):\n        if int(row.get('id')) == ny:\n            for tile in row.findall('Tile'):\n                if int(tile.get('id')) == nx:\n                    t_type = tile.get('type')\n                    has_obj = tile.get('has-object') == 'true'\n                    has_player = tile.get('has-player') == 'true'\n                    \n                    # Simple traversability check\n                    if t_type in ['FLOOR', 'GRASS', 'SAND']:\n                         if not has_obj or has_player: # Allow if player is there, block if other object\n                             is_traversable = True\n                    break\n            break\n    \n    if is_traversable:\n        dist = math.sqrt((nx - player_x)**2 + (ny - player_y)**2)\n        if dist < min_dist:\n            min_dist = dist\n            best_spot = {\"x\": nx, \"y\": ny, \"face\": face}\n\nif best_spot:\n    print(json.dumps(best_spot))\nelse:\n    print(json.dumps({\"error\": \"No accessible adjacent tiles found\"}))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-11-20T01:27:19.980Z",
        "action_counter": 301
      },
      {
        "commit_message": "fix: Update find_interaction_point to support looking up objects by 'object_name' in addition to 'object_id'. This allows targeting background objects (like computers or signs) that lack numeric IDs.",
        "timestamp": "2025-11-20T02:46:50.280Z",
        "action_counter": 421
      }
    ]
  },
  "scan_reachable_unseen": {
    "description": "Identifies unseen tiles that are reachable from the player's current position using a flood fill algorithm on traversable tiles. Returns a list of coordinates.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef is_traversable(tile_type):\n    traversable_types = [\n        \"FLOOR\", \"TALL_GRASS\", \"LONG_GRASS\", \"STAIRS\", \n        \"WARP_CARPET_DOWN\", \"WARP_CARPET_UP\", \"WARP_CARPET_LEFT\", \"WARP_CARPET_RIGHT\",\n        \"DOOR\", \"OPEN_DOOR\"\n    ]\n    return tile_type in traversable_types\n\nmap_data = ET.fromstring(map_xml_string)\nwidth = int(map_data.get(\"width\"))\nheight = int(map_data.get(\"height\"))\n\ngrid = [[None for _ in range(width)] for _ in range(height)]\nplayer_pos = None\n\nfor row in map_data.findall(\"Row\"):\n    y = int(row.get(\"id\"))\n    for tile in row.findall(\"Tile\"):\n        x = int(tile.get(\"id\"))\n        grid[y][x] = tile\n        if tile.find(\"Player\") is not None:\n            player_pos = (x, y)\n\nif not player_pos:\n    print(\"Player not found\")\n    exit()\n\nvisited = set()\nqueue = deque([player_pos])\nvisited.add(player_pos)\nreachable_unseen = []\n\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\nwhile queue:\n    cx, cy = queue.popleft()\n    \n    for dx, dy in directions:\n        nx, ny = cx + dx, cy + dy\n        \n        if 0 <= nx < width and 0 <= ny < height:\n            if (nx, ny) in visited:\n                continue\n                \n            tile = grid[ny][nx]\n            tile_type = tile.get(\"type\")\n            is_seen = tile.get(\"seen\") == \"true\"\n            has_object = tile.get(\"has-object\") == \"true\"\n            \n            if not is_seen:\n                reachable_unseen.append((nx, ny))\n                visited.add((nx, ny))\n                continue\n            \n            if is_traversable(tile_type) and not has_object:\n                visited.add((nx, ny))\n                queue.append((nx, ny))\n\nprint(f\"Reachable unseen tiles: {reachable_unseen}\")",
    "history": [
      {
        "commit_message": "feat: Add scan_reachable_unseen tool to identify reachable unseen tiles for exploration.",
        "timestamp": "2025-11-19T22:54:46.456Z",
        "action_counter": 59
      },
      {
        "commit_message": "feat: Add scan_reachable_unseen tool to identify reachable unseen tiles for exploration.",
        "timestamp": "2025-11-19T23:51:32.034Z",
        "action_counter": 153
      }
    ]
  },
  "swap_party_members": {
    "description": "Swaps two party members using the Start menu. Includes cursor reset for reliability.",
    "input_schema": {
      "type": "object",
      "properties": {
        "slot1": {
          "type": "integer",
          "description": "The 1-based index of the first Pokemon to swap."
        },
        "slot2": {
          "type": "integer",
          "description": "The 1-based index of the second Pokemon to swap."
        }
      },
      "required": [
        "slot1",
        "slot2"
      ]
    },
    "python_script": "import json\n\ninput_data = globals().get('input_data', {})\nslot1 = int(input_data.get('slot1', 1))\nslot2 = int(input_data.get('slot2', 2))\n\n# Validate slots (1-6)\nif not (1 <= slot1 <= 6 and 1 <= slot2 <= 6):\n    print(json.dumps([]))\n    exit()\n\nif slot1 == slot2:\n    print(json.dumps([]))\n    exit()\n\ncmds = []\n# Open Start Menu\ncmds.append(\"Start\")\ncmds.append(\"sleep 1000\")\n\n# Reset Cursor to top (Pokedex)\nfor _ in range(7):\n    cmds.append(\"Up\")\n    cmds.append(\"sleep 300\")\n\n# Move down to Pokemon (2nd option usually)\ncmds.append(\"Down\")\ncmds.append(\"sleep 300\")\ncmds.append(\"A\")\ncmds.append(\"sleep 1500\") # Wait for party menu to open\n\n# Cursor is now at Slot 1\ncurrent_slot = 1\n\n# Move to Slot 1\ndiff = slot1 - current_slot\nfor _ in range(diff):\n    cmds.append(\"Down\")\n    cmds.append(\"sleep 300\")\ncurrent_slot = slot1\n\n# Select Slot 1\ncmds.append(\"Select\")\ncmds.append(\"sleep 800\")\n\n# Move to Slot 2\ndiff = slot2 - current_slot\nif diff > 0:\n    for _ in range(diff):\n        cmds.append(\"Down\")\n        cmds.append(\"sleep 300\")\nelif diff < 0:\n    for _ in range(abs(diff)):\n        cmds.append(\"Up\")\n        cmds.append(\"sleep 300\")\n\n# Select Slot 2 (Swap)\ncmds.append(\"Select\")\ncmds.append(\"sleep 1500\") # Animation\n\n# Exit\ncmds.append(\"B\")\ncmds.append(\"sleep 800\")\ncmds.append(\"B\")\ncmds.append(\"sleep 800\")\n\nprint(json.dumps(cmds))",
    "history": [
      {
        "commit_message": "feat: Add swap_party_members tool to automate reordering the party via the Start menu.",
        "timestamp": "2025-11-20T05:18:34.141Z",
        "action_counter": 643
      },
      {
        "commit_message": "fix: Add cursor reset (Up presses) to start menu navigation to ensure correct selection regardless of previous cursor position.",
        "timestamp": "2025-11-20T05:22:25.872Z",
        "action_counter": 648
      },
      {
        "commit_message": "fix: Increase sleep delays in swap_party_members to ensure reliable menu navigation.",
        "timestamp": "2025-11-20T05:31:23.035Z",
        "action_counter": 657
      }
    ]
  }
}