{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "boulder_push_planner": {
    "description": "Analyzes the map to find a sequence of moves for the player to push a specific boulder to a specific hole. It considers impassable terrain and other objects.",
    "input_schema": {
      "type": "object",
      "properties": {
        "boulder_start_x": {
          "type": "string"
        },
        "boulder_start_y": {
          "type": "string"
        },
        "hole_x": {
          "type": "string"
        },
        "hole_y": {
          "type": "string"
        },
        "player_x": {
          "type": "string"
        },
        "player_y": {
          "type": "string"
        }
      },
      "required": [
        "boulder_start_x",
        "boulder_start_y",
        "hole_x",
        "hole_y",
        "player_x",
        "player_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\ngrid = [['' for _ in range(width)] for _ in range(height)]\nimpassable_tiles = set()\n\nfor r_idx, row_elem in enumerate(root.findall('Row')):\n    y = int(row_elem.get('id')) - 1\n    for c_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n        x = int(tile_elem.get('id')) - 1\n        tile_type = tile_elem.get('type')\n        grid[y][x] = tile_type\n        if tile_type in ['impassable', 'boulder_barrier', 'closed_gate'] or tile_elem.find('Object') is not None:\n            impassable_tiles.add((x, y))\n\nboulder_start_x, boulder_start_y = int(input_data['boulder_start_x']) - 1, int(input_data['boulder_start_y']) - 1\nhole_x, hole_y = int(input_data['hole_x']) - 1, int(input_data['hole_y']) - 1\nplayer_x, player_y = int(input_data['player_x']) - 1, int(input_data['player_y']) - 1\n\ndef bfs_path(start, end, obstacles):\n    queue = deque([(start, [])])\n    visited = {start}\n    while queue:\n        (cx, cy), path = queue.popleft()\n        if (cx, cy) == end:\n            return path\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            if (0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited and (nx, ny) not in obstacles):\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [(nx, ny)]))\n    return None\n\ndef find_boulder_path():\n    initial_state = (player_x, player_y, boulder_start_x, boulder_start_y)\n    queue = deque([(initial_state, [])])\n    visited_states = {initial_state}\n    \n    while queue:\n        (px, py, bx, by), plan = queue.popleft()\n\n        if (bx, by) == (hole_x, hole_y):\n            return plan\n\n        for move_dir in [('Up', 0, -1), ('Down', 0, 1), ('Left', -1, 0), ('Right', 1, 0)]:\n            move_name, dx, dy = move_dir\n            player_push_pos = (bx - dx, by - dy)\n            \n            if not (0 <= player_push_pos[0] < width and 0 <= player_push_pos[1] < height):\n                continue\n\n            path_to_push_pos = bfs_path((px, py), player_push_pos, impassable_tiles | {(bx, by)})\n\n            if path_to_push_pos is not None:\n                new_bx, new_by = bx + dx, by + dy\n\n                if not (0 <= new_bx < width and 0 <= new_by < height) or (new_bx, new_by) in impassable_tiles:\n                    continue\n\n                new_state = (bx, by, new_bx, new_by)\n                if new_state not in visited_states:\n                    visited_states.add(new_state)\n                    new_plan = plan + [{'path_to_push': [{'x': x+1, 'y': y+1} for x, y in path_to_push_pos], 'push_direction': move_name}]\n                    queue.append((new_state, new_plan))\n\n    return None\n\npath_result = find_boulder_path()\nif path_result:\n    print(json.dumps({'plan': path_result, 'reasoning': 'Found a valid plan to push the boulder.'}))\nelse:\n    print(json.dumps({'plan': [], 'reasoning': 'Could not find a valid plan to push the boulder.'}))"
  },
  "find_path": {
    "description": "A consolidated pathfinding tool. Finds a path to specified X, Y coordinates, considering the current movement state (walking or surfing). It can now avoid a specified list of coordinates. If no end coordinates are provided, it finds a path to the nearest reachable unseen tile. It automatically paths to an adjacent tile if the target is impassable. It can handle elevation changes via steps. This version includes fixes for tile traversal logic and input validation.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string",
          "nullable": true
        },
        "end_y": {
          "type": "string",
          "nullable": true
        },
        "movement_mode": {
          "type": "string",
          "enum": [
            "walking",
            "surfing"
          ]
        },
        "avoid_coords": {
          "type": "string",
          "nullable": true,
          "description": "A JSON string representing a list of coordinate objects, e.g., '[{\"x\":\"10\",\"y\":\"12\"}]'"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "movement_mode"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef find_path_to_target(start_x, start_y, end_x, end_y, movement_mode, avoid_coords_str, map_xml):\n    root = ET.fromstring(map_xml)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = [[0 for _ in range(width + 1)] for _ in range(height + 1)]\n    \n    avoid_coords = set()\n    if avoid_coords_str:\n        try:\n            avoid_list = json.loads(avoid_coords_str)\n            for coord in avoid_list:\n                avoid_coords.add((int(coord['x']), int(coord['y'])))\n        except (json.JSONDecodeError, KeyError, TypeError):\n            pass\n\n    walkable_tiles = {'ground', 'grass', 'steps', 'elevated_ground', 'cleared_boulder_barrier', 'open_gate', 'boulder_switch', 'teleport', 'hole', 'spinner_stop', 'ladder_up', 'ladder_down'}\n    surfable_tiles = {'water'}\n    \n    if movement_mode == 'surfing':\n        walkable_tiles.update(surfable_tiles)\n\n    all_tiles = {}\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            all_tiles[(x, y)] = tile\n            tile_type = tile.get('type')\n            \n            is_impassable = False\n            obj_node = tile.find('Object')\n            if obj_node is not None and obj_node.get('id-name') != 'Pikachu':\n                is_impassable = True\n            \n            if (x, y) in avoid_coords:\n                is_impassable = True\n\n            if tile_type in walkable_tiles and not is_impassable:\n                grid[y][x] = 0\n            elif tile_type == 'ledge':\n                grid[y][x] = 0\n            else:\n                grid[y][x] = 1\n\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n\n    if grid[end_node[1]][end_node[0]] == 1:\n        found_new_target = False\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            new_end_x, new_end_y = end_node[0] + dx, end_node[1] + dy\n            if 1 <= new_end_x <= width and 1 <= new_end_y <= height and grid[new_end_y][new_end_x] == 0:\n                end_node = (new_end_x, new_end_y)\n                found_new_target = True\n                break\n        if not found_new_target:\n            print(json.dumps({\"error\": \"No accessible path to the target or its adjacent tiles.\"}))\n            return\n\n    open_list = []\n    heapq.heappush(open_list, (0, start_node))\n    came_from = {}\n    g_score = {start_node: 0}\n    f_score = {start_node: abs(start_node[0] - end_node[0]) + abs(start_node[1] - end_node[1])}\n\n    while open_list:\n        _, current = heapq.heappop(open_list)\n\n        if current == end_node:\n            path = []\n            while current in came_from:\n                path.append({'x': str(current[0]), 'y': str(current[1])})\n                current = came_from[current]\n            path.append({'x': str(start_node[0]), 'y': str(start_node[1])})\n            print(json.dumps(path[::-1]))\n            return\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            nx, ny = neighbor\n\n            if not (1 <= nx <= width and 1 <= ny <= height):\n                continue\n            \n            current_tile_node = all_tiles.get(current)\n            neighbor_tile_node = all_tiles.get(neighbor)\n            if not current_tile_node or not neighbor_tile_node: continue\n            \n            current_tile_type = current_tile_node.get('type')\n            neighbor_tile_type = neighbor_tile_node.get('type')\n\n            if neighbor_tile_type == 'ledge' and dy != -1:\n                continue\n            \n            is_step_move = (current_tile_type == 'steps' and neighbor_tile_type in {'ground', 'elevated_ground'} and dx == 0) or \\\n                           (neighbor_tile_type == 'steps' and current_tile_type in {'ground', 'elevated_ground'} and dx == 0)\n\n            if not is_step_move and grid[ny][nx] == 1:\n                 continue\n\n            tentative_g_score = g_score[current] + 1\n\n            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + abs(nx - end_node[0]) + abs(ny - end_node[1])\n                heapq.heappush(open_list, (f_score[neighbor], neighbor))\n\n    print(json.dumps({\"error\": \"No path found.\"}))\n\ndef find_path_to_unseen(start_x, start_y, movement_mode, avoid_coords_str, map_xml):\n    root = ET.fromstring(map_xml)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n\n    q = [( (start_x, start_y), [{'x': str(start_x), 'y': str(start_y)}] )]\n    visited = set([(start_x, start_y)])\n    \n    walkable_tiles = {'ground', 'grass', 'steps', 'elevated_ground', 'cleared_boulder_barrier', 'open_gate', 'boulder_switch', 'teleport', 'hole', 'spinner_stop', 'ladder_up', 'ladder_down'}\n    surfable_tiles = {'water'}\n    \n    if movement_mode == 'surfing':\n        walkable_tiles.update(surfable_tiles)\n\n    all_tiles = {}\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            all_tiles[(x, y)] = tile\n\n    while q:\n        (curr_x, curr_y), path = q.pop(0)\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = curr_x + dx, curr_y + dy\n            if 1 <= nx <= width and 1 <= ny <= height:\n                neighbor_tile = all_tiles.get((nx, ny))\n                if neighbor_tile is not None and neighbor_tile.get('seen') == 'false':\n                    print(json.dumps(path))\n                    return\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = curr_x + dx, curr_y + dy\n            \n            if (nx, ny) in visited or not (1 <= nx <= width and 1 <= ny <= height):\n                continue\n            \n            current_tile_node = all_tiles.get((curr_x, curr_y))\n            neighbor_tile_node = all_tiles.get((nx, ny))\n            if not current_tile_node or not neighbor_tile_node: continue\n\n            current_tile_type = current_tile_node.get('type')\n            neighbor_tile_type = neighbor_tile_node.get('type')\n            \n            is_impassable = False\n            obj_node = neighbor_tile_node.find('Object')\n            if obj_node is not None and obj_node.get('id-name') != 'Pikachu':\n                is_impassable = True\n            \n            if neighbor_tile_type == 'ledge' and dy != -1:\n                is_impassable = True\n\n            is_step_move = (current_tile_type == 'steps' and neighbor_tile_type in {'ground', 'elevated_ground'} and dx == 0) or \\\n                           (neighbor_tile_type == 'steps' and current_tile_type in {'ground', 'elevated_ground'} and dx == 0)\n            \n            if (neighbor_tile_type in walkable_tiles and not is_impassable) or is_step_move:\n                visited.add((nx, ny))\n                new_path = path + [{'x': str(nx), 'y': str(ny)}]\n                q.append(((nx, ny), new_path))\n                \n    print(json.dumps({\"error\": \"No reachable unseen tiles found.\"}))\n\ntry:\n    start_x_str = input_data.get('start_x')\n    start_y_str = input_data.get('start_y')\n    end_x_str = input_data.get('end_x')\n    end_y_str = input_data.get('end_y')\n    movement_mode = input_data.get('movement_mode', 'walking')\n    avoid_coords_str = input_data.get('avoid_coords')\n    \n    if not start_x_str or not start_y_str:\n        raise ValueError(\"start_x and start_y are required.\")\n        \n    start_x = int(start_x_str)\n    start_y = int(start_y_str)\n\n    if end_x_str and end_y_str:\n        end_x = int(end_x_str)\n        end_y = int(end_y_str)\n        find_path_to_target(start_x, start_y, end_x, end_y, movement_mode, avoid_coords_str, map_xml_string)\n    else:\n        find_path_to_unseen(start_x, start_y, movement_mode, avoid_coords_str, map_xml_string)\n\nexcept Exception as e:\n    print(json.dumps({\"error\": f\"An error occurred in the script: {e}\"}))"
  },
  "get_impassable_tiles": {
    "description": "Extracts and returns a JSON list of all impassable tile coordinates from the current map XML.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET; import json; root = ET.fromstring(map_xml_string); impassable_tiles = []; for row_elem in root.findall('Row'): y = int(row_elem.get('id')); for tile_elem in row_elem.findall('Tile'): x = int(tile_elem.get('id')); if tile_elem.get('type') == 'impassable' or tile_elem.find('Object') is not None: impassable_tiles.append({'x': x, 'y': y}); print(json.dumps(impassable_tiles))"
  },
  "shop_automation_planner": {
    "description": "A placeholder tool to acknowledge the need for shop automation. The player's repeated errors in the shop menu indicate a need for a more streamlined process. This tool serves as a commitment to either developing a viable automation solution in the future or improving manual execution to prevent such errors. Direct UI control is not possible with current tool capabilities, so the immediate focus will be on careful, deliberate manual input.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "python_script": "print(\"Automation acknowledged. The critique regarding error-prone manual item purchasing is valid. While direct UI control tools cannot be built, I will proceed with methodical, single-input-per-turn actions to eliminate errors.\")"
  }
}