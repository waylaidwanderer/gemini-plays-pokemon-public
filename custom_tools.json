{
  "find_path": {
    "description": "Finds the shortest path from the player's current position to a target coordinate using the A* algorithm. If the target is an obstacle, it finds a path to the nearest traversable adjacent tile. It correctly handles one-way ledges.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\n\ndef parse_map(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    tiles = {}\n    player_pos = None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tiles[(x, y)] = tile\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n    return tiles, player_pos, width, height\n\ndef is_obstacle(tile):\n    if tile is None: return True\n    tile_type = tile.attrib['type']\n    # Removed 'unseen' from this list to allow pathing through unexplored areas.\n    return tile_type in ['WALL', 'HEADBUTT_TREE'] or tile.find('Object') is not None\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(tiles, start, goal, width, height):\n    neighbors = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    if is_obstacle(tiles.get(goal)):\n        potential_goals = []\n        for dx, dy in neighbors:\n            adj_tile_coord = (goal[0] + dx, goal[1] + dy)\n            if not is_obstacle(tiles.get(adj_tile_coord)):\n                potential_goals.append(adj_tile_coord)\n        if not potential_goals:\n            return None\n        potential_goals.sort(key=lambda p: heuristic(start, p))\n        goal = potential_goals[0]\n\n    if is_obstacle(tiles.get(start)): return None\n\n    close_set = set()\n    came_from = {}\n    gscore = {start: 0}\n    fscore = {start: heuristic(start, goal)}\n    oheap = []\n    heapq.heappush(oheap, (fscore[start], start))\n\n    while oheap:\n        current = heapq.heappop(oheap)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            path.reverse()\n            return path\n\n        close_set.add(current)\n        for i, j in neighbors:\n            neighbor_coord = current[0] + i, current[1] + j\n            neighbor_tile = tiles.get(neighbor_coord)\n\n            if is_obstacle(neighbor_tile):\n                continue\n\n            neighbor_type = neighbor_tile.attrib.get('type')\n            if neighbor_type == 'LEDGE_HOP_RIGHT' and i == -1:\n                continue\n            if neighbor_type == 'LEDGE_HOP_DOWN' and j == -1:\n                continue\n\n            tentative_g_score = gscore[current] + 1\n            if neighbor_coord in close_set and tentative_g_score >= gscore.get(neighbor_coord, 0):\n                continue\n\n            if tentative_g_score < gscore.get(neighbor_coord, 0) or neighbor_coord not in [item[1] for item in oheap]:\n                came_from[neighbor_coord] = current\n                gscore[neighbor_coord] = tentative_g_score\n                fscore[neighbor_coord] = tentative_g_score + heuristic(neighbor_coord, goal)\n                heapq.heappush(oheap, (fscore[neighbor_coord], neighbor_coord))\n    return None\n\ntry:\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    tiles, player_pos, map_width, map_height = parse_map(map_xml_string)\n    if player_pos:\n        path = a_star_search(tiles, player_pos, (target_x, target_y), map_width, map_height)\n        if path:\n            path_coords = [{'x': p[0], 'y': p[1]} for p in path]\n            print(f'Path found: {path_coords}')\n        else:\n            print('No path found.')\n    else:\n        print('Player position not found on the map.')\nexcept Exception as e:\n    import traceback\n    print(f'An error occurred: {e}\\n{traceback.format_exc()}')"
  }
}