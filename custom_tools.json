{
  "marker_compliance_tool": {
    "description": "Parses map markers and checks for compliance with protocols defined in the notepad. Identifies markers with non-standard emojis or incorrect label formats.",
    "input_schema": {
      "type": "object",
      "properties": {
        "notepad_contents": {
          "type": "string"
        }
      },
      "required": [
        "notepad_contents"
      ]
    },
    "python_script": "import json\nimport re\n\ndef check_marker_compliance():\n    notepad_content = input_data['notepad_contents']\n    \n    protocol_emojis = []\n    teleporter_format_regex_str = ''\n\n    try:\n        protocol_line = \"\"\n        for line in notepad_content.splitlines():\n            if \"CRITICAL: Map Marker Protocol\" in line:\n                protocol_line = line\n                break\n        \n        if not protocol_line:\n            print(json.dumps({'error': 'Map Marker Protocol line not found in notepad.'}))\n            return\n\n        teleporter_format_regex_str = r\"ðŸšª Warp to/from \\(\\d+, \\d+\\) \\[(?:Bi-directional|One-way)\\]\"\n        teleporter_format_regex = re.compile(teleporter_format_regex_str)\n        protocol_emojis = re.findall(r\"'([^']*)'\", protocol_line)\n\n    except Exception as e:\n        print(json.dumps({'error': f'Failed to parse protocols from notepad: {e}'}))\n        return\n\n    non_compliant_markers = []\n    try:\n        tiles = map_xml_string.split('</Tile>')\n        for tile_str in tiles:\n            if '<Marker' in tile_str:\n                try:\n                    coord_match = re.search(r'coordinate=\"\\((\\d+), (\\d+)\\)\"', tile_str)\n                    if not coord_match: continue\n                    x, y = int(coord_match.group(1)), int(coord_match.group(2))\n                except (ValueError, IndexError):\n                    continue\n\n                marker_parts = tile_str.split('<Marker emoji=\"')\n                for part in marker_parts[1:]:\n                    try:\n                        emoji = part.split('\"')[0]\n                        label = part.split('>')[1].split('</Marker>')[0]\n                        \n                        is_compliant = False\n                        if emoji in protocol_emojis:\n                            if emoji == 'ðŸšª':\n                                if teleporter_format_regex.fullmatch(f\"{emoji} {label}\"):\n                                    is_compliant = True\n                            else:\n                                is_compliant = True\n                        \n                        if not is_compliant:\n                            non_compliant_markers.append({\n                                \"x\": x,\n                                \"y\": y,\n                                \"emoji\": emoji,\n                                \"label\": label,\n                                \"reason\": f\"Emoji '{emoji}' not in protocol or label format for 'ðŸšª' is incorrect.\"\n                            })\n                    except IndexError:\n                        continue\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': f'Error during XML parsing: {str(e)}', 'traceback': traceback.format_exc()}))\n        return\n        \n    print(json.dumps(non_compliant_markers))\n\ncheck_marker_compliance()"
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map. It now correctly handles impassable tiles, dynamic transitions between walking and surfing, and navigates ledges. **REFINED:** Now uses manual string parsing instead of the forbidden xml.etree.ElementTree library and includes more robust error handling.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "is_surfing": {
          "type": "string",
          "enum": [
            "true",
            "false"
          ]
        },
        "can_surf": {
          "type": "string",
          "enum": [
            "true",
            "false"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "is_surfing",
        "can_surf"
      ]
    },
    "python_script": "import json\nimport heapq\n\ndef pathfinder_v3():\n    try:\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        end_x = int(input_data['end_x'])\n        end_y = int(input_data['end_y'])\n        is_surfing = input_data['is_surfing'].lower() == 'true'\n        can_surf = input_data['can_surf'].lower() == 'true'\n\n        # Manual XML parsing to avoid forbidden libraries\n        grid = {}\n        map_width_str = map_xml_string.split('width=\"')[1].split('\"')[0]\n        map_height_str = map_xml_string.split('height=\"')[1].split('\"')[0]\n        width = int(map_width_str)\n        height = int(map_height_str)\n\n        if not (1 <= start_x <= width and 1 <= start_y <= height and 1 <= end_x <= width and 1 <= end_y <= height):\n            print(json.dumps({'error': 'Start or end coordinates are out of map bounds.'}))\n            return\n\n        rows = map_xml_string.split('<Row id=')\n        for row_str in rows[1:]:\n            y = int(row_str.split('\"')[1])\n            tiles = row_str.split('<Tile id=')\n            for tile_str in tiles[1:]:\n                x = int(tile_str.split('\"')[1])\n                tile_type = tile_str.split('type=\"')[1].split('\"')[0]\n                has_object = 'has-object=\"true\"' in tile_str\n                if has_object and 'id-name=\"Pikachu\"' in tile_str:\n                    has_object = False\n                \n                is_teleporter = tile_type == 'teleport'\n                is_target_teleporter = is_teleporter and x == end_x and y == end_y\n\n                if tile_type in ['impassable', 'boulder_barrier', 'closed_gate'] or has_object or (is_teleporter and not is_target_teleporter):\n                    grid[(x, y)] = 'wall'\n                else:\n                    grid[(x, y)] = tile_type\n\n        if grid.get((end_x, end_y)) == 'wall':\n             print(json.dumps({'error': 'End coordinates are on an impassable tile.'}))\n             return\n\n        def get_neighbors(x, y):\n            neighbors = []\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if not (1 <= nx <= width and 1 <= ny <= height):\n                    continue\n\n                neighbor_tile = grid.get((nx, ny))\n                if neighbor_tile == 'wall':\n                    continue\n\n                if neighbor_tile == 'ledge' and dy == -1: # Cannot go up ledges\n                    continue\n\n                if neighbor_tile == 'water' and not can_surf:\n                    continue\n\n                if neighbor_tile == 'ledge' and dy == 1: # Jump down ledge\n                    nny = ny + 1\n                    if 1 <= nny <= height and grid.get((nx, nny)) != 'wall':\n                        neighbors.append((nx, nny))\n                else:\n                    neighbors.append((nx, ny))\n            return neighbors\n\n        start_node = (start_x, start_y)\n        end_node = (end_x, end_y)\n        open_set = [(0, start_node)]\n        came_from = {}\n        g_score = {start_node: 0}\n\n        while open_set:\n            _, current_node = heapq.heappop(open_set)\n\n            if current_node == end_node:\n                path = []\n                while current_node in came_from:\n                    path.append({'x': current_node[0], 'y': current_node[1]})\n                    current_node = came_from[current_node]\n                path.append({'x': start_node[0], 'y': start_node[1]})\n                print(json.dumps(path[::-1]))\n                return\n\n            cx, cy = current_node\n            for neighbor in get_neighbors(cx, cy):\n                new_g = g_score[current_node] + 1\n                if neighbor not in g_score or new_g < g_score[neighbor]:\n                    g_score[neighbor] = new_g\n                    f_score = new_g + abs(neighbor[0] - end_x) + abs(neighbor[1] - end_y)\n                    heapq.heappush(open_set, (f_score, neighbor))\n                    came_from[neighbor] = current_node\n\n        print(json.dumps([]))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))\n\npathfinder_v3()"
  },
  "systematic_searcher": {
    "description": "Calculates the next reachable, untested tile to check in a systematic sweep. It performs a reachability analysis (BFS) from the player's current position to avoid suggesting unreachable tiles. REFINED: Now correctly implements BFS.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "tested_coords_json": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "tested_coords_json"
      ]
    },
    "python_script": "import json\nimport re\nfrom collections import deque\n\ndef systematic_search_v3():\n    try:\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        tested_coords_list = json.loads(input_data['tested_coords_json'])\n        tested_set = set((d['x'], d['y']) for d in tested_coords_list)\n\n        grid = {}\n        width_match = re.search(r'<Map[^>]*width=\"(\\d+)\"', map_xml_string)\n        height_match = re.search(r'<Map[^>]*height=\"(\\d+)\"', map_xml_string)\n        width = int(width_match.group(1))\n        height = int(height_match.group(1))\n\n        tile_matches = re.finditer(r'<Tile[^>]*coordinate=\"\\((\\d+), (\\d+)\\)\"[^>]*type=\"([^\"]+)\"[^>]*>([\\s\\S]*?)</Tile>', map_xml_string)\n        for match in tile_matches:\n            x, y, tile_type, content = match.groups()\n            x, y = int(x), int(y)\n            is_impassable_type = tile_type in [\"impassable\", \"closed_gate\", \"boulder_barrier\"]\n            has_blocking_object = '<Object' in content and 'id-name=\"Pikachu\"' not in content\n            if is_impassable_type or has_blocking_object:\n                grid[(x, y)] = 'wall'\n            else:\n                grid[(x, y)] = tile_type\n        \n        reachable_set = set()\n        queue = deque([(start_x, start_y)])\n        visited = set([(start_x, start_y)])\n        \n        while queue:\n            cx, cy = queue.popleft()\n            reachable_set.add((cx, cy))\n            \n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = cx + dx, cy + dy\n                \n                if not (1 <= nx <= width and 1 <= ny <= height):\n                    continue\n                \n                if (nx, ny) in visited:\n                    continue\n                    \n                neighbor_tile = grid.get((nx, ny))\n                if neighbor_tile == 'wall':\n                    continue\n\n                if neighbor_tile == 'ledge' and dy == -1:\n                    continue\n                \n                visited.add((nx, ny))\n                if neighbor_tile == 'ledge' and dy == 1:\n                    nny = ny + 1\n                    if 1 <= nny <= height and grid.get((nx, nny)) != 'wall':\n                        queue.append((nx, nny))\n                else:\n                    queue.append((nx, ny))\n\n        sorted_reachable = sorted(list(reachable_set), key=lambda p: (p[1], p[0]))\n\n        for x, y in sorted_reachable:\n            if (x, y) not in tested_set:\n                print(json.dumps({'next_x': x, 'next_y': y}))\n                return\n\n        print(json.dumps({'error': \"No valid, untested, reachable tiles found.\"}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))\n\nsystematic_search_v3()\n"
  }
}