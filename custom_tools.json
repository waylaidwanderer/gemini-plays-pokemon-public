{
  "advance_dialogue": {
    "description": "Presses the 'A' button a specified number of times with short delays to advance dialogue.",
    "input_schema": {
      "type": "object",
      "properties": {
        "num_presses": {
          "type": "integer",
          "description": "Number of times to press A. Default is 5.",
          "default": 5
        }
      }
    },
    "python_script": "import json\nnum = input_data.get('num_presses', 5)\nbuttons = []\nfor _ in range(num):\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\") # Wait 0.5s between presses\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-22T03:56:36.634Z",
        "action_counter": 8282
      },
      {
        "commit_message": "Fixed bug where output was not valid JSON. Added json import and usage.",
        "timestamp": "2026-01-22T03:57:54.764Z",
        "action_counter": 8284
      }
    ]
  },
  "bfs_navigate": {
    "description": "Navigates to a target coordinate using BFS. You MUST provide the list of valid walkable tile TYPE IDs for the current map.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "walkable_types": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "target_x",
        "target_y",
        "walkable_types"
      ]
    },
    "python_script": "import sys\nimport xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef get_player_pos(root):\n    for row in root.findall('Row'):\n        for tile in row.findall('Tile'):\n            if tile.find('Player') is not None:\n                return int(tile.get('id')), int(row.get('id'))\n    return None\n\ndef bfs(start, target, grid, walkable_types, width, height):\n    queue = [(0, start, [])]\n    visited = set([start])\n    \n    while queue:\n        cost, current, path = heapq.heappop(queue)\n        \n        if current == target:\n            return path\n        \n        x, y = current\n        neighbors = [\n            (x, y - 1, 'Up'), (x, y + 1, 'Down'),\n            (x - 1, y, 'Left'), (x + 1, y, 'Right')\n        ]\n        \n        for nx, ny, direction in neighbors:\n            if 0 <= nx < width and 0 <= ny < height:\n                tile_type = grid.get((nx, ny))\n                if (nx, ny) not in visited and tile_type in walkable_types:\n                    visited.add((nx, ny))\n                    heapq.heappush(queue, (cost + 1, (nx, ny), path + [direction]))\n    return None\n\ntry:\n    # input_data is injected\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    walkable_types = set(input_data['walkable_types'])\n    autopress = input_data.get('autopress_buttons', False)\n\n    # map_xml_string is injected\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = {}\n    player_pos = None\n    \n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tile_type = tile.get('type')\n            grid[(x, y)] = tile_type\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n                \n    if not player_pos:\n        print(json.dumps({\"error\": \"Player not found\"}))\n        sys.exit(0)\n        \n    path = bfs(player_pos, (target_x, target_y), grid, walkable_types, width, height)\n    \n    if path:\n        print(json.dumps(path))\n    else:\n        print(json.dumps({\"error\": \"No path found\"}))\n\nexcept Exception as e:\n    print(json.dumps({\"error\": str(e)}))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-20T20:26:14.582Z",
        "action_counter": 6490
      },
      {
        "commit_message": "Fixed NameError by ensuring variable scope is correct in the try/except block.",
        "timestamp": "2026-01-22T02:39:20.905Z",
        "action_counter": 8194
      }
    ]
  },
  "buy_current_item": {
    "description": "Automates the purchase of the currently selected item in a shop menu by setting the quantity and confirming. Assumes the cursor is already on the desired item.",
    "input_schema": {
      "type": "object",
      "properties": {
        "quantity": {
          "type": "integer",
          "description": "The number of items to buy.",
          "minimum": 1,
          "maximum": 99
        }
      },
      "required": [
        "quantity"
      ]
    },
    "python_script": "def run(input_data):\n    quantity = input_data.get('quantity', 1)\n    buttons = []\n    \n    # Select the item\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # Adjust quantity\n    if quantity > 1:\n        # Press Up quantity-1 times (assuming Up increments from 1)\n        # Note: In some games Down goes to max, but Up is safer for specific counts\n        for _ in range(quantity - 1):\n            buttons.append(\"Up\")\n            # buttons.append(\"sleep 100\") # Small delay if needed\n            \n    # Confirm quantity\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # Handle \"Here you go\" dialogue?\n    # Usually requires one more A or B to clear text.\n    # Let's add one A to be safe, but user might need to handle dialogue.\n    buttons.append(\"A\")\n    \n    print(f'{{\"buttons\": {buttons}}}')",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-22T06:18:21.849Z",
        "action_counter": 8464
      }
    ]
  },
  "check_path_connectivity": {
    "description": "Checks if a path exists between two coordinates using BFS on the Mental Map XML. Returns path length and steps if found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import sys\nimport json\nimport xml.etree.ElementTree as ET\nimport collections\n\n# Get input data\nstart_x = input_data['start_x']\nstart_y = input_data['start_y']\ntarget_x = input_data['target_x']\ntarget_y = input_data['target_y']\nautopress = input_data.get('autopress_buttons', False)\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get(\"width\"))\n    height = int(root.get(\"height\"))\n    grid = {}\n    \n    for row in root.findall(\"Row\"):\n        y = int(row.get(\"id\"))\n        for tile in row.findall(\"Tile\"):\n            x = int(tile.get(\"id\"))\n            t_type = tile.get(\"type\")\n            grid[(x, y)] = t_type\n\n    start = (start_x, start_y)\n    target = (target_x, target_y)\n    \n    if start not in grid or target not in grid:\n        if autopress:\n            print(json.dumps([]))\n        else:\n            print(json.dumps({\"error\": \"Coordinates out of bounds or not in map data\"}))\n        exit()\n\n    queue = collections.deque([[start]])\n    visited = set([start])\n    \n    found = False\n    final_path = []\n    \n    # Standard wall types to avoid\n    WALL_TYPES = [\"TYPE_2889\", \"TYPE_80fc\", \"TYPE_5519\", \"TYPE_a336\"]\n    \n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n        \n        if (x, y) == target:\n            found = True\n            final_path = path\n            break\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < width and 0 <= ny < height:\n                if (nx, ny) not in visited:\n                    tile_type = grid.get((nx, ny), \"unseen\")\n                    if tile_type not in WALL_TYPES:\n                        visited.add((nx, ny))\n                        new_path = list(path)\n                        new_path.append((nx, ny))\n                        queue.append(new_path)\n\n    if found:\n        # Convert path to buttons\n        buttons = []\n        for i in range(len(final_path) - 1):\n            curr = final_path[i]\n            next_tile = final_path[i+1]\n            dx = next_tile[0] - curr[0]\n            dy = next_tile[1] - curr[1]\n            if dx == 1: buttons.append(\"Right\")\n            elif dx == -1: buttons.append(\"Left\")\n            elif dy == 1: buttons.append(\"Down\")\n            elif dy == -1: buttons.append(\"Up\")\n\n        if autopress:\n            print(json.dumps(buttons))\n        else:\n            # Return JSON object\n            print(json.dumps({\"found\": True, \"length\": len(final_path), \"path\": str(final_path), \"buttons\": buttons}))\n    else:\n        if autopress:\n            print(json.dumps([]))\n        else:\n            print(json.dumps({\"found\": False}))\n\nexcept Exception as e:\n    # Return valid JSON error or empty list\n    if autopress:\n        print(json.dumps([]))\n    else:\n        print(json.dumps({\"error\": str(e)}))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T04:38:25.635Z",
        "action_counter": 310
      },
      {
        "commit_message": "Fixed autopress_buttons support by returning JSON list of buttons.",
        "timestamp": "2026-01-17T05:14:56.870Z",
        "action_counter": 363
      },
      {
        "commit_message": "Initial definition of check_path_connectivity tool to help verify navigation paths.",
        "timestamp": "2026-01-17T19:59:31.235Z",
        "action_counter": 1608
      },
      {
        "commit_message": "Initial definition of check_path_connectivity tool for verifying paths on the mental map.",
        "timestamp": "2026-01-18T00:52:36.653Z",
        "action_counter": 2016
      },
      {
        "commit_message": "Fixed JSON parsing error by ensuring only valid JSON is printed to stdout.",
        "timestamp": "2026-01-24T13:10:59.316Z",
        "action_counter": 11043
      }
    ]
  },
  "find_map_edge": {
    "description": "Finds a path from the current position to a specified map edge (North, South, East, West) and returns the button sequence.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "edge": {
          "type": "string",
          "enum": [
            "North",
            "South",
            "East",
            "West"
          ]
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "start_x",
        "start_y",
        "edge"
      ]
    },
    "python_script": "import sys\nimport json\nimport xml.etree.ElementTree as ET\nimport collections\n\n# Get input data\nstart_x = input_data['start_x']\nstart_y = input_data['start_y']\nedge = input_data['edge']\nautopress = input_data.get('autopress_buttons', False)\n\n# Parse the map XML\ntry:\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get(\"width\"))\n    height = int(root.get(\"height\"))\n    grid = {}\n    \n    for row in root.findall(\"Row\"):\n        y = int(row.get(\"id\"))\n        for tile in row.findall(\"Tile\"):\n            x = int(tile.get(\"id\"))\n            t_type = tile.get(\"type\")\n            grid[(x, y)] = t_type\n\n    start = (start_x, start_y)\n    \n    if start not in grid:\n        print(json.dumps([])) # Return empty if start invalid\n        exit()\n\n    # Define target condition based on edge\n    def is_target(x, y):\n        if edge == \"North\": return y == 0\n        if edge == \"South\": return y == height - 1\n        if edge == \"West\": return x == 0\n        if edge == \"East\": return x == width - 1\n        return False\n\n    # BFS\n    queue = collections.deque([[start]])\n    visited = set([start])\n    \n    # Common walkable types plus unseen. \n    WALKABLE_TYPES = [\"TYPE_3fe2\", \"TYPE_3f8d\", \"TYPE_fed7\", \"TYPE_2849\", \"unseen\"] \n    \n    found_path = None\n    \n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n        \n        if is_target(x, y):\n            found_path = path\n            break\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < width and 0 <= ny < height:\n                if (nx, ny) not in visited:\n                    tile_type = grid.get((nx, ny), \"unseen\")\n                    # Check passability\n                    if tile_type in WALKABLE_TYPES or tile_type == \"unseen\": \n                        visited.add((nx, ny))\n                        new_path = list(path)\n                        new_path.append((nx, ny))\n                        queue.append(new_path)\n\n    if found_path:\n        # Convert path to buttons\n        buttons = []\n        for i in range(len(found_path) - 1):\n            curr = found_path[i]\n            next_tile = found_path[i+1]\n            dx = next_tile[0] - curr[0]\n            dy = next_tile[1] - curr[1]\n            if dx == 1: buttons.append(\"Right\")\n            elif dx == -1: buttons.append(\"Left\")\n            elif dy == 1: buttons.append(\"Down\")\n            elif dy == -1: buttons.append(\"Up\")\n            \n        print(json.dumps(buttons))\n    else:\n        print(json.dumps([]))\n\nexcept Exception as e:\n    # On error, return empty list to avoid crashing the tool runner\n    print(json.dumps([]))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-20T18:27:53.838Z",
        "action_counter": 6331
      },
      {
        "commit_message": "Fixed NameError by ensuring variable definitions match input extraction.",
        "timestamp": "2026-01-24T13:10:59.315Z",
        "action_counter": 11043
      }
    ]
  },
  "find_nearest_unseen": {
    "description": "Finds the 5 nearest 'unseen' tiles in the Mental Map to the current player position using Manhattan distance. Returns a list of coordinates sorted by distance.",
    "input_schema": {
      "type": "object",
      "properties": {
        "player_x": {
          "type": "integer"
        },
        "player_y": {
          "type": "integer"
        }
      },
      "required": [
        "player_x",
        "player_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ndef find_nearest_unseen(map_xml, p_x, p_y):\n    try:\n        root = ET.fromstring(map_xml)\n        unseen_tiles = []\n        for row in root.findall(\"Row\"):\n            r_id = int(row.get(\"id\"))\n            for tile in row.findall(\"Tile\"):\n                t_id = int(tile.get(\"id\"))\n                t_type = tile.get(\"type\")\n                if t_type == \"unseen\":\n                    dist = abs(p_x - t_id) + abs(p_y - r_id)\n                    unseen_tiles.append((dist, t_id, r_id))\n        \n        if not unseen_tiles:\n            print(\"[]\")\n            return\n\n        unseen_tiles.sort()\n        # Return list of dicts for JSON parsing\n        result = [{\"x\": t[1], \"y\": t[2], \"dist\": t[0]} for t in unseen_tiles[:5]]\n        print(json.dumps(result))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\np_x = input_data.get('player_x', 0)\np_y = input_data.get('player_y', 0)\nfind_nearest_unseen(map_xml_string, p_x, p_y)",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T05:16:24.634Z",
        "action_counter": 364
      },
      {
        "commit_message": "Initial definition of the find_nearest_unseen tool for fog-of-war clearing.",
        "timestamp": "2026-01-19T20:13:05.535Z",
        "action_counter": 5044
      }
    ]
  },
  "find_reachable_exits": {
    "description": "Uses BFS to find all reachable tiles on the map boundaries (Row 0, Col 0, Row H-1, Col W-1) and specific warp tiles (TYPE_201b) from the current position. Returns a list of reachable exit coordinates and warp locations.",
    "input_schema": {
      "type": "object",
      "properties": {
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "autopress_buttons"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get(\"width\"))\n        height = int(root.get(\"height\"))\n        \n        walkable = set()\n        warps = set()\n        \n        # Parse map\n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                x = int(tile.get('id'))\n                t_type = tile.get('type')\n                \n                # Walkable types based on observation:\n                # TYPE_3fe2: Standard floor\n                # TYPE_4e8c: Tracks (Walkable?)\n                # TYPE_201b: Door/Warp Mat\n                # TYPE_bc52: Carpet/Floor variation? (Adding common ones just in case)\n                # We will be generous and assume anything NOT 2889 (Wall) might be walkable if we are desperate,\n                # but let's stick to positive inclusion first.\n                \n                if t_type in ['TYPE_3fe2', 'TYPE_4e8c', 'TYPE_201b', 'TYPE_c453', 'TYPE_ffbb']: \n                    walkable.add((x, y))\n                \n                if t_type == 'TYPE_201b':\n                    warps.add((x, y))\n\n        # Find player position dynamically or pass it?\n        # The prompt says player position is in game state. \n        # But for the tool, I'll scan the XML for <Player/> tag to be safe, or just use a known start.\n        # Actually, let's scan for Player tag.\n        start_pos = None\n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                if tile.find('Player') is not None:\n                    start_pos = (int(tile.get('id')), y)\n                    break\n            if start_pos: break\n            \n        if not start_pos:\n            print(\"Player not found in XML. Defaulting to (33, 10).\")\n            start_pos = (33, 10)\n            if start_pos not in walkable:\n                walkable.add(start_pos)\n\n        queue = deque([start_pos])\n        visited = {start_pos}\n        exits = []\n        reachable_warps = []\n        \n        while queue:\n            cx, cy = queue.popleft()\n            \n            # Check if boundary\n            if cx == 0 or cy == 0 or cx == width - 1 or cy == height - 1:\n                exits.append((cx, cy))\n            \n            # Check if warp\n            if (cx, cy) in warps:\n                reachable_warps.append((cx, cy))\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = cx + dx, cy + dy\n                if (nx, ny) in walkable and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n        \n        print(f\"Analysis complete from {start_pos}.\")\n        print(f\"Reachable Map Edge Exits: {sorted(list(set(exits)))}\")\n        print(f\"Reachable Warp Tiles: {sorted(list(set(reachable_warps)))}\")\n        \n        if not exits and not reachable_warps:\n             print(\"No exits found! You might be trapped or walkable types are missing.\")\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-23T20:36:44.830Z",
        "action_counter": 9932
      }
    ]
  },
  "patrol_grass": {
    "description": "Moves the player Left and Right to search for wild Pokemon, and presses A to handle battle introductions.",
    "input_schema": {},
    "python_script": "import json\ncmds = [\"Left\", \"Right\", \"Left\", \"Right\", \"A\", \"A\", \"A\", \"A\"]\nprint(json.dumps(cmds))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T02:06:33.549Z",
        "action_counter": 93
      }
    ]
  },
  "scan_surroundings": {
    "description": "Scans the Mental Map around the player and returns the type and coordinates of nearby tiles. Useful for identifying walls, ledges, and navigable paths without walking into them.",
    "input_schema": {
      "type": "object",
      "properties": {
        "radius": {
          "type": "integer",
          "description": "The radius of tiles to scan around the player. Defaults to 2."
        }
      },
      "required": [
        "radius"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    player_pos = None\n    \n    # Find player position\n    for row in root.findall(\"Row\"):\n        for tile in row.findall(\"Tile\"):\n            if tile.find(\"Player\") is not None:\n                player_pos = (int(tile.get(\"id\")), int(row.get(\"id\")))\n                break\n        if player_pos: break\n\n    if not player_pos:\n        print(\"Error: Player not found in Mental Map.\")\n    else:\n        px, py = player_pos\n        radius = input_data.get('radius', 2)\n        map_id = root.get('id')\n        print(f\"Scanning radius {radius} around {player_pos} on map {map_id}:\")\n        \n        for y in range(py - radius, py + radius + 1):\n            row = root.find(f\"./Row[@id='{y}']\")\n            if row is not None:\n                row_str = \"\"\n                for x in range(px - radius, px + radius + 1):\n                    tile = row.find(f\"./Tile[@id='{x}']\")\n                    if tile is not None:\n                        t_type = tile.get(\"type\")\n                        row_str += f\"[{x},{y}: {t_type}] \"\n                    else:\n                        row_str += f\"[{x},{y}: N/A] \"\n                print(row_str)\n            else:\n                print(f\"Row {y} not found.\")\n\nexcept Exception as e:\n    print(f\"Error executing scan_surroundings: {e}\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T03:27:06.196Z",
        "action_counter": 213
      }
    ]
  },
  "test_sandbox": {
    "description": "A simple test to verify if the Python sandbox is functioning correctly.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "python_script": "print(\"Sandbox is working!\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-21T08:09:47.817Z",
        "action_counter": 7231
      }
    ]
  },
  "type_text": {
    "description": "Generates a sequence of button presses to type the specified text on the Gen 2 keyboard interface. Verified Layout: Rows 0-1 (9 cols), Row 2 (8 cols), Row 3 (10 cols), Row 4 (UPPER, DEL, END). Handles case switching.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_text": {
          "type": "string",
          "description": "The string to type."
        },
        "start_char": {
          "type": "string",
          "description": "The character or button code (UPPER, DEL, END) currently selected. Default is 'A'.",
          "default": "A"
        },
        "autopress_buttons": {
          "type": "boolean",
          "description": "If true, automatically press the buttons.",
          "default": false
        }
      },
      "required": [
        "target_text"
      ]
    },
    "python_script": "import json\nimport sys\n\ndef solve():\n    buttons = []\n    try:\n        # Attempt to get arguments from injected global variables\n        # If not present, try input_data dictionary (common pattern)\n        try:\n            t_text = target_text\n        except NameError:\n            try:\n                t_text = input_data['target_text']\n            except NameError:\n                t_text = \"\"\n        \n        try:\n            s_char = start_char\n        except NameError:\n            try:\n                s_char = input_data.get('start_char', 'A')\n            except:\n                s_char = 'A'\n        \n        # Keyboard Layout\n        layout_upper = [\n            ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'],\n            ['J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R'],\n            ['S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', ' '],\n            ['×', '(', ')', ':', ';', '[', ']', 'PK', 'MN', '?'],\n            ['UPPER', 'lower', 'DEL', 'END']\n        ]\n        layout_lower = [\n            ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'],\n            ['j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r'],\n            ['s', 't', 'u', 'v', 'w', 'x', 'y', 'z', ' '],\n            ['×', '(', ')', ':', ';', '[', ']', 'PK', 'MN', '?'],\n            ['UPPER', 'lower', 'DEL', 'END']\n        ]\n\n        # Coordinate Map\n        map_coords = {}\n        for r, row in enumerate(layout_upper):\n            for c, char in enumerate(row):\n                map_coords[(char, 0)] = (r, c)\n        for r, row in enumerate(layout_lower):\n            for c, char in enumerate(row):\n                map_coords[(char, 1)] = (r, c)\n        \n        # Special keys mapping\n        specials = ['UPPER', 'lower', 'DEL', 'END']\n        for i, key in enumerate(specials):\n             map_coords[(key, 0)] = (4, i)\n             map_coords[(key, 1)] = (4, i)\n\n        # Init Position\n        current_r, current_c = 0, 0\n        current_case = 0 # 0=Upper, 1=Lower\n        \n        # Find start position\n        start_key = (s_char, 0)\n        if start_key in map_coords:\n            current_r, current_c = map_coords[start_key]\n\n        for char in t_text:\n            # Determine target case\n            target_case = 0\n            if 'a' <= char <= 'z': target_case = 1\n            elif 'A' <= char <= 'Z': target_case = 0\n            else:\n                # For symbols, prefer current case if available\n                if (char, current_case) in map_coords:\n                    target_case = current_case\n                elif (char, 0) in map_coords:\n                    target_case = 0\n                elif (char, 1) in map_coords:\n                    target_case = 1\n            \n            # Switch case if needed\n            if current_case != target_case:\n                switch_key = 'lower' if target_case == 1 else 'UPPER'\n                tr, tc = map_coords[(switch_key, current_case)]\n                \n                # Move to switch\n                buttons.extend(['Down'] * (tr - current_r))\n                buttons.extend(['Up'] * (current_r - tr))\n                buttons.extend(['Right'] * (tc - current_c))\n                buttons.extend(['Left'] * (current_c - tc))\n                \n                buttons.append('A')\n                current_r, current_c = tr, tc\n                current_case = target_case\n            \n            # Move to char\n            if (char, target_case) in map_coords:\n                tr, tc = map_coords[(char, target_case)]\n                \n                buttons.extend(['Down'] * (tr - current_r))\n                buttons.extend(['Up'] * (current_r - tr))\n                buttons.extend(['Right'] * (tc - current_c))\n                buttons.extend(['Left'] * (current_c - tc))\n                \n                buttons.append('A')\n                current_r, current_c = tr, tc\n            else:\n                pass # Char not found, skip\n                \n    except Exception:\n        buttons = [] # Return empty on error\n    \n    print(json.dumps(buttons))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-25T19:07:50.224Z",
        "action_counter": 12601
      },
      {
        "commit_message": "Fixed layout coordinates: DEL is at col 4 (visual center), END at col 7. Added import json.",
        "timestamp": "2026-01-25T19:11:58.079Z",
        "action_counter": 12604
      },
      {
        "commit_message": "Fix type_text tool to properly access input arguments and return valid JSON.",
        "timestamp": "2026-01-26T11:30:24.969Z",
        "action_counter": 13565
      }
    ]
  }
}