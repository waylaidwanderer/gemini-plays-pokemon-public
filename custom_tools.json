{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "inventory_scanner": {
    "description": "Scans the player's inventory list for a target item and returns whether it was found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory_list": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "inventory_list",
        "target_item"
      ]
    },
    "python_script": "import json\n\ntry:\n    inventory_list = json.loads(input_data['inventory_list'])\n    target_item = input_data['target_item']\n    found = False\n    for item in inventory_list:\n        if target_item.lower() in item.lower():\n            found = True\n            break\n    print(f'Item found: {found}')\nexcept Exception as e:\n    print(f'An error occurred: {e}')"
  },
  "gem_path_planner_v11": {
    "description": "A custom pathfinding tool by Gem. Finds a path from start to target. v11 has more robust elevation change logic.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        },
        "movement_type": {
          "type": "string",
          "enum": [
            "walking",
            "surfing"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y",
        "movement_type"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\nclass AStar:\n    def __init__(self, map_xml_string):\n        self.root = ET.fromstring(map_xml_string)\n        self.width = int(self.root.get('width'))\n        self.height = int(self.root.get('height'))\n        self.grid = [[None for _ in range(self.width)] for _ in range(self.height)]\n        self.impassable_objects = set()\n\n        for row_elem in self.root.findall('Row'):\n            y = int(row_elem.get('id')) - 1\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id')) - 1\n                tile_type = tile_elem.get('type')\n                self.grid[y][x] = tile_type\n                if tile_elem.find('Object') is not None:\n                    obj = tile_elem.find('Object')\n                    if obj.get('id-name') != 'Pikachu':\n                        self.impassable_objects.add((x, y))\n\n    def heuristic(self, a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def get_neighbors(self, pos, movement_type):\n        x, y = pos\n        neighbors = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if not (0 <= nx < self.width and 0 <= ny < self.height):\n                continue\n            \n            if (nx, ny) in self.impassable_objects:\n                continue\n\n            current_tile_type = self.grid[y][x]\n            neighbor_tile_type = self.grid[ny][nx]\n\n            valid_move = False\n            if movement_type == 'walking':\n                if current_tile_type in ['ground', 'grass'] and neighbor_tile_type in ['ground', 'grass']: valid_move = True\n                elif current_tile_type == 'elevated_ground' and neighbor_tile_type == 'elevated_ground': valid_move = True\n                elif current_tile_type == 'steps' and neighbor_tile_type in ['ground', 'elevated_ground']: valid_move = True\n                elif neighbor_tile_type == 'steps' and current_tile_type in ['ground', 'elevated_ground']: valid_move = True\n                elif neighbor_tile_type in ['ladder_up', 'ladder_down', 'hole']: valid_move = True\n            \n            elif movement_type == 'surfing':\n                if current_tile_type == 'water' and neighbor_tile_type == 'water': valid_move = True\n                elif current_tile_type == 'water' and neighbor_tile_type in ['ground', 'elevated_ground', 'steps']: valid_move = True\n                elif neighbor_tile_type == 'water' and current_tile_type in ['ground', 'elevated_ground', 'steps']: valid_move = True\n\n            if valid_move:\n                neighbors.append((nx, ny))\n        return neighbors\n\n    def find_path(self, start, end, movement_type):\n        open_set = []\n        heapq.heappush(open_set, (0, start))\n        came_from = {}\n        g_score = { (x,y): float('inf') for y in range(self.height) for x in range(self.width) }\n        g_score[start] = 0\n        f_score = { (x,y): float('inf') for y in range(self.height) for x in range(self.width) }\n        f_score[start] = self.heuristic(start, end)\n\n        while open_set:\n            _, current = heapq.heappop(open_set)\n            if current == end:\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(start)\n                return path[::-1]\n\n            for neighbor in self.get_neighbors(current, movement_type):\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score[neighbor]:\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = g_score[neighbor] + self.heuristic(neighbor, end)\n                    if neighbor not in [i[1] for i in open_set]:\n                        heapq.heappush(open_set, (f_score[neighbor], neighbor))\n        return None\n\ntry:\n    start_x = int(input_data['start_x']) - 1\n    start_y = int(input_data['start_y']) - 1\n    target_x = int(input_data['target_x']) - 1\n    target_y = int(input_data['target_y']) - 1\n    movement_type = input_data['movement_type']\n    pathfinder = AStar(map_xml_string)\n    path = pathfinder.find_path((start_x, start_y), (target_x, target_y), movement_type)\n    if path:\n        buttons = []\n        for i in range(len(path) - 1):\n            cx, cy = path[i]\n            nx, ny = path[i+1]\n            if nx > cx: buttons.append('Right')\n            elif nx < cx: buttons.append('Left')\n            elif ny > cy: buttons.append('Down')\n            elif ny < cy: buttons.append('Up')\n        print(','.join(buttons))\n    else:\n        print('No path found')\nexcept Exception as e:\n    print(f'An error occurred: {e}')"
  },
  "gem_path_planner": {
    "description": "A custom pathfinding tool by Gem. Finds a path from start to target. This version has robust elevation and water transition logic.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        },
        "movement_type": {
          "type": "string",
          "enum": [
            "walking",
            "surfing"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y",
        "movement_type"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\nclass PathPlanner:\n    def __init__(self, xml_string, start_x, start_y, target_x, target_y, movement_type):\n        self.root = ET.fromstring(xml_string)\n        self.width = int(self.root.get('width'))\n        self.height = int(self.root.get('height'))\n        self.start_pos = (start_x, start_y)\n        self.target_pos = (target_x, target_y)\n        self.movement_type = movement_type\n        self.grid = self._create_grid()\n\n    def _create_grid(self):\n        grid = [[0 for _ in range(self.width + 1)] for _ in range(self.height + 1)]\n        for row in self.root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                x = int(tile.get('id'))\n                tile_type = tile.get('type')\n                has_object = tile.get('has-object') == 'true'\n                \n                is_pikachu = False\n                if has_object:\n                    obj = tile.find('Object')\n                    if obj is not None and obj.get('id-name') == 'Pikachu':\n                        is_pikachu = True\n\n                traversable = self._is_traversable(tile_type, has_object, is_pikachu)\n                grid[y][x] = {\n                    'type': tile_type,\n                    'traversable': traversable,\n                    'elevation': self._get_elevation(tile_type)\n                }\n        return grid\n\n    def _get_elevation(self, tile_type):\n        if tile_type in ['elevated_ground', 'steps']:\n            return 1\n        return 0\n\n    def _is_traversable(self, tile_type, has_object, is_pikachu):\n        walkable_tiles = ['ground', 'grass', 'steps', 'elevated_ground', 'cleared_boulder_barrier', 'open_gate', 'gate_offscreen', 'ladder_up', 'ladder_down', 'teleport', 'hole']\n        surfable_tiles = ['water']\n        \n        if self.movement_type == 'walking':\n            if tile_type in walkable_tiles:\n                if has_object and not is_pikachu:\n                    return False\n                return True\n        elif self.movement_type == 'surfing':\n            if tile_type in surfable_tiles:\n                return True\n        return False\n\n    def _heuristic(self, a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def _get_neighbors(self, pos):\n        neighbors = []\n        x, y = pos\n        current_tile = self.grid[y][x]\n        current_elevation = current_tile['elevation']\n\n        for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = x + dx, y + dy\n\n            if not (1 <= nx <= self.width and 1 <= ny <= self.height):\n                continue\n\n            neighbor_tile = self.grid[ny][nx]\n            neighbor_elevation = neighbor_tile['elevation']\n            \n            if current_tile['type'] == 'ledge' and dy == 1:\n                ny += 1\n                if not (1 <= ny <= self.height):\n                    continue\n                neighbor_tile = self.grid[ny][nx]\n                neighbor_elevation = neighbor_tile['elevation']\n\n            if not neighbor_tile['traversable']:\n                continue\n\n            if abs(current_elevation - neighbor_elevation) > 0:\n                if not (current_tile['type'] in ['steps', 'ladder_up', 'ladder_down'] or neighbor_tile['type'] in ['steps', 'ladder_up', 'ladder_down']):\n                    continue\n\n            neighbors.append(((nx, ny), move))\n\n        return neighbors\n        \n    def _get_cost(self, current_pos, next_pos):\n        return 1\n\n    def find_path(self):\n        open_set = [(0, self.start_pos)]\n        came_from = {}\n        g_score = { (x, y): float('inf') for y in range(self.height + 1) for x in range(self.width + 1) }\n        g_score[self.start_pos] = 0\n        f_score = { (x, y): float('inf') for y in range(self.height + 1) for x in range(self.width + 1) }\n        f_score[self.start_pos] = self._heuristic(self.start_pos, self.target_pos)\n\n        while open_set:\n            _, current = heapq.heappop(open_set)\n\n            if current == self.target_pos:\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(self.start_pos)\n                return path[::-1]\n\n            for neighbor_pos, move in self._get_neighbors(current):\n                tentative_g_score = g_score[current] + self._get_cost(current, neighbor_pos)\n                \n                if tentative_g_score < g_score[neighbor_pos]:\n                    came_from[neighbor_pos] = current\n                    g_score[neighbor_pos] = tentative_g_score\n                    f_score[neighbor_pos] = tentative_g_score + self._heuristic(neighbor_pos, self.target_pos)\n                    heapq.heappush(open_set, (f_score[neighbor_pos], neighbor_pos))\n        \n        return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    movement_type = input_data['movement_type']\n    \n    planner = PathPlanner(map_xml_string, start_x, start_y, target_x, target_y, movement_type)\n    path = planner.find_path()\n    \n    if path:\n        path_json = [{'x': p[0], 'y': p[1]} for p in path]\n        print(path_json)\n    else:\n        print(f'No path found from ({start_x},{start_y}) to ({target_x},{target_y})')\n\nexcept Exception as e:\n    print(f'An error occurred: {e}')"
  },
  "gem_path_planner_v12": {
    "description": "A custom pathfinding tool by Gem. Finds a path from start to target. v12 has improved logic for handling transitions between walking and surfing, and now correctly handles impassable tiles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\nclass AStar:\n    def __init__(self, map_xml_string):\n        self.root = ET.fromstring(map_xml_string)\n        self.width = int(self.root.get('width'))\n        self.height = int(self.root.get('height'))\n        self.grid = [[None for _ in range(self.width)] for _ in range(self.height)]\n        self.impassable_objects = set()\n\n        for row_elem in self.root.findall('Row'):\n            y = int(row_elem.get('id')) - 1\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id')) - 1\n                tile_type = tile_elem.get('type')\n                self.grid[y][x] = tile_type\n                if tile_elem.find('Object') is not None:\n                    obj = tile_elem.find('Object')\n                    if obj.get('id-name') != 'Pikachu':\n                        self.impassable_objects.add((x, y))\n\n    def heuristic(self, a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def get_neighbors(self, pos):\n        x, y = pos\n        neighbors = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if not (0 <= nx < self.width and 0 <= ny < self.height):\n                continue\n            if (nx, ny) in self.impassable_objects:\n                continue\n\n            current_tile_type = self.grid[y][x]\n            neighbor_tile_type = self.grid[ny][nx]\n            \n            if neighbor_tile_type == 'impassable':\n                continue\n\n            valid_move = False\n            # Case 1: Land -> Land\n            if current_tile_type in ['ground', 'grass', 'elevated_ground', 'steps', 'ladder_up', 'ladder_down', 'hole'] and \\\n               neighbor_tile_type in ['ground', 'grass', 'elevated_ground', 'steps', 'ladder_up', 'ladder_down', 'hole']:\n                # Can't move between ground and elevated_ground without steps\n                if (current_tile_type in ['ground', 'grass'] and neighbor_tile_type == 'elevated_ground') or \\\n                   (neighbor_tile_type in ['ground', 'grass'] and current_tile_type == 'elevated_ground'):\n                    valid_move = False\n                else:\n                    valid_move = True\n            # Case 2: Water -> Water\n            elif current_tile_type == 'water' and neighbor_tile_type == 'water':\n                valid_move = True\n            # Case 3: Land <-> Water transitions\n            elif (current_tile_type in ['ground', 'grass', 'steps'] and neighbor_tile_type == 'water') or \\\n                 (current_tile_type == 'water' and neighbor_tile_type in ['ground', 'grass', 'steps']):\n                valid_move = True\n\n            if valid_move:\n                neighbors.append((nx, ny))\n        return neighbors\n\n    def find_path(self, start, end):\n        open_set = []\n        heapq.heappush(open_set, (0, start))\n        came_from = {}\n        g_score = { (x,y): float('inf') for y in range(self.height) for x in range(self.width) }\n        g_score[start] = 0\n        f_score = { (x,y): float('inf') for y in range(self.height) for x in range(self.width) }\n        f_score[start] = self.heuristic(start, end)\n\n        while open_set:\n            _, current = heapq.heappop(open_set)\n            if current == end:\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(start)\n                return path[::-1]\n\n            for neighbor in self.get_neighbors(current):\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score[neighbor]:\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = g_score[neighbor] + self.heuristic(neighbor, end)\n                    if neighbor not in [i[1] for i in open_set]:\n                        heapq.heappush(open_set, (f_score[neighbor], neighbor))\n        return None\n\ntry:\n    start_x = int(input_data['start_x']) - 1\n    start_y = int(input_data['start_y']) - 1\n    target_x = int(input_data['target_x']) - 1\n    target_y = int(input_data['target_y']) - 1\n    pathfinder = AStar(map_xml_string)\n    path = pathfinder.find_path((start_x, start_y), (target_x, target_y))\n    if path:\n        buttons = []\n        for i in range(len(path) - 1):\n            cx, cy = path[i]\n            nx, ny = path[i+1]\n            if nx > cx: buttons.append('Right')\n            elif nx < cx: buttons.append('Left')\n            elif ny > cy: buttons.append('Down')\n            elif ny < cy: buttons.append('Up')\n        print(','.join(buttons))\n    else:\n        print('No path found')\nexcept Exception as e:\n    print(f'An error occurred: {e}')"
  }
}