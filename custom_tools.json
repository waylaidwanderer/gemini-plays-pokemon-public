{
  "find_path_v4": {
    "description": "Finds the shortest path to a target coordinate. Correctly handles walls, NPCs, and items. Returns an empty list if no path is found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef solve():\n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n        \n        root = ET.fromstring(map_xml_string)\n        \n        start_x, start_y = -1, -1\n        for row in root.findall('Row'):\n            curr_y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                if tile.find('Player') is not None:\n                    start_x = int(tile.attrib['id'])\n                    start_y = curr_y\n                    break\n            if start_x != -1: break\n            \n        if start_x == -1: return []\n\n        grid = {}\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                t_type = tile.attrib['type']\n                is_wall = t_type in ['WALL', 'COUNTER', 'BOOKSHELF', 'TABLE', 'MART_SHELF']\n                obj = tile.find('Object')\n                if obj is not None:\n                    # NPCs and items are walls unless they are the target (for interaction)\n                    if not (x == start_x and y == start_y) and not (x == target_x and y == target_y):\n                        is_wall = True\n                grid[(x, y)] = not is_wall\n\n        queue = deque([(start_x, start_y, [])])\n        visited = {(start_x, start_y)}\n        while queue:\n            x, y, path = queue.popleft()\n            if x == target_x and y == target_y:\n                return path\n            for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n                nx, ny = x + dx, y + dy\n                if (nx, ny) in grid and grid[(nx, ny)] and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [btn]))\n        return []\n    except Exception:\n        return []\n\nprint(json.dumps(solve()))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-21T06:11:17.104Z",
        "action_counter": 8161
      },
      {
        "commit_message": "Fixed find_path_v4: removed non-standard getparent() call and improved player position detection. Consolidated grid construction and BFS.",
        "timestamp": "2025-12-21T06:23:10.110Z",
        "action_counter": 8180
      }
    ]
  },
  "battle_move_selector_v2": {
    "description": "Selects a move from the move selection menu in battle. Assumes the move selection menu is open AND the cursor is at the first move (index 0). Moves the cursor down to the specified move_index (0-3) and presses A. Includes an initial 1000ms safety delay for menu transitions and 300ms between presses.",
    "input_schema": {
      "type": "object",
      "properties": {
        "move_index": {
          "type": "integer",
          "description": "The 0-indexed position of the move to select (0-3)."
        }
      },
      "required": [
        "move_index"
      ]
    },
    "python_script": "import json\n\ndef run(input_data):\n    try:\n        move_index = int(input_data.get('move_index', 0))\n    except (ValueError, TypeError):\n        move_index = 0\n        \n    buttons = [\"sleep 1000\"]\n    for _ in range(move_index):\n        buttons.append(\"Down\")\n        buttons.append(\"sleep 300\")\n    buttons.append(\"A\")\n    print(json.dumps(buttons))\n\nrun(input_data)\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-21T11:41:54.981Z",
        "action_counter": 8762
      },
      {
        "commit_message": "Corrected tool to use the 'input_data' variable for arguments instead of reading from stdin.",
        "timestamp": "2025-12-21T11:46:11.447Z",
        "action_counter": 8774
      },
      {
        "commit_message": "Added a safety delay (sleep 500) to ensure the move selection menu is fully active before button presses.",
        "timestamp": "2025-12-21T14:19:46.168Z",
        "action_counter": 9031
      },
      {
        "commit_message": "Fixed the tool by adding the necessary 'run(input_data)' call at the end of the script and added a cursor reset (3 Ups) to ensure it starts from move 0.",
        "timestamp": "2025-12-21T14:21:30.713Z",
        "action_counter": 9035
      },
      {
        "commit_message": "Increased initial safety delay to 1000ms to handle menu opening animations and added a 300ms delay after each move selection button to prevent input dropping.",
        "timestamp": "2025-12-21T14:22:49.888Z",
        "action_counter": 9037
      },
      {
        "commit_message": "Removed the faulty 'Up' reset logic which caused misclicks due to menu wrapping. Now relies on Gen 2's default behavior of resetting the cursor to 0 on menu open.",
        "timestamp": "2025-12-21T14:28:43.731Z",
        "action_counter": 9045
      },
      {
        "commit_message": "Re-added cursor reset (Up, Up, Up) with safety delays. In Gen 2, the move selection menu does NOT wrap, making this a reliable way to ensure the tool starts from move 0 even if the menu was already open.",
        "timestamp": "2025-12-21T14:31:21.406Z",
        "action_counter": 9048
      },
      {
        "commit_message": "Removed the faulty 'Up' reset logic and added a clear explanation in the description that the tool assumes the cursor starts at move index 0. This is necessary because the Gen 2 move menu wraps, making 'Up' resets unreliable.",
        "timestamp": "2025-12-21T14:32:49.857Z",
        "action_counter": 9049
      }
    ]
  },
  "get_map_warps_v1": {
    "description": "Extracts warp information (coordinates and entry points) for a list of map IDs from the mental map XML.",
    "input_schema": {
      "type": "object",
      "properties": {
        "map_ids": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "map_ids"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ndef run(input_data):\n    try:\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        print(f\"Error parsing XML: {e}\")\n        return\n\n    results = {}\n    map_ids = input_data.get('map_ids', [])\n    \n    # Check all maps in the XML (root and children)\n    for map_node in root.iter('Map'):\n        mid = map_node.get('id')\n        if mid in map_ids:\n            name = map_node.get('name')\n            warps = []\n            for row in map_node.findall('Row'):\n                y = row.get('id')\n                for tile in row.findall('Tile'):\n                    x = tile.get('id')\n                    warp = tile.find('Warp')\n                    if warp is not None:\n                        warps.append({\n                            'x': int(x),\n                            'y': int(y),\n                            'entry': int(warp.get('entry_point'))\n                        })\n            results[mid] = {'name': name, 'warps': warps}\n    print(json.dumps(results, indent=2))\n\nrun(input_data)",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-21T12:56:21.285Z",
        "action_counter": 8882
      },
      {
        "commit_message": "Refined to handle root <Map> element correctly by using root.iter('Map').",
        "timestamp": "2025-12-21T12:58:59.126Z",
        "action_counter": 8885
      }
    ]
  },
  "check_reachable_unseen_v1": {
    "description": "Finds all unseen tiles adjacent to reachable walkable tiles on the current map. Relies on verified traversable tile types from the notepad. Useful for clearing the exploration alert. Returns a list of coordinate dictionaries.",
    "input_schema": {
      "type": "object",
      "properties": {
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": []
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\nimport json\n\ndef run(input_data):\n    try:\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        print(f\"Error parsing XML: {e}\")\n        return\n\n    # Find the map where the player is\n    current_map = None\n    player_pos = None\n    \n    # Check if root is Map\n    if root.tag == 'Map':\n        current_map = root\n    else:\n        # Search for Map with Player\n        for map_node in root.iter('Map'):\n            if map_node.find('.//Player') is not None:\n                current_map = map_node\n                break\n    \n    if current_map is None:\n        print(\"No map with player found in XML.\")\n        return\n\n    # Find player position\n    for row in current_map.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            if tile.find('Player') is not None:\n                player_pos = (int(tile.get('id')), y)\n                break\n        if player_pos: break\n\n    if not player_pos:\n        print(\"Player position not found on the map.\")\n        return\n\n    width = int(current_map.get('width'))\n    height = int(current_map.get('height'))\n    \n    grid = {}\n    for row in current_map.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            grid[(x, y)] = {\n                'type': tile.get('type'),\n                'seen': tile.get('seen') == 'true',\n                'has_object': tile.get('has-object') == 'true'\n            }\n\n    traversable_types = ['FLOOR', 'STAIRCASE', 'LADDER', 'WARP_CARPET_DOWN', 'ICE']\n\n    # BFS to find reachable tiles\n    reachable = set()\n    queue = collections.deque([player_pos])\n    reachable.add(player_pos)\n\n    while queue:\n        cx, cy = queue.popleft()\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) in grid:\n                tile = grid[(nx, ny)]\n                if tile['seen'] and tile['type'] in traversable_types and not tile['has_object']:\n                    if (nx, ny) not in reachable:\n                        reachable.add((nx, ny))\n                        queue.append((nx, ny))\n\n    # Find unseen tiles adjacent to reachable tiles\n    unseen_reachable = []\n    for rx, ry in reachable:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = rx + dx, ry + dy\n            if (nx, ny) in grid:\n                if not grid[(nx, ny)]['seen']:\n                    unseen_reachable.append({'x': nx, 'y': ny})\n\n    # Deduplicate\n    unique_unseen = []\n    seen_coords = set()\n    for u in unseen_reachable:\n        coord = (u['x'], u['y'])\n        if coord not in seen_coords:\n            unique_unseen.append(u)\n            seen_coords.add(coord)\n\n    print(json.dumps(unique_unseen))\n\nrun(input_data)",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-21T13:00:01.847Z",
        "action_counter": 8888
      },
      {
        "commit_message": "Updated to find the map where the player is currently located and better handle traversable types.",
        "timestamp": "2025-12-21T13:01:21.398Z",
        "action_counter": 8891
      },
      {
        "commit_message": "Fixed map node detection to handle both <Map> as root or as a child of <MentalMap>.",
        "timestamp": "2025-12-21T13:01:56.860Z",
        "action_counter": 8892
      }
    ]
  }
}