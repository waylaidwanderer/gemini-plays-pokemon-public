{
  "get_traversable_neighbors": {
    "description": "Parses the map_xml_string to find all traversable neighbor tiles for a given (x, y) coordinate. It considers walls and objects as impassable.",
    "input_schema": {
      "type": "object",
      "properties": {
        "x": {
          "type": "string"
        },
        "y": {
          "type": "string"
        }
      },
      "required": [
        "x",
        "y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ndef get_traversable_neighbors(x, y):\n    root = ET.fromstring(map_xml_string)\n    impassable_tiles = ['WALL', 'PILLAR', 'BOOKSHELF', 'TV', 'RADIO', 'TOWN_MAP', 'TABLE', 'CHAIR', 'BIRD', 'MART_SHELF', 'PC', 'LINK_CABLE', 'TRADE_MACHINE', 'INCENSE_BURNER', 'ROOF', 'CHIMNEY', 'SIGN', 'FLOWER', 'TREE_TOP', 'WATER_EDGE_UP', 'WATER_EDGE_DOWN', 'WATER_EDGE_LEFT', 'WATER_EDGE_RIGHT', 'VOID', 'COUNTER', 'FENCE', 'LINK_RECEPTIONIST', 'WEIRD_TREE', 'PRINTER', 'BUOY', 'ROCK', 'WINDOW']\n    neighbors = []\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nx, ny = x + dx, y + dy\n        tile_element = root.find(f\".//Tile[@coordinate='({nx}, {ny})']\")\n        if tile_element is not None:\n            tile_type = tile_element.get('type')\n            has_object = tile_element.get('has-object') == 'true'\n            if tile_type not in impassable_tiles and not has_object:\n                neighbors.append({'x': nx, 'y': ny})\n    return neighbors\n\nx = int(input_data['x'])\ny = int(input_data['y'])\n\nresult = get_traversable_neighbors(x, y)\nprint(json.dumps(result))"
  },
  "impassable_tile_scanner": {
    "description": "Scans the current map and returns a list of all impassable coordinates, including walls and all objects.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\nroot = ET.fromstring(map_xml_string)\nimpassable_coords = []\n\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.attrib['id'])\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.attrib['id'])\n        tile_type = tile_elem.attrib['type']\n        has_object = tile_elem.find('Object') is not None\n        \n        if tile_type == 'WALL' or has_object:\n            impassable_coords.append({'x': x, 'y': y})\n\nprint(json.dumps(impassable_coords))"
  },
  "object_finder": {
    "description": "Finds a specific map object by its ID and returns its coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "object_id": {
          "type": "string"
        }
      },
      "required": [
        "object_id"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntarget_id = input_data['object_id']\nroot = ET.fromstring(map_xml_string)\nfound = False\nfor row in root.findall('Row'):\n    y = row.get('id')\n    for tile in row.findall('Tile'):\n        x = tile.get('id')\n        for obj in tile.findall('Object'):\n            if obj.get('id') == target_id:\n                print(json.dumps({'x': x, 'y': y}))\n                found = True\n                break\n        if found:\n            break\n    if found:\n        break\n\nif not found:\n    print(json.dumps({'error': 'Object not found on screen.'}))"
  },
  "unseen_tile_scanner": {
    "description": "Scans the current map XML and returns a list of coordinates for all unseen tiles.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\n\nunseen_tiles = []\nroot = ET.fromstring(map_xml_string)\nfor row in root.findall('Row'):\n    for tile in row.findall('Tile'):\n        if tile.get('seen') == 'false':\n            unseen_tiles.append(tile.get('coordinate'))\nprint(unseen_tiles)"
  },
  "reliable_pathfinder": {
    "description": "A reliable pathfinder using Breadth-First Search (BFS). It avoids walls, ledges, and on-screen NPCs, but allows pathing over item balls. If the destination is impassable, it finds a path to an adjacent traversable tile.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "traversable_tiles": {
          "type": "string"
        },
        "on_screen_objects": {
          "type": "string",
          "description": "A JSON string of a list of objects currently on screen."
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "traversable_tiles",
        "on_screen_objects"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef find_path():\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    traversable_tile_types = input_data['traversable_tiles'].split(',')\n    on_screen_objects_json = input_data.get('on_screen_objects', '[]')\n    \n    try:\n        root = ET.fromstring(map_xml_string)\n        map_width = int(root.get('width'))\n        map_height = int(root.get('height'))\n    except Exception as e:\n        print(f\"Error parsing map XML: {e}\")\n        return\n\n    impassable = set()\n    for row in root.findall('Row'):\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            y = int(row.get('id'))\n            if tile.get('type') not in traversable_tile_types:\n                impassable.add((x, y))\n            obj_node = tile.find('Object')\n            if obj_node is not None:\n                if obj_node.get('id-name') != 'POKE_BALL':\n                    impassable.add((x, y))\n\n    try:\n        on_screen_objects = json.loads(on_screen_objects_json)\n        for obj in on_screen_objects:\n            pos = obj.get('position')\n            obj_name = obj.get('object_name')\n            if pos and obj_name != 'POKE_BALL':\n                impassable.add((pos['x'], pos['y']))\n    except (json.JSONDecodeError, KeyError):\n        pass\n        \n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n\n    target_destinations = [end_node]\n    if end_node in impassable:\n        target_destinations = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_node = (end_node[0] + dx, end_node[1] + dy)\n            if adj_node not in impassable:\n                 target_destinations.append(adj_node)\n        \n        if not target_destinations:\n            print(\"FAIL: Destination and all adjacent tiles are impassable.\")\n            return\n\n    queue = deque([[start_node]])\n    visited = {start_node}\n\n    while queue:\n        path = queue.popleft()\n        node = path[-1]\n\n        if node in target_destinations:\n            path_json = json.dumps([{\"x\": x, \"y\": y} for x, y in path])\n            print(path_json)\n            return\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (node[0] + dx, node[1] + dy)\n            \n            if not (0 < neighbor[0] <= map_width and 0 < neighbor[1] <= map_height):\n                continue\n            \n            if neighbor not in visited and neighbor not in impassable:\n                visited.add(neighbor)\n                new_path = list(path)\n                new_path.append(neighbor)\n                queue.append(new_path)\n\n    print(\"FAIL: No path found.\")\n\nfind_path()\n"
  }
}