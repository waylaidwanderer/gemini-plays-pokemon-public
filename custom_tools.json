{
  "calculate_xp_requirements": {
    "description": "Calculates the experience points required for the next level for a given Pokémon species and its current level and experience. Supports the four standard experience curves found in Pokémon Crystal (Fast, Medium Fast, Medium Slow, Slow).",
    "input_schema": {
      "type": "object",
      "properties": {
        "current_exp": {
          "type": "integer"
        },
        "current_level": {
          "type": "integer"
        },
        "growth_rate": {
          "type": "string",
          "enum": [
            "Fast",
            "Medium Fast",
            "Medium Slow",
            "Slow"
          ]
        }
      },
      "required": [
        "current_exp",
        "current_level",
        "growth_rate"
      ]
    },
    "python_script": "import json\nimport sys\n\ndef calculate_xp_needed(growth_rate, current_level, current_exp):\n    next_level = current_level + 1\n    if growth_rate == \"Fast\":\n        next_exp = int(0.8 * (next_level**3))\n    elif growth_rate == \"Medium Fast\":\n        next_exp = int(next_level**3)\n    elif growth_rate == \"Medium Slow\":\n        next_exp = int(1.2 * (next_level**3) - 15 * (next_level**2) + 100 * next_level - 140)\n    elif growth_rate == \"Slow\":\n        next_exp = int(1.25 * (next_level**3))\n    else:\n        return \"Unknown growth rate\"\n    \n    xp_needed = max(0, next_exp - current_exp)\n    return xp_needed\n\nif __name__ == \"__main__\":\n    # In a real environment, input_data would be passed in.\n    # For this example, we'll simulate the input parsing.\n    # Since this is a script to be defined, we use a placeholder for input_data.\n    try:\n        # The system will provide input_data as a global or via some mechanism.\n        # Here we expect it to be available.\n        # For the purpose of definition, we just write the logic.\n        res = calculate_xp_needed(input_data[\"growth_rate\"], int(input_data[\"current_level\"]), int(input_data[\"current_exp\"]))\n        print(json.dumps({\"xp_needed\": res}))\n    except NameError:\n        # Fallback for testing if input_data isn't defined\n        pass\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T04:58:09.193Z",
        "action_counter": 817
      }
    ]
  },
  "find_path_v2": {
    "description": "Finds a path from the player's current position to a target coordinate on the current map using BFS. Returns a list of coordinate dictionaries, or a list of button strings if autopress_buttons is true. If the target is impassable, it finds a path to an adjacent traversable tile. Handles 'unseen' tiles as potentially walkable for exploration. Correctly handles one-way ledge mechanics.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "description": "If true and the tool returns a list of buttons, they will be pressed automatically.",
          "type": "boolean"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y",
        "autopress_buttons"
      ],
      "type": "object"
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\nimport json\n\ndef solve():\n    try:\n        if not map_xml_string:\n            print(\"Error: map_xml_string is empty.\")\n            return\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        print(f\"Error parsing XML: {e}\")\n        return\n\n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n        autopress = input_data.get('autopress_buttons', False)\n    except (KeyError, ValueError) as e:\n        print(f\"Error in input data: {e}\")\n        return\n    \n    tiles = {}\n    start_x, start_y = None, None\n    for row in root.findall('Row'):\n        row_id_attr = row.attrib.get('id')\n        if row_id_attr is None: continue\n        y = int(row_id_attr)\n        for tile in row.findall('Tile'):\n            tile_id_attr = tile.attrib.get('id')\n            if tile_id_attr is None: continue\n            x = int(tile_id_attr)\n            tiles[(x, y)] = tile\n            if tile.find('Player') is not None:\n                start_x, start_y = x, y\n    \n    if start_x is None:\n        print(\"Error: Player position not found in XML.\")\n        return\n    \n    queue = collections.deque([(start_x, start_y, [{\"x\": start_x, \"y\": start_y}])])\n    visited = set([(start_x, start_y)])\n    reachable = {}\n    \n    impassable_types = [\"WALL\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"WATER\", \"BOOKSHELF\", \"WINDOW\", \"TRASHCAN\", \"PC\", \"BOOKSHELVES\", \"VOID\"]\n    \n    while queue:\n        x, y, path = queue.popleft()\n        reachable[(x, y)] = path\n        if x == target_x and y == target_y:\n            break\n            \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) in visited: continue\n            \n            tile = tiles.get((nx, ny))\n            if tile is None: continue\n            \n            tile_type = tile.attrib.get('type', 'unseen').strip().upper()\n            \n            # Ledge check\n            if \"LEDGE\" in tile_type:\n                can_jump = False\n                if tile_type == \"LEDGE_HOP_DOWN\" and dy == 1: can_jump = True\n                elif tile_type == \"LEDGE_HOP_UP\" and dy == -1: can_jump = True\n                elif tile_type == \"LEDGE_HOP_LEFT\" and dx == -1: can_jump = True\n                elif tile_type == \"LEDGE_HOP_RIGHT\" and dx == 1: can_jump = True\n                \n                if can_jump:\n                    lx, ly = nx + dx, ny + dy\n                    landing_tile = tiles.get((lx, ly))\n                    if landing_tile is not None:\n                        landing_type = landing_tile.attrib.get('type', 'unseen').strip().upper()\n                        if landing_type not in impassable_types and landing_tile.attrib.get('has-object') != 'true' and (lx, ly) not in visited:\n                            visited.add((nx, ny))\n                            visited.add((lx, ly))\n                            new_path = path + [{\"x\": nx, \"y\": ny}, {\"x\": lx, \"y\": ly}]\n                            queue.append((lx, ly, new_path))\n                continue\n\n            if tile_type in impassable_types or tile.attrib.get('has-object') == 'true':\n                continue\n\n            visited.add((nx, ny))\n            queue.append((nx, ny, path + [{\"x\": nx, \"y\": ny}]))\n            \n    final_path = reachable.get((target_x, target_y))\n    \n    if final_path is None:\n        best_dist = float('inf')\n        for (rx, ry), rpath in reachable.items():\n            dist = abs(rx - target_x) + abs(ry - target_y)\n            if dist < best_dist:\n                best_dist = dist\n                final_path = rpath\n                \n    if final_path is None:\n        print(\"Error: No reachable tiles found.\")\n        return\n\n    if autopress:\n        buttons = []\n        for i in range(len(final_path) - 1):\n            curr = final_path[i]\n            next_t = final_path[i+1]\n            if next_t['x'] > curr['x']: buttons.append(\"Right\")\n            elif next_t['x'] < curr['x']: buttons.append(\"Left\")\n            elif next_t['y'] > curr['y']: buttons.append(\"Down\")\n            elif next_t['y'] < curr['y']: buttons.append(\"Up\")\n        print(json.dumps(buttons))\n    else:\n        print(json.dumps(final_path))\n\nsolve()",
    "history": [
      {
        "commit_message": "Refined find_path to handle potential map XML structure variations and ensure the Player location is detected accurately. Added more robust logging for debugging.",
        "timestamp": "2025-12-17T23:52:03.099Z",
        "action_counter": 203
      }
    ]
  },
  "list_unseen_reachable_v2": {
    "description": "Identifies 'unseen' tiles that are adjacent to reachable, traversable tiles on the current map. This helps prioritize exploration targets.",
    "input_schema": {},
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef main():\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = {}\n    start = None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            seen = tile.attrib.get('seen') == 'true'\n            has_obj = tile.attrib.get('has-object') == 'true'\n            if tile.find('Player') is not None:\n                start = (x, y)\n            grid[(x, y)] = {'type': t_type, 'seen': seen, 'has_obj': has_obj}\n\n    if start is None:\n        print(json.dumps([]))\n        return\n\n    reachable_seen = set()\n    queue = deque([start])\n    visited = {start}\n    \n    traversable_types = ['FLOOR', 'TALL_GRASS', 'DOOR', 'WARP_CARPET', 'WARP_CARPET_DOWN', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'WARP_CARPET_UP']\n    \n    while queue:\n        curr = queue.popleft()\n        reachable_seen.add(curr)\n        \n        x, y = curr\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) in grid:\n                tile = grid[(nx, ny)]\n                if tile['seen']:\n                    if tile['type'] in traversable_types and not tile['has_obj']:\n                        if (nx, ny) not in visited:\n                            visited.add((nx, ny))\n                            queue.append((nx, ny))\n                # Note: We don't traverse into unseen tiles here, we only find seen reachable ones.\n\n    unseen_reachable_adj = []\n    for (x, y) in reachable_seen:\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) in grid:\n                if not grid[(nx, ny)]['seen']:\n                    unseen_reachable_adj.append({\"x\": nx, \"y\": ny})\n    \n    unique_unseen = []\n    seen_coords = set()\n    for item in unseen_reachable_adj:\n        coord = (item['x'], item['y'])\n        if coord not in seen_coords:\n            unique_unseen.append(item)\n            seen_coords.add(coord)\n\n    print(json.dumps(unique_unseen))\n\nmain()\n",
    "history": [
      {
        "commit_message": "Refining list_unseen_reachable to filter by actual reachability from player's current position and returning only those adjacent to traversable tiles.",
        "timestamp": "2025-12-18T01:52:03.195Z",
        "action_counter": 427
      }
    ]
  },
  "find_path_v2_fixed": {
    "description": "Finds a path from the player's current position to a target coordinate on the current map using BFS. Returns a list of coordinate dictionaries, or a list of button strings if autopress_buttons is true. Handles 'unseen' tiles as potentially walkable. Correctly handles one-way ledge mechanics and identifies obstacles (NPCs, items, boulders) even when off-screen using Map Markers and persistent XML data.",
    "input_schema": {
      "type": "object",
      "properties": {
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\nimport json\n\ndef solve():\n    try:\n        if not map_xml_string:\n            print(\"Error: map_xml_string is empty.\")\n            return\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        print(f\"Error parsing XML: {e}\")\n        return\n\n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n        autopress = input_data.get('autopress_buttons', False)\n    except (KeyError, ValueError) as e:\n        print(f\"Error in input data: {e}\")\n        return\n    \n    tiles = {}\n    start_x, start_y = None, None\n    for row in root.findall('Row'):\n        row_id_attr = row.attrib.get('id')\n        if row_id_attr is None: continue\n        y = int(row_id_attr)\n        for tile in row.findall('Tile'):\n            tile_id_attr = tile.attrib.get('id')\n            if tile_id_attr is None: continue\n            x = int(tile_id_attr)\n            tiles[(x, y)] = tile\n            if tile.find('Player') is not None:\n                start_x, start_y = x, y\n    \n    if start_x is None:\n        print(\"Error: Player position not found in XML.\")\n        return\n    \n    queue = collections.deque([(start_x, start_y, [{\"x\": start_x, \"y\": start_y}])])\n    visited = set([(start_x, start_y)])\n    reachable = {}\n    \n    impassable_types = [\"WALL\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"WATER\", \"BOOKSHELF\", \"WINDOW\", \"TRASHCAN\", \"PC\", \"BOOKSHELVES\", \"VOID\"]\n    \n    while queue:\n        x, y, path = queue.popleft()\n        reachable[(x, y)] = path\n        if x == target_x and y == target_y:\n            break\n            \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) in visited: continue\n            \n            tile = tiles.get((nx, ny))\n            if tile is None: continue\n            \n            tile_type = tile.attrib.get('type', 'unseen').strip().upper()\n            \n            # Obstacle check: Object tags, Boulder tags, or Markers with object_id\n            is_blocked = (\n                tile.attrib.get('has-object') == 'true' or\n                tile.find('Object') is not None or\n                tile.find('Boulder') is not None or\n                any(m.attrib.get('object_id') is not None for m in tile.findall('Marker'))\n            )\n            \n            # Ledge check\n            if \"LEDGE\" in tile_type:\n                can_jump = False\n                if tile_type == \"LEDGE_HOP_DOWN\" and dy == 1: can_jump = True\n                elif tile_type == \"LEDGE_HOP_UP\" and dy == -1: can_jump = True\n                elif tile_type == \"LEDGE_HOP_LEFT\" and dx == -1: can_jump = True\n                elif tile_type == \"LEDGE_HOP_RIGHT\" and dx == 1: can_jump = True\n                \n                if can_jump:\n                    lx, ly = nx + dx, ny + dy\n                    landing_tile = tiles.get((lx, ly))\n                    if landing_tile is not None:\n                        landing_type = landing_tile.attrib.get('type', 'unseen').strip().upper()\n                        # Check landing tile obstacles too\n                        landing_blocked = (\n                            landing_tile.attrib.get('has-object') == 'true' or\n                            landing_tile.find('Object') is not None or\n                            landing_tile.find('Boulder') is not None or\n                            any(m.attrib.get('object_id') is not None for m in landing_tile.findall('Marker'))\n                        )\n                        if landing_type not in impassable_types and not landing_blocked and (lx, ly) not in visited:\n                            visited.add((nx, ny))\n                            visited.add((lx, ly))\n                            new_path = path + [{\"x\": nx, \"y\": ny}, {\"x\": lx, \"y\": ly}]\n                            queue.append((lx, ly, new_path))\n                continue\n\n            if tile_type in impassable_types or is_blocked:\n                continue\n\n            visited.add((nx, ny))\n            queue.append((nx, ny, path + [{\"x\": nx, \"y\": ny}]))\n            \n    final_path = reachable.get((target_x, target_y))\n    \n    if final_path is None:\n        # Fallback to nearest reachable tile\n        best_dist = float('inf')\n        for (rx, ry), rpath in reachable.items():\n            dist = abs(rx - target_x) + abs(ry - target_y)\n            if dist < best_dist:\n                best_dist = dist\n                final_path = rpath\n                \n    if final_path is None:\n        print(\"Error: No reachable tiles found.\")\n        return\n\n    if autopress:\n        buttons = []\n        for i in range(len(final_path) - 1):\n            curr = final_path[i]\n            next_t = final_path[i+1]\n            if next_t['x'] > curr['x']: buttons.append(\"Right\")\n            elif next_t['x'] < curr['x']: buttons.append(\"Left\")\n            elif next_t['y'] > curr['y']: buttons.append(\"Down\")\n            elif next_t['y'] < curr['y']: buttons.append(\"Up\")\n        print(json.dumps(buttons))\n    else:\n        print(json.dumps(final_path))\n\nsolve()\n",
    "history": [
      {
        "commit_message": "Improved obstacle detection by checking for Map Markers, persistent Object tags, and Boulder tags within tiles. Also fixed button generation logic.",
        "timestamp": "2025-12-18T05:06:23.955Z",
        "action_counter": 826
      }
    ]
  }
}