{
  "get_traversable_neighbors": {
    "description": "Parses the map_xml_string to find all traversable neighbor tiles for a given (x, y) coordinate. It considers walls and objects as impassable.",
    "input_schema": {
      "type": "object",
      "properties": {
        "x": {
          "type": "string"
        },
        "y": {
          "type": "string"
        }
      },
      "required": [
        "x",
        "y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ndef get_traversable_neighbors(x, y):\n    root = ET.fromstring(map_xml_string)\n    impassable_tiles = ['WALL', 'PILLAR', 'BOOKSHELF', 'TV', 'RADIO', 'TOWN_MAP', 'TABLE', 'CHAIR', 'BIRD', 'MART_SHELF', 'PC', 'LINK_CABLE', 'TRADE_MACHINE', 'INCENSE_BURNER', 'ROOF', 'CHIMNEY', 'SIGN', 'FLOWER', 'TREE_TOP', 'WATER_EDGE_UP', 'WATER_EDGE_DOWN', 'WATER_EDGE_LEFT', 'WATER_EDGE_RIGHT', 'VOID', 'COUNTER', 'FENCE', 'LINK_RECEPTIONIST', 'WEIRD_TREE', 'PRINTER', 'BUOY', 'ROCK', 'WINDOW']\n    neighbors = []\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nx, ny = x + dx, y + dy\n        tile_element = root.find(f\".//Tile[@coordinate='({nx}, {ny})']\")\n        if tile_element is not None:\n            tile_type = tile_element.get('type')\n            has_object = tile_element.get('has-object') == 'true'\n            if tile_type not in impassable_tiles and not has_object:\n                neighbors.append({'x': nx, 'y': ny})\n    return neighbors\n\nx = int(input_data['x'])\ny = int(input_data['y'])\n\nresult = get_traversable_neighbors(x, y)\nprint(json.dumps(result))"
  },
  "impassable_tile_scanner": {
    "description": "Scans the current map and returns a list of all impassable coordinates, including walls and all objects.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\nroot = ET.fromstring(map_xml_string)\nimpassable_coords = []\n\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.attrib['id'])\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.attrib['id'])\n        tile_type = tile_elem.attrib['type']\n        has_object = tile_elem.find('Object') is not None\n        \n        if tile_type == 'WALL' or has_object:\n            impassable_coords.append({'x': x, 'y': y})\n\nprint(json.dumps(impassable_coords))"
  },
  "object_finder": {
    "description": "Finds a specific map object by its ID and returns its coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "object_id": {
          "type": "string"
        }
      },
      "required": [
        "object_id"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntarget_id = input_data['object_id']\nroot = ET.fromstring(map_xml_string)\nfound = False\nfor row in root.findall('Row'):\n    y = row.get('id')\n    for tile in row.findall('Tile'):\n        x = tile.get('id')\n        for obj in tile.findall('Object'):\n            if obj.get('id') == target_id:\n                print(json.dumps({'x': x, 'y': y}))\n                found = True\n                break\n        if found:\n            break\n    if found:\n        break\n\nif not found:\n    print(json.dumps({'error': 'Object not found on screen.'}))"
  },
  "unseen_tile_scanner": {
    "description": "Scans the current map XML and returns a list of coordinates for all unseen tiles.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\n\nunseen_tiles = []\nroot = ET.fromstring(map_xml_string)\nfor row in root.findall('Row'):\n    for tile in row.findall('Tile'):\n        if tile.get('seen') == 'false':\n            unseen_tiles.append(tile.get('coordinate'))\nprint(unseen_tiles)"
  },
  "reliable_pathfinder": {
    "description": "A reliable pathfinder using Breadth-First Search (BFS). It avoids walls, ledges, and on-screen objects. If the destination is impassable, it finds a path to an adjacent traversable tile.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "traversable_tiles": {
          "type": "string"
        },
        "on_screen_objects": {
          "type": "string",
          "description": "A JSON string of a list of objects currently on screen, e.g., '[{\"id\": 6, \"position\": {\"x\": 21, \"y\": 12}}]'"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "traversable_tiles",
        "on_screen_objects"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport sys\nfrom collections import deque\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    traversable_tiles_str = input_data.get('traversable_tiles', '[]')\n    on_screen_objects_str = input_data.get('on_screen_objects', '[]')\n\n    cleaned_str = traversable_tiles_str.strip().strip(\"[]'\\\"\")\n    base_traversable_tiles = {tile.strip().strip(\"'\\\"\") for tile in cleaned_str.split(',')}\n\n    root = ET.fromstring(map_xml_string)\n    \n    impassable_coords = set()\n    try:\n        on_screen_objects = json.loads(on_screen_objects_str)\n        for obj in on_screen_objects:\n            pos = obj.get('position')\n            if pos and 'x' in pos and 'y' in pos:\n                impassable_coords.add((int(pos['x']), int(pos['y'])))\n    except json.JSONDecodeError:\n        pass\n\n    grid = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id'])\n            tile_type = tile_elem.attrib['type']\n            is_traversable = (tile_type in base_traversable_tiles) and \\\n                               ((x, y) not in impassable_coords) and \\\n                               ('ledge' not in tile_type.lower()) and \\\n                               ('wall' not in tile_type.lower())\n            grid[(x, y)] = is_traversable\n\n    start_node = (start_x, start_y)\n    target_node = (end_x, end_y)\n\n    if not grid.get(start_node, False):\n        print(json.dumps({'error': f'Start node {start_node} is not traversable.'}))\n        sys.exit()\n\n    if not grid.get(target_node, False):\n        possible_targets = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_node = (end_x + dx, end_y + dy)\n            if grid.get(adj_node, False):\n                possible_targets.append(adj_node)\n        if not possible_targets:\n            print(json.dumps({'error': f'No traversable tile adjacent to target {target_node}.'}))\n            sys.exit()\n        target_node = min(possible_targets, key=lambda p: abs(p[0]-start_x)+abs(p[1]-start_y))\n\n    queue = deque([(start_node, [start_node])])\n    visited = {start_node}\n\n    while queue:\n        (current_x, current_y), path = queue.popleft()\n\n        if (current_x, current_y) == target_node:\n            print(json.dumps({'path': [{'x': p[0], 'y': p[1]} for p in path]}))\n            sys.exit()\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current_x + dx, current_y + dy)\n            if grid.get(neighbor, False) and neighbor not in visited:\n                visited.add(neighbor)\n                new_path = list(path)\n                new_path.append(neighbor)\n                queue.append((neighbor, new_path))\n\n    print(json.dumps({'error': 'No path found.'}))\n\nexcept Exception as e:\n    print(json.dumps({'error': f'An error occurred: {e}'}))"
  }
}