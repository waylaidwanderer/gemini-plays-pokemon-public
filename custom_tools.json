{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "get_impassable_tiles": {
    "description": "Extracts and returns a JSON list of all impassable tile coordinates from the current map XML.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET; import json; root = ET.fromstring(map_xml_string); impassable_tiles = []; for row_elem in root.findall('Row'): y = int(row_elem.get('id')); for tile_elem in row_elem.findall('Tile'): x = int(tile_elem.get('id')); if tile_elem.get('type') == 'impassable' or tile_elem.find('Object') is not None: impassable_tiles.append({'x': x, 'y': y}); print(json.dumps(impassable_tiles))"
  },
  "inventory_navigator_tool": {
    "description": "Calculates the optimal number of button presses (Up/Down) to navigate from a current selection to a target item in a list-based menu. This version correctly handles non-wrapping menus and provides a warning for long scrolls.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory_list": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "current_selection": {
          "type": "string"
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "inventory_list",
        "current_selection",
        "target_item"
      ]
    },
    "python_script": "import json\ntry:\n    inventory = json.loads(input_data['inventory_list'])\n    current_item = input_data['current_selection']\n    target_item = input_data['target_item']\n\n    if current_item not in inventory or target_item not in inventory:\n        print(json.dumps({'error': 'Item not found in inventory list.'}))\n    else:\n        current_idx = inventory.index(current_item)\n        target_idx = inventory.index(target_item)\n        \n        response = {}\n        if current_idx == target_idx:\n            response = {'direction': 'NONE', 'presses': 0}\n        elif target_idx > current_idx:\n            presses = target_idx - current_idx\n            response = {'direction': 'DOWN', 'presses': presses}\n        else: # target_idx < current_idx\n            presses = current_idx - target_idx\n            response = {'direction': 'UP', 'presses': presses}\n\n        if response.get('presses', 0) > 4:\n            response['note'] = 'Warning: This is a long scroll. Press Down in increments of 4 to navigate pages more effectively.'\n        \n        print(json.dumps(response))\nexcept Exception as e:\n    print(json.dumps({'error': str(e), 'type': type(e).__name__}))"
  },
  "find_path": {
    "description": "A consolidated and robust pathfinding tool. Finds a path from a start to an end coordinate using A* algorithm, correctly handling all known tile types including ledges, open gates, and offscreen gates. If the destination is impassable, it finds a path to an adjacent walkable tile. This version now correctly handles disconnected map sections by first verifying connectivity.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "movement_mode": {
          "type": "string",
          "enum": [
            "walking",
            "surfing"
          ]
        },
        "ignore_npc_ids": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "movement_mode"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport heapq\nfrom collections import deque\n\ndef parse_map_xml(xml_string, ignore_ids):\n    root = ET.fromstring(xml_string)\n    grid = {}\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tile_type = tile.get('type')\n            is_warp = tile.get('is-warp') == 'true'\n            object_element = tile.find('Object')\n            has_object = False\n            is_pikachu = False\n            if object_element is not None:\n                obj_id_str = object_element.get('id')\n                if obj_id_str is not None and obj_id_str.isdigit():\n                    obj_id = int(obj_id_str)\n                    if obj_id not in ignore_ids:\n                        has_object = True\n                        if object_element.get('id-name') == 'Pikachu':\n                            is_pikachu = True\n                else: \n                    has_object = True\n            grid[(x, y)] = {'type': tile_type, 'has_object': has_object, 'is_pikachu': is_pikachu, 'is_warp': is_warp}\n    return grid, width, height\n\ndef is_walkable(tile_data, movement_mode):\n    if not tile_data: return False\n    if tile_data.get('is_warp'): return False\n    walkable_types = ['ground', 'grass', 'steps', 'elevated_ground', 'ladder_up', 'ladder_down', 'hole', 'teleport', 'spinner_stop', 'cuttable', 'open_gate', 'gate_offscreen']\n    surfable_types = ['water']\n    if movement_mode == 'walking':\n        return tile_data.get('type') in walkable_types\n    elif movement_mode == 'surfing':\n        return tile_data.get('type') in surfable_types\n    return False\n\ndef get_neighbors(current_pos, grid, width, height, movement_mode):\n    x, y = current_pos\n    neighbors = []\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nx, ny = x + dx, y + dy\n        if not (1 <= nx <= width and 1 <= ny <= height): continue\n        current_tile_data = grid.get((x, y), {})\n        if current_tile_data.get('type') == 'ledge':\n            if dx == 0 and dy == 1:\n                final_y = ny + 1\n                if 1 <= final_y <= height:\n                    landing_tile_data = grid.get((nx, final_y), {})\n                    if is_walkable(landing_tile_data, movement_mode) and not (landing_tile_data.get('has_object') and not landing_tile_data.get('is_pikachu')):\n                        neighbors.append((nx, final_y))\n            continue\n        next_tile_data = grid.get((nx, ny), {})\n        if is_walkable(next_tile_data, movement_mode) and not (next_tile_data.get('has_object') and not next_tile_data.get('is_pikachu')):\n            neighbors.append((nx, ny))\n    return neighbors\n\ndef find_connected_component(start, grid, width, height, movement_mode):\n    if not is_walkable(grid.get(start), movement_mode):\n        return set()\n    \n    q = deque([start])\n    visited = {start}\n    \n    while q:\n        current_pos = q.popleft()\n        for neighbor in get_neighbors(current_pos, grid, width, height, movement_mode):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                q.append(neighbor)\n    return visited\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef find_path_astar(grid, width, height, start, end, movement_mode):\n    original_end = end\n    \n    # Connectivity Check\n    reachable_tiles = find_connected_component(start, grid, width, height, movement_mode)\n    if end not in reachable_tiles:\n        # Check if any adjacent tiles to the end are reachable\n        is_end_adjacent_reachable = False\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_x, adj_y = original_end[0] + dx, original_end[1] + dy\n            if (adj_x, adj_y) in reachable_tiles:\n                is_end_adjacent_reachable = True\n                break\n        if not is_end_adjacent_reachable:\n            return None # End is in a completely different component\n\n    target_tile_data = grid.get(end)\n    if not target_tile_data or not is_walkable(target_tile_data, movement_mode) or (target_tile_data.get('has_object') and not target_tile_data.get('is_pikachu')):\n        possible_ends = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_x, adj_y = original_end[0] + dx, original_end[1] + dy\n            adj_pos = (adj_x, adj_y)\n            if adj_pos in reachable_tiles: # Only consider ends in the same component\n                adj_tile_data = grid.get(adj_pos)\n                if adj_tile_data and is_walkable(adj_tile_data, movement_mode) and not (adj_tile_data.get('has_object') and not adj_tile_data.get('is_pikachu')):\n                    num_walkable_neighbors = len(get_neighbors(adj_pos, grid, width, height, movement_mode))\n                    is_trap = 1 if num_walkable_neighbors <= 1 and adj_pos != start else 0\n                    dist = heuristic(start, adj_pos)\n                    heapq.heappush(possible_ends, (is_trap, dist, adj_pos))\n        if not possible_ends:\n            return None\n        _, _, end = heapq.heappop(possible_ends)\n\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {pos: float('inf') for pos in grid}\n    g_score[start] = 0\n    f_score = {pos: float('inf') for pos in grid}\n    f_score[start] = heuristic(start, end)\n    while open_set:\n        _, current = heapq.heappop(open_set)\n        if current == end:\n            path = []\n            temp = current\n            while temp in came_from:\n                path.append(temp)\n                temp = came_from[temp]\n            path.append(start)\n            return path[::-1]\n        for neighbor in get_neighbors(current, grid, width, height, movement_mode):\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, end)\n                if neighbor not in [i[1] for i in open_set]:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    movement_mode = input_data['movement_mode']\n    ignore_npc_ids_str = input_data.get('ignore_npc_ids', '')\n    ignore_ids = [int(id_str) for id_str in ignore_npc_ids_str.split(',') if id_str.strip().isdigit()] if ignore_npc_ids_str else []\n    grid, width, height = parse_map_xml(map_xml_string, ignore_ids)\n    path = find_path_astar(grid, width, height, (start_x, start_y), (end_x, end_y), movement_mode)\n    if path:\n        final_path = []\n        for (px, py) in path:\n            final_path.append({'x': str(px), 'y': str(py)})\n        print(json.dumps(final_path))\n    else:\n        print(json.dumps([]))\nexcept Exception as e:\n    import traceback\n    err_msg = f\"Error: {str(e)}, Type: {type(e).__name__}, Traceback: {traceback.format_exc()}\"\n    print(json.dumps([{'error': err_msg}]))"
  },
  "mansion_puzzle_solver": {
    "description": "Analyzes the Pokemon Mansion's gate and switch puzzles. It takes the map XML and identifies switches, gates, and positional triggers to calculate the optimal sequence of actions to explore the entire floor. (v2)",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef parse_map_xml(xml_string):\n    root = ET.fromstring(xml_string)\n    grid, width, height = {}, int(root.get('width')), int(root.get('height'))\n    switches, gates, warps = {}, {}, []\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tile_type = tile.get('type')\n            is_warp = tile.get('is-warp') == 'true'\n            grid[(x, y)] = {'type': tile_type, 'is_warp': is_warp}\n            if is_warp: warps.append((x,y))\n            obj = tile.find('Object')\n            if obj is not None and obj.get('name') and 'Switch' in obj.get('name'):\n                switches[(x, y)] = 'toggle'\n            if 'gate' in tile_type:\n                gates[(x, y)] = tile_type\n    return grid, width, height, switches, gates, warps\n\ndef get_neighbors(pos, width, height):\n    x, y = pos\n    neighbors = []\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nx, ny = x + dx, y + dy\n        if 1 <= nx <= width and 1 <= ny <= height: neighbors.append((nx, ny))\n    return neighbors\n\ndef solve_mansion_2f(grid, width, height, start_pos, target_pos):\n    # Hardcoded logic for Pokemon Mansion 2F (map_id 214)\n    switch_pos = (3, 12)\n    trigger_1_pos = (11, 10)\n    trigger_2_pos = (21, 13)\n    west_gates = [(10, 5), (10, 6)]\n    east_gates = [(19, 9), (20, 9)]\n    south_gates = [(8, 23), (8, 24)] # Hypothetical based on map layout\n\n    # State: (player_pos, west_open, east_open, south_open)\n    q = deque([(start_pos, False, True, False, [])]) # Initial state based on current observation\n    visited = set([(start_pos, False, True, False)])\n\n    while q:\n        pos, w_open, e_open, s_open, path = q.popleft()\n        if pos == target_pos: return path\n        if len(path) > 75: continue\n\n        # Movement\n        for neighbor in get_neighbors(pos, width, height):\n            tile_type = grid[neighbor]['type']\n            is_passable = tile_type in ['ground', 'open_gate']\n            if (neighbor in west_gates and w_open) or (neighbor in east_gates and e_open) or (neighbor in south_gates and s_open):\n                is_passable = True\n            if grid[neighbor].get('is_warp'): is_passable = True\n\n            if is_passable:\n                next_path = path + [neighbor]\n                nw_open, ne_open, ns_open = w_open, e_open, s_open\n                if neighbor == trigger_1_pos:\n                    nw_open, ne_open = False, True\n                if neighbor == trigger_2_pos:\n                    ne_open = True\n                \n                state = (neighbor, nw_open, ne_open, ns_open)\n                if state not in visited:\n                    visited.add(state)\n                    q.append((neighbor, nw_open, ne_open, ns_open, next_path))\n\n        # Switch Interaction (must be adjacent to (3,12) and facing it)\n        if abs(pos[0] - switch_pos[0]) + abs(pos[1] - switch_pos[1]) == 1:\n            next_path = path + [f'PRESS_SWITCH_{switch_pos}']\n            # Rule: Switch toggles the southern gates\n            ns_open_toggled = not s_open\n            state = (pos, w_open, e_open, ns_open_toggled)\n            if state not in visited:\n                visited.add(state)\n                q.append((pos, w_open, e_open, ns_open_toggled, next_path))\n\n    return ['No solution found by v2 solver.']\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    grid, width, height, _, _, _ = parse_map_xml(map_xml_string)\n    solution = solve_mansion_2f(grid, width, height, (start_x, start_y), (target_x, target_y))\n    print(json.dumps(solution))\nexcept Exception as e:\n    import traceback\n    print(json.dumps([f'Error: {str(e)}', traceback.format_exc()]))"
  }
}