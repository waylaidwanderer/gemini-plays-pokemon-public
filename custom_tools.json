{
  "find_path": {
    "description": "Finds the shortest path between two points on the current map using BFS. It avoids walls, ledges, and other known obstacles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef find_path_logic():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.attrib['width'])\n        height = int(root.attrib['height'])\n    except Exception:\n        print(\"Error: Could not parse map XML.\")\n        return\n\n    grid = [['' for _ in range(width)] for _ in range(height)]\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        if 0 <= y < height:\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.attrib['id'])\n                if 0 <= x < width:\n                    grid[y][x] = tile_elem.attrib['type']\n\n    walkable_tiles = ['FLOOR', 'TALL_GRASS', 'FLOOR_HOP_RIGHT_LEDGE', 'FLOOR_HOP_DOWN_LEDGE', 'FLOOR_HOP_DOWN_OR_RIGHT_LEDGE', 'FLOOR_HOP_LEFT_LEDGE', 'FLOOR_HOP_DOWN_OR_LEFT_LEDGE', 'unseen', 'HEADBUTT_TREE', 'CUT_TREE']\n\n    try:\n        start_x, start_y = int(input_data['start_x']), int(input_data['start_y'])\n        end_x, end_y = int(input_data['end_x']), int(input_data['end_y'])\n        start, end = (start_x, start_y), (end_x, end_y)\n    except (KeyError, ValueError):\n        print(\"Error: Invalid input coordinates.\")\n        return\n\n    if not (0 <= start_x < width and 0 <= start_y < height and 0 <= end_x < width and 0 <= end_y < height):\n        print(\"Error: Coordinates are out of bounds.\")\n        return\n\n    if grid[end_y][end_x] not in walkable_tiles and grid[end_y][end_x] != 'unseen':\n        print(f\"Error: End point ({end_x}, {end_y}) is not on a walkable tile.\")\n        return\n\n    queue = deque([(start, [start])])\n    visited = {start}\n\n    while queue:\n        (current_pos, path) = queue.popleft()\n        x, y = current_pos\n\n        if current_pos == end:\n            print(json.dumps(path))\n            return\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = x + dx, y + dy\n            neighbor = (next_x, next_y)\n\n            if 0 <= next_x < width and 0 <= next_y < height and neighbor not in visited:\n                if grid[next_y][next_x] in walkable_tiles:\n                    visited.add(neighbor)\n                    new_path = list(path)\n                    new_path.append(neighbor)\n                    queue.append((neighbor, new_path))\n    \n    print(\"No path found.\")\n\nfind_path_logic()\n"
  }
}