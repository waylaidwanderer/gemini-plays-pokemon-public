{
  "find_adjacent_traversable_tiles": {
    "description": "Takes a target coordinate and finds all adjacent (non-diagonal) tiles that are traversable, returning them as a list of coordinates. This is useful for finding valid spots to stand when trying to interact with an object or NPC.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntry:\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n\n    root = ET.fromstring(map_xml_string)\n    \n    impassable_types = {\n        'WALL', 'VOID', 'WATER', 'BOOKSHELF', 'COUNTER', 'CUT_TREE',\n        'HEADBUTT_TREE', 'MART_SHELF', 'PC', 'PILLAR', 'RADIO', 'TOWN_MAP',\n        'TV', 'WINDOW'\n    }\n\n    grid = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            has_object = tile_elem.find('Object') is not None\n            \n            is_impassable = (tile_type in impassable_types) or has_object\n            grid[(x, y)] = not is_impassable\n\n    adjacent_traversable = []\n    for dx, dy, direction in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n        nx, ny = target_x + dx, target_y + dy\n        neighbor_coord = (nx, ny)\n\n        if grid.get(neighbor_coord, False):\n            adjacent_traversable.append({'x': nx, 'y': ny, 'direction_from_target': direction})\n            \n    print(json.dumps(adjacent_traversable))\n\nexcept Exception as e:\n    print(json.dumps({\"error\": str(e)}))",
    "history": [
      {
        "commit_message": "feat: Create tool to find valid interaction spots. This tool, `find_adjacent_traversable_tiles`, replaces the functionality of the deleted `hypothesis_generator` agent. It deterministically parses the map XML to find all valid, traversable tiles adjacent to a target coordinate. This provides a reliable method for generating testable puzzle hypotheses and directly addresses the system critique regarding the faulty agent.",
        "timestamp": "2025-10-31T11:18:33.232Z",
        "action_counter": 10203
      }
    ]
  },
  "generate_path_plan": {
    "description": "Generates a sequence of coordinates to navigate from the player's current position to a target coordinate.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        },
        "object_locations_json": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\nimport json\nimport sys\n\ndef find_path_to_target_bfs(start_x_str, start_y_str, target_x_str, target_y_str, object_locations_json_str, map_xml_string):\n    start_x, start_y = int(start_x_str), int(start_y_str)\n    target_x, target_y = int(target_x_str), int(target_y_str)\n\n    try:\n        root = ET.fromstring(map_xml_string)\n    except ET.ParseError:\n        print(json.dumps([]))\n        return\n\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    map_id = root.get('id')\n\n    impassable_types = {'WALL', 'WATER', 'COUNTER', 'MART_SHELF', 'PC', 'TV', 'BOOKSHELF', 'RADIO', 'TOWN_MAP', 'WINDOW', 'CUT_TREE', 'HEADBUTT_TREE'}\n    warp_types = {'CAVE', 'DOOR', 'STAIRCASE', 'LADDER', 'WARP_CARPET_DOWN', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT'}\n    ledge_types = {'LEDGE_HOP_DOWN', 'LEDGE_HOP_LEFT', 'LEDGE_HOP_RIGHT'}\n    floor_up_wall_type = 'FLOOR_UP_WALL'\n\n    tile_data = {}\n    for row_elem in root.findall('Row'):\n        y_xml = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x_xml = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            if 1 <= x_xml <= width and 1 <= y_xml <= height:\n                tile_data[(x_xml, y_xml)] = tile_type\n\n    grid = [[1 for _ in range(width)] for _ in range(height)]\n    for y in range(height):\n        for x in range(width):\n            tile_type = tile_data.get((x + 1, y + 1))\n            if tile_type and tile_type not in impassable_types and tile_type not in warp_types:\n                grid[y][x] = 0\n\n    if object_locations_json_str and object_locations_json_str != 'null':\n        try:\n            object_locations = json.loads(object_locations_json_str)\n            if isinstance(object_locations, dict):\n                for obj_id, coords in object_locations.items():\n                    if isinstance(coords, list) and len(coords) == 2:\n                        ox, oy = int(coords[0]), int(coords[1])\n                        if 1 <= ox <= width and 1 <= oy <= height:\n                            grid[oy-1][ox-1] = 1\n        except (json.JSONDecodeError, TypeError): pass\n\n    if not (1 <= start_x <= width and 1 <= start_y <= height and 1 <= target_x <= width and 1 <= target_y <= height):\n        print(json.dumps([]))\n        return\n\n    start_node_0_indexed = (start_x - 1, start_y - 1)\n    target_node_0_indexed = (target_x - 1, target_y - 1)\n\n    queue = collections.deque([[start_node_0_indexed]])\n    visited = {start_node_0_indexed}\n\n    final_target_0_indexed = target_node_0_indexed\n    if grid[target_node_0_indexed[1]][target_node_0_indexed[0]] == 1:\n        adj_tiles = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = target_node_0_indexed[0] + dx, target_node_0_indexed[1] + dy\n            if 0 <= nx < width and 0 <= ny < height and grid[ny][nx] == 0:\n                adj_tiles.append((nx, ny))\n        if not adj_tiles:\n            print(json.dumps([]))\n            return\n        adj_tiles.sort(key=lambda p: (p[0] - start_node_0_indexed[0])**2 + (p[1] - start_node_0_indexed[1])**2)\n        final_target_0_indexed = adj_tiles[0]\n    \n    if start_node_0_indexed == final_target_0_indexed:\n        print(json.dumps([{\"x\": start_x, \"y\": start_y}]))\n        return\n\n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n\n        if (x, y) == final_target_0_indexed:\n            final_path_1_indexed = [{\"x\": px + 1, \"y\": py + 1} for px, py in path]\n            print(json.dumps(final_path_1_indexed))\n            return\n\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = x + dx, y + dy\n            neighbor_0_indexed = (nx, ny)\n\n            if not (0 <= nx < width and 0 <= ny < height) or neighbor_0_indexed in visited or grid[ny][nx] == 1:\n                continue\n\n            current_tile_type = tile_data.get((x + 1, y + 1))\n            neighbor_tile_type = tile_data.get((nx + 1, ny + 1))\n\n            if current_tile_type in ledge_types:\n                if (current_tile_type == 'LEDGE_HOP_DOWN' and dy != 1) or (current_tile_type == 'LEDGE_HOP_LEFT' and dx != -1) or (current_tile_type == 'LEDGE_HOP_RIGHT' and dx != 1):\n                    continue\n            \n            if (neighbor_tile_type == 'LEDGE_HOP_DOWN' and dy == -1) or \\\n               (neighbor_tile_type == 'LEDGE_HOP_LEFT' and dx == 1) or \\\n               (neighbor_tile_type == 'LEDGE_HOP_RIGHT' and dx == -1):\n                continue\n\n            if map_id == '3_37': # Union Cave 1F\n                if (current_tile_type == floor_up_wall_type and dy == -1) or (neighbor_tile_type == floor_up_wall_type and dy == 1):\n                    continue\n            elif map_id in ['10_9', '10_1']: # Route 32\n                 if current_tile_type != floor_up_wall_type and neighbor_tile_type == floor_up_wall_type and dy == 1:\n                     continue\n            elif map_id in ['3_38', '3_78']: # Union Cave B1F, Dark Cave\n                 if current_tile_type != floor_up_wall_type and neighbor_tile_type == floor_up_wall_type and dy == 1:\n                     continue\n\n            visited.add(neighbor_0_indexed)\n            new_path = list(path)\n            new_path.append(neighbor_0_indexed)\n            queue.append(new_path)\n\n    print(json.dumps([]))",
    "history": [
      {
        "commit_message": "feat: Re-create generate_path_plan tool. This commit re-defines the core pathfinding tool after it was deleted. It uses the last known working version of the ledge traversal logic, which is the more verbose, de-consolidated version that was proven to be functional. This addresses the critical need for a reliable navigation tool.",
        "timestamp": "2025-11-02T19:29:49.139Z",
        "action_counter": 15692
      },
      {
        "commit_message": "fix: Overhaul ledge traversal logic. The previous implementation was flawed, incorrectly blocking valid moves and allowing invalid ones. This commit replaces it with two distinct, clearer rules: one to completely forbid moving from a non-ledge to a ledge tile (climbing up), and another to restrict movement from a ledge tile to its specified direction. This correctly models the one-way obstacle behavior and resolves the critical pathfinding failure on Route 29.",
        "timestamp": "2025-11-02T19:32:45.321Z",
        "action_counter": 15696
      },
      {
        "commit_message": "fix: Overhaul ledge traversal logic. The previous implementation was flawed, incorrectly blocking valid moves and allowing invalid ones. This commit replaces it with two distinct, clearer rules: one to completely forbid moving from a non-ledge to a ledge tile (climbing up), and another to restrict movement from a ledge tile to its specified direction. This correctly models the one-way obstacle behavior and resolves the critical pathfinding failure on Route 29.",
        "timestamp": "2025-11-02T19:33:43.977Z",
        "action_counter": 15697
      },
      {
        "commit_message": "revert: Revert ledge logic to a previously working version. The recent consolidated and de-consolidated ledge logic both introduced regressions that prevented pathfinding over ledges. This commit reverts the ledge traversal logic to the older, more verbose version used by the `list_reachable_unseen_tiles` tool, which is known to be functional. This resolves the critical pathing failure.",
        "timestamp": "2025-11-02T19:35:13.413Z",
        "action_counter": 15699
      },
      {
        "commit_message": "fix: Overhaul coordinate system to be consistently 0-indexed internally. The tool was plagued by a recurring bug where it mixed 1-indexed game coordinates with 0-indexed Python grid indices, causing incorrect grid construction and out-of-bounds errors. This commit refactors the entire tool to consistently convert all 1-indexed inputs (start/target, XML data) to a 0-indexed system for all internal logic, then converts the final 0-indexed path back to 1-indexed for the game's path execution. This resolves the critical coordinate system flaw.",
        "timestamp": "2025-11-02T19:36:44.066Z",
        "action_counter": 15701
      },
      {
        "commit_message": "fix: Overhaul grid population and coordinate system logic. The tool was failing due to out-of-bounds errors caused by a brittle grid population method and recurring confusion between 1-indexed and 0-indexed coordinates. This commit refactors the logic to be more robust: it first parses all XML data into a 1-indexed dictionary, then iterates through the 0-indexed grid, safely looking up tile data and converting coordinates. This decouples parsing from grid construction and ensures all coordinate handling is explicit and correct, resolving the critical pathing failures.",
        "timestamp": "2025-11-02T19:43:47.427Z",
        "action_counter": 15706
      }
    ]
  }
}