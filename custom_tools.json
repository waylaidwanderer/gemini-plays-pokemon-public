{
  "pathfinder_tool": {
    "description": "Calculates the shortest path between two points on the current map using the A* algorithm. It avoids obstacles, impassable tiles, and respects one-way traversal rules.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.attrib['width'])\nheight = int(root.attrib['height'])\ngrid = [[0 for _ in range(width + 2)] for _ in range(height + 2)]\n\nimpassable_types = ['WALL', 'WATER', 'HEADBUTT_TREE', 'CUT_TREE', 'VOID']\n\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.attrib['id'])\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.attrib['id'])\n        tile_type = tile_elem.attrib['type']\n        has_object = tile_elem.find('Object') is not None\n        has_tracked_object = False\n        for marker in tile_elem.findall('Marker'):\n            if 'object_id' in marker.attrib:\n                has_tracked_object = True\n                break\n        if tile_type in impassable_types or has_object or has_tracked_object:\n            grid[y][x] = 1\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star(start, end):\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = { (r,c): float('inf') for r in range(height + 2) for c in range(width + 2) }\n    g_score[start] = 0\n    f_score = { (r,c): float('inf') for r in range(height + 2) for c in range(width + 2) }\n    f_score[start] = heuristic(start, end)\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == end:\n            path = []\n            while current in came_from:\n                path.append({'x': current[0], 'y': current[1]})\n                current = came_from[current]\n            path.append({'x': start[0], 'y': start[1]})\n            return path[::-1]\n\n        neighbors = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n\n            if not (0 < neighbor[0] <= width and 0 < neighbor[1] <= height):\n                continue\n\n            if grid[neighbor[1]][neighbor[0]] == 1:\n                continue\n                \n            current_tile_elem = root.find(f\".//Tile[@coordinate='({current[0]}, {current[1]})']\")\n            if current_tile_elem is not None and current_tile_elem.attrib['type'] == 'HOP_DOWN':\n                if dy != 1: \n                    continue\n\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, end)\n                if neighbor not in [i[1] for i in open_set]:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    return []\n\npath = a_star((start_x, start_y), (end_x, end_y))\nprint(path)"
  }
}