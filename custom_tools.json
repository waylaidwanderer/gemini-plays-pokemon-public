{
  "get_reachable_unseen_tiles": {
    "description": "Finds all unseen tiles that are directly adjacent to reachable, passable tiles on the current map. Returns a JSON array of coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef run():\n    try:\n        root = ET.fromstring(map_xml_string)\n        player_pos = None\n        grid = {}\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                if tile.find('Player') is not None:\n                    player_pos = (x, y)\n                grid[(x, y)] = {\n                    'type': tile.attrib['type'],\n                    'seen': tile.attrib['seen'] == 'true',\n                    'has_object': tile.attrib.get('has-object') == 'true',\n                    'is_warp': tile.attrib.get('is-warp') == 'true'\n                }\n        \n        if not player_pos:\n            print(\"Error: Player pos not found.\")\n            return\n\n        passable_types = ['FLOOR', 'TALL_GRASS', 'LONG_GRASS', 'WARP_CARPET', 'WATER', 'ICE', 'LADDER', 'PIT']\n        \n        reachable = set()\n        queue = deque([player_pos])\n        visited = {player_pos}\n\n        while queue:\n            cx, cy = queue.popleft()\n            reachable.add((cx, cy))\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = cx + dx, cy + dy\n                if (nx, ny) in grid and (nx, ny) not in visited:\n                    tile = grid[(nx, ny)]\n                    if tile['seen'] and tile['type'] in passable_types and not tile['has_object'] and not tile['is_warp']:\n                        visited.add((nx, ny))\n                        queue.append((nx, ny))\n\n        unseen_reachable = set()\n        for rx, ry in reachable:\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = rx + dx, ry + dy\n                if (nx, ny) in grid and not grid[(nx, ny)]['seen']:\n                    unseen_reachable.add((nx, ny))\n\n        print(json.dumps(sorted(list(unseen_reachable))))\n    except Exception as e:\n        print(f\"Error: {str(e)}\")\n\nrun()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T06:20:54.963Z",
        "action_counter": 27975
      },
      {
        "commit_message": "Fixed the tool to execute the logic and print the result properly. Removed function wrapping to ensure execution in the harness environment.",
        "timestamp": "2025-12-28T06:21:58.588Z",
        "action_counter": 27977
      },
      {
        "commit_message": "Added 'ICE' and 'WARP_CARPET_DOWN' to passable types for better exploration.",
        "timestamp": "2025-12-28T07:02:21.682Z",
        "action_counter": 28055
      },
      {
        "commit_message": "Updating exploration tool to find reachable unseen tiles.",
        "timestamp": "2025-12-28T09:40:39.023Z",
        "action_counter": 28377
      },
      {
        "commit_message": "Refining exploration tool to accurately identify reachable unseen tiles from the current player position.",
        "timestamp": "2025-12-28T09:41:08.853Z",
        "action_counter": 28378
      }
    ]
  },
  "solve_ice_puzzle_v1_reusable": {
    "description": "Calculates a path through ice sliding tiles using the global map_xml_string. Returns a JSON array of button presses.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "type": "boolean"
        },
        "extra_obstacles": {
          "items": {
            "properties": {
              "x": {
                "type": "integer"
              },
              "y": {
                "type": "integer"
              }
            },
            "required": [
              "x",
              "y"
            ],
            "type": "object"
          },
          "type": "array"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y",
        "autopress_buttons"
      ],
      "type": "object"
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport sys\n\ndef solve():\n    try:\n        input_data = json.loads(sys.argv[1])\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n        extra_obstacles = input_data.get('extra_obstacles', [])\n    except (IndexError, ValueError, KeyError, json.JSONDecodeError):\n        print(json.dumps([]))\n        return\n\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    passable_types = {'FLOOR', 'ICE', 'LADDER', 'WARP', 'STAIRS', 'DOOR', 'CAVE'}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            is_warp = tile.attrib.get('is-warp') == 'true'\n            has_obj = tile.attrib.get('has-object') == 'true'\n            is_passable = t_type in passable_types and not has_obj\n            grid[(x, y)] = {'passable': is_passable, 'type': t_type, 'warp': is_warp}\n            \n    for obs in extra_obstacles:\n        ox, oy = int(obs['x']), int(obs['y'])\n        if (ox, oy) in grid:\n            grid[(ox, oy)]['passable'] = False\n\n    queue = [((start_x, start_y), [])]\n    visited = {(start_x, start_y)}\n    \n    while queue:\n        (curr_x, curr_y), path = queue.pop(0)\n        \n        if (curr_x, curr_y) == (target_x, target_y):\n            print(json.dumps(path))\n            return\n            \n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = curr_x + dx, curr_y + dy\n            if (nx, ny) not in grid or not grid[(nx, ny)]['passable']: continue\n            \n            # Slide\n            sx, sy = curr_x, curr_y\n            while True:\n                tx, ty = sx + dx, sy + dy\n                if (tx, ty) not in grid or not grid[(tx, ty)]['passable']: break\n                \n                sx, sy = tx, ty\n                # Stop if not ICE\n                if grid[(sx, sy)]['type'] != 'ICE': break\n                # Stop if Warp\n                if grid[(sx, sy)]['warp']: break\n            \n            if (sx, sy) not in visited:\n                visited.add((sx, sy))\n                queue.append(((sx, sy), path + [btn]))\n    print(json.dumps([]))\n\nsolve()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T11:43:15.128Z",
        "action_counter": 28591
      },
      {
        "commit_message": "Refined ice puzzle solver to treat warps (pits/ladders) and non-ice tiles as stopping points. Added robust input handling.",
        "timestamp": "2025-12-28T13:00:13.449Z",
        "action_counter": 28714
      },
      {
        "commit_message": "Improved traversability check to include all passable tile types and exclude VOID, WALL, and objects. Refined sliding logic for warps and non-ice tiles.",
        "timestamp": "2025-12-28T13:02:07.116Z",
        "action_counter": 28716
      }
    ]
  },
  "activate_strength_v3": {
    "description": "Activates Strength using GNEISS (5th slot) with a robust reset sequence. Assumes GNEISS is in the 5th party slot.",
    "input_schema": {},
    "python_script": "import json\n\ndef run():\n    buttons = []\n    # Reset to overworld\n    for _ in range(10):\n        buttons.append(\"B\")\n    \n    buttons.append(\"Start\")\n    buttons.append(\"sleep 500\")\n    \n    # Ensure cursor is at the bottom (EXIT)\n    for _ in range(8):\n        buttons.append(\"Down\")\n    \n    # Navigate to POKEMON (Up 6 times from EXIT)\n    # 8: EXIT, 7: OPTION, 6: SAVE, 5: GEM, 4: GEAR, 3: PACK, 2: POKEMON, 1: POKEDEX\n    for _ in range(6):\n        buttons.append(\"Up\")\n    \n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # In POKEMON menu. Assume cursor is at top (Calcifer).\n    # GNEISS is in slot 5.\n    for _ in range(4):\n        buttons.append(\"Down\")\n    \n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # In GNEISS sub-menu. Strength is the first entry.\n    buttons.append(\"A\")\n    buttons.append(\"sleep 1000\")\n    \n    # Close dialogue\n    buttons.append(\"B\")\n    \n    print(json.dumps(buttons))\n\nrun()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T13:48:24.721Z",
        "action_counter": 28773
      },
      {
        "commit_message": "Refined Strength activation with a robust 'reset-to-bottom' sequence for the Start menu.",
        "timestamp": "2025-12-28T13:54:43.403Z",
        "action_counter": 28784
      }
    ]
  },
  "activate_strength_v3_fixed": {
    "description": "Activates Strength using GNEISS (5th slot) with a robust reset sequence. Assumes GNEISS is in the 5th party slot.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "python_script": "import json\n\ndef main():\n    # Robust reset to overworld\n    buttons = [\"B\"] * 10\n    buttons.append(\"Start\")\n    buttons.append(\"sleep 500\")\n    # Navigate to POKEMON (2nd option)\n    buttons.append(\"Down\")\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    # Navigate to 5th slot (GNEISS)\n    buttons.extend([\"Down\"] * 4)\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    # Select Strength (usually first option in sub-menu if usable)\n    buttons.append(\"A\")\n    buttons.append(\"sleep 1000\")\n    # Exit back to overworld\n    buttons.extend([\"B\"] * 3)\n    print(json.dumps(buttons))\n\nif __name__ == \"__main__\":\n    main()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T13:58:50.290Z",
        "action_counter": 28789
      }
    ]
  }
}