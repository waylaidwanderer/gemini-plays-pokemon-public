{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "inventory_navigator_tool": {
    "description": "Calculates the optimal number of button presses (Up/Down) to navigate from a current selection to a target item in a list-based menu. This version correctly handles non-wrapping menus and provides a warning for long scrolls.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory_list": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "current_selection": {
          "type": "string"
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "inventory_list",
        "current_selection",
        "target_item"
      ]
    },
    "python_script": "import json\ntry:\n    inventory = json.loads(input_data['inventory_list'])\n    current_item = input_data['current_selection']\n    target_item = input_data['target_item']\n\n    if current_item not in inventory or target_item not in inventory:\n        print(json.dumps({'error': 'Item not found in inventory list.'}))\n    else:\n        current_idx = inventory.index(current_item)\n        target_idx = inventory.index(target_item)\n        \n        response = {}\n        if current_idx == target_idx:\n            response = {'direction': 'NONE', 'presses': 0}\n        elif target_idx > current_idx:\n            presses = target_idx - current_idx\n            response = {'direction': 'DOWN', 'presses': presses}\n        else: # target_idx < current_idx\n            presses = current_idx - target_idx\n            response = {'direction': 'UP', 'presses': presses}\n\n        if response.get('presses', 0) > 4:\n            response['note'] = 'Warning: This is a long scroll. Press Down in increments of 4 to navigate pages more effectively.'\n        \n        print(json.dumps(response))\nexcept Exception as e:\n    print(json.dumps({'error': str(e), 'type': type(e).__name__}))"
  },
  "check_tile_walkable": {
    "description": "A diagnostic tool to check if a specific tile is walkable and print its properties for debugging.",
    "input_schema": {
      "type": "object",
      "properties": {
        "x": {
          "type": "string"
        },
        "y": {
          "type": "string"
        }
      },
      "required": [
        "x",
        "y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ndef is_walkable(x, y, grid):\n    tile = grid.get((x, y))\n    print(f\"Inside is_walkable: Checking tile ({x}, {y})\")\n    if not tile:\n        print(\"Result: False (Tile not in grid)\")\n        return False\n    tile_type = tile.get('type')\n    if tile_type in ['impassable']:\n        return False\n    return True\n\nmap_xml_string = globals().get('map_xml_string', '')\nif not map_xml_string:\n    print(json.dumps({'error': 'map_xml_string not found'}))\nelse:\n    try:\n        root = ET.fromstring(map_xml_string)\n        grid = {}\n        for row in root.findall('Row'):\n            y_coord = int(row.get('id'))\n            for tile_node in row.findall('Tile'):\n                x_coord = int(tile_node.get('id'))\n                grid[(x_coord, y_coord)] = tile_node\n\n        x_to_check = int(input_data['x'])\n        y_to_check = int(input_data['y'])\n\n        print(f\"Grid populated with {len(grid)} tiles.\")\n        walkable_status = is_walkable(x_to_check, y_to_check, grid)\n        print(f\"Final determination for ({x_to_check}, {y_to_check}): {'Walkable' if walkable_status else 'Not Walkable'}\")\n\n    except Exception as e:\n        print(json.dumps({'error': f'An unexpected error occurred: {e}'}))"
  },
  "pathfinder": {
    "description": "A robust A* pathfinding tool that finds the shortest path between two points on the current map. It correctly handles all known tile types, including impassable objects, ledges, and offscreen gates. This is a computational tool for navigation.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\nimport json\n\ndef find_path(input_data):\n    map_xml_string = globals().get('map_xml_string', '')\n    if not map_xml_string:\n        print(json.dumps({'path': [], 'message': 'map_xml_string not found'}))\n        return\n\n    try:\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n    except (ValueError, KeyError) as e:\n        print(json.dumps({'path': [], 'message': f'Invalid input: {e}'}))\n        return\n\n    try:\n        root = ET.fromstring(map_xml_string)\n        grid = {}\n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                x = int(tile.get('id'))\n                grid[(x, y)] = tile\n    except ET.ParseError as e:\n        print(json.dumps({'path': [], 'message': f'XML Parse Error: {e}'}))\n        return\n\n    def is_walkable(x, y, grid_map):\n        tile = grid_map.get((x, y))\n        if not tile or tile.get('seen') == 'false': return False\n        tile_type = tile.get('type')\n        if tile_type in ['impassable', 'boulder_barrier', 'closed_gate', 'water']:\n            return False\n        obj = tile.find('Object')\n        if obj is not None:\n            if obj.get('id-name') and obj.get('id-name') != 'PIKACHU': return False\n            if obj.get('name') and not obj.get('id-name'): return False\n        return True\n\n    def get_neighbors(x, y, grid_map):\n        neighbors = []\n        current_tile = grid_map.get((x,y))\n        current_tile_type = current_tile.get('type')\n        # Ledge logic\n        if current_tile_type == 'ledge':\n            if is_walkable(x, y + 1, grid_map):\n                neighbors.append(((x, y + 2), 1)) # Ledges move to y+2\n            return neighbors\n        # Standard movement\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            neighbor_tile = grid_map.get((nx, ny))\n            if not neighbor_tile: continue\n            neighbor_tile_type = neighbor_tile.get('type')\n            # Prevent moving up a ledge\n            if neighbor_tile_type == 'ledge' and dy == -1: continue\n            if is_walkable(nx, ny, grid_map):\n                neighbors.append(((nx, ny), 1))\n        return neighbors\n\n    start_node = (start_x, start_y)\n    target_node = (target_x, target_y)\n\n    if not is_walkable(target_x, target_y, grid):\n        found_new_target = False\n        # Find a walkable neighbor of the target\n        temp_neighbors = []\n        for dx_n, dy_n in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx_n, ny_n = target_x + dx_n, target_y + dy_n\n            if is_walkable(nx_n, ny_n, grid):\n                temp_neighbors.append((nx_n, ny_n))\n        if temp_neighbors:\n            target_node = min(temp_neighbors, key=lambda p: (p[0]-start_x)**2 + (p[1]-start_y)**2)\n            found_new_target = True\n        \n        if not found_new_target:\n            print(json.dumps({'path': [], 'message': 'Target and neighbors are unwalkable.'}))\n            return\n\n    open_set = [(0, start_node)]\n    came_from = {}\n    g_score = {node: float('inf') for node in grid}\n    g_score[start_node] = 0\n    f_score = {node: float('inf') for node in grid}\n    f_score[start_node] = abs(start_x - target_node[0]) + abs(start_y - target_node[1])\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n        if current == target_node:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start_node)\n            print(json.dumps({'path': path[::-1]}))\n            return\n        for neighbor, cost in get_neighbors(current[0], current[1], grid):\n            tentative_g_score = g_score[current] + cost\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + abs(neighbor[0] - target_node[0]) + abs(neighbor[1] - target_node[1])\n                if neighbor not in [i[1] for i in open_set]:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    print(json.dumps({'path': [], 'message': 'No path found.'}))\n\nfind_path(input_data)"
  }
}