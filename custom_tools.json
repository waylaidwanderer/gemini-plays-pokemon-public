{
  "marker_compliance_tool": {
    "description": "Parses map markers and checks for compliance with protocols defined in the notepad. Identifies markers with non-standard emojis or incorrect label formats.",
    "input_schema": {
      "type": "object",
      "properties": {
        "notepad_contents": {
          "type": "string"
        }
      },
      "required": [
        "notepad_contents"
      ]
    },
    "python_script": "import json\nimport re\n\ndef check_marker_compliance():\n    notepad_content = input_data['notepad_contents']\n    \n    protocol_emojis = []\n    teleporter_format_regex_str = ''\n\n    try:\n        protocol_line = \"\"\n        for line in notepad_content.splitlines():\n            if \"CRITICAL: Map Marker Protocol\" in line:\n                protocol_line = line\n                break\n        \n        if not protocol_line:\n            print(json.dumps({'error': 'Map Marker Protocol line not found in notepad.'}))\n            return\n\n        teleporter_format_regex_str = r\"ðŸšª Warp to/from \\(\\d+, \\d+\\) \\[(?:Bi-directional|One-way)\\]\"\n        teleporter_format_regex = re.compile(teleporter_format_regex_str)\n        protocol_emojis = re.findall(r\"'([^']*)'\", protocol_line)\n\n    except Exception as e:\n        print(json.dumps({'error': f'Failed to parse protocols from notepad: {e}'}))\n        return\n\n    non_compliant_markers = []\n    try:\n        tiles = map_xml_string.split('</Tile>')\n        for tile_str in tiles:\n            if '<Marker' in tile_str:\n                try:\n                    coord_match = re.search(r'coordinate=\"\\((\\d+), (\\d+)\\)\"', tile_str)\n                    if not coord_match: continue\n                    x, y = int(coord_match.group(1)), int(coord_match.group(2))\n                except (ValueError, IndexError):\n                    continue\n\n                marker_parts = tile_str.split('<Marker emoji=\"')\n                for part in marker_parts[1:]:\n                    try:\n                        emoji = part.split('\"')[0]\n                        label = part.split('>')[1].split('</Marker>')[0]\n                        \n                        is_compliant = False\n                        if emoji in protocol_emojis:\n                            if emoji == 'ðŸšª':\n                                if teleporter_format_regex.fullmatch(f\"{emoji} {label}\"):\n                                    is_compliant = True\n                            else:\n                                is_compliant = True\n                        \n                        if not is_compliant:\n                            non_compliant_markers.append({\n                                \"x\": x,\n                                \"y\": y,\n                                \"emoji\": emoji,\n                                \"label\": label,\n                                \"reason\": f\"Emoji '{emoji}' not in protocol or label format for 'ðŸšª' is incorrect.\"\n                            })\n                    except IndexError:\n                        continue\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': f'Error during XML parsing: {str(e)}', 'traceback': traceback.format_exc()}))\n        return\n        \n    print(json.dumps(non_compliant_markers))\n\ncheck_marker_compliance()"
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map using the A* algorithm. REFINED: Now uses a more robust parsing logic that builds a set of walkable tiles and ledges to prevent pathing into impassable terrain. Correctly handles ledges and treats Pikachu as walkable.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import heapq\nimport json\nimport xml.etree.ElementTree as ET\n\ndef a_star_search(grid_data, start, end):\n    walkable, ledges = grid_data\n    if end not in walkable:\n        walkable_neighbors = [\n            p for dx, dy in [(0, -1), (0,1), (-1, 0), (1, 0)] \n            if (p := (end[0] + dx, end[1] + dy)) in walkable\n        ]\n        if not walkable_neighbors:\n            return None, f'End point {end} is not walkable and has no walkable neighbors.'\n        end = min(walkable_neighbors, key=lambda pos: abs(start[0] - pos[0]) + abs(start[1] - pos[1]))\n\n    open_set = [(0, start)]\n    came_from = {}\n    g_score = {pos: float('inf') for pos in walkable}\n    g_score[start] = 0\n    f_score = {pos: float('inf') for pos in walkable}\n    f_score[start] = abs(start[0] - end[0]) + abs(start[1] - end[1])\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == end:\n            path = [current]\n            while current in came_from:\n                current = came_from[current]\n                path.append(current)\n            return path[::-1], 'Path found.'\n\n        # Standard Neighbors\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            \n            if current in ledges and dy == 1: # Moving down from a ledge\n                ledge_jump_target = (current[0], current[1] + 1)\n                if ledge_jump_target in walkable:\n                    tentative_g_score = g_score[current] + 1\n                    if tentative_g_score < g_score.get(ledge_jump_target, float('inf')):\n                        came_from[ledge_jump_target] = current\n                        g_score[ledge_jump_target] = tentative_g_score\n                        f_score[ledge_jump_target] = tentative_g_score + (abs(ledge_jump_target[0] - end[0]) + abs(ledge_jump_target[1] - end[1]))\n                        heapq.heappush(open_set, (f_score[ledge_jump_target], ledge_jump_target))\n                continue\n            \n            if neighbor in walkable:\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = tentative_g_score + (abs(neighbor[0] - end[0]) + abs(neighbor[1] - end[1]))\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    return None, 'No path found to destination.'\n\ndef parse_map_to_grid(xml_str):\n    walkable_tiles = set()\n    ledge_tiles = set()\n    try:\n        root = ET.fromstring(xml_str)\n        for row in root.findall('Row'):\n            for tile in row.findall('Tile'):\n                coord_str = tile.get('coordinate')\n                x_str, y_str = coord_str.strip('()').split(',')\n                x, y = int(x_str), int(y_str)\n                tile_type = tile.get('type')\n                \n                has_impassable_object = False\n                obj_element = tile.find('Object')\n                if obj_element is not None:\n                    id_name = obj_element.get('id-name')\n                    if id_name != \"Pikachu\":\n                        has_impassable_object = True\n\n                impassable_types = ['impassable', 'unknown', 'closed_gate', 'water']\n                \n                if tile_type not in impassable_types and not has_impassable_object:\n                    walkable_tiles.add((x, y))\n                \n                if tile_type == 'ledge':\n                    ledge_tiles.add((x,y))\n\n    except (ET.ParseError, ValueError, IndexError, AttributeError) as e:\n        return None, f\"Error parsing map XML: {e}\"\n        \n    return (walkable_tiles, ledge_tiles), None\n\nstart_pos = (int(input_data['start_x']), int(input_data['start_y']))\nend_pos = (int(input_data['end_x']), int(input_data['end_y']))\n\ngrid_data, error_msg = parse_map_to_grid(map_xml_string)\n\nif error_msg:\n    print(json.dumps({'error': error_msg}))\nelse:\n    path_coords, msg = a_star_search(grid_data, start_pos, end_pos)\n    if path_coords:\n        print(json.dumps([{'x': x, 'y': y} for x, y in path_coords]))\n    else:\n        print(json.dumps({'error': msg}))"
  },
  "systematic_searcher": {
    "description": "Calculates the next reachable, untested tile to check in a systematic sweep. It parses the map XML to find all walkable tiles and uses BFS to find the nearest target.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "tested_coords_json": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "tested_coords_json"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef parse_map(xml_str):\n    walkable = set()\n    impassable = set()\n    root = ET.fromstring(xml_str)\n    for row in root.findall('Row'):\n        for tile in row.findall('Tile'):\n            coord_str = tile.get('coordinate')\n            x_str, y_str = coord_str.strip('()').split(',')\n            x, y = int(x_str), int(y_str)\n            tile_type = tile.get('type')\n            has_obj = tile.find('Object') is not None and tile.find('Object').get('id-name') != 'Pikachu'\n            if tile_type in ['impassable', 'unknown', 'closed_gate'] or has_obj:\n                impassable.add((x, y))\n            else:\n                walkable.add((x, y))\n    return walkable, impassable\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\ntested_coords = set(tuple(c) for c in json.loads(input_data['tested_coords_json']))\n\nwalkable, impassable = parse_map(map_xml_string)\n\nqueue = deque([((start_x, start_y), [])])\nvisited = set([(start_x, start_y)])\n\nwhile queue:\n    (x, y), path = queue.popleft()\n\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n        adj_x, adj_y = x + dx, y + dy\n        if (adj_x, adj_y) in impassable and (adj_x, adj_y) not in tested_coords:\n            print(json.dumps({'target_x': x, 'target_y': y, 'wall_x': adj_x, 'wall_y': adj_y}))\n            exit()\n\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n        next_x, next_y = x + dx, y + dy\n        if (next_x, next_y) in walkable and (next_x, next_y) not in visited:\n            visited.add((next_x, next_y))\n            new_path = list(path)\n            new_path.append((next_x, next_y))\n            queue.append(((next_x, next_y), new_path))\n\nprint(json.dumps({'error': 'No new adjacent walls to test.'}))"
  },
  "find_next_exploration_target": {
    "description": "Analyzes unseen tiles and reachable barriers to suggest the most logical next exploration target. Prioritizes the closest unseen tile. If none exist, it finds the closest reachable barrier based on Manhattan distance from the player's current coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "unseen_tiles_json": {
          "type": "string"
        },
        "reachable_barriers_json": {
          "type": "string"
        },
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "unseen_tiles_json",
        "reachable_barriers_json",
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import json\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nunseen_tiles = json.loads(input_data['unseen_tiles_json'])\nreachable_barriers = json.loads(input_data['reachable_barriers_json'])\n\nstart_pos = (start_x, start_y)\nnext_target = None\nmin_dist = float('inf')\nreasoning = ''\n\nif unseen_tiles:\n    for tile in unseen_tiles:\n        dist = heuristic(start_pos, (tile['x'], tile['y']))\n        if dist < min_dist:\n            min_dist = dist\n            next_target = tile\n    if next_target:\n        reasoning = f'The closest unseen tile is at ({next_target[\"x\"]}, {next_target[\"y\"]}) with a distance of {min_dist}.'\n    else:\n        reasoning = 'No unseen tiles found.'\nelif reachable_barriers:\n    for barrier in reachable_barriers:\n        dist = heuristic(start_pos, (barrier['x'], barrier['y']))\n        if dist < min_dist:\n            min_dist = dist\n            next_target = barrier\n    if next_target:\n        reasoning = f'No unseen tiles. The closest reachable barrier is at ({next_target[\"x\"]}, {next_target[\"y\"]}) with a distance of {min_dist}.'\n    else:\n        reasoning = 'No reachable barriers found.'\nelse:\n    reasoning = 'No unseen tiles or reachable barriers to suggest.'\n\nif next_target:\n    print(json.dumps({'next_target_x': next_target['x'], 'next_target_y': next_target['y'], 'reasoning': reasoning}))\nelse:\n    print(json.dumps({'next_target_x': None, 'next_target_y': None, 'reasoning': reasoning}))"
  },
  "gate_navigator": {
    "description": "Calculates the shortest path to an adjacent, walkable tile of a specified gate. Useful for navigating to gates that are visually open but still marked as 'closed_gate' in the map data.",
    "input_schema": {
      "type": "object",
      "properties": {
        "gate_x": {
          "type": "string"
        },
        "gate_y": {
          "type": "string"
        }
      },
      "required": [
        "gate_x",
        "gate_y"
      ]
    },
    "python_script": "import heapq\nimport json\nimport xml.etree.ElementTree as ET\n\ndef parse_map_for_nav(xml_str):\n    grid = {}\n    player_pos = None\n    try:\n        root = ET.fromstring(xml_str)\n        for row in root.findall('Row'):\n            for tile in row.findall('Tile'):\n                coord_str = tile.get('coordinate')\n                x_str, y_str = coord_str.strip('()').split(',')\n                x, y = int(x_str), int(y_str)\n                tile_type = tile.get('type')\n                if tile.find('Player') is not None:\n                    player_pos = (x, y)\n                obj_element = tile.find('Object')\n                is_pikachu = False\n                if obj_element is not None and obj_element.get('id-name') == 'Pikachu':\n                    is_pikachu = True\n                has_object = obj_element is not None\n                impassable_types = ['impassable', 'unknown', 'closed_gate', 'water']\n                is_impassable = tile_type in impassable_types or (has_object and not is_pikachu)\n                grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n    except Exception as e:\n        return None, None, f'XML Parse Error: {e}'\n    return grid, player_pos, None\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(grid, start, end):\n    open_set = [(0, start)]\n    came_from = {}\n    g_score = {pos: float('inf') for pos in grid}\n    g_score[start] = 0\n    f_score = {pos: float('inf') for pos in grid}\n    f_score[start] = heuristic(start, end)\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n        if current == end:\n            path = [current]\n            while current in came_from:\n                current = came_from[current]\n                path.append(current)\n            return path[::-1], 'Path found.'\n        \n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if neighbor in grid and not grid[neighbor]['impassable']:\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, end)\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    return None, 'No path found.'\n\ntry:\n    gate_x = int(input_data['gate_x'])\n    gate_y = int(input_data['gate_y'])\n    gate_pos = (gate_x, gate_y)\n\n    game_map, start_pos, error_msg = parse_map_for_nav(map_xml_string)\n\n    if error_msg:\n        print(json.dumps({'error': error_msg}))\n    elif not start_pos:\n        print(json.dumps({'error': 'Player start position not found in map data.'}))\n    else:\n        walkable_neighbors = []\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            neighbor = (gate_pos[0] + dx, gate_pos[1] + dy)\n            if neighbor in game_map and not game_map[neighbor]['impassable']:\n                walkable_neighbors.append(neighbor)\n        \n        if not walkable_neighbors:\n            print(json.dumps({'error': f'Gate at {gate_pos} has no walkable neighbors.'}))\n        else:\n            target_pos = min(walkable_neighbors, key=lambda pos: heuristic(start_pos, pos))\n            path_coords, msg = a_star_search(game_map, start_pos, target_pos)\n            if path_coords:\n                print(json.dumps([{'x': x, 'y': y} for x, y in path_coords]))\n            else:\n                print(json.dumps({'error': msg}))\nexcept Exception as e:\n    print(json.dumps({'error': f'An unexpected error occurred: {e}'}))"
  }
}