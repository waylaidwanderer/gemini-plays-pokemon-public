{
  "marker_compliance_tool": {
    "description": "Parses map markers and checks for compliance with protocols defined in the notepad. Identifies markers with non-standard emojis or incorrect label formats.",
    "input_schema": {
      "type": "object",
      "properties": {
        "notepad_contents": {
          "type": "string"
        }
      },
      "required": [
        "notepad_contents"
      ]
    },
    "python_script": "import json\nimport re\n\ndef check_marker_compliance():\n    notepad_content = input_data['notepad_contents']\n    \n    protocol_emojis = []\n    teleporter_format_regex_str = ''\n\n    try:\n        protocol_line = \"\"\n        for line in notepad_content.splitlines():\n            if \"CRITICAL: Map Marker Protocol\" in line:\n                protocol_line = line\n                break\n        \n        if not protocol_line:\n            print(json.dumps({'error': 'Map Marker Protocol line not found in notepad.'}))\n            return\n\n        teleporter_format_regex_str = r\"ðŸšª Warp to/from \\(\\d+, \\d+\\) \\[(?:Bi-directional|One-way)\\]\"\n        teleporter_format_regex = re.compile(teleporter_format_regex_str)\n        protocol_emojis = re.findall(r\"'([^']*)'\", protocol_line)\n\n    except Exception as e:\n        print(json.dumps({'error': f'Failed to parse protocols from notepad: {e}'}))\n        return\n\n    non_compliant_markers = []\n    try:\n        tiles = map_xml_string.split('</Tile>')\n        for tile_str in tiles:\n            if '<Marker' in tile_str:\n                try:\n                    coord_match = re.search(r'coordinate=\"\\((\\d+), (\\d+)\\)\"', tile_str)\n                    if not coord_match: continue\n                    x, y = int(coord_match.group(1)), int(coord_match.group(2))\n                except (ValueError, IndexError):\n                    continue\n\n                marker_parts = tile_str.split('<Marker emoji=\"')\n                for part in marker_parts[1:]:\n                    try:\n                        emoji = part.split('\"')[0]\n                        label = part.split('>')[1].split('</Marker>')[0]\n                        \n                        is_compliant = False\n                        if emoji in protocol_emojis:\n                            if emoji == 'ðŸšª':\n                                if teleporter_format_regex.fullmatch(f\"{emoji} {label}\"):\n                                    is_compliant = True\n                            else:\n                                is_compliant = True\n                        \n                        if not is_compliant:\n                            non_compliant_markers.append({\n                                \"x\": x,\n                                \"y\": y,\n                                \"emoji\": emoji,\n                                \"label\": label,\n                                \"reason\": f\"Emoji '{emoji}' not in protocol or label format for 'ðŸšª' is incorrect.\"\n                            })\n                    except IndexError:\n                        continue\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': f'Error during XML parsing: {str(e)}', 'traceback': traceback.format_exc()}))\n        return\n        \n    print(json.dumps(non_compliant_markers))\n\ncheck_marker_compliance()"
  },
  "maze_solver_tool": {
    "description": "Calculates the shortest path through a maze, including warps. It takes start and end coordinates and returns a sequence of button presses.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import collections\n\ndef parse_map_xml(xml_string):\n    impassable_tiles = set()\n    warps = {}\n    width, height = 0, 0\n\n    lines = xml_string.strip().split('\\n')\n    for line in lines:\n        line = line.strip()\n        if line.startswith('<Map '):\n            parts = line.split(' ')\n            for part in parts:\n                if part.startswith('width='):\n                    width = int(part.split('\"')[1])\n                elif part.startswith('height='):\n                    height = int(part.split('\"')[1])\n        elif line.startswith('<Tile '):\n            parts = line.split(' ')\n            x, y, tile_type = 0, 0, ''\n            is_warp = False\n            for part in parts:\n                if part.startswith('id='):\n                    x = int(part.split('\"')[1])\n                elif part.startswith('coordinate='):\n                    coord_str = part.split('\"')[1].strip('()')\n                    x_str, y_str = coord_str.split(', ')\n                    x, y = int(x_str), int(y_str)\n                elif part.startswith('type='):\n                    tile_type = part.split('\"')[1]\n                elif part.startswith('is-warp='):\n                    is_warp = part.split('\"')[1] == 'true'\n            \n            if tile_type in ['impassable', 'unknown']:\n                impassable_tiles.add((x, y))\n            \n            if is_warp:\n                # This is a simplified placeholder. A real implementation\n                # would need to parse the destination from within the <Tile> tag.\n                # For now, we'll assume a fixed destination for demonstration.\n                # In a real scenario, you would need to parse the <Warp> child element.\n                pass # Simplified for now\n\n    return impassable_tiles, warps, width, height\n\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nimpassable, warps, width, height = parse_map_xml(map_xml_string)\n\nqueue = collections.deque([((start_x, start_y), [])])\nvisited = { (start_x, start_y) }\n\npath_found = False\nwhile queue:\n    (x, y), path = queue.popleft()\n\n    if (x, y) == (end_x, end_y):\n        print(f\"Path found: {path}\")\n        path_found = True\n        break\n\n    # Check warps\n    if (x, y) in warps:\n        warp_dest = warps[(x, y)]\n        if warp_dest not in visited:\n            visited.add(warp_dest)\n            queue.append((warp_dest, path + [\"Warp\"]))\n\n    # Check neighbors\n    for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n        nx, ny = x + dx, y + dy\n        if 1 <= nx <= width and 1 <= ny <= height and (nx, ny) not in impassable and (nx, ny) not in visited:\n            visited.add((nx, ny))\n            queue.append(((nx, ny), path + [move]))\n\nif not path_found:\n    print(\"No path found.\")\n"
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map using the A* algorithm. It correctly handles ledges (one-way traversal), can path to the nearest walkable tile if the destination is blocked, and correctly treats Pikachu as a walkable object. REFINED: Now outputs a JSON array of coordinate dictionaries for the path plan. REFINED AGAIN: Now correctly handles water tiles as impassable. REFINED A THIRD TIME: Removed dependency on the xml.et module for more robust parsing. REFINED A FOURTH TIME: Added detailed error logging to the manual parser to debug parsing failures. REFINED A FIFTH TIME: Added even more robust parsing logic to prevent future failures. REFINED A SIXTH TIME: Switched to a more reliable regex-based XML parser.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import heapq\nimport json\nimport re\n\ndef parse_map_with_regex(xml_str):\n    grid = {}\n    error_log = []\n    try:\n        tile_pattern = re.compile(r'<Tile id=\"\\d+\" coordinate=\"\\((\\d+), (\\d+)\\)\" type=\"(\\w+)\"(.*?)>')\n        matches = tile_pattern.finditer(xml_str)\n        for match in matches:\n            try:\n                x, y, tile_type, attributes = int(match.group(1)), int(match.group(2)), match.group(3), match.group(4)\n                has_object = 'has-object=\"true\"' in attributes\n                is_pikachu = 'id-name=\"Pikachu\"' in attributes\n                impassable_types = ['impassable', 'unknown', 'closed_gate', 'water']\n                is_impassable = tile_type in impassable_types or (has_object and not is_pikachu)\n                grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n            except (ValueError, IndexError) as e:\n                error_log.append(f'Error processing tile: {match.group(0)}, Error: {e}')\n    except Exception as e:\n        error_log.append(f'General regex error: {e}')\n        return None, error_log\n    if not grid:\n        error_log.append('Regex parser found no tiles.')\n    return grid, error_log\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef get_neighbors(grid, node):\n    neighbors = []\n    x, y = node\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n        nx, ny = x + dx, y + dy\n        neighbor_pos = (nx, ny)\n        if neighbor_pos in grid:\n            tile_data = grid[neighbor_pos]\n            if tile_data['type'] == 'ledge' and dy == 1 and y < ny:\n                landing_pos = (nx, ny + 1)\n                if landing_pos in grid and not grid[landing_pos].get('impassable', True):\n                    neighbors.append((landing_pos, 1))\n                continue\n            if not tile_data.get('impassable', True):\n                neighbors.append((neighbor_pos, 1))\n    return neighbors\n\ndef a_star_search(grid, start, end):\n    if not grid: return None\n    if grid.get(end, {}).get('impassable', True):\n        walkable_neighbors = [p for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)] if (p := (end[0] + dx, end[1] + dy)) in grid and not grid[p].get('impassable', True)]\n        if not walkable_neighbors: return None\n        end = min(walkable_neighbors, key=lambda pos: heuristic(start, pos))\n\n    open_set = [(0, start)]\n    came_from = {}\n    g_score = {pos: float('inf') for pos in grid}\n    if start not in g_score: return None\n    g_score[start] = 0\n    f_score = {pos: float('inf') for pos in grid}\n    f_score[start] = heuristic(start, end)\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n        if current == end:\n            path = [current]\n            while current in came_from:\n                current = came_from[current]\n                path.append(current)\n            return path[::-1]\n        for neighbor, cost in get_neighbors(grid, current):\n            tentative_g_score = g_score[current] + cost\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, end)\n                heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    return None\n\nstart_pos = (int(input_data['start_x']), int(input_data['start_y']))\nend_pos = (int(input_data['end_x']), int(input_data['end_y']))\ngame_map, errors = parse_map_with_regex(map_xml_string)\n\nif not game_map:\n    print(json.dumps({'error': 'Map parsing failed', 'log': errors}))\nelse:\n    path_coords = a_star_search(game_map, start_pos, end_pos)\n    if path_coords:\n        print(json.dumps([{'x': x, 'y': y} for x, y in path_coords]))\n    else:\n        print(json.dumps([]))"
  },
  "systematic_searcher": {
    "description": "Calculates the next reachable, untested tile to check in a systematic sweep. It parses the map XML to find all walkable tiles and uses BFS to find the nearest target. REFINED: Now correctly handles tested coordinates to avoid re-testing.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "tested_coords_json": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "tested_coords_json"
      ]
    },
    "python_script": "import json\nimport re\nfrom collections import deque\n\ndef parse_map_with_regex(xml_str):\n    grid = {}\n    try:\n        tile_pattern = re.compile(r'<Tile id=\"\\d+\" coordinate=\"\\((\\d+), (\\d+)\\)\" type=\"(\\w+)\"(.*?)>')\n        matches = tile_pattern.finditer(xml_str)\n        for match in matches:\n            x, y, tile_type, attributes = int(match.group(1)), int(match.group(2)), match.group(3), match.group(4)\n            has_object = 'has-object=\"true\"' in attributes\n            is_pikachu = 'id-name=\"Pikachu\"' in attributes\n            impassable_types = ['impassable', 'unknown', 'closed_gate', 'water']\n            is_impassable = tile_type in impassable_types or (has_object and not is_pikachu)\n            grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n    except Exception:\n        return None\n    return grid\n\n# --- Input Processing ---\nstart_pos = (int(input_data['start_x']), int(input_data['start_y']))\ntested_coords_data = json.loads(input_data['tested_coords_json'])\ntested_coords = set((item['x'], item['y']) for item in tested_coords_data)\n\n# --- Map Analysis ---\ngame_map = parse_map_with_regex(map_xml_string)\nif not game_map:\n    print(json.dumps(None))\nelse:\n    walkable_tiles = {pos for pos, data in game_map.items() if not data['impassable']}\n    # Ensure the starting position is considered 'tested' for the search\n    # This prevents the tool from suggesting the player's current tile.\n    all_tested_coords = tested_coords.union({start_pos})\n    untested_tiles = walkable_tiles - all_tested_coords\n\n    if not untested_tiles:\n        print(json.dumps(None))\n    else:\n        # --- Pathfinding (BFS) ---\n        queue = deque([(start_pos, [])])\n        visited = {start_pos}\n        target_found = None\n\n        while queue:\n            current_pos, path = queue.popleft()\n            # Systematic neighbor check order: Up, Down, Left, Right\n            for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n                if next_pos in walkable_tiles and next_pos not in visited:\n                    visited.add(next_pos)\n                    # If a reachable neighbor is untested, we found our target\n                    if next_pos in untested_tiles:\n                        target_found = next_pos\n                        break\n                    queue.append((next_pos, path + [next_pos]))\n            if target_found:\n                break\n        \n        # --- Output ---\n        if target_found:\n            print(json.dumps({'x': target_found[0], 'y': target_found[1]}))\n        else:\n            # Fallback for disconnected areas: find the geometrically closest untested tile.\n            if untested_tiles:\n                closest_untested = min(untested_tiles, key=lambda t: abs(t[0] - start_pos[0]) + abs(t[1] - start_pos[1]))\n                print(json.dumps({'x': closest_untested[0], 'y': closest_untested[1]}))\n            else:\n                print(json.dumps(None))"
  },
  "find_next_exploration_target": {
    "description": "Analyzes unseen tiles and reachable barriers to suggest the most logical next exploration target. Prioritizes the closest unseen tile. If none exist, it finds the closest reachable barrier based on Manhattan distance from the player's current coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "unseen_tiles_json": {
          "type": "string"
        },
        "reachable_barriers_json": {
          "type": "string"
        },
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "unseen_tiles_json",
        "reachable_barriers_json",
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import json\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nunseen_tiles = json.loads(input_data['unseen_tiles_json'])\nreachable_barriers = json.loads(input_data['reachable_barriers_json'])\n\nstart_pos = (start_x, start_y)\nnext_target = None\nmin_dist = float('inf')\nreasoning = ''\n\nif unseen_tiles:\n    for tile in unseen_tiles:\n        dist = heuristic(start_pos, (tile['x'], tile['y']))\n        if dist < min_dist:\n            min_dist = dist\n            next_target = tile\n    if next_target:\n        reasoning = f'The closest unseen tile is at ({next_target[\"x\"]}, {next_target[\"y\"]}) with a distance of {min_dist}.'\n    else:\n        reasoning = 'No unseen tiles found.'\nelif reachable_barriers:\n    for barrier in reachable_barriers:\n        dist = heuristic(start_pos, (barrier['x'], barrier['y']))\n        if dist < min_dist:\n            min_dist = dist\n            next_target = barrier\n    if next_target:\n        reasoning = f'No unseen tiles. The closest reachable barrier is at ({next_target[\"x\"]}, {next_target[\"y\"]}) with a distance of {min_dist}.'\n    else:\n        reasoning = 'No reachable barriers found.'\nelse:\n    reasoning = 'No unseen tiles or reachable barriers to suggest.'\n\nif next_target:\n    print(json.dumps({'next_target_x': next_target['x'], 'next_target_y': next_target['y'], 'reasoning': reasoning}))\nelse:\n    print(json.dumps({'next_target_x': None, 'next_target_y': None, 'reasoning': reasoning}))"
  }
}