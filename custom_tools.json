{
  "route_finder": {
    "description": "Finds a path between two maps using the World Knowledge Graph.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_map_id": {
          "type": "string"
        },
        "end_map_id": {
          "type": "string"
        }
      },
      "required": [
        "start_map_id",
        "end_map_id"
      ]
    },
    "python_script": "import json\nimport heapq\nfrom collections import defaultdict\nimport itertools\n\nworld_knowledge = json.loads(world_knowledge_graph_json_string)\nnodes = world_knowledge['nodes']\nedges = world_knowledge['edges']\n\nstart_map = input_data['start_map_id']\nend_map = input_data['end_map_id']\n\ngraph = defaultdict(list)\n\n# Add explicit edges from the knowledge graph\nfor edge in edges:\n    if edge['source_node_id'] and edge['destination_node_id']:\n        graph[edge['source_node_id']].append(edge['destination_node_id'])\n        if not edge.get('is_one_way', False):\n            graph[edge['destination_node_id']].append(edge['source_node_id'])\n\n# Group nodes by map_id\nnodes_by_map = defaultdict(list)\nfor node in nodes:\n    nodes_by_map[node['map_id']].append(node['id'])\n\n# Add implicit intra-map edges\nfor map_id, map_nodes in nodes_by_map.items():\n    if len(map_nodes) > 1:\n        for u, v in itertools.combinations(map_nodes, 2):\n            graph[u].append(v)\n            graph[v].append(u)\n\nstart_node_ids = nodes_by_map.get(start_map, [])\n\nif not start_node_ids:\n    print(f'Start node for map {start_map} not found in World Knowledge Graph.')\n    exit()\n\n# Dijkstra's algorithm to find the shortest path\nqueue = [(0, start_node_id, [start_node_id]) for start_node_id in start_node_ids]\nvisited = set()\n\nwhile queue:\n    cost, current_node_id, path = heapq.heappop(queue)\n\n    if current_node_id in visited:\n        continue\n    visited.add(current_node_id)\n\n    current_map_id = next((n['map_id'] for n in nodes if n['id'] == current_node_id), None)\n    if current_map_id == end_map:\n        path_details = []\n        for node_id in path:\n            node_info = next((n for n in nodes if n['id'] == node_id), None)\n            if node_info:\n                path_details.append(f\"{node_info['name']} ({node_info['map_id']})\")\n        print(' -> '.join(path_details))\n        exit()\n\n    for neighbor_id in graph[current_node_id]:\n        if neighbor_id not in visited:\n            new_path = path + [neighbor_id]\n            heapq.heappush(queue, (cost + 1, neighbor_id, new_path))\n\nprint(f'No path found from map {start_map} to {end_map}.')"
  },
  "path_finder_plus": {
    "description": "A more advanced pathfinder that can temporarily stun a moving NPC to navigate around them.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "npc_to_stun_id": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\nimport json\n\nclass Node:\n    def __init__(self, parent=None, position=None):\n        self.parent = parent\n        self.position = position\n        self.g = 0\n        self.h = 0\n        self.f = 0\n\n    def __eq__(self, other):\n        return self.position == other.position\n\n    def __lt__(self, other):\n        return self.f < other.f\n\n    def __hash__(self):\n        return hash(self.position)\n\ndef get_path(grid_data, start, end, on_screen_objects):\n    impassable_tiles = {'WALL', 'VOID', 'WATER', 'CUT_TREE', 'COUNTER', 'BUOY', 'HEADBUTT_TREE', 'MART_SHELF'}\n    start_node = Node(None, start)\n    end_node = Node(None, end)\n    open_list = []\n    closed_set = set()\n    heapq.heappush(open_list, (start_node.f, start_node))\n\n    while open_list:\n        _, current_node = heapq.heappop(open_list)\n\n        if current_node.position in closed_set:\n            continue\n        closed_set.add(current_node.position)\n\n        if current_node == end_node:\n            path = []\n            current = current_node\n            while current is not None:\n                path.append(list(current.position))\n                current = current.parent\n            return path[::-1]\n\n        children = []\n        for move_offset in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            node_position = (current_node.position[0] + move_offset[0], current_node.position[1] + move_offset[1])\n            if node_position not in grid_data:\n                continue\n\n            tile_info = grid_data[node_position]\n            current_tile_info = grid_data[current_node.position]\n            \n            if tile_info['type'] in impassable_tiles:\n                continue\n\n            if node_position in on_screen_objects and node_position != end:\n                continue\n\n            if move_offset == (0, -1) and tile_info['type'] in ('LEDGE', 'FLOOR_ALLOW_HOP_DOWN', 'FLOOR_ALLOW_HOP_DOWN_OR_RIGHT'): continue\n            if move_offset == (0, -1) and current_tile_info['type'] == 'FLOOR_UP_WALL': continue\n            if move_offset == (0, 1) and tile_info['type'] == 'FLOOR_UP_WALL': continue\n            if move_offset == (-1, 0) and tile_info['type'] in ('FLOOR_ALLOW_HOP_RIGHT', 'FLOOR_ALLOW_HOP_DOWN_OR_RIGHT'): continue\n            if move_offset == (1, 0) and tile_info['type'] == 'FLOOR_ALLOW_HOP_LEFT': continue\n\n            new_node = Node(current_node, node_position)\n            children.append(new_node)\n\n        for child in children:\n            if child.position in closed_set:\n                continue\n\n            child.g = current_node.g + 1\n            child.h = abs(child.position[0] - end_node.position[0]) + abs(child.position[1] - end_node.position[1])\n            child.f = child.g + child.h\n\n            if any(item for item in open_list if child == item[1] and child.g >= item[1].g):\n                continue\n\n            heapq.heappush(open_list, (child.f, child))\n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    \n    root = ET.fromstring(map_xml_string)\n    grid_data = {}\n    on_screen_objects = set()\n    for row in root.findall('Row'):\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            y = int(row.get('id'))\n            grid_data[(x, y)] = {'type': tile.get('type')}\n            if tile.find('Object') is not None and tile.find('Player') is None:\n                on_screen_objects.add((x, y))\n\n    path = get_path(grid_data, (start_x, start_y), (end_x, end_y), on_screen_objects)\n\n    if path:\n        print(json.dumps(path))\n    else:\n        print(json.dumps([]))\nexcept Exception as e:\n    import traceback\n    print(json.dumps([f'Error: {str(e)}', traceback.format_exc()]))\n"
  },
  "path_finder": {
    "description": "A* pathfinding algorithm to find a path between two points on the current map, avoiding obstacles, impassable terrain, and on-screen objects. This is the new, reliable version.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\nimport json\n\nclass Node:\n    def __init__(self, position, parent=None):\n        self.parent = parent\n        self.position = position\n        self.g = 0\n        self.h = 0\n        self.f = 0\n\n    def __eq__(self, other):\n        return self.position == other.position\n\n    def __lt__(self, other):\n        return self.f < other.f\n\n    def __hash__(self):\n        return hash(self.position)\n\ndef astar(grid, start, end, objects):\n    impassable_tiles = {\n        'WALL', 'VOID', 'WATER', 'CUT_TREE', 'COUNTER', 'BUOY', 'HEADBUTT_TREE', 'unseen',\n        'MART_SHELF', 'BOOKSHELF', 'TV', 'RADIO', 'PC', 'TOWN_MAP', 'WINDOW', 'PAINTING', 'STATUE', 'PILLAR'\n    }\n    warp_tiles = {'DOOR', 'CAVE', 'LADDER', 'WARP_CARPET_DOWN', 'WARP_CARPET_RIGHT', 'WARP_CARPET_LEFT'}\n\n    start_node = Node(start, None)\n    end_node = Node(end, None)\n\n    open_list = []\n    closed_set = set()\n\n    heapq.heappush(open_list, (start_node.f, start_node))\n\n    while open_list:\n        _, current_node = heapq.heappop(open_list)\n\n        if current_node.position in closed_set:\n            continue\n        closed_set.add(current_node.position)\n\n        if current_node == end_node:\n            path = []\n            current = current_node\n            while current is not None:\n                path.append(list(current.position))\n                current = current.parent\n            return path[::-1]\n\n        for move_offset in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            node_position = (current_node.position[0] + move_offset[0], current_node.position[1] + move_offset[1])\n\n            if node_position not in grid:\n                continue\n\n            tile_info = grid[node_position]\n            current_tile_info = grid[current_node.position]\n\n            if node_position in objects and node_position != end:\n                continue\n\n            if tile_info['type'] in impassable_tiles and node_position != end:\n                continue\n            \n            if tile_info['type'] in warp_tiles and node_position != end:\n                continue\n\n            if move_offset == (0, -1) and tile_info['type'] in ('LEDGE', 'FLOOR_ALLOW_HOP_DOWN', 'FLOOR_ALLOW_HOP_DOWN_OR_RIGHT'): continue\n            if move_offset == (0, -1) and current_tile_info['type'] == 'FLOOR_UP_WALL': continue\n            if move_offset == (0, 1) and tile_info['type'] == 'FLOOR_UP_WALL': continue\n            if move_offset == (-1, 0) and tile_info['type'] in ('FLOOR_ALLOW_HOP_RIGHT', 'FLOOR_ALLOW_HOP_DOWN_OR_RIGHT'): continue\n            if move_offset == (1, 0) and tile_info['type'] == 'FLOOR_ALLOW_HOP_LEFT': continue\n\n            child = Node(node_position, current_node)\n            child.g = current_node.g + 1\n            child.h = ((child.position[0] - end_node.position[0]) ** 2) + ((child.position[1] - end_node.position[1]) ** 2)\n            child.f = child.g + child.h\n\n            if any(open_node for f, open_node in open_list if open_node == child and child.g >= open_node.g):\n                continue\n\n            heapq.heappush(open_list, (child.f, child))\n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    \n    root = ET.fromstring(map_xml_string)\n    grid_data = {}\n    on_screen_objects = set()\n    for row in root.findall('Row'):\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            y = int(row.get('id'))\n            grid_data[(x, y)] = {'type': tile.get('type')}\n            obj_element = tile.find('Object')\n            if obj_element is not None and tile.find('Player') is None:\n                on_screen_objects.add((x, y))\n\n    path = astar(grid_data, (start_x, start_y), (end_x, end_y), on_screen_objects)\n\n    if path:\n        print(json.dumps(path))\n    else:\n        print(json.dumps([]))\nexcept Exception as e:\n    import traceback\n    print(json.dumps([f'Error: {str(e)}', traceback.format_exc()]))"
  },
  "battle_menu_select": {
    "description": "A reliable tool to select a main battle menu option (FIGHT, PKMN, PACK, RUN). Replaces the buggy `select_battle_option`.",
    "input_schema": {
      "type": "object",
      "properties": {
        "option_to_select": {
          "type": "string",
          "enum": [
            "FIGHT",
            "PKMN",
            "PACK",
            "RUN"
          ]
        }
      },
      "required": [
        "option_to_select"
      ]
    },
    "python_script": "import json\noption = input_data.get('option_to_select')\nbuttons = []\nif option == 'FIGHT':\n    buttons = ['A']\nelif option == 'PKMN':\n    buttons = ['Right', 'A']\nelif option == 'PACK':\n    buttons = ['Down', 'A']\nelif option == 'RUN':\n    buttons = ['Down', 'Right', 'A']\nprint(json.dumps(buttons))"
  }
}