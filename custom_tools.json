{
  "buy_item_quantity": {
    "description": "Buys a specific quantity of the currently selected item in the shop menu. Assumes the 'How many?' prompt is open with 'x01' selected.",
    "input_schema": {
      "type": "object",
      "properties": {
        "quantity": {
          "type": "integer",
          "description": "The number of items to buy."
        }
      },
      "required": [
        "quantity"
      ]
    },
    "python_script": "import json\nquantity = int(input_data[\"quantity\"])\nbuttons = []\nif quantity > 1:\n    for _ in range(quantity - 1):\n        buttons.append(\"Up\")\nbuttons.append(\"A\")\nbuttons.append(\"A\")\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "feat: Add buy_item_quantity tool to automate purchasing multiple items in shops. This reduces repetitive button presses for stocking up on supplies.",
        "timestamp": "2025-11-21T09:07:28.956Z",
        "action_counter": 2285
      },
      {
        "commit_message": "feat: Add buy_item_quantity tool to automate purchasing multiple items in shops. This reduces repetitive button presses for stocking up on supplies.",
        "timestamp": "2025-11-21T22:16:51.727Z",
        "action_counter": 3066
      }
    ]
  },
  "find_interaction_point": {
    "description": "Calculates the best adjacent tile to stand on to interact with a specific map object. Supports searching by `object_id` (for sprites), `object_name` (for background objects), or explicit `target_x`/`target_y` coordinates. Returns the target coordinates (x, y) and the direction to face. Does NOT return button presses.",
    "input_schema": {
      "type": "object",
      "properties": {
        "object_id": {
          "type": "integer",
          "nullable": true
        },
        "object_name": {
          "type": "string",
          "nullable": true
        },
        "target_x": {
          "type": "integer",
          "nullable": true
        },
        "target_y": {
          "type": "integer",
          "nullable": true
        },
        "player_x": {
          "type": "integer"
        },
        "player_y": {
          "type": "integer"
        }
      },
      "required": [
        "player_x",
        "player_y"
      ]
    },
    "python_script": "import sys\nimport json\nimport math\nimport xml.etree.ElementTree as ET\n\n# Parse input data\ntarget_obj_id = input_data.get('object_id')\ntarget_obj_name = input_data.get('object_name')\ntarget_x_arg = input_data.get('target_x')\ntarget_y_arg = input_data.get('target_y')\nplayer_x = int(input_data.get('player_x'))\nplayer_y = int(input_data.get('player_y'))\n\ntry:\n    root = ET.fromstring(map_xml_string)\nexcept Exception as e:\n    print(json.dumps({\"error\": f\"Failed to parse XML: {e}\"}))\n    sys.exit()\n\ntarget_x = None\ntarget_y = None\n\n# 1. Determine Target Coordinates\nif target_x_arg is not None and target_y_arg is not None:\n    target_x = int(target_x_arg)\n    target_y = int(target_y_arg)\nelse:\n    # Search XML for object\n    found = False\n    for row in root.findall(\"Row\"):\n        y = int(row.get(\"id\"))\n        for tile in row.findall(\"Tile\"):\n            x = int(tile.get(\"id\"))\n            \n            # Check Map Objects\n            if target_obj_id is not None:\n                for obj in tile.findall(\"Object\"):\n                    if obj.get(\"id\") == str(target_obj_id):\n                        target_x = x\n                        target_y = y\n                        found = True\n                        break\n            \n            # Check Background Objects (by name)\n            if not found and target_obj_name is not None:\n                for obj in tile.findall(\"Object\"):\n                    if obj.get(\"name\") == target_obj_name:\n                        target_x = x\n                        target_y = y\n                        found = True\n                        break\n            \n            if found: break\n        if found: break\n\nif target_x is None or target_y is None:\n    print(json.dumps({\"error\": \"Target not found\"}))\n    sys.exit()\n\n# 2. Find Best Interaction Spot\nneighbors = [\n    (target_x, target_y - 1, \"Down\"),\n    (target_x, target_y + 1, \"Up\"),\n    (target_x - 1, target_y, \"Right\"),\n    (target_x + 1, target_y, \"Left\")\n]\n\nvalid_spots = []\nmap_width = int(root.get(\"width\"))\nmap_height = int(root.get(\"height\"))\n\nfor nx, ny, face in neighbors:\n    if 0 <= nx < map_width and 0 <= ny < map_height:\n        is_walkable = False\n        for row in root.findall(\"Row\"):\n            if int(row.get(\"id\")) == ny:\n                for tile in row.findall(\"Tile\"):\n                    if int(tile.get(\"id\")) == nx:\n                        t_type = tile.get(\"type\")\n                        # Basic traversability check including warp carpets\n                        if t_type in [\"FLOOR\", \"GRASS\", \"TALL_GRASS\", \"LONG_GRASS\", \"SAND\", \"PATH\", \"WARP_CARPET_DOWN\", \"WARP_CARPET_UP\", \"WARP_CARPET_LEFT\", \"WARP_CARPET_RIGHT\"]:\n                            has_obj = tile.get(\"has-object\") == \"true\"\n                            # We treat objects as obstacles, unless it's the player\n                            if not has_obj or (nx == player_x and ny == player_y):\n                                is_walkable = True\n                        break\n                break\n        \n        if is_walkable:\n            dist = math.sqrt((nx - player_x)**2 + (ny - player_y)**2)\n            valid_spots.append({\"x\": nx, \"y\": ny, \"face\": face, \"dist\": dist})\n\nif not valid_spots:\n    # Fallback: if no spots are technically walkable (e.g. player is standing on one and it's considered blocked?), just return the closest one.\n    # For now, report error.\n    print(json.dumps({\"error\": \"No reachable interaction spots found\"}))\nelse:\n    # Sort by distance\n    valid_spots.sort(key=lambda s: s[\"dist\"])\n    best = valid_spots[0]\n    print(json.dumps(best))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-11-20T01:27:19.980Z",
        "action_counter": 301
      },
      {
        "commit_message": "fix: Update find_interaction_point to support looking up objects by 'object_name' in addition to 'object_id'. This allows targeting background objects (like computers or signs) that lack numeric IDs.",
        "timestamp": "2025-11-20T02:46:50.280Z",
        "action_counter": 421
      },
      {
        "commit_message": "fix: Add debug output to find_interaction_point to verify target location logic.",
        "timestamp": "2025-11-22T04:35:50.805Z",
        "action_counter": 3661
      },
      {
        "commit_message": "fix: Add support for explicit target_x/target_y arguments to bypass XML search if needed. Add debug prints to trace object location and neighbor traversability.",
        "timestamp": "2025-11-22T04:39:05.076Z",
        "action_counter": 3665
      },
      {
        "commit_message": "fix: Add explicit coordinate support and debug prints to find_interaction_point.",
        "timestamp": "2025-11-22T04:47:49.445Z",
        "action_counter": 3683
      },
      {
        "commit_message": "fix: Remove debug prints that were causing JSON parsing errors. Improve robustness of target finding and coordinate parsing.",
        "timestamp": "2025-11-22T08:28:38.782Z",
        "action_counter": 3965
      },
      {
        "commit_message": "fix: Remove debug print statements that were corrupting the JSON output. The tool now outputs clean JSON containing the target coordinates and facing direction.",
        "timestamp": "2025-11-22T08:50:25.869Z",
        "action_counter": 3991
      }
    ]
  },
  "find_path": {
    "description": "Calculates a path from the player's current position to a target coordinate (x, y) using BFS. Returns a JSON array of button presses. Treats tiles with objects, object-linked markers, markers labeled 'Hole', 'PIT' tiles, and 'LADDER' tiles as obstacles (unless the target IS the ladder).",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n        \n        # Get player position\n        p_tile = root.find(\".//Tile[@has-player='true']\")\n        if p_tile is None:\n            print(\"[]\")\n            return\n\n        start_x = int(p_tile.get('id'))\n        start_y = int(p_tile.get('coordinate').split(',')[1].strip(') '))\n        \n        if 'target_x' not in input_data or 'target_y' not in input_data:\n             print(\"[]\")\n             return\n\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n        \n        grid = {}\n        # Obstacles list - Added LADDER to prevent accidental warping\n        obstacles = [\n            \"WALL\", \"COUNTER\", \"PC\", \"SIGN\", \"TREE\", \"ROCK\", \"BOULDER\", \"WATER\", \"WHIRLPOOL\", \n            \"LEDGE_DOWN\", \"LEDGE_UP\", \"LEDGE_LEFT\", \"LEDGE_RIGHT\", \n            \"LEDGE_HOP_DOWN\", \"LEDGE_HOP_UP\", \"LEDGE_HOP_LEFT\", \"LEDGE_HOP_RIGHT\",\n            \"WINDOW\", \"DOOR_LOCKED\", \"HEADBUTT_TREE\", \"PIT\", \"LADDER\"\n        ]\n        \n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                x = int(tile.get('id'))\n                t_type = tile.get('type')\n                has_object = tile.get('has-object') == 'true'\n                \n                walkable = True\n                if t_type in obstacles:\n                    walkable = False\n                \n                # Check for objects (NPCs, items, etc) - they are walls\n                if has_object:\n                    walkable = False\n                \n                # Check for Markers\n                for marker in tile.findall('Marker'):\n                    label = marker.text or \"\"\n                    emoji = marker.get('emoji') or \"\"\n                    obj_id = marker.get('object_id')\n                    \n                    if \"Hole\" in label or \"üï≥Ô∏è\" in emoji:\n                        walkable = False\n                    \n                    if obj_id:\n                        walkable = False\n\n                grid[(x, y)] = walkable\n\n        # Logic: If target is blocked (e.g. it's a LADDER or PIT), path to nearest adjacent walkable\n        target_walkable = grid.get((target_x, target_y), False)\n        targets = set()\n        \n        if target_walkable:\n            targets.add((target_x, target_y))\n        else:\n            # If target is obstacle, allow adjacent tiles\n            for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                nx, ny = target_x + dx, target_y + dy\n                if grid.get((nx, ny), False):\n                    targets.add((nx, ny))\n            \n            if not targets:\n                print(\"[]\")\n                return\n\n        # BFS\n        queue = deque([(start_x, start_y, [])])\n        visited = set([(start_x, start_y)])\n        \n        while queue:\n            cx, cy, path = queue.popleft()\n            \n            if (cx, cy) in targets:\n                buttons = []\n                curr_x, curr_y = start_x, start_y\n                for (nx, ny) in path:\n                    if nx > curr_x: buttons.append(\"Right\")\n                    elif nx < curr_x: buttons.append(\"Left\")\n                    elif ny > curr_y: buttons.append(\"Down\")\n                    elif ny < curr_y: buttons.append(\"Up\")\n                    curr_x, curr_y = nx, ny\n                print(json.dumps(buttons))\n                return\n\n            for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                nx, ny = cx + dx, cy + dy\n                if (nx, ny) not in visited and grid.get((nx, ny), False):\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [(nx, ny)]))\n                    \n        print(\"[]\")\n\n    except Exception as e:\n        print(\"[]\")\n\nsolve()",
    "history": [
      {
        "commit_message": "feat: Add find_path tool. Calculates shortest path using BFS, handling walls, objects, and one-way ledges.",
        "timestamp": "2025-11-20T08:35:46.882Z",
        "action_counter": 924
      },
      {
        "commit_message": "fix: Add LADDER to traversable basic_types in find_path. Previously, the tool considered LADDER tiles as walls, preventing pathfinding to or from them.",
        "timestamp": "2025-11-20T10:46:07.670Z",
        "action_counter": 1068
      },
      {
        "commit_message": "fix: Add FLOOR_UP_WALL to traversable tiles when moving down. This tile type appears on Route 32 and visually resembles a ledge, so it is assumed to be jumpable from the north.",
        "timestamp": "2025-11-20T21:10:28.299Z",
        "action_counter": 1479
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. In-game testing proved this tile type blocks movement from the north, contrary to the initial hypothesis that it was a jumpable ledge.",
        "timestamp": "2025-11-20T21:14:51.875Z",
        "action_counter": 1484
      },
      {
        "commit_message": "fix: Reinforce object collision check in find_path and add debug prints for player's neighbors to diagnose issues where objects are ignored.",
        "timestamp": "2025-11-20T23:31:27.320Z",
        "action_counter": 1632
      },
      {
        "commit_message": "fix: Add CAVE to traversable basic_types. This tile type represents cave entrances (warps) and must be traversable to enter dungeons like Union Cave. Also removed debug prints.",
        "timestamp": "2025-11-20T23:38:16.306Z",
        "action_counter": 1641
      },
      {
        "commit_message": "fix: Enable FLOOR_UP_WALL as a traversable ledge when moving down. This is necessary to test if the western ledge at (12, 18) is jumpable, as the eastern path is blocked.",
        "timestamp": "2025-11-21T00:47:29.072Z",
        "action_counter": 1752
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. Verified in-game at (16, 21) that this tile type acts as a wall and cannot be jumped from the north.",
        "timestamp": "2025-11-21T00:59:17.529Z",
        "action_counter": 1768
      },
      {
        "commit_message": "fix: Ensure FLOOR_UP_WALL is treated as a wall. Previous testing at (16, 21) confirmed it is not jumpable from the north.",
        "timestamp": "2025-11-21T01:01:08.516Z",
        "action_counter": 1771
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. Verified in-game at (12, 17) -> (12, 18) that this tile type acts as a wall and cannot be jumped from the north.",
        "timestamp": "2025-11-21T01:05:06.366Z",
        "action_counter": 1776
      },
      {
        "commit_message": "feat: Allow movement UP onto FLOOR_UP_WALL tiles. Verified in-game at Union Cave (5, 19) -> (5, 18) that this tile type acts as a climbable ramp from the south.",
        "timestamp": "2025-11-21T02:01:30.245Z",
        "action_counter": 1847
      },
      {
        "commit_message": "feat: Allow horizontal movement on FLOOR_UP_WALL. The tiles at row 18 act as a traversable ridge connecting the west and east sides of the room.",
        "timestamp": "2025-11-21T02:05:19.643Z",
        "action_counter": 1850
      },
      {
        "commit_message": "feat: Update find_path to automatically target adjacent traversable tiles if the destination is blocked by a wall or object. This eliminates the need for manual coordinate guessing when targeting NPCs or obstacles.",
        "timestamp": "2025-11-22T00:45:06.962Z",
        "action_counter": 3307
      },
      {
        "commit_message": "feat: Enhance find_path to treat tiles with object-linked markers as obstacles. This prevents the pathfinder from routing through off-screen NPCs or objects that are known to exist but not currently rendered in the viewport.",
        "timestamp": "2025-11-22T02:29:58.782Z",
        "action_counter": 3465
      },
      {
        "commit_message": "refactor: Change output format from coordinates to button presses (e.g. [\"Up\", \"Right\"]). This enables compatibility with the `autopress_buttons: true` feature for automated navigation.",
        "timestamp": "2025-11-22T06:33:20.386Z",
        "action_counter": 3846
      },
      {
        "commit_message": "fix: Update find_path to return a JSON array of button strings (e.g. ['Up', 'Right']) instead of coordinates, enabling compatibility with autopress_buttons. Also re-implements logic to path to adjacent tiles if the target is blocked.",
        "timestamp": "2025-11-22T06:37:44.405Z",
        "action_counter": 3851
      },
      {
        "commit_message": "fix: Rewrite find_path to output a JSON array of button strings (e.g. [\"Up\", \"Right\"]) instead of coordinate objects. Adds logic to automatically path to an adjacent tile if the target is blocked by a wall, object, or marker.",
        "timestamp": "2025-11-22T06:42:53.734Z",
        "action_counter": 3857
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE to the obstacles list in find_path. Previously, the pathfinder treated these trees as walkable FLOOR tiles, causing pathfinding failures on Route 36.",
        "timestamp": "2025-11-22T09:46:43.517Z",
        "action_counter": 4061
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE to obstacles list in find_path tool. This prevents pathfinding through solid trees on Route 36.",
        "timestamp": "2025-11-22T09:53:42.815Z",
        "action_counter": 4069
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE to obstacles list in find_path tool. This prevents pathfinding failures where the tool tries to route through solid trees on Route 36.",
        "timestamp": "2025-11-22T10:01:47.695Z",
        "action_counter": 4078
      },
      {
        "commit_message": "fix: Add LEDGE_HOP_DOWN, LEDGE_HOP_UP, LEDGE_HOP_LEFT, and LEDGE_HOP_RIGHT to the obstacles list in find_path. This prevents the pathfinder from incorrectly generating paths that try to walk up one-way ledges, which caused a navigation error on Route 37.",
        "timestamp": "2025-11-22T11:03:50.170Z",
        "action_counter": 4148
      },
      {
        "commit_message": "fix: Update find_path to treat tiles marked with 'Hole' or üï≥Ô∏è as obstacles. This prevents the pathfinder from routing the player into pits in the Burned Tower.",
        "timestamp": "2025-11-22T15:38:21.684Z",
        "action_counter": 4436
      },
      {
        "commit_message": "fix: Update find_path to treat tiles marked with 'Hole' or üï≥Ô∏è as obstacles. This prevents the pathfinder from routing the player into pits in the Burned Tower.",
        "timestamp": "2025-11-22T15:45:56.249Z",
        "action_counter": 4441
      },
      {
        "commit_message": "fix: Update find_path to correctly identify tiles with 'Hole' markers or object-linked markers as obstacles. This prevents pathfinding through dangerous tiles in the Burned Tower.",
        "timestamp": "2025-11-22T15:59:15.044Z",
        "action_counter": 4454
      },
      {
        "commit_message": "fix: Add PIT to obstacles list in find_path. This prevents the pathfinder from routing the player into pits in the Lighthouse.",
        "timestamp": "2025-11-23T02:50:16.179Z",
        "action_counter": 5202
      },
      {
        "commit_message": "fix: Add LADDER to obstacles list in find_path. This prevents the pathfinder from routing through ladders which are warps, avoiding accidental map transitions.",
        "timestamp": "2025-11-23T05:18:17.385Z",
        "action_counter": 5381
      }
    ]
  },
  "scan_reachable_unseen": {
    "description": "Identifies unseen tiles that are reachable from the player's current position using a flood fill algorithm on traversable tiles. Returns a list of coordinates.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef is_traversable(tile_type):\n    traversable_types = [\n        \"FLOOR\", \"TALL_GRASS\", \"LONG_GRASS\", \"STAIRS\", \n        \"WARP_CARPET_DOWN\", \"WARP_CARPET_UP\", \"WARP_CARPET_LEFT\", \"WARP_CARPET_RIGHT\",\n        \"DOOR\", \"OPEN_DOOR\"\n    ]\n    return tile_type in traversable_types\n\nmap_data = ET.fromstring(map_xml_string)\nwidth = int(map_data.get(\"width\"))\nheight = int(map_data.get(\"height\"))\n\ngrid = [[None for _ in range(width)] for _ in range(height)]\nplayer_pos = None\n\nfor row in map_data.findall(\"Row\"):\n    y = int(row.get(\"id\"))\n    for tile in row.findall(\"Tile\"):\n        x = int(tile.get(\"id\"))\n        grid[y][x] = tile\n        if tile.find(\"Player\") is not None:\n            player_pos = (x, y)\n\nif not player_pos:\n    print(\"Player not found\")\n    exit()\n\nvisited = set()\nqueue = deque([player_pos])\nvisited.add(player_pos)\nreachable_unseen = []\n\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\nwhile queue:\n    cx, cy = queue.popleft()\n    \n    for dx, dy in directions:\n        nx, ny = cx + dx, cy + dy\n        \n        if 0 <= nx < width and 0 <= ny < height:\n            if (nx, ny) in visited:\n                continue\n                \n            tile = grid[ny][nx]\n            tile_type = tile.get(\"type\")\n            is_seen = tile.get(\"seen\") == \"true\"\n            has_object = tile.get(\"has-object\") == \"true\"\n            \n            if not is_seen:\n                reachable_unseen.append((nx, ny))\n                visited.add((nx, ny))\n                continue\n            \n            if is_traversable(tile_type) and not has_object:\n                visited.add((nx, ny))\n                queue.append((nx, ny))\n\nprint(f\"Reachable unseen tiles: {reachable_unseen}\")",
    "history": [
      {
        "commit_message": "feat: Add scan_reachable_unseen tool to identify reachable unseen tiles for exploration.",
        "timestamp": "2025-11-19T22:54:46.456Z",
        "action_counter": 59
      },
      {
        "commit_message": "feat: Add scan_reachable_unseen tool to identify reachable unseen tiles for exploration.",
        "timestamp": "2025-11-19T23:51:32.034Z",
        "action_counter": 153
      }
    ]
  },
  "sequence_press": {
    "description": "Executes a sequence of button presses provided as a comma-separated string. Essential for navigating menus or keyboards where mixing directional and action inputs is required in a single turn.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "string",
          "description": "Comma-separated list of buttons to press, e.g., 'A, Down, Down, A'"
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nbuttons_str = input_data.get('buttons', '')\nif not buttons_str:\n    print('[]')\nelse:\n    button_list = [btn.strip() for btn in buttons_str.split(',')]\n    print(json.dumps(button_list))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-11-22T06:30:16.355Z",
        "action_counter": 3843
      }
    ]
  }
}