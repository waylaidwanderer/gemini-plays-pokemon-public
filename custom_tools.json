{
  "master_navigator": {
    "description": "A consolidated navigation tool that handles pathfinding. It can find a path to a specific coordinate. It now considers map markers for obstacles and correctly handles ledges and transitions between different traversable tile types. Includes an option to ignore objects for testing purposes. THIS IS A DEBUG VERSION.",
    "input_schema": {
      "type": "object",
      "properties": {
        "mode": {
          "type": "string",
          "enum": [
            "pathfind"
          ]
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer",
          "nullable": true
        },
        "end_y": {
          "type": "integer",
          "nullable": true
        },
        "traversable_tiles": {
          "type": "string"
        },
        "ignore_objects": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "mode",
        "start_x",
        "start_y",
        "traversable_tiles"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\nimport sys\n\nsys.stderr = sys.stdout\n\ndef find_path(map_xml_string, start_x, start_y, end_x, end_y, traversable_tiles_str, ignore_objects_str):\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n\n        traversable_tiles = traversable_tiles_str.split(',')\n        ignore_objects = ignore_objects_str.lower() == 'true' if ignore_objects_str else False\n        \n        grid = [[False for _ in range(width)] for _ in range(height)]\n        \n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            if not (1 <= y <= height): continue\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                if not (1 <= x <= width): continue\n\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                is_player_tile = tile_elem.find('Player') is not None\n                \n                is_traversable = tile_type in traversable_tiles\n                \n                if has_object and not is_player_tile and not ignore_objects:\n                    is_traversable = False\n                \n                for marker in tile_elem.findall('Marker'):\n                    if marker.get('emoji') == 'ðŸš«':\n                        is_traversable = False\n                        break\n                \n                if is_traversable or is_player_tile:\n                    grid[y-1][x-1] = True\n\n        def heuristic(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n        start = (start_x - 1, start_y - 1)\n        goal = (end_x - 1, end_y - 1)\n\n        if not (0 <= start[0] < width and 0 <= start[1] < height and grid[start[1]][start[0]]):\n            return {\"error\": f\"Start ({start_x},{start_y}) is not on a traversable tile.\"}\n        \n        if not (0 <= goal[0] < width and 0 <= goal[1] < height):\n            return {\"error\": f\"Goal ({end_x},{end_y}) is outside map boundaries.\"}\n\n        if not grid[goal[1]][goal[0]]:\n            found_new_goal = False\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_goal_candidate = (goal[0] + dx, goal[1] + dy)\n                if 0 <= new_goal_candidate[0] < width and 0 <= new_goal_candidate[1] < height and grid[new_goal_candidate[1]][new_goal_candidate[0]]:\n                    goal = new_goal_candidate\n                    found_new_goal = True\n                    break\n            if not found_new_goal:\n                 return {\"error\": f\"Goal ({end_x},{end_y}) and all adjacent tiles are not traversable.\"}\n\n        open_set = [(0, start)]\n        came_from = {}\n        g_score = { (c,r): float('inf') for r in range(height) for c in range(width) }\n        g_score[start] = 0\n        f_score = { (c,r): float('inf') for r in range(height) for c in range(width) }\n        f_score[start] = heuristic(start, goal)\n        \n        while open_set:\n            _, current = heapq.heappop(open_set)\n\n            if current == goal:\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(start)\n                path_coords = [{'x': x + 1, 'y': y + 1} for x, y in reversed(path)]\n                return path_coords\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                neighbor = (current[0] + dx, current[1] + dy)\n                nx, ny = neighbor\n\n                if not (0 <= nx < width and 0 <= ny < height and grid[ny][nx]):\n                    continue\n\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, goal)\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n        \n        return {\"error\": \"No path found.\"}\n\n    except Exception as e:\n        import traceback\n        return {\"error\": str(e), \"traceback\": traceback.format_exc()}\n\ntry:\n    mode = input_data['mode']\n    if mode == 'pathfind':\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        end_x = int(input_data.get('end_x'))\n        end_y = int(input_data.get('end_y'))\n        traversable_tiles_str = input_data['traversable_tiles']\n        ignore_objects_str = input_data.get('ignore_objects')\n\n        path = find_path(map_xml_string, start_x, start_y, end_x, end_y, traversable_tiles_str, ignore_objects_str)\n\n        if isinstance(path, dict) and \"error\" in path:\n            print(json.dumps(path))\n        elif path:\n            print(json.dumps({\"path\": path}))\n        else:\n            print(json.dumps({\"error\": \"No path found.\"}))\n    else:\n        print(json.dumps({\"error\": f\"Invalid mode: {mode}\"}))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({\"error\": f\"Tool execution failed: {str(e)}\", \"traceback\": traceback.format_exc()}))"
  }
}