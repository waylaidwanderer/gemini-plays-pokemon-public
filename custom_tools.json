{
  "automated_explorer": {
    "description": "Finds the nearest reachable unseen tile and generates a path to an adjacent traversable tile. Now correctly handles water traversal with SURF, defeated trainers, and uses robust pathfinding logic.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\nimport json\n\ndef find_all_reachable_and_paths(start, grid, width, height, is_surfing_state):\n    queue = collections.deque([start])\n    came_from = {start: None}\n    \n    while queue:\n        current = queue.popleft()\n        \n        for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = current[0] + move_x, current[1] + move_y\n            next_pos = (next_x, next_y)\n            \n            if not (1 <= next_x <= width and 1 <= next_y <= height):\n                continue\n            \n            if next_pos in came_from:\n                continue\n                \n            current_tile_info = grid.get(current, {})\n            next_tile_info = grid.get(next_pos, {})\n            next_tile_type = next_tile_info.get('type')\n            \n            if move_y == 1 and current_tile_info.get('type') != 'ledge' and next_tile_type == 'ledge':\n                ledge_jump_pos = (next_x, next_y + 1)\n                if ledge_jump_pos in came_from: continue\n                if grid.get(ledge_jump_pos, {}).get('type') not in ['impassable', 'unknown']:\n                    came_from[next_pos] = current\n                    came_from[ledge_jump_pos] = next_pos\n                    queue.append(ledge_jump_pos)\n                continue\n\n            impassable_types = ['impassable', 'unknown']\n            if current_tile_info.get('type') != 'water':\n                 impassable_types.append('ledge')\n            \n            if next_tile_type in impassable_types:\n                continue\n\n            if next_tile_type == 'water' and not is_surfing_state:\n                continue\n            \n            if next_tile_info.get('has_object') and next_tile_info.get('object_name') != 'Pikachu' and not next_tile_info.get('is_defeated_trainer', False):\n                continue\n\n            current_elevation = 'elevated' if current_tile_info.get('type') == 'elevated_ground' else 'ground'\n            next_elevation = 'elevated' if next_tile_type == 'elevated_ground' else 'ground'\n            if current_elevation != next_elevation and current_tile_info.get('type') not in ['steps', 'ladder_up', 'ladder_down'] and next_tile_type not in ['steps', 'ladder_up', 'ladder_down']:\n                continue\n            \n            came_from[next_pos] = current\n            queue.append(next_pos)\n            \n    return came_from\n\ndef reconstruct_path(came_from, end):\n    if end not in came_from:\n        return None\n    path = []\n    current = end\n    while current is not None:\n        path.append(list(current))\n        current = came_from.get(current)\n    return path[::-1]\n\ndef main():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        start_node = (start_x, start_y)\n\n        grid = {}\n        unseen_tiles = []\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                is_defeated = any(marker.get('emoji') == '☠️' for marker in tile_elem.findall('Marker'))\n                grid[(x, y)] = {\n                    'type': tile_elem.get('type'),\n                    'has_object': tile_elem.get('has-object') == 'true',\n                    'object_name': tile_elem.find('Object').get('id-name') if tile_elem.find('Object') is not None else None,\n                    'is_defeated_trainer': is_defeated\n                }\n                if tile_elem.get('seen') == 'false':\n                    unseen_tiles.append((x, y))\n\n        is_surfing_state = grid.get(start_node, {}).get('type') == 'water'\n\n        if not unseen_tiles:\n            print(json.dumps({'status': 'success', 'message': 'No unseen tiles found.'}))\n            return\n\n        came_from = find_all_reachable_and_paths(start_node, grid, width, height, is_surfing_state)\n        reachable_nodes = set(came_from.keys())\n        \n        targetable_unseen_tiles = [tile for tile in unseen_tiles if any((tile[0] + dx, tile[1] + dy) in reachable_nodes for dx, dy in [(0,1),(0,-1),(1,0),(-1,0)])]\n\n        if not targetable_unseen_tiles:\n            print(json.dumps({'status': 'error', 'message': 'No unseen tiles are adjacent to reachable areas.', 'reachable_nodes_count': len(reachable_nodes)}))\n            return\n\n        shortest_path = None\n        target_unseen = None\n        \n        sorted_targets = sorted(targetable_unseen_tiles, key=lambda t: (abs(t[0] - start_x) + abs(t[1] - start_y)))\n\n        for tile in sorted_targets:\n            best_adj_path = None\n            for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adj_x, adj_y = tile[0] + move_x, tile[1] + move_y\n                adj_pos = (adj_x, adj_y)\n                if adj_pos in reachable_nodes:\n                    path = reconstruct_path(came_from, adj_pos)\n                    if path and (best_adj_path is None or len(path) < len(best_adj_path)):\n                        best_adj_path = path\n            \n            if best_adj_path:\n                shortest_path = best_adj_path\n                target_unseen = tile\n                break\n        \n        if shortest_path:\n            print(json.dumps({'status': 'success', 'path': shortest_path, 'target_unseen_tile': target_unseen}))\n        else:\n            print(json.dumps({'status': 'error', 'message': 'Could not find a path to any adjacent tile of any reachable unseen tiles.'}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'status': 'error', 'message': f'An exception occurred: {traceback.format_exc()}'}))\n\nmain()"
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map using the Breadth-First Search (BFS) algorithm. It considers tile types (including elevation, water), impassable objects (excluding Pikachu), and special ledge traversal rules. It now detects and reports if a destination is on an unreachable map segment. The output is a JSON string containing the path or debug info.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\nimport json\n\ndef find_path():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        start = (int(input_data['start_x']), int(input_data['start_y']))\n        end = (int(input_data['end_x']), int(input_data['end_y']))\n\n        grid = {}\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                object_name = None\n                if has_object:\n                    obj_elem = tile_elem.find('Object')\n                    if obj_elem is not None:\n                        object_name = obj_elem.get('id-name')\n                grid[(x, y)] = {'type': tile_type, 'has_object': has_object, 'object_name': object_name}\n\n        queue = collections.deque([start])\n        came_from = {start: None}\n\n        while queue:\n            current = queue.popleft()\n            if current == end:\n                break\n\n            for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                next_x, next_y = current[0] + move_x, current[1] + move_y\n                next_pos = (next_x, next_y)\n\n                if not (1 <= next_x <= width and 1 <= next_y <= height) or next_pos in came_from:\n                    continue\n\n                current_tile_info = grid.get(current, {})\n                next_tile_info = grid.get(next_pos, {})\n                next_tile_type = next_tile_info.get('type')\n\n                if next_tile_type in ['impassable', 'unknown', 'closed_gate']:\n                    continue\n\n                if next_tile_info.get('has_object') and next_tile_info.get('object_name') != 'Pikachu':\n                    if next_pos != end:\n                        continue\n                \n                if next_tile_type == 'ledge':\n                    if move_y == 1:\n                        ledge_jump_pos = (next_x, next_y + 1)\n                        if ledge_jump_pos in came_from: continue\n                        if grid.get(ledge_jump_pos, {}).get('type') not in ['impassable', 'unknown', 'closed_gate']:\n                            came_from[next_pos] = current\n                            came_from[ledge_jump_pos] = next_pos\n                            queue.append(ledge_jump_pos)\n                        continue\n                    else:\n                        continue\n\n                current_is_elevated = current_tile_info.get('type') == 'elevated_ground'\n                next_is_elevated = next_tile_info.get('type') == 'elevated_ground'\n                if current_is_elevated != next_is_elevated:\n                    if not (current_tile_info.get('type') in ['steps', 'ladder_up', 'ladder_down'] or next_tile_type in ['steps', 'ladder_up', 'ladder_down']):\n                        continue\n                \n                came_from[next_pos] = current\n                queue.append(next_pos)\n\n        if end in came_from:\n            path = []\n            current = end\n            while current is not None:\n                path.append(list(current))\n                current = came_from.get(current)\n            print(json.dumps({\"status\": \"success\", \"path\": path[::-1]}))\n        else:\n            print(json.dumps({\"status\": \"error\", \"message\": \"No path found. The destination is on an unreachable segment of the map.\"}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({\"status\": \"error\", \"message\": f'An exception occurred: {traceback.format_exc()}'}))\n\nfind_path()\n"
  },
  "wkg_pathfinder": {
    "description": "Calculates the shortest path between two maps in the World Knowledge Graph, returning a sequence of map IDs and warp coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_map_id": {
          "type": "string"
        },
        "end_map_id": {
          "type": "string"
        }
      },
      "required": [
        "start_map_id",
        "end_map_id"
      ]
    },
    "python_script": "import json\nimport collections\n\ndef find_path_in_wkg():\n    try:\n        graph = json.loads(world_knowledge_graph_json_string)\n        start_map = input_data['start_map_id']\n        end_map = input_data['end_map_id']\n\n        nodes = graph.get('nodes', [])\n        edges = graph.get('edges', [])\n\n        adj = collections.defaultdict(list)\n        for edge in edges:\n            adj[edge['source_node_id']].append(edge['destination_node_id'])\n            if not edge.get('is_one_way', False):\n                adj[edge['destination_node_id']].append(edge['source_node_id'])\n\n        node_map = {node['id']: node for node in nodes}\n\n        start_nodes = [node['id'] for node in nodes if node['map_id'] == start_map]\n        if not start_nodes:\n            print(json.dumps({\"status\": \"error\", \"message\": f\"Start map ID '{start_map}' not found in World Knowledge Graph.\"}))\n            return\n\n        queue = collections.deque([(start_node, [start_node]) for start_node in start_nodes])\n        visited = set(start_nodes)\n        \n        path_found = False\n        final_path = []\n\n        while queue:\n            current_node_id, path = queue.popleft()\n\n            if node_map[current_node_id]['map_id'] == end_map:\n                path_found = True\n                final_path = path\n                break\n\n            for neighbor_id in adj[current_node_id]:\n                if neighbor_id not in visited:\n                    visited.add(neighbor_id)\n                    new_path = list(path)\n                    new_path.append(neighbor_id)\n                    queue.append((neighbor_id, new_path))\n\n        if path_found:\n            result_path = []\n            for node_id in final_path:\n                node_info = node_map.get(node_id)\n                if node_info:\n                    result_path.append({\n                        \"map_id\": node_info.get(\"map_id\"),\n                        \"coordinates\": node_info.get(\"coordinates\")\n                    })\n            print(json.dumps({\"status\": \"success\", \"path\": result_path}))\n        else:\n            print(json.dumps({\"status\": \"error\", \"message\": f\"No path found from map '{start_map}' to '{end_map}'.\"}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({\"status\": \"error\", \"message\": f'An exception occurred: {traceback.format_exc()}'}))\n\nfind_path_in_wkg()\n"
  },
  "find_wkg_node_by_coords": {
    "description": "Finds a World Knowledge Graph node ID by map ID and coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "map_id": {
          "type": "string"
        },
        "x": {
          "type": "string"
        },
        "y": {
          "type": "string"
        }
      },
      "required": [
        "map_id",
        "x",
        "y"
      ]
    },
    "python_script": "import json\n\ndef find_node():\n    try:\n        wkg = json.loads(world_knowledge_graph_json_string)\n        target_map_id = input_data['map_id']\n        target_x = int(input_data['x'])\n        target_y = int(input_data['y'])\n\n        for node in wkg['nodes']:\n            if str(node['map_id']) == str(target_map_id) and node['coordinates']['x'] == target_x and node['coordinates']['y'] == target_y:\n                print(json.dumps({'status': 'success', 'node_id': node['id']}))\n                return\n        \n        print(json.dumps({'status': 'error', 'message': f'Node not found on map {target_map_id} at ({target_x}, {target_y}).'}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'status': 'error', 'message': f'An exception occurred: {traceback.format_exc()}'}))\n\nfind_node()"
  }
}