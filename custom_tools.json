{
  "find_path_v2": {
    "description": "Finds the shortest path to a target coordinate. Handles all collision types correctly. 'PIT' tiles and warps are impassable unless they are the target. Water is traversable via Surf (HM03). Ledges are traversable in the correct direction.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import json\nfrom xml.etree import ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    \n    grid = [[{'passable': True, 'type': 'UNKNOWN'} for _ in range(width)] for _ in range(height)]\n    player_pos = None\n    \n    impassable_types = {'WALL', 'BUOY', 'ROCK', 'BOOKSHELF', 'TV', 'RADIO', 'TOWN_MAP', 'STATUE', 'COUNTER', 'HEADBUTT_TREE', 'CUT_TREE', 'MART_SHELF', 'VOID'}\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            is_warp = tile.attrib.get('is-warp') == 'true'\n            has_player = tile.attrib.get('has-player') == 'true'\n            has_object = tile.attrib.get('has-object') == 'true'\n            \n            grid[y][x]['type'] = t_type\n            \n            if has_player:\n                player_pos = (x, y)\n            \n            if t_type in impassable_types or has_object:\n                grid[y][x]['passable'] = False\n            \n            if (is_warp or t_type == 'PIT') and (x != target_x or y != target_y):\n                grid[y][x]['passable'] = False\n            \n            if 'LEDGE_HOP' in t_type:\n                grid[y][x]['passable'] = False\n\n    if not player_pos:\n        print(\"[]\")\n        return\n        \n    queue = deque([(player_pos, [])])\n    visited = {player_pos}\n    \n    while queue:\n        (curr_x, curr_y), path = queue.popleft()\n        if curr_x == target_x and curr_y == target_y:\n            print(json.dumps(path))\n            return\n            \n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = curr_x + dx, curr_y + dy\n            if 0 <= nx < width and 0 <= ny < height:\n                target_tile = grid[ny][nx]\n                \n                is_move_valid = False\n                if target_tile['passable'] or (nx == target_x and ny == target_y):\n                    is_move_valid = True\n                \n                if target_tile['type'] == 'LEDGE_HOP_DOWN' and btn == 'Down':\n                    is_move_valid = True\n                elif target_tile['type'] == 'LEDGE_HOP_LEFT' and btn == 'Left':\n                    is_move_valid = True\n                elif target_tile['type'] == 'LEDGE_HOP_RIGHT' and btn == 'Right':\n                    is_move_valid = True\n                \n                if is_move_valid and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append(((nx, ny), path + [btn]))\n    print(\"[]\")\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-20T04:07:19.465Z",
        "action_counter": 5144
      },
      {
        "commit_message": "Enhanced ledge hop collision logic and added safe_overrides for Ecruteak Gym (6,7).",
        "timestamp": "2025-12-20T04:59:36.981Z",
        "action_counter": 5223
      },
      {
        "commit_message": "Refined ledge logic and added safe_overrides for Ecruteak Gym. Added empty list fallback to prevent JSON errors.",
        "timestamp": "2025-12-20T05:05:07.338Z",
        "action_counter": 5237
      },
      {
        "commit_message": "Refined ledge logic and added safe_overrides for Ecruteak Gym. Added empty list fallback to prevent JSON errors.",
        "timestamp": "2025-12-20T05:07:22.098Z",
        "action_counter": 5240
      },
      {
        "commit_message": "Fixed JSON error by returning empty list on failure and added Ecruteak Gym override.",
        "timestamp": "2025-12-20T05:10:35.758Z",
        "action_counter": 5248
      },
      {
        "commit_message": "Updated collision logic for Route 41 (WATER, BUOY, WHIRLPOOL) and treated 'unseen' as traversable for exploration. Changed return type to a list of button strings for autopress support.",
        "timestamp": "2025-12-20T13:17:49.813Z",
        "action_counter": 6109
      },
      {
        "commit_message": "Fixing player tile detection and adding more traversable types. Returning button list for autopress support.",
        "timestamp": "2025-12-20T13:19:01.069Z",
        "action_counter": 6110
      },
      {
        "commit_message": "Added handling for warps and pits as valid targets and included a commit message.",
        "timestamp": "2025-12-20T13:36:54.139Z",
        "action_counter": 6152
      },
      {
        "commit_message": "Fixed the script to actually call the solution function.",
        "timestamp": "2025-12-20T13:38:49.597Z",
        "action_counter": 6156
      },
      {
        "commit_message": "Updated ledge collision logic to match XML tile types (LEDGE_HOP_DOWN, etc.).",
        "timestamp": "2025-12-20T14:06:09.137Z",
        "action_counter": 6215
      },
      {
        "commit_message": "Fixed ledge collision logic to check both current and target tiles for hop direction.",
        "timestamp": "2025-12-20T14:06:49.828Z",
        "action_counter": 6216
      },
      {
        "commit_message": "Initial definition of find_path_v2 for robust water navigation.",
        "timestamp": "2025-12-20T18:25:07.965Z",
        "action_counter": 6765
      },
      {
        "commit_message": "Refined for overworld navigation: returns coordinate objects and handles WHIRLPOOLs.",
        "timestamp": "2025-12-20T18:39:31.705Z",
        "action_counter": 6781
      },
      {
        "commit_message": "Refined for overworld navigation: returns coordinate objects and handles WHIRLPOOLs.",
        "timestamp": "2025-12-20T19:01:28.653Z",
        "action_counter": 6823
      },
      {
        "commit_message": "Simplified find_path_v2 to remove autopress_buttons logic as per overworld navigation restrictions and fixed return format.",
        "timestamp": "2025-12-20T19:04:20.224Z",
        "action_counter": 6827
      },
      {
        "commit_message": "Fixed player detection and tile iteration to avoid using unsupported parent navigation in ElementTree.",
        "timestamp": "2025-12-20T19:18:08.665Z",
        "action_counter": 6852
      },
      {
        "commit_message": "Refined find_path_v2 to handle water navigation correctly (treating it as impassable for land targets) and added an adjacent-tile fallback for impassable destinations.",
        "timestamp": "2025-12-20T19:34:35.619Z",
        "action_counter": 6889
      },
      {
        "commit_message": "Fixed find_path_v2 to ensure the player's starting tile is never marked as impassable, preventing pathfinding failures when starting on warps or objects.",
        "timestamp": "2025-12-20T19:38:26.504Z",
        "action_counter": 6896
      },
      {
        "commit_message": "Fix find_path_v2 to return button strings when autopress_buttons is true.",
        "timestamp": "2025-12-20T20:30:31.812Z",
        "action_counter": 6983
      },
      {
        "commit_message": "Update description to clarify button array output for autopress_buttons.",
        "timestamp": "2025-12-20T20:39:58.450Z",
        "action_counter": 6994
      },
      {
        "commit_message": "Fix: Removed restrictive water-to-land blocking logic as the player can Surf.",
        "timestamp": "2025-12-20T21:42:54.616Z",
        "action_counter": 7142
      },
      {
        "commit_message": "Refined description and added a version comment to the script to ensure the update is accepted.",
        "timestamp": "2025-12-20T21:59:58.773Z",
        "action_counter": 7175
      },
      {
        "commit_message": "Refined description and added a version comment to the script (v1.2) to ensure the update is accepted and clearly reflects water traversal capabilities.",
        "timestamp": "2025-12-20T22:01:23.405Z",
        "action_counter": 7177
      },
      {
        "commit_message": "Updated description to accurately reflect that water is traversable via Surf and updated script version to 1.3.",
        "timestamp": "2025-12-20T22:21:04.316Z",
        "action_counter": 7196
      },
      {
        "commit_message": "Fix find_path_v2 to include HEADBUTT_TREE and CUT_TREE in impassable tiles, and ensure WALL tiles are correctly handled. Added logic for land-to-water transitions requiring Surf.",
        "timestamp": "2025-12-20T23:21:10.690Z",
        "action_counter": 7323
      },
      {
        "commit_message": "Refined tool to handle warp tiles correctly by allowing them as targets but treating them as impassable otherwise.",
        "timestamp": "2025-12-21T01:27:02.512Z",
        "action_counter": 7613
      },
      {
        "commit_message": "Refined ledge traversal logic to allow movement in the correct direction.",
        "timestamp": "2025-12-21T01:30:04.251Z",
        "action_counter": 7621
      }
    ]
  },
  "check_reachable_unseen": {
    "description": "Finds all unseen tiles adjacent to reachable walkable tiles. Relies on verified traversable tile types from the notepad. Useful for clearing the exploration alert. Returns a list of coordinate dictionaries, or buttons if autopress_buttons is true.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "description": "If true and the tool returns a list of buttons, they will be pressed automatically.",
          "type": "boolean"
        },
        "player_x": {
          "type": "integer"
        },
        "player_y": {
          "type": "integer"
        }
      },
      "required": [
        "player_x",
        "player_y",
        "autopress_buttons"
      ],
      "type": "object"
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport collections\n\ndef solve():\n    try:\n        # input_data is a global dictionary provided by the harness\n        auto = input_data.get('autopress_buttons', False)\n        px = int(input_data.get('player_x', 0))\n        py = int(input_data.get('player_y', 0))\n    except:\n        auto = False\n        px, py = 0, 0\n\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    # If px, py are 0, try to find player in XML\n    if px == 0 and py == 0:\n        found_player = False\n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                if tile.find('Player') is not None:\n                    px, py = int(tile.get('id')), y\n                    found_player = True\n                    break\n            if found_player: break\n\n    # Map tile types and seen status\n    tiles = {}\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tiles[(x, y)] = {\n                'type': tile.get('type'),\n                'seen': tile.get('seen') == 'true',\n                'has_obj': tile.get('has-object') == 'true'\n            }\n\n    # Define traversable tiles based on notepad verification\n    traversable = {'FLOOR', 'WARP_CARPET_DOWN', 'WARP_CARPET', 'LADDER', 'STAIRS', 'DOOR', 'FLOOR_UP_WALL', 'GRASS', 'TALL_GRASS'}\n    \n    # BFS to find reachable tiles\n    reachable = set()\n    queue = collections.deque([(px, py)])\n    reachable.add((px, py))\n    parent = {}\n\n    while queue:\n        cx, cy = queue.popleft()\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) in tiles and (nx, ny) not in reachable:\n                tile = tiles[(nx, ny)]\n                if tile['type'] in traversable and not tile['has_obj']:\n                    reachable.add((nx, ny))\n                    parent[(nx, ny)] = (cx, cy)\n                    queue.append((nx, ny))\n    \n    # Identify unseen tiles adjacent to reachable tiles\n    unseen_targets = []\n    for rx, ry in reachable:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = rx + dx, ry + dy\n            if (nx, ny) in tiles:\n                if not tiles[(nx, ny)]['seen']:\n                    unseen_targets.append((nx, ny, rx, ry))\n            elif 0 <= nx < width and 0 <= ny < height:\n                # Boundary tile not in 'tiles' dict implies unseen\n                unseen_targets.append((nx, ny, rx, ry))\n\n    if not auto:\n        # Return coordinates of unseen tiles\n        unique_unseen = []\n        seen_coords = set()\n        for ux, uy, rx, ry in unseen_targets:\n            if (ux, uy) not in seen_coords:\n                unique_unseen.append({\"x\": ux, \"y\": uy})\n                seen_coords.add((ux, uy))\n        print(json.dumps(unique_unseen))\n    else:\n        # Return buttons to reach the closest reachable tile adjacent to an unseen one\n        if not unseen_targets:\n            print(\"[]\")\n            return\n            \n        # Dijkstra-like BFS for distance\n        dist = {(px, py): 0}\n        q = collections.deque([(px, py)])\n        while q:\n            cx, cy = q.popleft()\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = cx + dx, cy + dy\n                if (nx, ny) in reachable and (nx, ny) not in dist:\n                    dist[(nx, ny)] = dist[(cx, cy)] + 1\n                    q.append((nx, ny))\n                    \n        # Find best target (closest reachable tile with unseen neighbor)\n        best_target = None\n        min_dist = float('inf')\n        for ux, uy, rx, ry in unseen_targets:\n            if (rx, ry) in dist and dist[(rx, ry)] < min_dist:\n                min_dist = dist[(rx, ry)]\n                best_target = (rx, ry)\n                \n        if best_target:\n            # Reconstruct path\n            path = []\n            curr = best_target\n            while curr != (px, py):\n                path.append(curr)\n                curr = parent[curr]\n            path.reverse()\n            \n            # Convert to buttons\n            buttons = []\n            cx, cy = px, py\n            for nx, ny in path:\n                if nx > cx: buttons.append(\"Right\")\n                elif nx < cx: buttons.append(\"Left\")\n                elif ny > cy: buttons.append(\"Down\")\n                elif ny < cy: buttons.append(\"Up\")\n                cx, cy = nx, ny\n            print(json.dumps(buttons))\n        else:\n            print(\"[]\")\n\nif __name__ == \"__main__\":\n    solve()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-21T01:42:51.206Z",
        "action_counter": 7635
      },
      {
        "commit_message": "Refined traversable tiles to match verified mechanics in notepad and added object collision check.",
        "timestamp": "2025-12-21T01:51:20.552Z",
        "action_counter": 7655
      },
      {
        "commit_message": "Added FLOOR_UP_WALL to traversable tiles and updated description to clarify output.",
        "timestamp": "2025-12-21T02:16:24.728Z",
        "action_counter": 7707
      },
      {
        "commit_message": "Added WATER to traversable tiles to support exploration while surfing.",
        "timestamp": "2025-12-21T02:28:00.542Z",
        "action_counter": 7736
      },
      {
        "commit_message": "Fixing autopress_buttons logic to return a button array instead of coordinates when enabled.",
        "timestamp": "2025-12-21T04:13:20.660Z",
        "action_counter": 7952
      }
    ]
  },
  "battle_move_selector": {
    "description": "Selects a move from the move selection menu in battle. Assumes the menu is open and the cursor is at the first move (index 0).",
    "input_schema": {
      "type": "object",
      "properties": {
        "move_index": {
          "type": "integer",
          "description": "The 0-indexed position of the move to select (0-3)."
        }
      },
      "required": [
        "move_index"
      ]
    },
    "python_script": "import json\nmove_index = int(input_data['move_index'])\n# Add a longer sleep to ensure the move menu is fully open before directional inputs\nbuttons = [\"sleep 500\"] + (['Down'] * move_index) + ['A']\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-21T03:35:53.973Z",
        "action_counter": 7878
      },
      {
        "commit_message": "Added a sleep command to the start of the button sequence to ensure the move menu is fully open before directional inputs are applied. This prevents mis-navigation into the PACK menu.",
        "timestamp": "2025-12-21T03:42:45.741Z",
        "action_counter": 7891
      },
      {
        "commit_message": "Increased sleep time to 500ms to provide more buffer for the menu transition animation, preventing mis-navigation into the main menu options.",
        "timestamp": "2025-12-21T03:45:45.715Z",
        "action_counter": 7897
      }
    ]
  },
  "find_path_v3": {
    "description": "Finds the shortest path to a target coordinate. Correctly handles walls, NPCs, and items.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y",
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\nimport sys\n\ndef solve():\n    try:\n        data = json.loads(sys.argv[1])\n        start_x = int(data['start_x'])\n        start_y = int(data['start_y'])\n        target_x = int(data['target_x'])\n        target_y = int(data['target_y'])\n        \n        root = ET.fromstring(map_xml_string)\n        grid = {}\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                t_type = tile.attrib['type']\n                # COLLISION: WALL, COUNTER, BOOKSHELF, TABLE, MART_SHELF\n                is_wall = t_type in ['WALL', 'COUNTER', 'BOOKSHELF', 'TABLE', 'MART_SHELF']\n                \n                # Objects (NPCs, Items) are walls\n                obj = tile.find('Object')\n                if obj is not None:\n                    # Exception: if it's the player's current tile or the target tile (for warps/events)\n                    if not (x == start_x and y == start_y) and not (x == target_x and y == target_y):\n                        is_wall = True\n                \n                grid[(x, y)] = not is_wall\n\n        # BFS\n        queue = deque([(start_x, start_y, [])])\n        visited = {(start_x, start_y)}\n        while queue:\n            x, y, path = queue.popleft()\n            if x == target_x and y == target_y:\n                return path\n            for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n                nx, ny = x + dx, y + dy\n                if (nx, ny) in grid and grid[(nx, ny)] and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [btn]))\n        return []\n    except Exception as e:\n        return [str(e)]\n\nprint(json.dumps(solve()))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-21T05:16:03.605Z",
        "action_counter": 8076
      },
      {
        "commit_message": "Refined find_path_v3 to ignore markers and handle collisions more accurately. Added MART_SHELF to impassable types.",
        "timestamp": "2025-12-21T05:32:39.553Z",
        "action_counter": 8101
      }
    ]
  },
  "switch_pokemon_v1": {
    "description": "Switches the active Pokémon to the one at the specified party index (0-5). Assumes the PKMN menu is open and the cursor is at the first Pokémon (index 0).",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_index": {
          "type": "integer",
          "description": "The 0-indexed position of the Pokémon to switch to (0-5)."
        }
      },
      "required": [
        "target_index"
      ]
    },
    "python_script": "import json\nimport sys\n\ndef solve():\n    try:\n        data = json.loads(sys.argv[1])\n        target_index = int(data['target_index'])\n        # Assumes cursor is at index 0 in the party list\n        buttons = []\n        for _ in range(target_index):\n            buttons.append(\"Down\")\n        buttons.append(\"A\") # Select Pokemon\n        buttons.append(\"A\") # Choose 'SHIFT'\n        return buttons\n    except Exception as e:\n        return [str(e)]\n\nprint(json.dumps(solve()))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-21T05:20:50.975Z",
        "action_counter": 8084
      },
      {
        "commit_message": "Refined switch_pokemon_v1 to ensure correct menu navigation by pressing directional buttons before selecting.",
        "timestamp": "2025-12-21T05:32:39.555Z",
        "action_counter": 8101
      }
    ]
  }
}