{
  "object_finder": {
    "description": "Finds a specific map object by its ID and returns its coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "object_id": {
          "type": "string"
        }
      },
      "required": [
        "object_id"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntarget_id = input_data['object_id']\nroot = ET.fromstring(map_xml_string)\nfound = False\nfor row in root.findall('Row'):\n    y = row.get('id')\n    for tile in row.findall('Tile'):\n        x = tile.get('id')\n        for obj in tile.findall('Object'):\n            if obj.get('id') == target_id:\n                print(json.dumps({'x': x, 'y': y}))\n                found = True\n                break\n        if found:\n            break\n    if found:\n        break\n\nif not found:\n    print(json.dumps({'error': 'Object not found on screen.'}))"
  },
  "pathfinder": {
    "description": "A* pathfinding tool that finds the shortest path between two points on the current map. It takes start and end coordinates, a list of traversable tile types, and returns a sequence of coordinates to follow the path. It has improved logic to handle one-way ledges and find paths to tiles adjacent to impassable destinations. Now includes a debug mode.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "traversable_tiles": {
          "type": "string",
          "description": "A comma-separated string of tile types that are considered traversable."
        },
        "debug": {
          "type": "string",
          "description": "Optional. Set to 'true' to enable debug logging."
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "traversable_tiles"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef to_coordinate_list(path):\n    return [{'x': p[0], 'y': p[1]} for p in path]\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    traversable_tiles_str = input_data.get('traversable_tiles', '')\n    traversable_tiles = {tile.strip() for tile in traversable_tiles_str.split(',')}\n    debug_mode = input_data.get('debug', 'false').lower() == 'true'\n    debug_log = []\n\n    if debug_mode:\n        debug_log.append(f\"Pathfinder starting from ({start_x}, {start_y}) to ({end_x}, {end_y})\")\n        debug_log.append(f\"Traversable tiles: {traversable_tiles}\")\n\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    tile_data = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id'])\n            tile_type = tile_elem.attrib['type']\n            has_object = tile_elem.attrib.get('has-object') == 'true'\n            tile_data[(x, y)] = {'type': tile_type, 'has_object': has_object}\n\n    start_node = (start_x, start_y)\n    target_node = (end_x, end_y)\n    \n    actual_end_node = None\n    end_node_info = tile_data.get(target_node)\n    \n    if end_node_info and end_node_info['type'] in traversable_tiles and not end_node_info['has_object']:\n        actual_end_node = target_node\n    else:\n        potential_ends = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_node = (target_node[0] + dx, target_node[1] + dy)\n            adj_info = tile_data.get(adj_node)\n            if adj_info and adj_info['type'] in traversable_tiles and not adj_info['has_object']:\n                dist = abs(adj_node[0] - start_node[0]) + abs(adj_node[1] - start_node[1])\n                heapq.heappush(potential_ends, (dist, adj_node))\n        \n        if potential_ends:\n            _, actual_end_node = heapq.heappop(potential_ends)\n\n    if actual_end_node is None:\n        error_msg = \"No path found. Destination and all adjacent tiles are unreachable.\"\n        if debug_mode:\n            debug_log.append(error_msg)\n            print(json.dumps({\"debug_log\": debug_log, \"error\": error_msg}))\n        else:\n            print(json.dumps({\"error\": error_msg}))\n        exit()\n    \n    if debug_mode:\n        debug_log.append(f\"Actual end node: {actual_end_node}\")\n\n    open_set = []\n    heapq.heappush(open_set, (0, start_node))\n    came_from = {}\n    g_score = {start_node: 0}\n    closed_set = set()\n\n    path_found = False\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current in closed_set:\n            continue\n        closed_set.add(current)\n\n        if current == actual_end_node:\n            path = []\n            temp = current\n            while temp in came_from:\n                path.append(temp)\n                temp = came_from[temp]\n            path.append(start_node)\n            path.reverse()\n            coordinate_path = to_coordinate_list(path)\n            if debug_mode:\n                debug_log.append(f\"Final Path Found: {coordinate_path}\")\n                print(json.dumps({\"debug_log\": debug_log, \"path\": coordinate_path}))\n            else:\n                print(json.dumps({\"path\": coordinate_path}))\n            path_found = True\n            break\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n\n            if not (1 <= neighbor[0] <= width and 1 <= neighbor[1] <= height):\n                continue\n\n            neighbor_info = tile_data.get(neighbor)\n            current_info = tile_data.get(current)\n            \n            is_traversable = neighbor_info and neighbor_info['type'] in traversable_tiles and not neighbor_info['has_object']\n            if debug_mode:\n                debug_log.append(f\"Checking neighbor {neighbor} of {current}. Type: {neighbor_info['type'] if neighbor_info else 'N/A'}. Traversable: {is_traversable}\")\n\n            if not is_traversable:\n                continue\n\n            if current_info and current_info['type'] == 'LEDGE_HOP_DOWN' and dy == -1: continue\n            if current_info and current_info['type'] == 'LEDGE_HOP_LEFT' and dx == 1: continue\n            if current_info and current_info['type'] == 'LEDGE_HOP_RIGHT' and dx == -1: continue\n            \n            is_current_fuw = current_info and current_info['type'] == 'FLOOR_UP_WALL'\n            is_neighbor_fuw = neighbor_info['type'] == 'FLOOR_UP_WALL'\n            if is_neighbor_fuw and not is_current_fuw:\n                if dy != -1: continue\n            elif is_current_fuw and not is_neighbor_fuw:\n                if dy != 1: continue\n            elif is_current_fuw and is_neighbor_fuw:\n                if dy != 0: continue\n\n            tentative_g_score = g_score.get(current, float('inf')) + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score = tentative_g_score + abs(neighbor[0] - actual_end_node[0]) + abs(neighbor[1] - actual_end_node[1])\n                heapq.heappush(open_set, (f_score, neighbor))\n    \n    if not path_found:\n        error_msg = \"No path found.\"\n        if debug_mode:\n            debug_log.append(error_msg)\n            print(json.dumps({\"debug_log\": debug_log, \"error\": error_msg}))\n        else:\n            print(json.dumps({\"error\": error_msg}))\nexcept Exception as e:\n    error_msg = f\"An error occurred: {e}\"\n    # Use locals() to check if debug_log was defined to avoid NameError\n    if 'debug_log' in locals() and 'debug_mode' in locals() and debug_mode:\n        debug_log.append(error_msg)\n        print(json.dumps({\"debug_log\": debug_log, \"error\": error_msg}))\n    else:\n        print(json.dumps({\"error\": error_msg}))"
  },
  "warp_scanner": {
    "description": "Scans the current map XML and returns the coordinates of all warp tiles that do not have a map marker.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\nroot = ET.fromstring(map_xml_string)\nunmarked_warps = []\nfor row_elem in root.findall('Row'):\n    for tile_elem in row_elem.findall('Tile'):\n        if tile_elem.attrib.get('is-warp') == 'true':\n            has_marker = False\n            for child in tile_elem:\n                if child.tag == 'Marker':\n                    has_marker = True\n                    break\n            if not has_marker:\n                x = tile_elem.attrib['id']\n                y = row_elem.attrib['id']\n                unmarked_warps.append({'x': int(x), 'y': int(y)})\nprint(json.dumps({'unmarked_warps': unmarked_warps}))"
  },
  "puzzle_solver_step": {
    "description": "Calculates the next single button press to solve the Ruins of Alph tile puzzle. It takes the current puzzle grid, target grid, cursor position, and whether a piece is being held, and returns the next single D-pad or 'A' button press.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_grid": {
          "type": "string"
        },
        "target_grid": {
          "type": "string"
        },
        "cursor_x": {
          "type": "string"
        },
        "cursor_y": {
          "type": "string"
        },
        "holding_piece": {
          "type": "string"
        },
        "held_piece_id": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "start_grid",
        "target_grid",
        "cursor_x",
        "cursor_y",
        "holding_piece"
      ]
    },
    "python_script": "import json\nimport heapq\n\ndef parse_grid_input(grid_str):\n    grid = {}\n    pieces = grid_str.replace('[', '').replace(']', '').split(') ')\n    for piece_str in pieces:\n        if not piece_str:\n            continue\n        parts = piece_str.strip().split(' (')\n        name_part = parts[0]\n        coord_part = parts[1].replace(')', '')\n        x_str, y_str = coord_part.split(',')\n        x, y = int(x_str), int(y_str)\n        if \"Piece\" in name_part:\n            piece_id = int(name_part.split(' ')[1])\n            grid[(x, y)] = piece_id\n        else:\n            grid[(x, y)] = 0\n    return grid\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(start, goal, grid):\n    neighbors = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    close_set = set()\n    came_from = {}\n    gscore = {start: 0}\n    fscore = {start: heuristic(start, goal)}\n    oheap = []\n    heapq.heappush(oheap, (fscore[start], start))\n    while oheap:\n        current = heapq.heappop(oheap)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        close_set.add(current)\n        for i, j in neighbors:\n            neighbor = current[0] + i, current[1] + j\n            if 0 <= neighbor[0] < 6 and 0 <= neighbor[1] < 6:\n                tentative_g_score = gscore[current] + 1\n                if neighbor in close_set and tentative_g_score >= gscore.get(neighbor, 0):\n                    continue\n                if tentative_g_score < gscore.get(neighbor, 0) or neighbor not in [i[1] for i in oheap]:\n                    came_from[neighbor] = current\n                    gscore[neighbor] = tentative_g_score\n                    fscore[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                    heapq.heappush(oheap, (fscore[neighbor], neighbor))\n    return []\n\ndef get_move(current, next_pos):\n    dx = next_pos[0] - current[0]\n    dy = next_pos[1] - current[1]\n    if dx == 1: return \"Right\"\n    if dx == -1: return \"Left\"\n    if dy == 1: return \"Down\"\n    if dy == -1: return \"Up\"\n    return \"A\"\n\ntry:\n    start_grid_str = input_data['start_grid']\n    target_grid_str = input_data['target_grid']\n    cursor_x = int(input_data['cursor_x'])\n    cursor_y = int(input_data['cursor_y'])\n    holding_piece = input_data['holding_piece'].lower() == 'true'\n    held_piece_id_str = input_data.get('held_piece_id')\n    held_piece_id = int(held_piece_id_str) if held_piece_id_str and held_piece_id_str != 'null' else None\n    start_grid = parse_grid_input(start_grid_str)\n    target_grid = parse_grid_input(target_grid_str)\n    cursor_pos = (cursor_x, cursor_y)\n    action = \"\"\n    if not holding_piece:\n        piece_to_move = -1\n        current_pos = None\n        for i in range(1, 17):\n            current_piece_pos = next((pos for pos, pid in start_grid.items() if pid == i), None)\n            target_piece_pos = next((pos for pos, pid in target_grid.items() if pid == i), None)\n            if current_piece_pos != target_piece_pos:\n                piece_to_move = i\n                current_pos = current_piece_pos\n                break\n        if piece_to_move != -1:\n            if cursor_pos == current_pos:\n                action = \"A\"\n            else:\n                path = a_star_search(cursor_pos, current_pos, start_grid)\n                if path:\n                    action = get_move(cursor_pos, path[0])\n                else:\n                    action = \"Start\"\n    else:\n        target_pos = next((pos for pos, pid in target_grid.items() if pid == held_piece_id), None)\n        if target_pos:\n            if start_grid.get(target_pos, 0) != 0:\n                blocking_piece_id = start_grid[target_pos]\n                blocking_piece_target_pos = next((pos for pos, pid in target_grid.items() if pid == blocking_piece_id), None)\n                empty_spot = next((pos for pos, pid in start_grid.items() if pid == 0 and pos != target_pos and pos != blocking_piece_target_pos), None)\n                if empty_spot:\n                    if cursor_pos == target_pos:\n                        action = \"A\"\n                    else:\n                        path = a_star_search(cursor_pos, target_pos, start_grid)\n                        if path:\n                            action = get_move(cursor_pos, path[0])\n                        else:\n                            action = \"Start\"\n                else:\n                    action = \"Start\"\n            else:\n                if cursor_pos == target_pos:\n                    action = \"A\"\n                else:\n                    path = a_star_search(cursor_pos, target_pos, start_grid)\n                    if path:\n                        action = get_move(cursor_pos, path[0])\n                    else:\n                        action = \"Start\"\n        else:\n             action = \"Start\"\n    print(json.dumps({\"action\": action}))\nexcept Exception as e:\n    print(json.dumps({\"action\": \"Start\", \"error\": str(e)}))"
  }
}