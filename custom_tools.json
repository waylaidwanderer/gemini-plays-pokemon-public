{
  "master_navigator": {
    "description": "A consolidated navigation tool that handles pathfinding. It can find a path to a specific coordinate. It now considers map markers for obstacles and correctly handles ledges and transitions between different traversable tile types. Includes an option to ignore objects for testing purposes. THIS IS A DEBUG VERSION.",
    "input_schema": {
      "type": "object",
      "properties": {
        "mode": {
          "type": "string",
          "enum": [
            "pathfind"
          ]
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer",
          "nullable": true
        },
        "end_y": {
          "type": "integer",
          "nullable": true
        },
        "traversable_tiles": {
          "type": "string"
        },
        "ignore_objects": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "mode",
        "start_x",
        "start_y",
        "traversable_tiles"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\nimport sys\n\nsys.stderr = sys.stdout\n\ndef find_path(map_xml_string, start_x, start_y, end_x, end_y, traversable_tiles_str, ignore_objects_str):\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n\n        traversable_tiles = traversable_tiles_str.split(',')\n        ignore_objects = ignore_objects_str.lower() == 'true' if ignore_objects_str else False\n        \n        print(f\"Master Navigator Debug: Start=({start_x},{start_y}), End=({end_x},{end_y}), Traversable={traversable_tiles}, IgnoreObjects={ignore_objects}\")\n\n        grid = [[False for _ in range(width)] for _ in range(height)]\n        \n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            if not (1 <= y <= height): continue\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                if not (1 <= x <= width): continue\n\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                is_player_tile = tile_elem.find('Player') is not None\n                \n                is_traversable = tile_type in traversable_tiles\n                \n                # DEBUG PRINT\n                print(f\"  Tile ({x},{y}): type={tile_type}, has_object={has_object}, is_player={is_player_tile}, initial_traversable={is_traversable}\")\n\n                if has_object and not is_player_tile and not ignore_objects:\n                    is_traversable = False\n                    print(f\"    -> Marked as NOT traversable due to object.\")\n                \n                # UPDATED LOGIC TO CHECK ALL OBJECT MARKERS\n                for marker in tile_elem.findall('Marker'):\n                    if marker.get('object_id') is not None and not ignore_objects:\n                        is_traversable = False\n                        print(f\"    -> Marked as NOT traversable due to object marker {marker.get('emoji')}.\")\n                        break\n                \n                if is_traversable or is_player_tile:\n                    grid[y-1][x-1] = True\n\n        def heuristic(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n        start = (start_x - 1, start_y - 1)\n        goal = (end_x - 1, end_y - 1)\n\n        if not (0 <= start[0] < width and 0 <= start[1] < height and grid[start[1]][start[0]]):\n            return {\"error\": f\"Start ({start_x},{start_y}) is not on a traversable tile.\"}\n        \n        if not (0 <= goal[0] < width and 0 <= goal[1] < height):\n            return {\"error\": f\"Goal ({end_x},{end_y}) is outside map boundaries.\"}\n\n        if not grid[goal[1]][goal[0]]:\n            found_new_goal = False\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_goal_candidate = (goal[0] + dx, goal[1] + dy)\n                if 0 <= new_goal_candidate[0] < width and 0 <= new_goal_candidate[1] < height and grid[new_goal_candidate[1]][new_goal_candidate[0]]:\n                    goal = new_goal_candidate\n                    found_new_goal = True\n                    break\n            if not found_new_goal:\n                 return {\"error\": f\"Goal ({end_x},{end_y}) and all adjacent tiles are not traversable.\"}\n\n        open_set = [(0, start)]\n        came_from = {}\n        g_score = { (c,r): float('inf') for r in range(height) for c in range(width) }\n        g_score[start] = 0\n        f_score = { (c,r): float('inf') for r in range(height) for c in range(width) }\n        f_score[start] = heuristic(start, goal)\n        \n        while open_set:\n            _, current = heapq.heappop(open_set)\n\n            if current == goal:\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(start)\n                path_coords = [{'x': x + 1, 'y': y + 1} for x, y in reversed(path)]\n                return path_coords\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                neighbor = (current[0] + dx, current[1] + dy)\n                nx, ny = neighbor\n\n                if not (0 <= nx < width and 0 <= ny < height and grid[ny][nx]):\n                    continue\n\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, goal)\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n        \n        return {\"error\": \"No path found.\"}\n\n    except Exception as e:\n        import traceback\n        return {\"error\": str(e), \"traceback\": traceback.format_exc()}\n\ntry:\n    mode = input_data['mode']\n    if mode == 'pathfind':\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        end_x = int(input_data.get('end_x'))\n        end_y = int(input_data.get('end_y'))\n        traversable_tiles_str = input_data['traversable_tiles']\n        ignore_objects_str = input_data.get('ignore_objects')\n\n        path = find_path(map_xml_string, start_x, start_y, end_x, end_y, traversable_tiles_str, ignore_objects_str)\n\n        if isinstance(path, dict) and \"error\" in path:\n            print(json.dumps(path))\n        elif path:\n            print(json.dumps({\"path\": path}))\n        else:\n            print(json.dumps({\"error\": \"No path found.\"}))\n    else:\n        print(json.dumps({\"error\": f\"Invalid mode: {mode}\"}))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({\"error\": f\"Tool execution failed: {str(e)}\", \"traceback\": traceback.format_exc()}))\n"
  },
  "puzzle_solver": {
    "description": "Solves state-based puzzles, like boulder mazes, by finding a sequence of moves from a start to a goal state. It uses a breadth-first search algorithm.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "goal_x": {
          "type": "integer"
        },
        "goal_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "goal_x",
        "goal_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve_boulder_puzzle(start_pos, goal_pos, initial_boulders, walls, width, height):\n    queue = deque([(start_pos, initial_boulders, [])])\n    visited = set([(start_pos, tuple(sorted(initial_boulders)))])\n\n    while queue:\n        (player_x, player_y), boulders, path = queue.popleft()\n\n        if (player_x, player_y) == goal_pos:\n            return path\n\n        for move_x, move_y, move_dir in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            next_x, next_y = player_x + move_x, player_y + move_y\n\n            if not (0 <= next_x < width and 0 <= next_y < height) or (next_x, next_y) in walls:\n                continue\n\n            boulder_at_next = (next_x, next_y) in boulders\n            if boulder_at_next:\n                push_to_x, push_to_y = next_x + move_x, next_y + move_y\n                if (push_to_x, push_to_y) in walls or (push_to_x, push_to_y) in boulders:\n                    continue\n                \n                new_boulders = set(boulders)\n                new_boulders.remove((next_x, next_y))\n                new_boulders.add((push_to_x, push_to_y))\n                new_boulders_tuple = tuple(sorted(list(new_boulders)))\n                \n                # The player moves into the boulder's old spot\n                new_player_pos = (next_x, next_y)\n                state = (new_player_pos, new_boulders_tuple)\n                if state not in visited:\n                    visited.add(state)\n                    new_path = path + [f'Push boulder at ({next_x},{next_y}) {move_dir}']\n                    queue.append((new_player_pos, new_boulders, new_path))\n            else:\n                new_player_pos = (next_x, next_y)\n                state = (new_player_pos, tuple(sorted(boulders)))\n                if state not in visited:\n                    visited.add(state)\n                    new_path = path + [move_dir]\n                    queue.append((new_player_pos, boulders, new_path))\n    return None\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\n\nwalls = set()\nboulders = set()\nplayer_pos = None\n\nfor y, row in enumerate(root.findall('Row')):\n    for x, tile in enumerate(row.findall('Tile')):\n        tile_type = tile.get('type')\n        if tile_type == 'WALL':\n            walls.add((x, y))\n        if tile.find('Object') is not None and tile.find('Object').get('id-name') == 'BOULDER':\n            boulders.add((x, y))\n        if tile.find('Player') is not None:\n            player_pos = (x, y)\n        if tile.find('Object') is not None and tile.find('Object').get('id-name') != 'BOULDER': # Treat other objects as walls\n             walls.add((x, y))\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['goal_x'])\nend_y = int(input_data['goal_y'])\n\nif player_pos:\n    start_pos = (start_x, start_y)\n    goal_pos = (end_x, end_y)\n    \n    # Since the puzzle state might be different from the player's current position,\n    # we need to simulate from the puzzle's reset state.\n    # For Cianwood Gym, the initial state is specific.\n    initial_boulders_state = {(3, 6), (4, 4), (5, 6)}\n    initial_player_pos = (4, 8) # Reset tile\n    \n    solution = solve_boulder_puzzle(initial_player_pos, goal_pos, initial_boulders_state, walls, width, height)\n    \n    if solution:\n        print(\"Solution found:\")\n        for step in solution:\n            print(step)\n    else:\n        print(\"No solution found.\")\nelse:\n    print(\"Player not found on map.\")"
  }
}