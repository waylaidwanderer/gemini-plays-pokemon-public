{
  "find_path_v2": {
    "description": "Finds the shortest path between two coordinates, supporting land-to-water (Surf) transitions, ledge jumps, and whirlpool clearing. Returns a JSON array of buttons.",
    "input_schema": {
      "properties": {
        "avoid_warps": {
          "default": true,
          "type": "boolean"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ],
      "type": "object"
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\nimport json\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n    except:\n        print(\"[]\")\n        return\n\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    tiles = {}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            has_obj = tile.find('Object') is not None\n            is_warp = tile.attrib.get('is-warp') == 'true'\n            tiles[(x, y)] = {'type': t_type, 'obj': has_obj, 'is_warp': is_warp}\n\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    avoid_warps = input_data.get('avoid_warps', True)\n    \n    start = (start_x, start_y)\n    goal = (end_x, end_y)\n    \n    start_tile = tiles.get(start)\n    if not start_tile:\n        print(\"[]\")\n        return\n    is_start_water = start_tile['type'] in ['WATER', 'WHIRLPOOL']\n    \n    queue = collections.deque([(start[0], start[1], is_start_water, [])])\n    visited = set([(start[0], start[1], is_start_water)])\n    \n    while queue: \n        x, y, surfing, path = queue.popleft()\n        \n        if (x, y) == goal:\n            print(json.dumps(path))\n            return\n            \n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < width and 0 <= ny < height:\n                target = tiles.get((nx, ny))\n                if not target: continue\n                \n                if avoid_warps and target['is_warp'] and (nx, ny) != goal:\n                    continue\n                \n                t_type = target['type']\n                is_water = t_type == 'WATER'\n                is_whirlpool = t_type == 'WHIRLPOOL'\n                is_wall = t_type in ['WALL', 'BUOY', 'FLOOR_UP_WALL', 'HEADBUTT_TREE'] or target['obj']\n                is_ledge = t_type in ['LEDGE', 'LEDGE_HOP_DOWN']\n                \n                if not surfing:\n                    if is_wall: continue\n                    if is_ledge:\n                        if btn == 'Down':\n                            nnx, nny = nx, ny + 1\n                            if 0 <= nnx < width and 0 <= nny < height:\n                                l_target = tiles.get((nnx, nny))\n                                if l_target and l_target['type'] not in ['WALL', 'BUOY', 'WHIRLPOOL'] and not l_target['obj']:\n                                    new_p = path + [btn, 'sleep 500']\n                                    if (nnx, nny, False) not in visited:\n                                        visited.add((nnx, nny, False))\n                                        queue.append((nnx, nny, False, new_p))\n                        continue\n                    \n                    if is_water:\n                        new_p = path + [btn, 'A', 'sleep 500', 'A', 'sleep 500', 'A', 'sleep 500', btn]\n                        if (nx, ny, True) not in visited:\n                            visited.add((nx, ny, True))\n                            queue.append((nx, ny, True, new_p))\n                    elif is_whirlpool:\n                        new_p = path + [btn, 'A', 'sleep 500', 'A', 'sleep 500', 'A', 'sleep 500', btn, 'A', 'sleep 500', 'A', 'sleep 500', btn]\n                        if (nx, ny, True) not in visited:\n                            visited.add((nx, ny, True))\n                            queue.append((nx, ny, True, new_p))\n                    else:\n                        new_p = path + [btn]\n                        if (nx, ny, False) not in visited:\n                            visited.add((nx, ny, False))\n                            queue.append((nx, ny, False, new_p))\n                else:\n                    if is_wall or is_ledge: continue\n                    if is_water:\n                        new_p = path + [btn]\n                        if (nx, ny, True) not in visited:\n                            visited.add((nx, ny, True))\n                            queue.append((nx, ny, True, new_p))\n                    elif is_whirlpool:\n                        new_p = path + [btn, 'A', 'sleep 500', 'A', 'sleep 500', 'A', 'sleep 500', btn]\n                        if (nx, ny, True) not in visited:\n                            visited.add((nx, ny, True))\n                            queue.append((nx, ny, True, new_p))\n                    else:\n                        new_p = path + [btn]\n                        if (nx, ny, False) not in visited:\n                            visited.add((nx, ny, False))\n                            queue.append((nx, ny, False, new_p))\n    print(\"[]\")\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T20:27:16.465Z",
        "action_counter": 29425
      },
      {
        "commit_message": "Refined to correctly identify objects using 'has-object' attribute and added logic for boulder bridges in pits.",
        "timestamp": "2025-12-28T20:30:14.390Z",
        "action_counter": 29431
      },
      {
        "commit_message": "Refined to correctly handle autopress_buttons by outputting button strings and fixed pathfinding logic for boulder bridges.",
        "timestamp": "2025-12-28T20:30:50.776Z",
        "action_counter": 29432
      },
      {
        "commit_message": "Refined to handle boulder bridges in Blackthorn Gym 1F and improved object detection.",
        "timestamp": "2025-12-28T20:47:40.334Z",
        "action_counter": 29458
      },
      {
        "commit_message": "Fixing missing commit message and improving tile passability logic.",
        "timestamp": "2025-12-28T22:59:48.479Z",
        "action_counter": 29673
      },
      {
        "commit_message": "Fix find_path_v2 by providing a commit message and using input_data correctly.",
        "timestamp": "2025-12-29T03:29:03.821Z",
        "action_counter": 30041
      },
      {
        "commit_message": "Refine find_path_v2 to treat PIT and LADDER tiles as obstacles by default to prevent accidental warps, unless they are the intended destination.",
        "timestamp": "2025-12-29T04:09:14.393Z",
        "action_counter": 30092
      },
      {
        "commit_message": "Refine find_path_v2 to treat all warp tiles (PIT, LADDER) as obstacles unless they are the specific destination, and correctly identify objects using 'has-object'.",
        "timestamp": "2025-12-29T04:10:34.909Z",
        "action_counter": 30094
      },
      {
        "commit_message": "Initial definition with ledge handling.",
        "timestamp": "2026-01-06T20:56:57.721Z",
        "action_counter": 30778
      },
      {
        "commit_message": "Added commit message to update tool.",
        "timestamp": "2026-01-06T21:16:09.438Z",
        "action_counter": 30812
      },
      {
        "commit_message": "Refined ledge handling: ledges are now impassable from all directions except the jump direction. Added more impassable tile types.",
        "timestamp": "2026-01-06T21:17:48.184Z",
        "action_counter": 30816
      },
      {
        "commit_message": "Added CAVE and WARP to impassable tiles to prevent accidental map transitions.",
        "timestamp": "2026-01-06T21:27:34.747Z",
        "action_counter": 30833
      },
      {
        "commit_message": "Added avoid_warps parameter and object detection logic. Refined ledge and warp handling.",
        "timestamp": "2026-01-06T21:37:49.308Z",
        "action_counter": 30841
      },
      {
        "commit_message": "Removed 'unseen' from impassable_base to allow exploration pathing.",
        "timestamp": "2026-01-06T21:53:26.245Z",
        "action_counter": 30871
      },
      {
        "commit_message": "Removed 'unseen' from impassable tiles to allow exploration pathing. Added avoid_warps parameter. Refined ledge and object handling.",
        "timestamp": "2026-01-06T21:58:47.153Z",
        "action_counter": 30880
      },
      {
        "commit_message": "Initial definition with correct schema and logic.",
        "timestamp": "2026-01-07T09:27:38.973Z",
        "action_counter": 32021
      },
      {
        "commit_message": "Refined find_path_v2 to treat HEADBUTT_TREE as an obstacle and allow player to move from their current tile.",
        "timestamp": "2026-01-07T12:10:42.415Z",
        "action_counter": 32283
      },
      {
        "commit_message": "Refined find_path_v2 to handle ledge hopping (LEDGE_HOP_DOWN, LEFT, RIGHT) as one-way jump transitions.",
        "timestamp": "2026-01-07T12:55:12.814Z",
        "action_counter": 32363
      },
      {
        "commit_message": "Fixed the tool to always return a JSON array (empty if no path found) and added basic error handling for XML parsing.",
        "timestamp": "2026-01-09T01:04:39.975Z",
        "action_counter": 35402
      },
      {
        "commit_message": "Added BUOY to the list of obstacles and ensured it returns a JSON array of buttons.",
        "timestamp": "2026-01-09T01:06:48.407Z",
        "action_counter": 35404
      },
      {
        "commit_message": "Refined find_path_v2 to handle avoid_warps parameter and improved obstacle detection logic for better pathfinding in both walking and surfing scenarios.",
        "timestamp": "2026-01-09T01:13:38.129Z",
        "action_counter": 35415
      },
      {
        "commit_message": "Refined find_path_v2 to handle land/water transitions by checking the player's current tile type. If on land, WATER is an obstacle (unless Surfing is intended). If on water, FLOOR is an obstacle (unless landing is intended). Added support for landing on adjacent FLOOR tiles.",
        "timestamp": "2026-01-09T01:18:32.241Z",
        "action_counter": 35424
      },
      {
        "commit_message": "Refined find_path_v2 to allow transitions from land to water (initiating Surf) during pathfinding. This allows the tool to generate paths that include entering the water from an adjacent land tile.",
        "timestamp": "2026-01-09T01:22:42.025Z",
        "action_counter": 35431
      },
      {
        "commit_message": "Refined land-to-water transition logic to include 'A' press and pauses for Surfing.",
        "timestamp": "2026-01-09T03:09:43.002Z",
        "action_counter": 35647
      },
      {
        "commit_message": "Refined land-to-water transition in find_path_v2 to include movement button after dialogue.",
        "timestamp": "2026-01-09T03:12:21.889Z",
        "action_counter": 35651
      },
      {
        "commit_message": "Refined whirlpool handling in find_path_v2 to treat WHIRLPOOL tiles as traversable with interaction sequence.",
        "timestamp": "2026-01-09T03:40:30.503Z",
        "action_counter": 35701
      }
    ]
  },
  "press_menu_buttons": {
    "description": "Presses a sequence of buttons to navigate menus, bypassing the directional/action mixing restriction. Use for menu navigation ONLY. Returns the sequence of buttons as a JSON array.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nprint(json.dumps(input_data['buttons']))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-29T01:56:30.654Z",
        "action_counter": 29934
      }
    ]
  },
  "ice_pathfinder_v2": {
    "description": "Finds a path through ice sliding puzzles in Pokemon Crystal. Handles sliding until an obstacle or non-ice tile is hit, and jumps over ledges in the valid direction. Returns a JSON array of button strings (e.g., [\"Up\", \"Down\"]).",
    "input_schema": {
      "type": "object",
      "properties": {
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n        grid = {}\n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                x = int(tile.get('id'))\n                t_type = tile.get('type')\n                has_obj = tile.find('Object') is not None\n                # Include FLOOR_UP_WALL as a blocked type\n                grid[(x, y)] = {'type': t_type, 'blocked': has_obj or t_type in ['WALL', 'VOID', 'FLOOR_UP_WALL']}\n\n        start = (int(input_data['start_x']), int(input_data['start_y']))\n        end = (int(input_data['end_x']), int(input_data['end_y']))\n\n        queue = deque([(start[0], start[1], [])])\n        visited = {start}\n        \n        while queue:\n            cx, cy, path = queue.popleft()\n            if (cx, cy) == end:\n                print(json.dumps(path))\n                return\n                \n            for dx, dy, btn in [(0, -1, \"Up\"), (0, 1, \"Down\"), (-1, 0, \"Left\"), (1, 0, \"Right\")]:\n                nx, ny = cx + dx, cy + dy\n                \n                # Check if next tile is blocked, but ALLOW the destination tile even if it has an object\n                if (nx, ny) not in grid or (grid[(nx, ny)]['blocked'] and (nx, ny) != end):\n                    continue\n\n                # Handle Ledges (Manual jump logic)\n                curr_type = grid[(cx, cy)]['type']\n                if curr_type == 'LEDGE_HOP_DOWN' and btn == 'Down': nx, ny = cx, cy + 2\n                elif curr_type == 'LEDGE_HOP_UP' and btn == 'Up': nx, ny = cx, cy - 2\n                elif curr_type == 'LEDGE_HOP_LEFT' and btn == 'Left': nx, ny = cx - 2, cy\n                elif curr_type == 'LEDGE_HOP_RIGHT' and btn == 'Right': nx, ny = cx + 2, cy\n                \n                if (nx, ny) not in grid or (grid[(nx, ny)]['blocked'] and (nx, ny) != end):\n                    continue\n                \n                # Ice Sliding\n                if grid[(nx, ny)]['type'] == 'ICE' and (nx, ny) != end:\n                    while True:\n                        tx, ty = nx + dx, ny + dy\n                        if (tx, ty) not in grid or (grid[(tx, ty)]['blocked'] and (tx, ty) != end): break\n                        \n                        next_type = grid[(tx, ty)]['type']\n                        # Stop on ledge tiles to jump? In Crystal, sliding into a ledge jumps automatically.\n                        if next_type == 'LEDGE_HOP_DOWN' and btn == 'Down': \n                            nx, ny = tx, ty + 2\n                            break\n                        elif next_type == 'LEDGE_HOP_UP' and btn == 'Up':\n                            nx, ny = tx, ty - 2\n                            break\n                        elif next_type == 'LEDGE_HOP_LEFT' and btn == 'Left':\n                            nx, ny = tx - 2, ty\n                            break\n                        elif next_type == 'LEDGE_HOP_RIGHT' and btn == 'Right':\n                            nx, ny = tx + 2, ty\n                            break\n                        \n                        nx, ny = tx, ty\n                        if (nx, ny) == end or grid[(nx, ny)]['type'] != 'ICE': break\n                \n                if (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [btn]))\n        print(\"[]\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-09T08:31:11.309Z",
        "action_counter": 36237
      },
      {
        "commit_message": "Refined ice_pathfinder_v2 to return a JSON array of button strings and correctly handle ice sliding and ledge jumping.",
        "timestamp": "2026-01-09T09:02:31.849Z",
        "action_counter": 36279
      },
      {
        "commit_message": "Modified ice_pathfinder_v2 to allow the destination tile to be 'blocked' (e.g. by an object) so items can be targeted.",
        "timestamp": "2026-01-09T09:08:29.834Z",
        "action_counter": 36289
      },
      {
        "commit_message": "Updated ice_pathfinder_v2 to include 'FLOOR_UP_WALL' in the list of blocked tile types.",
        "timestamp": "2026-01-09T09:27:01.306Z",
        "action_counter": 36314
      }
    ]
  },
  "find_reachable_unseen_tiles": {
    "description": "Finds all unseen tiles that are adjacent to reachable walkable tiles on the current map.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        print(json.dumps({\"error\": f\"Failed to parse XML: {str(e)}\"}))\n        return\n\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            t_type = tile.get('type')\n            seen = tile.get('seen') == 'true'\n            has_object = tile.get('has-object') == 'true'\n            grid[(x, y)] = (t_type, seen, has_object)\n\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    \n    walkable_types = {'FLOOR', 'TALL_GRASS', 'WATER', 'LADDER', 'BUOY', 'DOOR', 'CAVE', 'WARP_CARPET_DOWN', 'WARP_CARPET_UP', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'LEDGE_HOP_DOWN', 'LEDGE_HOP_UP', 'LEDGE_HOP_LEFT', 'LEDGE_HOP_RIGHT'}\n    \n    reachable = set()\n    queue = deque([(start_x, start_y)])\n    reachable.add((start_x, start_y))\n    \n    while queue:\n        cx, cy = queue.popleft()\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in reachable:\n                if (nx, ny) in grid:\n                    t_type, seen, has_object = grid[(nx, ny)]\n                    if seen and t_type in walkable_types and not has_object:\n                        reachable.add((nx, ny))\n                        queue.append((nx, ny))\n    \n    unseen_reachable = []\n    for rx, ry in reachable:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = rx + dx, ry + dy\n            if 0 <= nx < width and 0 <= ny < height:\n                if (nx, ny) in grid:\n                    t_type, seen, has_object = grid[(nx, ny)]\n                    if not seen:\n                        unseen_reachable.append({'x': nx, 'y': ny, 'adjacent_to': {'x': rx, 'y': ry}})\n    \n    unique_unseen = []\n    seen_coords = set()\n    for item in unseen_reachable:\n        coord = (item['x'], item['y'])\n        if coord not in seen_coords:\n            unique_unseen.append(item)\n            seen_coords.add(coord)\n            \n    print(json.dumps(unique_unseen))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-09T11:27:25.878Z",
        "action_counter": 36502
      }
    ]
  },
  "find_closest_unseen_path_v2": {
    "description": "Finds the closest unseen tile adjacent to a reachable walkable tile and returns a JSON array of buttons to reach the adjacent walkable tile.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef find_closest_unseen_path(xml_str, start_x, start_y):\n    root = ET.fromstring(xml_str)\n    grid = {}\n    for row in root.findall(\"Row\"):\n        y = int(row.attrib['id'])\n        for tile in row.findall(\"Tile\"):\n            x = int(tile.attrib['id'])\n            grid[(x, y)] = {\n                'type': tile.attrib['type'],\n                'seen': tile.attrib['seen'] == 'true',\n                'has_object': tile.get('has-object') == 'true'\n            }\n            \n    queue = deque([(start_x, start_y, [])])\n    visited = set([(start_x, start_y)])\n    \n    walkable = [\"FLOOR\", \"TALL_GRASS\", \"LONG_GRASS\", \"BRIDGE\", \"LADDER\", \"STAIRS\", \"DOOR\", \"WARP_CARPET_UP\", \"WARP_CARPET_DOWN\", \"WARP_CARPET_LEFT\", \"WARP_CARPET_RIGHT\"]\n    \n    while queue:\n        x, y, path = queue.popleft()\n        \n        for dx, dy, btn in [(0, -1, \"Up\"), (0, 1, \"Down\"), (-1, 0, \"Left\"), (1, 0, \"Right\")]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) in grid:\n                if not grid[(nx, ny)]['seen']:\n                    return path\n                \n                if (nx, ny) not in visited:\n                    t_info = grid[(nx, ny)]\n                    if t_info['type'] in walkable and not t_info['has_object']:\n                        visited.add((nx, ny))\n                        queue.append((nx, ny, path + [btn]))\n    return []\n\n# map_xml_string is globally available\nbuttons = find_closest_unseen_path(map_xml_string, input_data['start_x'], input_data['start_y'])\nprint(json.dumps(buttons))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-09T12:24:12.057Z",
        "action_counter": 36603
      }
    ]
  }
}