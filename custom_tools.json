{
  "find_path": {
    "description": "Calculates the shortest path from the player's current position to a target coordinate (x, y) on the current map. It avoids impassable tiles and objects. If the target tile itself is impassable (e.g., occupied by an NPC), it will find a path to an adjacent, traversable tile. Outputs a JSON list of coordinate dictionaries for use with `path_plan`.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef find_path_logic_v2():\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.get('width'))\n    map_height = int(root.get('height'))\n    player_tile = root.find('.//Player/..')\n    if player_tile is None:\n        print(json.dumps([]))\n        return\n    start_x = int(player_tile.get('id'))\n    start_y = int(player_tile.get('coordinate').split(',')[1].strip(')'))\n    \n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n    except (KeyError, ValueError):\n        print(json.dumps([]))\n        return\n\n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tile_type = tile.get('type')\n            is_impassable = tile_type in ['WALL', 'WATER', 'COUNTER', 'HEADBUTT_TREE', 'CUT_TREE'] or tile.find('Object') is not None\n            grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n\n    target_tile_info = grid.get((target_x, target_y))\n    targets = []\n    if target_tile_info and not target_tile_info['impassable']:\n        targets.append((target_x, target_y))\n    else:\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            adj_x, adj_y = target_x + dx, target_y + dy\n            if grid.get((adj_x, adj_y)) and not grid[(adj_x, adj_y)]['impassable']:\n                targets.append((adj_x, adj_y))\n    \n    if not targets:\n        print(json.dumps([]))\n        return\n\n    queue = deque([((start_x, start_y), [])])\n    visited = {(start_x, start_y)}\n\n    while queue:\n        (current_x, current_y), path = queue.popleft()\n\n        if (current_x, current_y) in targets:\n            full_path = [{'x': start_x, 'y': start_y}] + [{'x': p[0], 'y': p[1]} for p in path]\n            print(json.dumps(full_path))\n            return\n\n        for move, dx, dy in [('Up', 0, -1), ('Down', 0, 1), ('Left', -1, 0), ('Right', 1, 0)]:\n            next_x, next_y = current_x + dx, current_y + dy\n            \n            if not (1 <= next_x <= map_width and 1 <= next_y <= map_height) or (next_x, next_y) in visited:\n                continue\n\n            next_tile_info = grid.get((next_x, next_y))\n            current_tile_info = grid.get((current_x, current_y))\n            \n            if not next_tile_info or next_tile_info['impassable']:\n                continue\n            \n            if current_tile_info:\n                if (current_tile_info.get('type') == 'LEDGE_HOP_DOWN' and move != 'Down') or \\\n                   (current_tile_info.get('type') == 'LEDGE_HOP_LEFT' and move != 'Left') or \\\n                   (current_tile_info.get('type') == 'LEDGE_HOP_RIGHT' and move != 'Right'):\n                    continue\n\n            visited.add((next_x, next_y))\n            new_path = path + [(next_x, next_y)]\n            queue.append(((next_x, next_y), new_path))\n\n    print(json.dumps([]))\n\nfind_path_logic_v2()\n"
  },
  "find_reachable_unseen_tiles": {
    "description": "Analyzes the current map to find all unseen tiles that are adjacent to seen, traversable tiles and determines which of them are actually reachable from the player's current position. Outputs a JSON list of coordinate dictionaries for reachable unseen tiles.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef find_reachable_unseen_tiles_logic():\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.get('width'))\n    map_height = int(root.get('height'))\n    player_tile = root.find('.//Player/..')\n    if player_tile is None:\n        print(json.dumps([]))\n        return\n    start_x = int(player_tile.get('id'))\n    start_y = int(player_tile.get('coordinate').split(',')[1].strip(')'))\n\n    grid = {}\n    unseen_targets = []\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tile_type = tile.get('type')\n            seen = tile.get('seen') == 'true'\n            is_impassable = tile_type in ['WALL', 'WATER', 'COUNTER', 'HEADBUTT_TREE', 'CUT_TREE'] or tile.find('Object') is not None\n            grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable, 'seen': seen}\n\n    for (x, y), tile_info in grid.items():\n        if not tile_info['seen']:\n            for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                adj_x, adj_y = x + dx, y + dy\n                adj_tile = grid.get((adj_x, adj_y))\n                if adj_tile and adj_tile['seen'] and not adj_tile['impassable']:\n                    unseen_targets.append((x, y))\n                    break\n    \n    if not unseen_targets:\n        print(json.dumps([]))\n        return\n\n    queue = deque([((start_x, start_y), [])])\n    visited = {(start_x, start_y)}\n    reachable_unseen = []\n\n    # BFS to find all reachable tiles\n    reachable_nodes = { (start_x, start_y) }\n    q = deque([(start_x, start_y)])\n    visited_bfs = {(start_x, start_y)}\n\n    while q:\n        curr_x, curr_y = q.popleft()\n        \n        for move, dx, dy in [('Up', 0, -1), ('Down', 0, 1), ('Left', -1, 0), ('Right', 1, 0)]:\n            next_x, next_y = curr_x + dx, curr_y + dy\n\n            if not (1 <= next_x <= map_width and 1 <= next_y <= map_height) or (next_x, next_y) in visited_bfs:\n                continue\n\n            next_tile_info = grid.get((next_x, next_y))\n            current_tile_info = grid.get((curr_x, curr_y))\n            \n            if not next_tile_info or next_tile_info['impassable']:\n                continue\n            \n            if current_tile_info:\n                if (current_tile_info.get('type') == 'LEDGE_HOP_DOWN' and move != 'Down') or \\\n                   (current_tile_info.get('type') == 'LEDGE_HOP_LEFT' and move != 'Left') or \\\n                   (current_tile_info.get('type') == 'LEDGE_HOP_RIGHT' and move != 'Right'):\n                    continue\n            \n            visited_bfs.add((next_x, next_y))\n            reachable_nodes.add((next_x, next_y))\n            q.append((next_x, next_y))\n\n    # Check which of the unseen_targets are in the set of reachable_nodes\n    final_reachable = []\n    for tx, ty in unseen_targets:\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            adj_x, adj_y = tx + dx, ty + dy\n            if (adj_x, adj_y) in reachable_nodes:\n                final_reachable.append({'x': tx, 'y': ty})\n                break\n\n    print(json.dumps(final_reachable))\n\nfind_reachable_unseen_tiles_logic()\n"
  }
}