{
  "exp_calculator_tool": {
    "description": "Calculates the average EXP gain from a list of wild Pokémon encounters.",
    "input_schema": {
      "type": "object",
      "properties": {
        "encounters": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "pokemon_name": {
                "type": "string"
              },
              "level": {
                "type": "integer"
              },
              "exp_yield": {
                "type": "integer"
              }
            },
            "required": [
              "pokemon_name",
              "level",
              "exp_yield"
            ]
          }
        }
      },
      "required": [
        "encounters"
      ]
    },
    "python_script": "import json\n\ndef exp_calculator(input_data):\n    encounters = input_data['encounters']\n    if not encounters:\n        return 'No encounters provided.'\n    total_exp = sum(e['exp_yield'] for e in encounters)\n    average_exp = total_exp / len(encounters)\n    return f'Average EXP gain: {average_exp:.2f}'\n\nresult = exp_calculator(json.loads(input_data))\nprint(result)"
  },
  "inventory_scanner": {
    "description": "Scans the player's inventory list for a target item and returns whether it was found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory_list": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "inventory_list",
        "target_item"
      ]
    },
    "python_script": "import json\n\ntry:\n    inventory_list = json.loads(input_data['inventory_list'])\n    target_item = input_data['target_item']\n    found = False\n    for item in inventory_list:\n        if target_item.lower() in item.lower():\n            found = True\n            break\n    print(f'Item found: {found}')\nexcept Exception as e:\n    print(f'An error occurred: {e}')"
  },
  "pathfinder": {
    "description": "Calculates the shortest path from the player's current position to a target coordinate. It now requires party data to verify HMs (Surf, Strength, Cut) and can handle optional impassable coordinates. It includes logic for 'steps' and 'ledges', finds paths to adjacent tiles for impassable targets, and correctly handles land-to-water transitions for SURF. Outputs a JSON array for the path_plan.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "party_data": {
          "type": "string",
          "description": "A stringified JSON array of the player's party Pokémon, including their moves and fainted status."
        },
        "impassable_coords": {
          "type": "string",
          "description": "An optional stringified JSON array of coordinates to treat as impassable, e.g., '[{\"x\": 8, \"y\": 13}]'",
          "nullable": true
        }
      },
      "required": [
        "target_x",
        "target_y",
        "party_data"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef find_path(input_data):\n    def parse_map(xml_string):\n        root = ET.fromstring(xml_string)\n        grid = {}\n        player_pos = None\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                is_warp = tile_elem.get('is-warp') == 'true'\n                object_id_name = None\n                obj_elem = tile_elem.find('Object')\n                if obj_elem is not None:\n                    object_id_name = obj_elem.get('id-name')\n                if tile_elem.find('Player') is not None:\n                    player_pos = (x, y)\n                grid[(x, y)] = {'type': tile_type, 'has_object': has_object, 'is_warp': is_warp, 'object_id_name': object_id_name}\n        return grid, player_pos, int(root.get('width')), int(root.get('height'))\n\n    def has_hm(party, hm_name):\n        if party is None: return False\n        for pokemon in party:\n            if not pokemon.get('is_fainted', False):\n                for move in pokemon.get('moves', []):\n                    if isinstance(move, dict) and move.get('name') == hm_name: return True\n                    elif isinstance(move, str) and move == hm_name: return True\n        return False\n\n    def is_traversable(from_coord, to_coord, grid, party, impassable_coords):\n        if to_coord in impassable_coords: return False\n        if to_coord not in grid: return False\n        from_tile = grid[from_coord]\n        to_tile = grid[to_coord]\n        from_type = from_tile['type']\n        to_type = to_tile['type']\n\n        if to_type == 'impassable': return False\n        if to_tile['has_object'] and not to_tile['is_warp'] and to_tile.get('object_id_name') != 'PIKACHU': return False\n\n        if to_type == 'ledge':\n            return from_coord[1] == to_coord[1] - 1 and from_coord[0] == to_coord[0]\n\n        if to_type == 'water':\n            if from_type in ['ground', 'steps', 'grass'] and has_hm(party, 'SURF'):\n                return True\n            return from_type == 'water'\n        if from_type == 'water':\n            return to_type in ['ground', 'steps', 'grass']\n\n        valid_land_types = {'ground', 'grass', 'elevated_ground', 'steps', 'ladder_up', 'ladder_down'}\n        if from_type in valid_land_types and to_type in valid_land_types:\n            if (from_type == 'steps' and to_type in ['ground', 'elevated_ground', 'grass']) or \\\n               (to_type == 'steps' and from_type in ['ground', 'elevated_ground', 'grass']):\n                return True\n            if from_type == to_type:\n                return True\n            if from_type in ['ground', 'grass'] and to_type in ['ground', 'grass']:\n                return True\n            if from_type in ['ladder_up', 'ladder_down'] or to_type in ['ladder_up', 'ladder_down']:\n                return True\n            return False\n\n        return False\n\n    def get_neighbors(node, grid, party, map_width, map_height, impassable_coords):\n        x, y = node\n        neighbors = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 1 <= nx <= map_width and 1 <= ny <= map_height:\n                if is_traversable((x, y), (nx, ny), grid, party, impassable_coords):\n                    cost = 1\n                    to_tile_type = grid.get((nx, ny), {}).get('type')\n                    if to_tile_type == 'ledge' and dy == 1:\n                        if is_traversable((nx, ny), (nx, ny + 1), grid, party, impassable_coords):\n                           neighbors.append(((nx, ny + 1), cost))\n                        continue \n                    neighbors.append(((nx, ny), cost))\n        return neighbors\n\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def a_star(start, goal, grid, party, map_width, map_height, impassable_coords):\n        original_goal = goal\n        goal_tile = grid.get(goal)\n        \n        is_goal_valid = False\n        if goal_tile and goal_tile['type'] != 'impassable' and not (goal_tile['has_object'] and not goal_tile['is_warp'] and goal_tile.get('object_id_name') != 'PIKACHU') and goal not in impassable_coords:\n            is_goal_valid = True\n\n        if not is_goal_valid:\n            found_new_goal = False\n            sorted_neighbors = sorted([(dx, dy) for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]],\n                                      key=lambda p: heuristic(start, (original_goal[0] + p[0], original_goal[1] + p[1])))\n            for dx, dy in sorted_neighbors:\n                new_goal = (original_goal[0] + dx, original_goal[1] + dy)\n                if new_goal in grid:\n                    new_goal_tile = grid[new_goal]\n                    if new_goal_tile['type'] != 'impassable' and not (new_goal_tile['has_object'] and not new_goal_tile['is_warp'] and new_goal_tile.get('object_id_name') != 'PIKACHU') and new_goal not in impassable_coords:\n                        goal = new_goal\n                        found_new_goal = True\n                        break\n            if not found_new_goal: return None\n\n        frontier = [(0, start)]\n        came_from = {start: None}\n        cost_so_far = {start: 0}\n        while frontier:\n            _, current = heapq.heappop(frontier)\n            if current == goal: break\n            for next_node, cost in get_neighbors(current, grid, party, map_width, map_height, impassable_coords):\n                new_cost = cost_so_far[current] + cost\n                if next_node not in cost_so_far or new_cost < cost_so_far[next_node]:\n                    cost_so_far[next_node] = new_cost\n                    priority = new_cost + heuristic(goal, next_node)\n                    heapq.heappush(frontier, (priority, next_node))\n                    came_from[next_node] = current\n        else: return None\n        path = []\n        current = goal\n        while current is not None: path.append(current); current = came_from.get(current)\n        path.reverse()\n        return path\n\n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n        party_str = input_data['party_data']\n        party = json.loads(party_str) if party_str and party_str != 'null' else []\n        impassable_coords_str = input_data.get('impassable_coords')\n        impassable_coords = []\n        if impassable_coords_str and impassable_coords_str != 'null':\n            impassable_coords_list = json.loads(impassable_coords_str)\n            impassable_coords = [tuple(c.values()) for c in impassable_coords_list]\n\n        grid, player_pos, map_width, map_height = parse_map(map_xml_string)\n        if player_pos is None: raise ValueError('Player position not found.')\n        path_plan = a_star(player_pos, (target_x, target_y), grid, party, map_width, map_height, impassable_coords)\n        if path_plan:\n            print(json.dumps({'path_plan': [{'x': x, 'y': y} for x, y in path_plan]}))\n        else:\n            print(json.dumps({'error': 'No path found to the target.'}))\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': f'An error occurred: {str(e)}', 'traceback': traceback.format_exc()}))\n\nfind_path(input_data)"
  },
  "spinner_maze_solver": {
    "description": "Finds the shortest path in a spinner maze. It parses the map_xml_string, builds a graph including spinner traversals, and uses A* to find the path from the player's position to a target coordinate. Handles impassable targets by pathing to an adjacent tile. This version correctly handles spinner loops.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef spinner_maze_solver(input_data, map_xml_string):\n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n        root = ET.fromstring(map_xml_string)\n    except (ValueError, ET.ParseError):\n        print(json.dumps({'error': 'Invalid input or map data.'}))\n        return\n\n    tile_map = {}\n    player_pos = None\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            has_obj = tile_elem.find('Object') is not None and tile_elem.find('Object').get('id-name') != 'PIKACHU'\n            spinner_info = tile_elem.find('Spinner')\n            spinner_direction = spinner_info.get('direction') if spinner_info is not None else None\n            tile_map[(x, y)] = {'type': tile_type, 'has_obj': has_obj, 'spinner': spinner_direction}\n            if tile_elem.find('Player') is not None:\n                player_pos = (x, y)\n\n    if not player_pos:\n        print(json.dumps({'error': 'Player position not found.'}))\n        return\n\n    def is_walkable(coord):\n        if coord not in tile_map: return False\n        tile = tile_map[coord]\n        if tile['has_obj']: return False\n        return tile['type'] not in ['impassable', 'boulder_barrier', 'unknown', 'closed_gate']\n\n    def get_spinner_destination(start_coord):\n        x, y = start_coord\n        path = [start_coord]\n        visited = {start_coord}\n        while tile_map.get((x,y), {}).get('spinner') and tile_map[(x,y)]['spinner'] != 'stop':\n            direction = tile_map[(x, y)]['spinner']\n            if direction == 'up': y -= 1\n            elif direction == 'down': y += 1\n            elif direction == 'left': x -= 1\n            elif direction == 'right': x += 1\n            if not (1 <= x <= width and 1 <= y <= height) or (x, y) in visited:\n                return None, [] # Loop or out of bounds\n            visited.add((x, y))\n            path.append((x, y))\n        return (x, y), path\n\n    target_node = (target_x, target_y)\n    if not is_walkable(target_node):\n        # Find adjacent walkable tile if target is not\n        found_new_target = False\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            adj_target = (target_x + dx, target_y + dy)\n            if is_walkable(adj_target):\n                target_node = adj_target\n                found_new_target = True\n                break\n        if not found_new_target:\n            print(json.dumps({'error': 'Target is impassable and no adjacent traversable tile found.'}))\n            return\n\n    open_set = [(0, player_pos)]\n    came_from = {}\n    g_score = {player_pos: 0}\n\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == target_node:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(player_pos)\n            path.reverse()\n            \n            final_path = []\n            for i in range(len(path) - 1):\n                start_node = path[i]\n                final_path.append(start_node)\n                if tile_map[start_node]['spinner']:\n                    _, spin_path = get_spinner_destination(start_node)\n                    if spin_path and len(spin_path) > 1:\n                        final_path.extend(spin_path[1:])\n            if path[-1] not in final_path:\n                final_path.append(path[-1])\n\n            print(json.dumps([{'x': x, 'y': y} for x, y in final_path]))\n            return\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not is_walkable(neighbor): continue\n\n            move_cost = 1\n            final_dest = neighbor\n            if tile_map[neighbor]['spinner']:\n                dest, spin_path = get_spinner_destination(neighbor)\n                if dest is None: continue # Spinner leads to loop/invalid state\n                final_dest = dest\n                move_cost = len(spin_path)\n            \n            tentative_g_score = g_score[current] + move_cost\n            if final_dest not in g_score or tentative_g_score < g_score[final_dest]:\n                g_score[final_dest] = tentative_g_score\n                f_score = tentative_g_score + heuristic(final_dest, target_node)\n                heapq.heappush(open_set, (f_score, final_dest))\n                came_from[final_dest] = current\n\n    print(json.dumps({'error': 'No path found.'}))\n\nspinner_maze_solver(input_data, map_xml_string)"
  },
  "boulder_puzzle_solver": {
    "description": "Analyzes the map XML for a boulder puzzle and provides a step-by-step solution. This version includes A* pathfinding to ensure the player can reach the boulders before attempting a push. It correctly handles puzzles with more boulders than switches, includes an iteration limit, and validates that the player can reach the exact push position. **This version now correctly checks for the SURF HM and allows the player pathfinding to traverse water tiles.**",
    "input_schema": {
      "type": "object",
      "properties": {
        "boulder_coords": {
          "type": "string"
        },
        "switch_coords": {
          "type": "string"
        },
        "party_data": {
          "type": "string"
        }
      },
      "required": [
        "boulder_coords",
        "switch_coords",
        "party_data"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\nfrom collections import deque\n\ndef solve_boulder_puzzle(input_data):\n    grid = {}\n    player_pos = None\n    map_width = 0\n    map_height = 0\n    party_data = []\n\n    def parse_map_and_party(xml_string, party_str):\n        nonlocal grid, player_pos, map_width, map_height, party_data\n        root = ET.fromstring(xml_string)\n        map_width = int(root.get('width'))\n        map_height = int(root.get('height'))\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                is_warp = tile_elem.get('is-warp') == 'true'\n                object_id_name = None\n                obj_elem = tile_elem.find('Object')\n                if obj_elem is not None:\n                    object_id_name = obj_elem.get('id-name')\n                if tile_elem.find('Player') is not None:\n                    player_pos = (x, y)\n                grid[(x, y)] = {'type': tile_type, 'has_object': has_object, 'is_warp': is_warp, 'object_id_name': object_id_name}\n        party_data = json.loads(party_str) if party_str else []\n\n    def has_hm(hm_name):\n        for pokemon in party_data:\n            if not pokemon.get('is_fainted', False):\n                for move in pokemon.get('moves', []):\n                    if isinstance(move, dict) and move.get('name') == hm_name: return True\n                    elif isinstance(move, str) and move == hm_name: return True\n        return False\n\n    def is_player_traversable(from_coord, to_coord, current_boulders):\n        if to_coord not in grid: return False\n        to_tile = grid[to_coord]\n        from_tile = grid[from_coord]\n        from_type = from_tile['type']\n        to_type = to_tile['type']\n\n        if to_type in ['impassable', 'boulder_barrier'] or to_coord in current_boulders: return False\n        if to_tile['has_object'] and not to_tile['is_warp'] and to_tile.get('object_id_name') != 'PIKACHU': return False\n        \n        if to_type == 'water' and has_hm('SURF'):\n            if from_type in ['ground', 'steps', 'grass', 'water']:\n                return True\n        if from_type == 'water' and to_type in ['ground', 'steps', 'grass'] and has_hm('SURF'):\n            return True\n\n        valid_land_types = {'ground', 'grass', 'steps', 'elevated_ground', 'ladder_up', 'ladder_down'}\n        if from_type in valid_land_types and to_type in valid_land_types:\n            if from_type == 'steps' and to_type in {'ground', 'grass', 'elevated_ground', 'steps'}: return True\n            if to_type == 'steps' and from_type in {'ground', 'grass', 'elevated_ground'}: return True\n            if from_type == to_type: return True\n            if from_type in {'ground', 'grass'} and to_type in {'ground', 'grass'}: return True\n            if from_type in {'ladder_up', 'ladder_down'} or to_type in {'ladder_up', 'ladder_down'}: return True\n            return False\n        return False\n\n    def get_player_neighbors(node, current_boulders):\n        x, y = node\n        neighbors = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 1 <= nx <= map_width and 1 <= ny <= map_height:\n                if is_player_traversable((x, y), (nx, ny), current_boulders):\n                    neighbors.append((nx, ny))\n        return neighbors\n\n    def player_a_star(start, goal, current_boulders):\n        frontier = [(0, start)]\n        came_from = {start: None}\n        cost_so_far = {start: 0}\n        max_iterations = 2000\n        iterations = 0\n        while frontier:\n            iterations += 1\n            if iterations > max_iterations: return None\n            _, current = heapq.heappop(frontier)\n            if current == goal: break\n            for next_node in get_player_neighbors(current, current_boulders):\n                new_cost = cost_so_far[current] + 1\n                if next_node not in cost_so_far or new_cost < cost_so_far[next_node]:\n                    cost_so_far[next_node] = new_cost\n                    priority = new_cost + abs(goal[0] - next_node[0]) + abs(goal[1] - next_node[1])\n                    heapq.heappush(frontier, (priority, next_node))\n                    came_from[next_node] = current\n        else: return None\n        path = []\n        current = goal\n        while current is not None: path.append(current); current = came_from.get(current)\n        path.reverse()\n        return path\n\n    def get_boulder_neighbors(state, current_player_pos):\n        neighbors = []\n        boulders = set(state)\n        for i, boulder in enumerate(state):\n            bx, by = boulder\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                player_pos_req = (bx - dx, by - dy)\n                new_boulder_pos = (bx + dx, by + dy)\n                if new_boulder_pos in boulders or new_boulder_pos not in grid or grid[new_boulder_pos]['type'] in ['impassable', 'boulder_barrier'] or (grid[new_boulder_pos]['has_object'] and not grid[new_boulder_pos]['is_warp'] and grid[new_boulder_pos].get('object_id_name') != 'PIKACHU'): continue\n                path_to_push = player_a_star(current_player_pos, player_pos_req, boulders)\n                if path_to_push:\n                    new_state_list = list(state)\n                    new_state_list[i] = new_boulder_pos\n                    new_state_tuple = tuple(sorted(new_state_list))\n                    move = {'boulder_index': i, 'start_pos': boulder, 'end_pos': new_boulder_pos, 'player_path': path_to_push}\n                    neighbors.append((new_state_tuple, move))\n        return neighbors\n\n    def puzzle_heuristic(state, switches):\n        total_dist = 0\n        unplaced_boulders = sorted([b for b in state if b not in switches])\n        open_switches = sorted([s for s in switches if s not in state])\n        for boulder in unplaced_boulders:\n            if not open_switches: break\n            min_dist = float('inf')\n            best_switch = None\n            for switch in open_switches:\n                dist = abs(boulder[0] - switch[0]) + abs(boulder[1] - switch[1])\n                if dist < min_dist: min_dist = dist; best_switch = switch\n            total_dist += min_dist\n            if best_switch: open_switches.remove(best_switch)\n        return total_dist\n\n    def puzzle_a_star_solver(start_state, switches, initial_player_pos):\n        start_node = (tuple(sorted(start_state)), initial_player_pos)\n        frontier = [(puzzle_heuristic(start_node[0], switches), start_node)]\n        came_from = {start_node: (None, None)}\n        cost_so_far = {start_node: 0}\n        max_iterations = 15000\n        iterations = 0\n        while frontier:\n            iterations += 1\n            if iterations > max_iterations: return 'timeout'\n            _, current_node = heapq.heappop(frontier)\n            current_state, current_player_pos = current_node\n            if len(switches) > 0 and set(switches).issubset(set(current_state)):\n                path = []\n                curr = current_node\n                while curr is not None:\n                    parent, move = came_from.get(curr, (None, None))\n                    if move: path.append(move)\n                    curr = parent\n                path.reverse()\n                return path\n            for next_state, move in get_boulder_neighbors(current_state, current_player_pos):\n                new_cost = cost_so_far[current_node] + 1\n                next_player_pos = move['start_pos']\n                next_node = (next_state, next_player_pos)\n                if next_node not in cost_so_far or new_cost < cost_so_far[next_node]:\n                    cost_so_far[next_node] = new_cost\n                    priority = new_cost + puzzle_heuristic(next_state, switches)\n                    heapq.heappush(frontier, (priority, next_node))\n                    came_from[next_node] = (current_node, move)\n        return None\n\n    try:\n        parse_map_and_party(map_xml_string, input_data['party_data'])\n        boulder_coords = [tuple(coord) for coord in json.loads(input_data['boulder_coords'])]\n        switch_coords = [tuple(coord) for coord in json.loads(input_data['switch_coords'])]\n        solution = puzzle_a_star_solver(boulder_coords, switch_coords, player_pos)\n        if solution == 'timeout':\n            print(json.dumps({'error': 'Solver timed out after too many iterations.'}))\n        elif solution:\n            print(json.dumps({'solution_path': solution}))\n        else:\n            print(json.dumps({'error': 'No solution found for the puzzle.'}))\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': f'An error occurred: {str(e)}', 'traceback': traceback.format_exc()}))\n\nsolve_boulder_puzzle(input_data)\n"
  }
}