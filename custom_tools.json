{
  "find_path": {
    "description": "Calculates a path from the player's current position to a target coordinate (x, y) using BFS. Returns a JSON array of button presses. Automatically detects if the player is surfing to treat WATER tiles as traversable. Treats tiles with objects, object-linked markers, markers labeled 'Hole', 'PIT' tiles, 'LADDER' tiles, and 'BUOY' tiles as obstacles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "# injected imports [\"sys\", \"json\"]\n# injected variables [\"map_xml_string\", \"input_data\"]\n\nimport xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n        \n        # Get player position\n        p_tile = root.find(\".//Tile[@has-player='true']\")\n        if p_tile is None:\n            print(\"[]\")\n            return\n\n        start_x = int(p_tile.get('id'))\n        start_y = int(p_tile.get('coordinate').split(',')[1].strip(') '))\n        start_type = p_tile.get('type')\n        \n        if 'target_x' not in input_data or 'target_y' not in input_data:\n             print(\"[]\")\n             return\n\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n        \n        grid = {}\n        # Base obstacles that are always impassable\n        base_obstacles = {\n            \"WALL\", \"COUNTER\", \"PC\", \"SIGN\", \"TREE\", \"ROCK\", \"BOULDER\", \"WHIRLPOOL\", \n            \"LEDGE_DOWN\", \"LEDGE_UP\", \"LEDGE_LEFT\", \"LEDGE_RIGHT\", \n            \"LEDGE_HOP_DOWN\", \"LEDGE_HOP_UP\", \"LEDGE_HOP_LEFT\", \"LEDGE_HOP_RIGHT\",\n            \"WINDOW\", \"DOOR_LOCKED\", \"HEADBUTT_TREE\", \"PIT\", \"LADDER\", \"BUOY\"\n        }\n        \n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                x = int(tile.get('id'))\n                t_type = tile.get('type')\n                has_object = tile.get('has-object') == 'true'\n                \n                walkable = True\n                \n                # Check base obstacles\n                if t_type in base_obstacles:\n                    walkable = False\n                \n                # Context-aware water logic\n                # If we are NOT on water, WATER tiles are obstacles (need Surf)\n                if start_type != \"WATER\" and t_type == \"WATER\":\n                    walkable = False\n                # If we ARE on water, WATER tiles are walkable.\n                \n                # Check for objects (NPCs, items, etc) - they are walls\n                if has_object:\n                    walkable = False\n                \n                # Check for Markers\n                for marker in tile.findall('Marker'):\n                    label = marker.text or \"\"\n                    emoji = marker.get('emoji') or \"\"\n                    obj_id = marker.get('object_id')\n                    \n                    if \"Hole\" in label or \"üï≥Ô∏è\" in emoji:\n                        walkable = False\n                    \n                    if obj_id:\n                        walkable = False\n\n                grid[(x, y)] = walkable\n\n        # Logic: If target is blocked (e.g. it's a LADDER or PIT or Object), path to nearest adjacent walkable\n        target_walkable = grid.get((target_x, target_y), False)\n        targets = set()\n        \n        if target_walkable:\n            targets.add((target_x, target_y))\n        else:\n            # If target is obstacle, allow adjacent tiles\n            for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                nx, ny = target_x + dx, target_y + dy\n                if grid.get((nx, ny), False):\n                    targets.add((nx, ny))\n            \n            if not targets:\n                print(\"[]\")\n                return\n\n        # BFS\n        queue = deque([(start_x, start_y, [])])\n        visited = set([(start_x, start_y)])\n        \n        while queue:\n            cx, cy, path = queue.popleft()\n            \n            if (cx, cy) in targets:\n                buttons = []\n                curr_x, curr_y = start_x, start_y\n                for (nx, ny) in path:\n                    if nx > curr_x: buttons.append(\"Right\")\n                    elif nx < curr_x: buttons.append(\"Left\")\n                    elif ny > curr_y: buttons.append(\"Down\")\n                    elif ny < curr_y: buttons.append(\"Up\")\n                    curr_x, curr_y = nx, ny\n                print(json.dumps(buttons))\n                return\n\n            for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                nx, ny = cx + dx, cy + dy\n                if (nx, ny) not in visited and grid.get((nx, ny), False):\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [(nx, ny)]))\n                    \n        print(\"[]\")\n\n    except Exception as e:\n        print(\"[]\")\n\nsolve()",
    "history": [
      {
        "commit_message": "feat: Add find_path tool. Calculates shortest path using BFS, handling walls, objects, and one-way ledges.",
        "timestamp": "2025-11-20T08:35:46.882Z",
        "action_counter": 924
      },
      {
        "commit_message": "fix: Add LADDER to traversable basic_types in find_path. Previously, the tool considered LADDER tiles as walls, preventing pathfinding to or from them.",
        "timestamp": "2025-11-20T10:46:07.670Z",
        "action_counter": 1068
      },
      {
        "commit_message": "fix: Add FLOOR_UP_WALL to traversable tiles when moving down. This tile type appears on Route 32 and visually resembles a ledge, so it is assumed to be jumpable from the north.",
        "timestamp": "2025-11-20T21:10:28.299Z",
        "action_counter": 1479
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. In-game testing proved this tile type blocks movement from the north, contrary to the initial hypothesis that it was a jumpable ledge.",
        "timestamp": "2025-11-20T21:14:51.875Z",
        "action_counter": 1484
      },
      {
        "commit_message": "fix: Reinforce object collision check in find_path and add debug prints for player's neighbors to diagnose issues where objects are ignored.",
        "timestamp": "2025-11-20T23:31:27.320Z",
        "action_counter": 1632
      },
      {
        "commit_message": "fix: Add CAVE to traversable basic_types. This tile type represents cave entrances (warps) and must be traversable to enter dungeons like Union Cave. Also removed debug prints.",
        "timestamp": "2025-11-20T23:38:16.306Z",
        "action_counter": 1641
      },
      {
        "commit_message": "fix: Enable FLOOR_UP_WALL as a traversable ledge when moving down. This is necessary to test if the western ledge at (12, 18) is jumpable, as the eastern path is blocked.",
        "timestamp": "2025-11-21T00:47:29.072Z",
        "action_counter": 1752
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. Verified in-game at (16, 21) that this tile type acts as a wall and cannot be jumped from the north.",
        "timestamp": "2025-11-21T00:59:17.529Z",
        "action_counter": 1768
      },
      {
        "commit_message": "fix: Ensure FLOOR_UP_WALL is treated as a wall. Previous testing at (16, 21) confirmed it is not jumpable from the north.",
        "timestamp": "2025-11-21T01:01:08.516Z",
        "action_counter": 1771
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. Verified in-game at (12, 17) -> (12, 18) that this tile type acts as a wall and cannot be jumped from the north.",
        "timestamp": "2025-11-21T01:05:06.366Z",
        "action_counter": 1776
      },
      {
        "commit_message": "feat: Allow movement UP onto FLOOR_UP_WALL tiles. Verified in-game at Union Cave (5, 19) -> (5, 18) that this tile type acts as a climbable ramp from the south.",
        "timestamp": "2025-11-21T02:01:30.245Z",
        "action_counter": 1847
      },
      {
        "commit_message": "feat: Allow horizontal movement on FLOOR_UP_WALL. The tiles at row 18 act as a traversable ridge connecting the west and east sides of the room.",
        "timestamp": "2025-11-21T02:05:19.643Z",
        "action_counter": 1850
      },
      {
        "commit_message": "feat: Update find_path to automatically target adjacent traversable tiles if the destination is blocked by a wall or object. This eliminates the need for manual coordinate guessing when targeting NPCs or obstacles.",
        "timestamp": "2025-11-22T00:45:06.962Z",
        "action_counter": 3307
      },
      {
        "commit_message": "feat: Enhance find_path to treat tiles with object-linked markers as obstacles. This prevents the pathfinder from routing through off-screen NPCs or objects that are known to exist but not currently rendered in the viewport.",
        "timestamp": "2025-11-22T02:29:58.782Z",
        "action_counter": 3465
      },
      {
        "commit_message": "refactor: Change output format from coordinates to button presses (e.g. [\"Up\", \"Right\"]). This enables compatibility with the `autopress_buttons: true` feature for automated navigation.",
        "timestamp": "2025-11-22T06:33:20.386Z",
        "action_counter": 3846
      },
      {
        "commit_message": "fix: Update find_path to return a JSON array of button strings (e.g. ['Up', 'Right']) instead of coordinates, enabling compatibility with autopress_buttons. Also re-implements logic to path to adjacent tiles if the target is blocked.",
        "timestamp": "2025-11-22T06:37:44.405Z",
        "action_counter": 3851
      },
      {
        "commit_message": "fix: Rewrite find_path to output a JSON array of button strings (e.g. [\"Up\", \"Right\"]) instead of coordinate objects. Adds logic to automatically path to an adjacent tile if the target is blocked by a wall, object, or marker.",
        "timestamp": "2025-11-22T06:42:53.734Z",
        "action_counter": 3857
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE to the obstacles list in find_path. Previously, the pathfinder treated these trees as walkable FLOOR tiles, causing pathfinding failures on Route 36.",
        "timestamp": "2025-11-22T09:46:43.517Z",
        "action_counter": 4061
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE to obstacles list in find_path tool. This prevents pathfinding through solid trees on Route 36.",
        "timestamp": "2025-11-22T09:53:42.815Z",
        "action_counter": 4069
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE to obstacles list in find_path tool. This prevents pathfinding failures where the tool tries to route through solid trees on Route 36.",
        "timestamp": "2025-11-22T10:01:47.695Z",
        "action_counter": 4078
      },
      {
        "commit_message": "fix: Add LEDGE_HOP_DOWN, LEDGE_HOP_UP, LEDGE_HOP_LEFT, and LEDGE_HOP_RIGHT to the obstacles list in find_path. This prevents the pathfinder from incorrectly generating paths that try to walk up one-way ledges, which caused a navigation error on Route 37.",
        "timestamp": "2025-11-22T11:03:50.170Z",
        "action_counter": 4148
      },
      {
        "commit_message": "fix: Update find_path to treat tiles marked with 'Hole' or üï≥Ô∏è as obstacles. This prevents the pathfinder from routing the player into pits in the Burned Tower.",
        "timestamp": "2025-11-22T15:38:21.684Z",
        "action_counter": 4436
      },
      {
        "commit_message": "fix: Update find_path to treat tiles marked with 'Hole' or üï≥Ô∏è as obstacles. This prevents the pathfinder from routing the player into pits in the Burned Tower.",
        "timestamp": "2025-11-22T15:45:56.249Z",
        "action_counter": 4441
      },
      {
        "commit_message": "fix: Update find_path to correctly identify tiles with 'Hole' markers or object-linked markers as obstacles. This prevents pathfinding through dangerous tiles in the Burned Tower.",
        "timestamp": "2025-11-22T15:59:15.044Z",
        "action_counter": 4454
      },
      {
        "commit_message": "fix: Add PIT to obstacles list in find_path. This prevents the pathfinder from routing the player into pits in the Lighthouse.",
        "timestamp": "2025-11-23T02:50:16.179Z",
        "action_counter": 5202
      },
      {
        "commit_message": "fix: Add LADDER to obstacles list in find_path. This prevents the pathfinder from routing through ladders which are warps, avoiding accidental map transitions.",
        "timestamp": "2025-11-23T05:18:17.385Z",
        "action_counter": 5381
      },
      {
        "commit_message": "fix: Update find_path to be context-aware for Surfing. Now checks if the player is on a WATER tile; if so, removes WATER from the obstacle list. Also added BUOY to the base obstacle list to prevent pathing into buoys.",
        "timestamp": "2025-11-23T12:00:41.709Z",
        "action_counter": 5818
      }
    ]
  },
  "sequence_press": {
    "description": "Executes a sequence of button presses provided as a comma-separated string. Essential for navigating menus or keyboards where mixing directional and action inputs is required in a single turn.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "string",
          "description": "Comma-separated list of buttons to press, e.g., 'A, Down, Down, A'"
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nbuttons_str = input_data.get('buttons', '')\nif not buttons_str:\n    print('[]')\nelse:\n    button_list = [btn.strip() for btn in buttons_str.split(',')]\n    print(json.dumps(button_list))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-11-22T06:30:16.355Z",
        "action_counter": 3843
      }
    ]
  }
}