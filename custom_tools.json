{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "find_path": {
    "description": "A robust pathfinding tool. Finds a path to specified X, Y coordinates, considering the current movement state (walking or surfing). It can now avoid a specified list of coordinates. If no end coordinates are provided, it finds a path to the nearest reachable unseen tile. It automatically paths to an adjacent tile if the target is impassable. It can handle elevation changes via steps, off-screen gates, and correctly paths through Pikachu.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string",
          "nullable": true
        },
        "end_y": {
          "type": "string",
          "nullable": true
        },
        "movement_mode": {
          "type": "string",
          "enum": [
            "walking",
            "surfing"
          ]
        },
        "avoid_coords": {
          "type": "string",
          "nullable": true,
          "description": "A JSON string representing a list of coordinate objects, e.g., '[{\"x\":\"10\",\"y\":\"12\"}]'"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "movement_mode"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef parse_map_xml(xml_string):\n    root = ET.fromstring(xml_string)\n    grid = {}\n    unseen_tiles = []\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tile_type = tile.get('type')\n            is_warp = tile.get('is-warp') == 'true'\n            is_seen = tile.get('seen') == 'true'\n            object_element = tile.find('Object')\n            has_object = object_element is not None\n            is_pikachu = has_object and object_element.get('id-name') == 'Pikachu'\n            grid[(x, y)] = {\n                'type': tile_type, \n                'is_warp': is_warp, \n                'has_object': has_object, \n                'is_pikachu': is_pikachu,\n                'is_seen': is_seen\n            }\n            if not is_seen:\n                unseen_tiles.append((x, y))\n    return grid, width, height, unseen_tiles\n\ndef is_walkable(tile_data, movement_mode):\n    if not tile_data: return False\n    walkable_types = ['ground', 'grass', 'cleared_boulder_barrier', 'boulder_switch', 'open_gate', 'gate_offscreen', 'steps', 'elevated_ground', 'ladder_up', 'ladder_down', 'hole']\n    surfable_types = ['water']\n    if movement_mode == 'walking':\n        return tile_data.get('type') in walkable_types\n    elif movement_mode == 'surfing':\n        return tile_data.get('type') in surfable_types\n    return False\n\ndef get_neighbors(x, y, grid, width, height, movement_mode):\n    neighbors = []\n    for dx, dy, direction in [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n        nx, ny = x + dx, y + dy\n        if not (1 <= nx <= width and 1 <= ny <= height):\n            continue\n        \n        current_tile_data = grid.get((x,y), {})\n        next_tile_data = grid.get((nx,ny), {})\n        current_tile_type = current_tile_data.get('type')\n        next_tile_type = next_tile_data.get('type')\n        \n        # Ledge logic\n        if next_tile_type == 'ledge':\n            if direction == 'Down':\n                # Valid ledge jump\n                final_y = ny + 1\n                if 1 <= final_y <= height:\n                    neighbors.append((nx, final_y))\n            # From other directions, ledges are impassable, so we just continue\n            continue\n\n        if is_walkable(next_tile_data, movement_mode):\n            if next_tile_data.get('has_object'):\n                if next_tile_data.get('is_pikachu'):\n                    neighbors.append((nx, ny))\n                # Other objects are impassable\n            else:\n                neighbors.append((nx, ny))\n    return neighbors\n\ndef find_path_bfs(grid, width, height, start, end, movement_mode, avoid_coords_set, unseen_tiles):\n    queue = deque([(start, [start])])\n    visited = {start}\n    \n    if end is None:\n        # Path to nearest unseen tile\n        unseen_tiles.sort(key=lambda t: abs(t[0] - start[0]) + abs(t[1] - start[1]))\n        for unseen_end in unseen_tiles:\n            # Try to path to an adjacent walkable tile\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adj_x, adj_y = unseen_end[0] + dx, unseen_end[1] + dy\n                adj_tile_data = grid.get((adj_x, adj_y))\n                if adj_tile_data and is_walkable(adj_tile_data, movement_mode) and not (adj_tile_data.get('has_object') and not adj_tile_data.get('is_pikachu')):\n                    path_to_unseen = find_path_bfs(grid, width, height, start, (adj_x, adj_y), movement_mode, avoid_coords_set, [])\n                    if path_to_unseen:\n                        return path_to_unseen\n        return None\n\n    target_tile_data = grid.get(end, {})\n    is_target_impassable = not is_walkable(target_tile_data, movement_mode) or (target_tile_data.get('has_object') and not target_tile_data.get('is_pikachu'))\n    \n    if is_target_impassable:\n        # Find best adjacent tile to path to\n        best_adj = None\n        min_dist = float('inf')\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_x, adj_y = end[0] + dx, end[1] + dy\n            adj_tile_data = grid.get((adj_x, adj_y))\n            if adj_tile_data and is_walkable(adj_tile_data, movement_mode):\n                is_adj_impassable = adj_tile_data.get('has_object') and not adj_tile_data.get('is_pikachu')\n                if not is_adj_impassable:\n                    dist = abs(adj_x - start[0]) + abs(adj_y - start[1])\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_adj = (adj_x, adj_y)\n        if best_adj is None: return None\n        end = best_adj\n\n    while queue:\n        (current_pos, path) = queue.popleft()\n        if current_pos == end:\n            return path\n        \n        x, y = current_pos\n        for neighbor in get_neighbors(x, y, grid, width, height, movement_mode):\n            if neighbor not in visited and neighbor not in avoid_coords_set:\n                visited.add(neighbor)\n                new_path = list(path)\n                new_path.append(neighbor)\n                queue.append((neighbor, new_path))\n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    movement_mode = input_data['movement_mode']\n    end_x = int(input_data.get('end_x')) if input_data.get('end_x') else None\n    end_y = int(input_data.get('end_y')) if input_data.get('end_y') else None\n    \n    avoid_coords_str = input_data.get('avoid_coords')\n    avoid_coords_list = json.loads(avoid_coords_str) if avoid_coords_str else []\n    avoid_coords_set = {(int(c['x']), int(c['y'])) for c in avoid_coords_list}\n\n    grid, width, height, unseen_tiles = parse_map_xml(map_xml_string)\n    \n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y) if end_x is not None and end_y is not None else None\n\n    path = find_path_bfs(grid, width, height, start_node, end_node, movement_mode, avoid_coords_set, unseen_tiles)\n\n    if path:\n        path_dicts = [{'x': str(p[0]), 'y': str(p[1])} for p in path]\n        print(json.dumps(path_dicts))\n    else:\n        print(json.dumps([]))\n\nexcept Exception as e:\n    print(json.dumps([{'error': str(e)}]))"
  },
  "get_impassable_tiles": {
    "description": "Extracts and returns a JSON list of all impassable tile coordinates from the current map XML.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET; import json; root = ET.fromstring(map_xml_string); impassable_tiles = []; for row_elem in root.findall('Row'): y = int(row_elem.get('id')); for tile_elem in row_elem.findall('Tile'): x = int(tile_elem.get('id')); if tile_elem.get('type') == 'impassable' or tile_elem.find('Object') is not None: impassable_tiles.append({'x': x, 'y': y}); print(json.dumps(impassable_tiles))"
  }
}