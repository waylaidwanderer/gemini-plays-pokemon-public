{
  "master_navigator": {
    "description": "A consolidated navigation tool that handles pathfinding. It can find a path to a specific coordinate. It now considers map markers for obstacles and correctly handles ledges and transitions between different traversable tile types. Includes an option to ignore objects for testing purposes. THIS IS A DEBUG VERSION.",
    "input_schema": {
      "type": "object",
      "properties": {
        "mode": {
          "type": "string",
          "enum": [
            "pathfind"
          ]
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer",
          "nullable": true
        },
        "end_y": {
          "type": "integer",
          "nullable": true
        },
        "traversable_tiles": {
          "type": "string"
        },
        "ignore_objects": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "mode",
        "start_x",
        "start_y",
        "traversable_tiles"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\nimport sys\n\nsys.stderr = sys.stdout\n\ndef find_path(map_xml_string, start_x, start_y, end_x, end_y, traversable_tiles_str, ignore_objects_str):\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n\n        traversable_tiles = traversable_tiles_str.split(',')\n        ignore_objects = ignore_objects_str.lower() == 'true' if ignore_objects_str else False\n        \n        print(f\"Master Navigator Debug: Start=({start_x},{start_y}), End=({end_x},{end_y}), Traversable={traversable_tiles}, IgnoreObjects={ignore_objects}\")\n\n        grid = [[False for _ in range(width)] for _ in range(height)]\n        \n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            if not (1 <= y <= height): continue\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                if not (1 <= x <= width): continue\n\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                is_player_tile = tile_elem.find('Player') is not None\n                \n                is_traversable = tile_type in traversable_tiles\n                \n                # DEBUG PRINT\n                print(f\"  Tile ({x},{y}): type={tile_type}, has_object={has_object}, is_player={is_player_tile}, initial_traversable={is_traversable}\")\n\n                if has_object and not is_player_tile and not ignore_objects:\n                    is_traversable = False\n                    print(f\"    -> Marked as NOT traversable due to object.\")\n                \n                # UPDATED LOGIC TO CHECK ALL OBJECT MARKERS\n                for marker in tile_elem.findall('Marker'):\n                    if marker.get('object_id') is not None and not ignore_objects:\n                        is_traversable = False\n                        print(f\"    -> Marked as NOT traversable due to object marker {marker.get('emoji')}.\")\n                        break\n                \n                if is_traversable or is_player_tile:\n                    grid[y-1][x-1] = True\n\n        def heuristic(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n        start = (start_x - 1, start_y - 1)\n        goal = (end_x - 1, end_y - 1)\n\n        if not (0 <= start[0] < width and 0 <= start[1] < height and grid[start[1]][start[0]]):\n            return {\"error\": f\"Start ({start_x},{start_y}) is not on a traversable tile.\"}\n        \n        if not (0 <= goal[0] < width and 0 <= goal[1] < height):\n            return {\"error\": f\"Goal ({end_x},{end_y}) is outside map boundaries.\"}\n\n        if not grid[goal[1]][goal[0]]:\n            found_new_goal = False\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_goal_candidate = (goal[0] + dx, goal[1] + dy)\n                if 0 <= new_goal_candidate[0] < width and 0 <= new_goal_candidate[1] < height and grid[new_goal_candidate[1]][new_goal_candidate[0]]:\n                    goal = new_goal_candidate\n                    found_new_goal = True\n                    break\n            if not found_new_goal:\n                 return {\"error\": f\"Goal ({end_x},{end_y}) and all adjacent tiles are not traversable.\"}\n\n        open_set = [(0, start)]\n        came_from = {}\n        g_score = { (c,r): float('inf') for r in range(height) for c in range(width) }\n        g_score[start] = 0\n        f_score = { (c,r): float('inf') for r in range(height) for c in range(width) }\n        f_score[start] = heuristic(start, goal)\n        \n        while open_set:\n            _, current = heapq.heappop(open_set)\n\n            if current == goal:\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(start)\n                path_coords = [{'x': x + 1, 'y': y + 1} for x, y in reversed(path)]\n                return path_coords\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                neighbor = (current[0] + dx, current[1] + dy)\n                nx, ny = neighbor\n\n                if not (0 <= nx < width and 0 <= ny < height and grid[ny][nx]):\n                    continue\n\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, goal)\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n        \n        return {\"error\": \"No path found.\"}\n\n    except Exception as e:\n        import traceback\n        return {\"error\": str(e), \"traceback\": traceback.format_exc()}\n\ntry:\n    mode = input_data['mode']\n    if mode == 'pathfind':\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        end_x = int(input_data.get('end_x'))\n        end_y = int(input_data.get('end_y'))\n        traversable_tiles_str = input_data['traversable_tiles']\n        ignore_objects_str = input_data.get('ignore_objects')\n\n        path = find_path(map_xml_string, start_x, start_y, end_x, end_y, traversable_tiles_str, ignore_objects_str)\n\n        if isinstance(path, dict) and \"error\" in path:\n            print(json.dumps(path))\n        elif path:\n            print(json.dumps({\"path\": path}))\n        else:\n            print(json.dumps({\"error\": \"No path found.\"}))\n    else:\n        print(json.dumps({\"error\": f\"Invalid mode: {mode}\"}))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({\"error\": f\"Tool execution failed: {str(e)}\", \"traceback\": traceback.format_exc()}))\n"
  },
  "puzzle_solver": {
    "description": "Solves state-based puzzles, like boulder mazes, by finding a sequence of moves from a start to a goal state. It uses a breadth-first search algorithm.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer",
          "nullable": true
        },
        "start_y": {
          "type": "integer",
          "nullable": true
        },
        "goal_x": {
          "type": "integer"
        },
        "goal_y": {
          "type": "integer"
        }
      },
      "required": [
        "goal_x",
        "goal_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef solve_boulder_puzzle(start_pos, goal_pos, initial_boulders, walls, width, height):\n    queue = deque([(start_pos, initial_boulders, [])])\n    visited = set([(start_pos, tuple(sorted(initial_boulders)))])\n\n    while queue:\n        (player_x, player_y), boulders, path = queue.popleft()\n\n        if (player_x, player_y) == goal_pos:\n            return path\n\n        for move_x, move_y, move_dir in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            next_x, next_y = player_x + move_x, player_y + move_y\n\n            if not (0 <= next_x < width and 0 <= next_y < height) or (next_x, next_y) in walls:\n                continue\n\n            boulder_at_next = (next_x, next_y) in boulders\n            if boulder_at_next:\n                push_to_x, push_to_y = next_x + move_x, next_y + move_y\n                if not (0 <= push_to_x < width and 0 <= push_to_y < height) or (push_to_x, push_to_y) in walls or (push_to_x, push_to_y) in boulders:\n                    continue\n                \n                new_boulders = set(boulders)\n                new_boulders.remove((next_x, next_y))\n                new_boulders.add((push_to_x, push_to_y))\n                new_boulders_tuple = tuple(sorted(list(new_boulders)))\n                \n                new_player_pos = (next_x, next_y)\n                state = (new_player_pos, new_boulders_tuple)\n                if state not in visited:\n                    visited.add(state)\n                    new_path = path + [f'Push boulder at ({next_x},{next_y}) {move_dir}']\n                    queue.append((new_player_pos, new_boulders, new_path))\n            else:\n                new_player_pos = (next_x, next_y)\n                state = (new_player_pos, tuple(sorted(boulders)))\n                if state not in visited:\n                    visited.add(state)\n                    new_path = path + [move_dir]\n                    queue.append((new_player_pos, boulders, new_path))\n    return None\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n\n    walls = set()\n    boulders = set()\n    player_pos = None\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id')) - 1\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id')) - 1\n            tile_type = tile_elem.get('type')\n            if tile_type in ['WALL', 'VOID']:\n                walls.add((x, y))\n            \n            obj = tile_elem.find('Object')\n            if obj is not None:\n                obj_name = obj.get('id-name')\n                if obj_name == 'BOULDER':\n                    boulders.add((x, y))\n                elif obj_name != 'PLAYER':\n                    walls.add((x, y))\n            \n            if tile_elem.find('Player') is not None:\n                player_pos = (x, y)\n\n    start_x_str = input_data.get('start_x')\n    start_y_str = input_data.get('start_y')\n    end_x = int(input_data['goal_x'])\n    end_y = int(input_data['goal_y'])\n\n    if start_x_str and start_y_str:\n        start_pos = (int(start_x_str), int(start_y_str))\n    elif player_pos:\n        start_pos = player_pos\n    else:\n        raise ValueError(\"Player position not found in map XML and no start coordinates provided.\")\n\n    goal_pos = (end_x, end_y)\n    \n    solution = solve_boulder_puzzle(start_pos, goal_pos, frozenset(boulders), walls, width, height)\n    \n    if solution:\n        print(json.dumps({\"status\": \"success\", \"solution\": solution}))\n    else:\n        print(json.dumps({\"status\": \"failure\", \"reason\": \"No solution found.\"}))\n\nexcept Exception as e:\n    print(json.dumps({\"status\": \"error\", \"message\": str(e)}))\n"
  }
}