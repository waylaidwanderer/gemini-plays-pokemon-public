{
  "find_path_v2": {
    "description": "Finds the shortest path between two coordinates on the current map using BFS, considering walls, objects, and hazardous tiles as obstacles. Returns a JSON array of buttons. Re-defined to correctly handle HEADBUTT_TREE as an obstacle.",
    "input_schema": {
      "type": "object",
      "properties": {
        "autopress_buttons": {
          "default": false,
          "type": "boolean"
        },
        "avoid_warps": {
          "default": true,
          "type": "boolean"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "autopress_buttons"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef solve():\n    tree = ET.fromstring(map_xml_string)\n    width = int(tree.attrib['width'])\n    height = int(tree.attrib['height'])\n    \n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    avoid_warps = input_data.get('avoid_warps', True)\n    \n    # Define traversable types based on notepad and observation\n    traversable_types = {'FLOOR', 'TALL_GRASS', 'LONG_GRASS', 'WARP_CARPET_UP', 'WARP_CARPET_DOWN', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'CAVE', 'DOOR', 'STAIRS', 'LADDER'}\n    warp_types = {'WARP_CARPET_UP', 'WARP_CARPET_DOWN', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'CAVE', 'DOOR', 'STAIRS', 'LADDER'}\n    \n    grid = {}\n    for row in tree.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            \n            # Tile is an obstacle if its type is not in traversable_types\n            is_obstacle = t_type not in traversable_types\n            \n            # Warps are obstacles if avoid_warps is True, unless it's the destination\n            if avoid_warps and t_type in warp_types and (x != end_x or y != end_y):\n                is_obstacle = True\n            \n            # Map Objects (NPCs, items) are obstacles. \n            # We ignore the object at the starting position to allow movement.\n            if tile.find('Object') is not None:\n                if x != start_x or y != start_y:\n                    is_obstacle = True\n                \n            grid[(x, y)] = is_obstacle\n\n    queue = deque([(start_x, start_y, [])])\n    visited = {(start_x, start_y)}\n    \n    while queue:\n        cx, cy, path = queue.popleft()\n        if cx == end_x and cy == end_y:\n            print(json.dumps(path))\n            return\n            \n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:\n                # Tile is traversable if it's not marked as an obstacle\n                # OR if it's the destination (to allow walking into warps)\n                if not grid.get((nx, ny), True) or (nx == end_x and ny == end_y):\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [btn]))\n                    \n    print(json.dumps({\"error\": \"No path found\"}))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T20:27:16.465Z",
        "action_counter": 29425
      },
      {
        "commit_message": "Refined to correctly identify objects using 'has-object' attribute and added logic for boulder bridges in pits.",
        "timestamp": "2025-12-28T20:30:14.390Z",
        "action_counter": 29431
      },
      {
        "commit_message": "Refined to correctly handle autopress_buttons by outputting button strings and fixed pathfinding logic for boulder bridges.",
        "timestamp": "2025-12-28T20:30:50.776Z",
        "action_counter": 29432
      },
      {
        "commit_message": "Refined to handle boulder bridges in Blackthorn Gym 1F and improved object detection.",
        "timestamp": "2025-12-28T20:47:40.334Z",
        "action_counter": 29458
      },
      {
        "commit_message": "Fixing missing commit message and improving tile passability logic.",
        "timestamp": "2025-12-28T22:59:48.479Z",
        "action_counter": 29673
      },
      {
        "commit_message": "Fix find_path_v2 by providing a commit message and using input_data correctly.",
        "timestamp": "2025-12-29T03:29:03.821Z",
        "action_counter": 30041
      },
      {
        "commit_message": "Refine find_path_v2 to treat PIT and LADDER tiles as obstacles by default to prevent accidental warps, unless they are the intended destination.",
        "timestamp": "2025-12-29T04:09:14.393Z",
        "action_counter": 30092
      },
      {
        "commit_message": "Refine find_path_v2 to treat all warp tiles (PIT, LADDER) as obstacles unless they are the specific destination, and correctly identify objects using 'has-object'.",
        "timestamp": "2025-12-29T04:10:34.909Z",
        "action_counter": 30094
      },
      {
        "commit_message": "Initial definition with ledge handling.",
        "timestamp": "2026-01-06T20:56:57.721Z",
        "action_counter": 30778
      },
      {
        "commit_message": "Added commit message to update tool.",
        "timestamp": "2026-01-06T21:16:09.438Z",
        "action_counter": 30812
      },
      {
        "commit_message": "Refined ledge handling: ledges are now impassable from all directions except the jump direction. Added more impassable tile types.",
        "timestamp": "2026-01-06T21:17:48.184Z",
        "action_counter": 30816
      },
      {
        "commit_message": "Added CAVE and WARP to impassable tiles to prevent accidental map transitions.",
        "timestamp": "2026-01-06T21:27:34.747Z",
        "action_counter": 30833
      },
      {
        "commit_message": "Added avoid_warps parameter and object detection logic. Refined ledge and warp handling.",
        "timestamp": "2026-01-06T21:37:49.308Z",
        "action_counter": 30841
      },
      {
        "commit_message": "Removed 'unseen' from impassable_base to allow exploration pathing.",
        "timestamp": "2026-01-06T21:53:26.245Z",
        "action_counter": 30871
      },
      {
        "commit_message": "Removed 'unseen' from impassable tiles to allow exploration pathing. Added avoid_warps parameter. Refined ledge and object handling.",
        "timestamp": "2026-01-06T21:58:47.153Z",
        "action_counter": 30880
      },
      {
        "commit_message": "Initial definition with correct schema and logic.",
        "timestamp": "2026-01-07T09:27:38.973Z",
        "action_counter": 32021
      },
      {
        "commit_message": "Refined find_path_v2 to treat HEADBUTT_TREE as an obstacle and allow player to move from their current tile.",
        "timestamp": "2026-01-07T12:10:42.415Z",
        "action_counter": 32283
      }
    ]
  },
  "press_menu_buttons": {
    "description": "Presses a sequence of buttons to navigate menus, bypassing the directional/action mixing restriction. Use for menu navigation ONLY. Returns the sequence of buttons as a JSON array.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nprint(json.dumps(input_data['buttons']))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-29T01:56:30.654Z",
        "action_counter": 29934
      }
    ]
  },
  "fly_to": {
    "description": "Moves the cursor to a specific city on the 2D Fly map and selects it. This tool MUST be called while the Fly map is open. It calculates the necessary directional presses from a starting city to a target city.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_city": {
          "enum": [
            "New Bark Town",
            "Cherrygrove City",
            "Violet City",
            "Azalea Town",
            "Goldenrod City",
            "Ecruteak City",
            "Olivine City",
            "Cianwood City",
            "Mahogany Town",
            "Blackthorn City"
          ],
          "type": "string"
        },
        "current_city": {
          "enum": [
            "New Bark Town",
            "Cherrygrove City",
            "Violet City",
            "Azalea Town",
            "Goldenrod City",
            "Ecruteak City",
            "Olivine City",
            "Cianwood City",
            "Mahogany Town",
            "Blackthorn City"
          ],
          "type": "string"
        }
      },
      "required": [
        "current_city",
        "target_city"
      ]
    },
    "python_script": "import json\n\ndef solve():\n    # Coordinates of cities on the 2D Fly map (approximate relative positions)\n    city_coords = {\n        \"New Bark Town\": (7, 3),\n        \"Cherrygrove City\": (6, 3),\n        \"Violet City\": (4, 2),\n        \"Azalea Town\": (4, 4),\n        \"Goldenrod City\": (2, 3),\n        \"Ecruteak City\": (4, 1),\n        \"Olivine City\": (2, 2),\n        \"Cianwood City\": (0, 2),\n        \"Mahogany Town\": (6, 1),\n        \"Blackthorn City\": (7, 1)\n    }\n    \n    current = input_data['current_city']\n    target = input_data['target_city']\n    \n    curr_x, curr_y = city_coords[current]\n    targ_x, targ_y = city_coords[target]\n    \n    buttons = []\n    \n    # Move X\n    dx = targ_x - curr_x\n    if dx > 0:\n        buttons.extend([\"Right\"] * dx)\n    elif dx < 0:\n        buttons.extend([\"Left\"] * abs(dx))\n        \n    # Move Y\n    dy = targ_y - curr_y\n    if dy > 0:\n        buttons.extend([\"Down\"] * dy)\n    elif dy < 0:\n        buttons.extend([\"Up\"] * abs(dy))\n        \n    buttons.append(\"A\")\n    print(json.dumps(buttons))\n\nsolve()",
    "history": [
      {
        "commit_message": "Created fly_to tool to automate 2D map navigation in the Fly menu.",
        "timestamp": "2026-01-07T12:25:00.677Z",
        "action_counter": 32313
      }
    ]
  }
}