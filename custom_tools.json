{
  "unseen_tile_checker": {
    "description": "Analyzes the list of unseen tiles from a system alert and uses pathfinding logic to determine which are actually reachable from the player's current position.",
    "input_schema": {
      "type": "object",
      "properties": {
        "coordinates": {
          "type": "string",
          "description": "A stringified JSON array of coordinate objects, e.g., '[{\"x\":1,\"y\":2}]'"
        }
      },
      "required": [
        "coordinates"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\nimport json\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(start, goal, traversable, one_way_rules):\n    open_set = [(0 + heuristic(start, goal), 0, start)]\n    came_from = {}\n    g_score = {start: 0}\n\n    while open_set:\n        _, current_g, current_node = heapq.heappop(open_set)\n\n        if current_node == goal:\n            return True # Path found\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current_node[0] + dx, current_node[1] + dy)\n\n            if neighbor not in traversable and neighbor != goal: # Allow pathing to the goal even if it's not in the initial traversable set (e.g., unseen)\n                continue\n\n            if neighbor in one_way_rules:\n                allowed_from = one_way_rules[neighbor]\n                if (current_node[0] - neighbor[0], current_node[1] - neighbor[1]) != allowed_from:\n                    continue\n\n            tentative_g_score = current_g + 1\n\n            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                g_score[neighbor] = tentative_g_score\n                f_score = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_score, tentative_g_score, neighbor))\n                came_from[neighbor] = current_node\n\n    return False # No path found\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    player_x, player_y = -1, -1\n    traversable = set()\n    one_way_rules = {}\n\n    impassable_types = ['WALL', 'WINDOW', 'VOID', 'CUT_TREE', 'SIGN', 'BOOKSHELF', 'BLACKBOARD', 'MART_SHELF', 'BUOY', 'TV', 'TOWN_MAP', 'RADIO', 'INCENSE_BURNER', 'BIRD', 'HEADBUTT_TREE', 'FRUIT_TREE', 'COMPUTER', 'PRINTER', 'PC', 'COUNTER', 'CAVE']\n    one_way_types = {\n        'LEDGE_HOP_DOWN': (0, -1),\n        'LEDGE_HOP_LEFT': (1, 0),\n        'LEDGE_HOP_RIGHT': (-1, 0)\n    }\n\n    for row in root.findall('Row'):\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            y = int(row.get('id'))\n            tile_type = tile.get('type')\n\n            if tile.find('Player') is not None:\n                player_x, player_y = x, y\n\n            if tile_type not in impassable_types and tile.find('Object') is None:\n                traversable.add((x, y))\n                if tile_type in one_way_types:\n                    one_way_rules[(x, y)] = one_way_types[tile_type]\n\n    start_node = (player_x, player_y)\n    target_coordinates = json.loads(input_data['coordinates'])\n    reachable_tiles = []\n\n    if start_node == (-1, -1):\n        print('{\"error\": \"Player not found on the map.\"}')\n    else:\n        for coord in target_coordinates:\n            goal_node = (int(coord['x']), int(coord['y']))\n            if a_star_search(start_node, goal_node, traversable, one_way_rules):\n                reachable_tiles.append(coord)\n        print(json.dumps(reachable_tiles))\n\nexcept Exception as e:\n    print(f'{{\"error\": \"An unexpected error occurred in unseen_tile_checker: {str(e)}\"}}')\n",
    "history": [
      {
        "commit_message": "feat: Create unseen_tile_checker tool. This tool automates the process of checking which unseen tiles from a system alert are actually reachable, streamlining exploration and preventing wasted turns trying to path to disconnected areas.",
        "timestamp": "2025-07-29T03:31:55.070Z",
        "action_counter": 15144
      },
      {
        "commit_message": "feat: Create unseen_tile_checker tool. This tool automates the process of checking which unseen tiles from a system alert are actually reachable, streamlining exploration and preventing wasted turns trying to path to disconnected areas.",
        "timestamp": "2025-07-29T06:52:53.467Z",
        "action_counter": 15273
      }
    ]
  },
  "pathfinder": {
    "description": "Finds the shortest path from the player's current position to a target coordinate on the current map using the A* algorithm. It avoids impassable tiles and respects one-way traversal rules.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\n\n# Heuristic function for A*\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n# A* pathfinding function\ndef a_star_search(start, goal, traversable, one_way_rules):\n    # Priority queue for open nodes: (f_score, g_score, current_node)\n    open_set = [(0 + heuristic(start, goal), 0, start)]\n    # Dictionary to store the path\n    came_from = {}\n    # Dictionary to store g_scores (cost from start to node)\n    g_score = {start: 0}\n\n    while open_set:\n        _, current_g, current_node = heapq.heappop(open_set)\n\n        if current_node == goal:\n            path = []\n            while current_node in came_from:\n                path.append(current_node)\n                current_node = came_from[current_node]\n            path.append(start)\n            return path[::-1] # Return reversed path\n\n        # Explore neighbors\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current_node[0] + dx, current_node[1] + dy)\n\n            # Check if neighbor is a valid, traversable tile\n            if neighbor not in traversable:\n                continue\n\n            # Check one-way traversal rules\n            if neighbor in one_way_rules:\n                allowed_from = one_way_rules[neighbor]\n                if (current_node[0] - neighbor[0], current_node[1] - neighbor[1]) != allowed_from:\n                    continue\n\n            tentative_g_score = current_g + 1\n\n            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                g_score[neighbor] = tentative_g_score\n                f_score = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_score, tentative_g_score, neighbor))\n                came_from[neighbor] = current_node\n\n    return None # No path found\n\n# Main script execution\ntry:\n    root = ET.fromstring(map_xml_string)\n    player_x, player_y = -1, -1\n    traversable = set()\n    one_way_rules = {}\n\n    impassable_types = ['WALL', 'WINDOW', 'VOID', 'CUT_TREE', 'SIGN', 'BOOKSHELF', 'BLACKBOARD', 'MART_SHELF', 'BUOY', 'TV', 'TOWN_MAP', 'RADIO', 'INCENSE_BURNER', 'BIRD', 'HEADBUTT_TREE', 'FRUIT_TREE', 'COMPUTER', 'PRINTER', 'PC', 'COUNTER', 'CAVE']\n    one_way_types = {\n        'LEDGE_HOP_DOWN': (0, -1), # Can only enter from above\n        'LEDGE_HOP_LEFT': (1, 0),  # Can only enter from the right\n        'LEDGE_HOP_RIGHT': (-1, 0) # Can only enter from the left\n    }\n\n    for row in root.findall('Row'):\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            y = int(row.get('id'))\n            tile_type = tile.get('type')\n\n            if tile.find('Player') is not None:\n                player_x, player_y = x, y\n\n            # Tile is traversable if not impassable and has no object\n            if tile_type not in impassable_types and tile.find('Object') is None:\n                traversable.add((x, y))\n                if tile_type in one_way_types:\n                    one_way_rules[(x, y)] = one_way_types[tile_type]\n\n    start_node = (player_x, player_y)\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    goal_node = (target_x, target_y)\n\n    if start_node == (-1, -1):\n        print('{\"error\": \"Player not found on the map.\"}')\n    elif goal_node not in traversable:\n        print('{\"error\": \"Target is not a traversable tile.\"}')\n    else:\n        path = a_star_search(start_node, goal_node, traversable, one_way_rules)\n        if path:\n            path_json = [{'x': p[0], 'y': p[1]} for p in path]\n            import json\n            print(json.dumps(path_json))\n        else:\n            print('[]') # No path found\n\nexcept Exception as e:\n    print(f'{{\"error\": \"An unexpected error occurred: {str(e)}\"}}')\n",
    "history": [
      {
        "commit_message": "feat: Recreate pathfinder tool after deletion. This is an attempt to resolve the persistent sandbox error by forcing a complete reset of the tool's environment. The script itself remains unchanged as it was previously functional.",
        "timestamp": "2025-07-29T06:31:10.732Z",
        "action_counter": 15245
      },
      {
        "commit_message": "fix: Overhaul pathfinder script for robustness. The previous 'sandbox not running' error was likely a red herring for a script that was crashing silently. This revision adds comprehensive error handling with a try-except block, explicit type casting for input data, and refined logic for parsing the map XML and identifying traversable tiles. This should resolve the persistent failures and restore pathfinding functionality.",
        "timestamp": "2025-07-29T06:51:09.535Z",
        "action_counter": 15271
      }
    ]
  }
}