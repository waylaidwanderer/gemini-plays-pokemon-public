{
  "find_path": {
    "description": "Calculates a path using A*. Strictly handles Surfing state and Directional Ledges. Treats WALL, CUT_TREE, HEADBUTT_TREE, BUOY, WHIRLPOOL, WINDOW, CAVE_WALL, BOOKSHELF, TV, PC, TOWN_MAP, MART_SHELF, UNSEEN, COUNTER, and tiles with Object-linked Markers as obstacles. Handles directional walls (FLOOR_LEFT_WALL, FLOOR_RIGHT_WALL) by blocking exit in the specific direction.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "# injected imports [\"sys\", \"json\"]\n# injected variables [\"map_xml_string\", \"input_data\"]\n\nimport xml.etree.ElementTree as ET\nimport heapq\nimport math\nimport json\n\n# Parse Map\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.attrib['width'])\nheight = int(root.attrib['height'])\ngrid = {}\nplayer_pos = None\n\nfor row in root.findall('Row'):\n    y = int(row.attrib['id'])\n    for tile in row.findall('Tile'):\n        x = int(tile.attrib['id'])\n        t_type = tile.attrib['type'].strip().upper()\n        has_object = tile.attrib.get('has-object') == 'true'\n        is_warp = tile.attrib.get('is-warp') == 'true'\n        \n        # Check for player\n        if tile.find('Player') is not None:\n            player_pos = (x, y)\n        \n        # Check for objects in children (more robust)\n        if not has_object:\n            if tile.find('Object') is not None:\n                has_object = True\n            # Check for Markers with object_id (tracked off-screen objects)\n            marker = tile.find('Marker')\n            if marker is not None:\n                 if marker.attrib.get('object_id'):\n                     has_object = True\n                \n        grid[(x, y)] = {\n            'type': t_type,\n            'blocked': has_object, # Objects are walls unless target\n            'is_warp': is_warp # Warps are walls unless target\n        }\n\nif not player_pos:\n    print(\"Error: Player not found\")\n    exit()\n\ntarget_x = int(input_data['target_x'])\ntarget_y = int(input_data['target_y'])\ntarget = (target_x, target_y)\n\n# Determine Surfing State\nplayer_tile = grid.get(player_pos)\nis_surfing = player_tile['type'] == 'WATER'\n\n# Define Cost Function\ndef get_cost(curr, next_node):\n    c_tile = grid.get(curr)\n    n_tile = grid.get(next_node)\n    \n    if not n_tile: return float('inf')\n    \n    # Basic Terrain Blocking\n    # Added UNSEEN to blocked list to prevent routing through unexplored areas\n    # Added HEADBUTT_TREE, CUT_08, CUT_28_GARBAGE to blocked list\n    if n_tile['type'] in ['WALL', 'CUT_TREE', 'HEADBUTT_TREE', 'CUT_08', 'CUT_28_GARBAGE', 'BUOY', 'WHIRLPOOL', 'WINDOW', 'CAVE_WALL', 'FLOOR_UP_WALL', 'BOOKSHELF', 'TV', 'PC', 'TOWN_MAP', 'MART_SHELF', 'UNSEEN', 'COUNTER']:\n        return float('inf')\n    \n    # Directional Movement Logic\n    dx = next_node[0] - curr[0]\n    dy = next_node[1] - curr[1]\n    \n    # Ledge Logic - Strict Directional Entry\n    # LEDGE_HOP_DOWN can only be entered from ABOVE (dy=1)\n    if n_tile['type'] == 'LEDGE_HOP_DOWN' and dy != 1: return float('inf')\n    # LEDGE_HOP_UP can only be entered from BELOW (dy=-1)\n    if n_tile['type'] == 'LEDGE_HOP_UP' and dy != -1: return float('inf')\n    # LEDGE_HOP_LEFT can only be entered from RIGHT (dx=-1)\n    if n_tile['type'] == 'LEDGE_HOP_LEFT' and dx != -1: return float('inf')\n    # LEDGE_HOP_RIGHT can only be entered from LEFT (dx=1)\n    if n_tile['type'] == 'LEDGE_HOP_RIGHT' and dx != 1: return float('inf')\n\n    # Directional Wall Logic (Blocks EXIT from current tile)\n    # FLOOR_LEFT_WALL blocks moving LEFT\n    if c_tile['type'] == 'FLOOR_LEFT_WALL' and dx == -1: return float('inf')\n    # FLOOR_RIGHT_WALL blocks moving RIGHT\n    if c_tile['type'] == 'FLOOR_RIGHT_WALL' and dx == 1: return float('inf')\n    # FLOOR_UP_WALL blocks moving UP (conservatively added based on general pattern, though context dependent)\n    if c_tile['type'] == 'FLOOR_UP_WALL' and dy == -1: return float('inf')\n    \n    # Object Blocking (unless target)\n    if n_tile['blocked'] and next_node != target: return float('inf')\n    \n    # Warp Blocking (unless target)\n    if n_tile['is_warp'] and next_node != target: return float('inf')\n\n    # Water/Land Transitions\n    c_type = c_tile['type']\n    n_type = n_tile['type']\n    \n    if is_surfing:\n        # Penalize dismounting unless it's the target\n        if c_type == 'WATER' and n_type != 'WATER':\n            if next_node == target: return 1\n            return 10000\n    else:\n        # Penalize entering water (require manual surf tool)\n        if c_type != 'WATER' and n_type == 'WATER':\n            return float('inf') \n            \n    return 1\n\n# A* Algorithm\ndef solve_path(start, end):\n    queue = [(0, start)]\n    came_from = {start: None}\n    cost_so_far = {start: 0}\n    \n    while queue:\n        _, current = heapq.heappop(queue)\n        \n        if current == end:\n            break\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_node = (current[0] + dx, current[1] + dy)\n            if next_node not in grid: continue\n            \n            new_cost = cost_so_far[current] + get_cost(current, next_node)\n            \n            if new_cost < float('inf'):\n                if next_node not in cost_so_far or new_cost < cost_so_far[next_node]:\n                    cost_so_far[next_node] = new_cost\n                    priority = new_cost + abs(end[0] - next_node[0]) + abs(end[1] - next_node[1])\n                    heapq.heappush(queue, (priority, next_node))\n                    came_from[next_node] = current\n                    \n    return came_from, cost_so_far\n\n# Handle Blocked Target (e.g. clicking on an NPC)\nfinal_target = target\ncame_from, cost_so_far = solve_path(player_pos, target)\n\nif target not in came_from:\n    # Target unreachable. Try adjacent tiles\n    neighbors = []\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        n = (target[0] + dx, target[1] + dy)\n        if n in grid and not grid[n]['blocked'] and grid[n]['type'] != 'WALL':\n             neighbors.append(n)\n    \n    # Sort neighbors by distance to player\n    neighbors.sort(key=lambda n: abs(player_pos[0]-n[0]) + abs(player_pos[1]-n[1]))\n    \n    path_found = False\n    for n in neighbors:\n        came_from, cost_so_far = solve_path(player_pos, n)\n        if n in came_from:\n            final_target = n\n            path_found = True\n            break\n            \n    if not path_found:\n        print(\"[]\")\n        exit()\n\n# Reconstruct Path\npath = []\ncurr = final_target\nwhile curr != player_pos:\n    path.append(curr)\n    curr = came_from[curr]\npath.reverse()\n\n# Output\noutput = [{'x': p[0], 'y': p[1]} for p in path]\nprint(json.dumps(output))",
    "history": [
      {
        "commit_message": "feat: Add find_path tool. Calculates shortest path using BFS, handling walls, objects, and one-way ledges.",
        "timestamp": "2025-11-20T08:35:46.882Z",
        "action_counter": 924
      },
      {
        "commit_message": "fix: Add LADDER to traversable basic_types in find_path. Previously, the tool considered LADDER tiles as walls, preventing pathfinding to or from them.",
        "timestamp": "2025-11-20T10:46:07.670Z",
        "action_counter": 1068
      },
      {
        "commit_message": "fix: Add FLOOR_UP_WALL to traversable tiles when moving down. This tile type appears on Route 32 and visually resembles a ledge, so it is assumed to be jumpable from the north.",
        "timestamp": "2025-11-20T21:10:28.299Z",
        "action_counter": 1479
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. In-game testing proved this tile type blocks movement from the north, contrary to the initial hypothesis that it was a jumpable ledge.",
        "timestamp": "2025-11-20T21:14:51.875Z",
        "action_counter": 1484
      },
      {
        "commit_message": "fix: Reinforce object collision check in find_path and add debug prints for player's neighbors to diagnose issues where objects are ignored.",
        "timestamp": "2025-11-20T23:31:27.320Z",
        "action_counter": 1632
      },
      {
        "commit_message": "fix: Add CAVE to traversable basic_types. This tile type represents cave entrances (warps) and must be traversable to enter dungeons like Union Cave. Also removed debug prints.",
        "timestamp": "2025-11-20T23:38:16.306Z",
        "action_counter": 1641
      },
      {
        "commit_message": "fix: Enable FLOOR_UP_WALL as a traversable ledge when moving down. This is necessary to test if the western ledge at (12, 18) is jumpable, as the eastern path is blocked.",
        "timestamp": "2025-11-21T00:47:29.072Z",
        "action_counter": 1752
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. Verified in-game at (16, 21) that this tile type acts as a wall and cannot be jumped from the north.",
        "timestamp": "2025-11-21T00:59:17.529Z",
        "action_counter": 1768
      },
      {
        "commit_message": "fix: Ensure FLOOR_UP_WALL is treated as a wall. Previous testing at (16, 21) confirmed it is not jumpable from the north.",
        "timestamp": "2025-11-21T01:01:08.516Z",
        "action_counter": 1771
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. Verified in-game at (12, 17) -> (12, 18) that this tile type acts as a wall and cannot be jumped from the north.",
        "timestamp": "2025-11-21T01:05:06.366Z",
        "action_counter": 1776
      },
      {
        "commit_message": "feat: Allow movement UP onto FLOOR_UP_WALL tiles. Verified in-game at Union Cave (5, 19) -> (5, 18) that this tile type acts as a climbable ramp from the south.",
        "timestamp": "2025-11-21T02:01:30.245Z",
        "action_counter": 1847
      },
      {
        "commit_message": "feat: Allow horizontal movement on FLOOR_UP_WALL. The tiles at row 18 act as a traversable ridge connecting the west and east sides of the room.",
        "timestamp": "2025-11-21T02:05:19.643Z",
        "action_counter": 1850
      },
      {
        "commit_message": "feat: Update find_path to automatically target adjacent traversable tiles if the destination is blocked by a wall or object. This eliminates the need for manual coordinate guessing when targeting NPCs or obstacles.",
        "timestamp": "2025-11-22T00:45:06.962Z",
        "action_counter": 3307
      },
      {
        "commit_message": "feat: Enhance find_path to treat tiles with object-linked markers as obstacles. This prevents the pathfinder from routing through off-screen NPCs or objects that are known to exist but not currently rendered in the viewport.",
        "timestamp": "2025-11-22T02:29:58.782Z",
        "action_counter": 3465
      },
      {
        "commit_message": "refactor: Change output format from coordinates to button presses (e.g. [\"Up\", \"Right\"]). This enables compatibility with the `autopress_buttons: true` feature for automated navigation.",
        "timestamp": "2025-11-22T06:33:20.386Z",
        "action_counter": 3846
      },
      {
        "commit_message": "fix: Update find_path to return a JSON array of button strings (e.g. ['Up', 'Right']) instead of coordinates, enabling compatibility with autopress_buttons. Also re-implements logic to path to adjacent tiles if the target is blocked.",
        "timestamp": "2025-11-22T06:37:44.405Z",
        "action_counter": 3851
      },
      {
        "commit_message": "fix: Rewrite find_path to output a JSON array of button strings (e.g. [\"Up\", \"Right\"]) instead of coordinate objects. Adds logic to automatically path to an adjacent tile if the target is blocked by a wall, object, or marker.",
        "timestamp": "2025-11-22T06:42:53.734Z",
        "action_counter": 3857
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE to the obstacles list in find_path. Previously, the pathfinder treated these trees as walkable FLOOR tiles, causing pathfinding failures on Route 36.",
        "timestamp": "2025-11-22T09:46:43.517Z",
        "action_counter": 4061
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE to obstacles list in find_path tool. This prevents pathfinding through solid trees on Route 36.",
        "timestamp": "2025-11-22T09:53:42.815Z",
        "action_counter": 4069
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE to obstacles list in find_path tool. This prevents pathfinding failures where the tool tries to route through solid trees on Route 36.",
        "timestamp": "2025-11-22T10:01:47.695Z",
        "action_counter": 4078
      },
      {
        "commit_message": "fix: Add LEDGE_HOP_DOWN, LEDGE_HOP_UP, LEDGE_HOP_LEFT, and LEDGE_HOP_RIGHT to the obstacles list in find_path. This prevents the pathfinder from incorrectly generating paths that try to walk up one-way ledges, which caused a navigation error on Route 37.",
        "timestamp": "2025-11-22T11:03:50.170Z",
        "action_counter": 4148
      },
      {
        "commit_message": "fix: Update find_path to treat tiles marked with 'Hole' or ðŸ•³ï¸ as obstacles. This prevents the pathfinder from routing the player into pits in the Burned Tower.",
        "timestamp": "2025-11-22T15:38:21.684Z",
        "action_counter": 4436
      },
      {
        "commit_message": "fix: Update find_path to treat tiles marked with 'Hole' or ðŸ•³ï¸ as obstacles. This prevents the pathfinder from routing the player into pits in the Burned Tower.",
        "timestamp": "2025-11-22T15:45:56.249Z",
        "action_counter": 4441
      },
      {
        "commit_message": "fix: Update find_path to correctly identify tiles with 'Hole' markers or object-linked markers as obstacles. This prevents pathfinding through dangerous tiles in the Burned Tower.",
        "timestamp": "2025-11-22T15:59:15.044Z",
        "action_counter": 4454
      },
      {
        "commit_message": "fix: Add PIT to obstacles list in find_path. This prevents the pathfinder from routing the player into pits in the Lighthouse.",
        "timestamp": "2025-11-23T02:50:16.179Z",
        "action_counter": 5202
      },
      {
        "commit_message": "fix: Add LADDER to obstacles list in find_path. This prevents the pathfinder from routing through ladders which are warps, avoiding accidental map transitions.",
        "timestamp": "2025-11-23T05:18:17.385Z",
        "action_counter": 5381
      },
      {
        "commit_message": "fix: Update find_path to be context-aware for Surfing. Now checks if the player is on a WATER tile; if so, removes WATER from the obstacle list. Also added BUOY to the base obstacle list to prevent pathing into buoys.",
        "timestamp": "2025-11-23T12:00:41.709Z",
        "action_counter": 5818
      },
      {
        "commit_message": "fix: Add FLOOR_UP_WALL, FLOOR_DOWN_WALL, FLOOR_LEFT_WALL, and FLOOR_RIGHT_WALL to the obstacles list in find_path. These tiles represent ledges or one-way walls in the current map data (Mt. Mortar) and were causing pathfinding failures.",
        "timestamp": "2025-11-24T01:30:19.414Z",
        "action_counter": 6532
      },
      {
        "commit_message": "fix: Explicitly add FLOOR_UP_WALL, FLOOR_DOWN_WALL, FLOOR_LEFT_WALL, and FLOOR_RIGHT_WALL to the base_obstacles set. These tiles are solid walls (ledge faces) and caused pathfinding errors when the tool incorrectly treated them as traversable.",
        "timestamp": "2025-11-24T02:01:48.846Z",
        "action_counter": 6571
      },
      {
        "commit_message": "fix: Update find_path to treat tiles marked with 'Trap' or 'ðŸ’£' as obstacles. This is critical for navigating the trap-filled corridor in Team Rocket Base B1F.",
        "timestamp": "2025-11-24T20:34:39.795Z",
        "action_counter": 7056
      },
      {
        "commit_message": "fix: Add COUNTER, BOOKSHELF, PC, TV, RADIO, WINDOW, TOWN_MAP, and MART_SHELF to the obstacle list in find_path. These are solid objects that block movement but were previously treated as traversable, causing pathfinding failures in the Rocket Base.",
        "timestamp": "2025-11-24T21:20:07.644Z",
        "action_counter": 7120
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE and CUT_TREE to obstacle_types in find_path. Previously, the tool treated these tiles as traversable, causing invalid paths through solid trees.",
        "timestamp": "2025-11-28T21:17:01.577Z",
        "action_counter": 12561
      },
      {
        "commit_message": "fix: Make obstacle detection robust by treating any tile type containing 'WALL' or 'TREE' as an obstacle. This prevents pathfinding failures on HEADBUTT_TREE or variant wall tiles that were previously missed.",
        "timestamp": "2025-11-28T21:27:51.596Z",
        "action_counter": 12576
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T21:45:16.721Z",
        "action_counter": 12601
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T21:48:50.709Z",
        "action_counter": 12606
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T21:53:24.421Z",
        "action_counter": 12612
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T21:56:57.360Z",
        "action_counter": 12616
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T21:59:09.404Z",
        "action_counter": 12620
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T22:03:11.092Z",
        "action_counter": 12625
      },
      {
        "commit_message": "fix: Added 'BOULDER' to obstacle keywords and explicitly checked for marker IDs to ensure dynamic objects are treated as obstacles. Added redundant checks for object attributes.",
        "timestamp": "2025-11-29T04:38:45.546Z",
        "action_counter": 13141
      },
      {
        "commit_message": "fix: Remove syntax error (garbage characters) from the end of the script and ensure 'BOULDER' is in the obstacle list.",
        "timestamp": "2025-11-29T04:41:30.820Z",
        "action_counter": 13146
      },
      {
        "commit_message": "fix: Remove 'LADDER' from obstacle_substrings. LADDER tiles are traversable and necessary for navigation in multi-floor areas like Dragon's Den. Previously, the tool incorrectly treated them as walls, causing pathfinding failures.",
        "timestamp": "2025-11-30T10:59:03.285Z",
        "action_counter": 14869
      },
      {
        "commit_message": "fix: Update find_path to be context-aware for Surfing. Now, if the player is surfing, all non-water tiles are treated as obstacles UNLESS they are the specific target destination. This prevents the pathfinder from creating routes that cut corners over land, which causes accidental dismounting.",
        "timestamp": "2025-11-30T11:33:19.757Z",
        "action_counter": 14914
      },
      {
        "commit_message": "feat: Update find_path to use Dijkstra with weighted edges. Adds high penalty for Land->Water transitions when player is surfing to prevent accidental dismounting/corner-cutting. Treats 'unseen' tiles as Water to allow optimistic pathfinding.",
        "timestamp": "2025-11-30T11:37:19.429Z",
        "action_counter": 14916
      },
      {
        "commit_message": "fix: Improve terrain handling. 1) When Walking, treat WATER tiles as obstacles. 2) When Surfing, penalize Water->Land transitions (dismounting) unless the land tile is the specific target. This prevents accidental dismounting and walking on water.",
        "timestamp": "2025-11-30T12:31:57.252Z",
        "action_counter": 14977
      },
      {
        "commit_message": "fix: Improve terrain handling. 1) When Walking, treat WATER tiles as obstacles. 2) When Surfing, penalize Water->Land transitions (dismounting) unless the land tile is the specific target. This prevents accidental dismounting and walking on water.",
        "timestamp": "2025-11-30T12:49:59.585Z",
        "action_counter": 14982
      },
      {
        "commit_message": "fix: Improve terrain handling. 1) When Walking, treat WATER tiles as obstacles. 2) When Surfing, penalize Water->Land transitions (dismounting) unless the land tile is the specific target. This prevents accidental dismounting and walking on water.",
        "timestamp": "2025-11-30T13:08:37.662Z",
        "action_counter": 14990
      },
      {
        "commit_message": "fix: Improve find_path robustness. 1) Better Player detection using has-player attribute. 2) Optimistic 'unseen' tile handling (matches current state). 3) Prevent start node from being treated as obstacle.",
        "timestamp": "2025-11-30T13:13:01.533Z",
        "action_counter": 14993
      },
      {
        "commit_message": "fix: Improve terrain handling. 1) When Surfing, penalize ANY transition between Water and Land (cost 1000). This encourages staying in the current medium (Water) until the destination requires landing, preventing inefficient 'island hopping' or accidental dismounting. 2) When Walking, treat Water as high-cost/obstacle to prefer land paths.",
        "timestamp": "2025-11-30T13:35:12.114Z",
        "action_counter": 14997
      },
      {
        "commit_message": "fix: Redefine find_path to strictly handle Surfing state. Detects player_on_water from map XML. If Surfing, penalizes Water->Land transitions (dismounting) unless destination is Land. If Walking, treats Water as high-cost. Optimistic handling for unseen tiles matching current medium.",
        "timestamp": "2025-11-30T13:57:04.458Z",
        "action_counter": 15011
      },
      {
        "commit_message": "fix: Improve find_path logic for surfing transitions. Explicitly penalize Water->Land (dismounting) unless destination is Land. Correctly detect 'is_water' property from map XML. Optimistic handling for unseen tiles.",
        "timestamp": "2025-11-30T13:58:34.916Z",
        "action_counter": 15013
      },
      {
        "commit_message": "fix: Add DOOR, CAVE, and STAIRS to obstacle list in find_path. This prevents the pathfinder from routing through warps as shortcuts, ensuring it sticks to the current map logic unless the warp is the explicit target.",
        "timestamp": "2025-11-30T14:01:17.738Z",
        "action_counter": 15014
      },
      {
        "commit_message": "fix: Redefine find_path to strictly handle Surfing state. Detects player_on_water from map XML. If Surfing, penalizes Water->Land transitions (dismounting) unless destination is Land. If Walking, treats Water as high-cost. Optimistic handling for unseen tiles matching current medium.",
        "timestamp": "2025-11-30T14:05:52.961Z",
        "action_counter": 15018
      },
      {
        "commit_message": "fix: Overhaul find_path logic for surfing. 1) Strictly detect player state (Water/Land). 2) If Surfing, apply massive 10000 cost to dismounting UNLESS destination is the target or adjacent. 3) If Walking, apply massive cost to entering water. 4) Treat warps (DOOR, CAVE) as obstacles to prevent accidental entry.",
        "timestamp": "2025-11-30T14:13:34.568Z",
        "action_counter": 15023
      },
      {
        "commit_message": "fix: Overhaul find_path logic for surfing. 1) Strictly detect player state (Water/Land) from XML. 2) If Surfing, apply massive 10000 cost to dismounting UNLESS destination is the target. 3) If Walking, apply massive cost to entering water. 4) Correct logic to check Water->Land transition.",
        "timestamp": "2025-11-30T14:29:22.468Z",
        "action_counter": 15036
      },
      {
        "commit_message": "fix: Overhaul find_path logic for surfing. 1) Strictly detect player state (Water/Land) from XML. 2) If Surfing, apply massive 10000 cost to dismounting UNLESS destination is the target. 3) If Walking, apply massive cost to entering water. 4) Correct logic to check Water->Land transition.",
        "timestamp": "2025-11-30T14:44:58.505Z",
        "action_counter": 15055
      },
      {
        "commit_message": "fix: Overhaul find_path. 1) Detect surfing state. 2) Penalize dismounting (Water->Land) unless target. 3) Penalize entering water (Land->Water) unless surfing. 4) Treat non-target Warps and Objects as obstacles. 5) Handle blocked targets by pathing to adjacent tiles.",
        "timestamp": "2025-12-01T00:58:00.885Z",
        "action_counter": 15865
      },
      {
        "commit_message": "fix: Overhaul find_path. 1) Detect surfing state. 2) Penalize dismounting (Water->Land) unless target. 3) Penalize entering water (Land->Water) unless surfing. 4) Treat non-target Warps and Objects as obstacles. 5) Handle blocked targets by pathing to adjacent tiles.",
        "timestamp": "2025-12-01T01:01:23.396Z",
        "action_counter": 15871
      },
      {
        "commit_message": "fix: Overhaul find_path logic. 1) Strictly detect surfing state from XML. 2) Penalize dismounting (Water->Land) unless target. 3) Penalize entering water (Land->Water) unless surfing. 4) Treat Warps and Objects as obstacles unless they are the target. 5) Handle blocked targets (like NPCs) by pathing to the nearest traversable adjacent tile.",
        "timestamp": "2025-12-01T01:06:11.937Z",
        "action_counter": 15879
      },
      {
        "commit_message": "fix: Add CUT_TREE, BUOY, and WHIRLPOOL to the list of impassable tile types in get_cost. This prevents the pathfinder from generating paths through obstacles that require HM interaction.",
        "timestamp": "2025-12-01T22:21:32.123Z",
        "action_counter": 16767
      },
      {
        "commit_message": "fix: Add strict directional logic for LEDGE_HOP tiles (DOWN, UP, LEFT, RIGHT). The pathfinder now returns infinity cost if attempting to enter a ledge tile from any direction other than the hop direction (e.g., entering LEDGE_HOP_DOWN from below is now blocked).",
        "timestamp": "2025-12-02T04:33:45.317Z",
        "action_counter": 17245
      },
      {
        "commit_message": "fix: Improve find_path robustness. 1) Strip whitespace and uppercase tile types. 2) Explicitly add WINDOW and CAVE_WALL to blocked types. 3) Fix potential edge cases with blocked targets.",
        "timestamp": "2025-12-02T23:35:55.644Z",
        "action_counter": 17976
      },
      {
        "commit_message": "fix: Add FLOOR_UP_WALL to impassable tile types. This tile type blocked movement on Route 9, acting as a wall. Adding it prevents the pathfinder from attempting to walk through these tiles.",
        "timestamp": "2025-12-03T00:05:44.630Z",
        "action_counter": 18005
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from impassable tile types. This tile type acts as a traversable plateau edge on Route 9, and treating it as a wall was blocking the only valid path around an obstacle.",
        "timestamp": "2025-12-03T03:37:35.832Z",
        "action_counter": 18248
      },
      {
        "commit_message": "fix: Re-add FLOOR_UP_WALL to impassable tile types. Movement test at (41, 15) -> (41, 16) confirmed this tile type blocks movement on Route 9, requiring the pathfinder to route around it.",
        "timestamp": "2025-12-03T03:43:12.611Z",
        "action_counter": 18254
      },
      {
        "commit_message": "fix: Add BOOKSHELF, TV, PC, TOWN_MAP, and MART_SHELF to impassable tile types. These tiles were previously treated as walkable, causing pathfinding errors in buildings.",
        "timestamp": "2025-12-05T15:51:06.365Z",
        "action_counter": 20331
      },
      {
        "commit_message": "fix: Update find_path to handle directional walls (FLOOR_LEFT_WALL, FLOOR_RIGHT_WALL). These tiles now correctly block movement in their named direction (e.g., cannot move Left from FLOOR_LEFT_WALL), preventing invalid paths through walls.",
        "timestamp": "2025-12-05T18:41:22.776Z",
        "action_counter": 20524
      },
      {
        "commit_message": "fix: Strictly enforce directional logic for LEDGE_HOP tiles. LEDGE_HOP_LEFT now correctly blocks movement unless entering from the Right (dx=-1). This prevents pathfinding errors where the tool attempted to walk through ledges from the wrong direction.",
        "timestamp": "2025-12-06T02:30:36.490Z",
        "action_counter": 21196
      },
      {
        "commit_message": "fix: Add UNSEEN to impassable tile types. The pathfinder was previously routing through unseen tiles (e.g., Row 1 of Route 8), assuming they were walkable. This caused it to generate invalid paths through walls or out-of-bounds areas. Treating UNSEEN as impassable ensures paths are only generated through confirmed walkable terrain.",
        "timestamp": "2025-12-06T07:06:45.348Z",
        "action_counter": 21628
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE, CUT_08, and CUT_28_GARBAGE to impassable tile types. The pathfinder was attempting to route through HEADBUTT_TREE tiles, causing navigation failures.",
        "timestamp": "2025-12-09T00:17:39.859Z",
        "action_counter": 24970
      },
      {
        "commit_message": "fix: Update find_path to treat tiles with object-linked Markers as obstacles. This ensures that off-screen NPCs, which are not present in the <Object> list but are tracked by Map Markers with an object_id, are correctly treated as blocked tiles. This prevents pathfinding through known but off-screen obstacles.",
        "timestamp": "2025-12-09T00:45:41.605Z",
        "action_counter": 24996
      },
      {
        "commit_message": "fix: Add COUNTER to impassable tile types. The pathfinder was incorrectly attempting to route through counter tiles, causing collisions in buildings. This ensures paths respect counters as obstacles.",
        "timestamp": "2025-12-09T18:51:22.286Z",
        "action_counter": 25626
      },
      {
        "commit_message": "fix: Add COUNTER to impassable tile types. The pathfinder was incorrectly attempting to route through counter tiles, causing collisions in buildings. This ensures paths respect counters as obstacles.",
        "timestamp": "2025-12-09T19:36:33.019Z",
        "action_counter": 25683
      }
    ]
  },
  "press_sequence": {
    "description": "Executes a custom sequence of button presses defined by a comma-separated string. Robustly handles whitespace and returns valid JSON. Valid buttons: A, B, Up, Down, Left, Right, Start, Select.",
    "input_schema": {
      "type": "object",
      "properties": {
        "sequence": {
          "type": "string",
          "description": "Comma-separated list of buttons and sleep commands (e.g. 'A, sleep 500, Down')."
        }
      },
      "required": [
        "sequence"
      ]
    },
    "python_script": "import json\nsequence = input_data['sequence']\ncomponents = [s.strip() for s in sequence.split(',')]\nprint(json.dumps(components))",
    "history": [
      {
        "commit_message": "feat: Create press_sequence tool to allow execution of complex, mixed-button sequences in a single turn, overcoming the limitations of force_press_button (single button type) and run_code (no autopress).",
        "timestamp": "2025-12-06T08:59:06.250Z",
        "action_counter": 21796
      },
      {
        "commit_message": "fix: Strip whitespace from input components to ensure reliable parsing. Previous version likely failed on inputs like 'Up, A' due to leading spaces.",
        "timestamp": "2025-12-07T20:45:07.508Z",
        "action_counter": 23841
      },
      {
        "commit_message": "fix: Strip whitespace from input components to ensure reliable parsing. Previous version likely failed on inputs like 'Up, A' due to leading spaces.",
        "timestamp": "2025-12-07T20:50:07.618Z",
        "action_counter": 23847
      },
      {
        "commit_message": "fix: Strip whitespace from input components to ensure reliable parsing. Previous version likely failed on inputs like 'Up, A' due to leading spaces.",
        "timestamp": "2025-12-07T21:19:37.746Z",
        "action_counter": 23867
      },
      {
        "commit_message": "fix: Use json.dumps to ensure output is valid JSON (double quotes). Previous version used single quotes which caused parsing errors.",
        "timestamp": "2025-12-07T21:34:03.551Z",
        "action_counter": 23868
      },
      {
        "commit_message": "fix: Ensure output is valid JSON using json.dumps and strip whitespace from input components. This resolves the invalid JSON error caused by Python's default single-quote string representation.",
        "timestamp": "2025-12-07T22:08:40.922Z",
        "action_counter": 23877
      },
      {
        "commit_message": "fix: Ensure output is valid JSON using json.dumps and strip whitespace from input components. This resolves the invalid JSON error caused by Python's default single-quote string representation.",
        "timestamp": "2025-12-07T22:14:24.466Z",
        "action_counter": 23885
      },
      {
        "commit_message": "fix: Ensure output is valid JSON using json.dumps and strip whitespace from input components. This resolves the invalid JSON error caused by Python's default single-quote string representation.",
        "timestamp": "2025-12-07T22:16:48.647Z",
        "action_counter": 23890
      },
      {
        "commit_message": "fix: Ensure output is valid JSON using json.dumps and strip whitespace from input components. This resolves the invalid JSON error caused by Python's default single-quote string representation.",
        "timestamp": "2025-12-07T22:31:08.619Z",
        "action_counter": 23909
      }
    ]
  },
  "select_move": {
    "description": "Automatically selects a move in the battle menu by parsing the screen text for the cursor 'â–¶' and the target move name in a vertical list. Adds sleep delays for robustness.",
    "input_schema": {
      "type": "object",
      "properties": {
        "move_name": {
          "type": "string"
        },
        "screen_text": {
          "type": "string"
        }
      },
      "required": [
        "move_name",
        "screen_text"
      ]
    },
    "python_script": "import json\n\ninput_data = locals().get('input_data', {})\nscreen_text = input_data.get('screen_text', '')\ntarget_move = input_data.get('move_name', '').upper()\n\nlines = screen_text.split('\\n')\ncursor_line = -1\ntarget_line = -1\n\nfor i, line in enumerate(lines):\n    if 'â–¶' in line:\n        cursor_line = i\n    if target_move in line.upper():\n        target_line = i\n\nbuttons = []\nif cursor_line != -1 and target_line != -1:\n    diff = target_line - cursor_line\n    if diff > 0:\n        for _ in range(diff):\n            buttons.append(\"Down\")\n            buttons.append(\"sleep 500\")\n    elif diff < 0:\n        for _ in range(abs(diff)):\n            buttons.append(\"Up\")\n            buttons.append(\"sleep 500\")\n\nbuttons.append(\"A\")\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "feat: Add select_move tool to automate move selection in battle menus, preventing manual input errors.",
        "timestamp": "2025-11-25T17:55:51.068Z",
        "action_counter": 7861
      },
      {
        "commit_message": "fix: Refine select_move to strictly validate inputs and ensure robust cursor detection logic, addressing the persistent cursor memory issue identified in critique.",
        "timestamp": "2025-11-30T07:21:13.927Z",
        "action_counter": 14672
      },
      {
        "commit_message": "fix: Refine select_move to strictly validate inputs and ensure robust cursor detection logic, addressing the persistent cursor memory issue identified in critique.",
        "timestamp": "2025-11-30T07:23:59.588Z",
        "action_counter": 14676
      },
      {
        "commit_message": "fix: Refine select_move to strictly validate inputs and ensure robust cursor detection logic, addressing the persistent cursor memory issue identified in critique.",
        "timestamp": "2025-11-30T07:25:07.230Z",
        "action_counter": 14678
      },
      {
        "commit_message": "fix: Refine select_move logic to robustly detect cursor and target move from screen text, adding debug prints to diagnose issues. This ensures the tool correctly handles persistent cursor memory in menus.",
        "timestamp": "2025-11-30T07:34:46.846Z",
        "action_counter": 14693
      },
      {
        "commit_message": "fix: Remove debug print statements that were causing JSON parsing errors. The tool now strictly outputs only the JSON array of button presses.",
        "timestamp": "2025-11-30T16:50:55.137Z",
        "action_counter": 15149
      },
      {
        "commit_message": "fix: Remove debug print statements causing JSON errors. Improve cursor and target detection logic to strictly output valid JSON button arrays.",
        "timestamp": "2025-11-30T17:09:48.544Z",
        "action_counter": 15170
      },
      {
        "commit_message": "fix: Overhaul select_move with robust 2x2 grid parsing. Now detects 'â–¶' cursor and target move row/column to calculate navigation steps, preventing errors where the tool assumed the cursor was already correctly placed.",
        "timestamp": "2025-12-01T09:07:47.934Z",
        "action_counter": 16323
      },
      {
        "commit_message": "fix: Update select_move to handle vertical move lists used in Gen 2 (Crystal), replacing the incorrect 2x2 grid logic. Calculates button presses based on line difference between the cursor 'â–¶' and the target move in the screen text.",
        "timestamp": "2025-12-01T21:58:56.900Z",
        "action_counter": 16736
      },
      {
        "commit_message": "fix: Add sleep delays (500ms) between directional inputs in select_move to ensure the game registers each press during menu navigation. This addresses reliability issues where rapid inputs were ignored.",
        "timestamp": "2025-12-05T07:29:11.785Z",
        "action_counter": 19985
      }
    ]
  },
  "smart_scroll": {
    "description": "Selects an item or move from a vertical list by parsing screen text. If the target is found, navigates to it and presses A. If not found, scrolls down to reveal more options.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_text": {
          "type": "string"
        },
        "screen_text": {
          "type": "string"
        }
      },
      "required": [
        "target_text",
        "screen_text"
      ]
    },
    "python_script": "import json\ntry:\n    target = input_data['target_text'].upper()\n    text = input_data['screen_text']\n    lines = text.split('\\n')\n    cursor_row = -1\n    target_row = -1\n    \n    for i, line in enumerate(lines):\n        if 'â–¶' in line:\n            cursor_row = i\n        if target in line.upper():\n            target_row = i\n            \n    buttons = []\n    if cursor_row != -1 and target_row != -1:\n        # Target is on screen\n        diff = target_row - cursor_row\n        if diff > 0:\n            for _ in range(diff):\n                buttons.append(\"Down\")\n                buttons.append(\"sleep 200\")\n        elif diff < 0:\n            for _ in range(abs(diff)):\n                buttons.append(\"Up\")\n                buttons.append(\"sleep 200\")\n        buttons.append(\"A\")\n    else:\n        # Target not found, scroll down 3 times\n        for _ in range(3):\n            buttons.append(\"Down\")\n            buttons.append(\"sleep 200\")\n            \n    print(json.dumps(buttons))\nexcept Exception as e:\n    print(json.dumps([]))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-10T03:05:49.734Z",
        "action_counter": 26395
      }
    ]
  }
}