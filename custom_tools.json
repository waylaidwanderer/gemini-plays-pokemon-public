{
  "sequence_press": {
    "description": "Executes a sequence of button presses to navigate menus or perform actions. Allows mixing directional and action buttons.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\ntry:\n    buttons = input_data['buttons']\n    print(json.dumps(buttons))\nexcept KeyError:\n    print(\"Error: 'buttons' key not found in input_data\")\n    print(f\"input_data keys: {input_data.keys()}\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T08:10:06.907Z",
        "action_counter": 33328
      },
      {
        "commit_message": "Initial definition of sequence_press tool",
        "timestamp": "2026-01-11T10:39:20.952Z",
        "action_counter": 33514
      },
      {
        "commit_message": "Debugging tool to find variable injection method",
        "timestamp": "2026-01-11T10:41:14.927Z",
        "action_counter": 33517
      },
      {
        "commit_message": "Fix variable access by using input_data dictionary",
        "timestamp": "2026-01-11T10:43:22.032Z",
        "action_counter": 33520
      }
    ]
  },
  "pathfind": {
    "description": "Finds a path from the player's current position to a target coordinate using BFS. Returns a list of buttons.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\n# Retrieve arguments safely from input_data\ntry:\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    autopress_buttons = bool(input_data.get('autopress_buttons', False))\nexcept (NameError, KeyError, ValueError) as e:\n    print(json.dumps({\"error\": f\"Invalid arguments: {e}\"}))\n    exit()\n\ndef pathfind(target_x, target_y, autopress_buttons=False):\n    # Parse the map XML\n    try:\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        print(json.dumps({\"error\": f\"Error parsing XML: {e}\"}))\n        return []\n\n    # Get map dimensions\n    try:\n        width = int(root.attrib.get('width'))\n        height = int(root.attrib.get('height'))\n    except:\n        return []\n    \n    # Get player position\n    player_pos = None\n    \n    # Build the grid and find player\n    grid = {}\n    \n    for row in root.findall('Row'):\n        try:\n            y = int(row.attrib['id'])\n        except:\n            continue\n            \n        for tile in row.findall('Tile'):\n            try:\n                x = int(tile.attrib['id'])\n            except:\n                continue\n                \n            t_type = tile.attrib.get('type', 'unseen')\n            \n            # Check for player\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n            elif tile.attrib.get('has-player') == 'true':\n                 player_pos = (x, y)\n\n            # Determine walkability\n            walkable = True\n            # Basic blocking types\n            if t_type in ['WALL', 'HEADBUTT_TREE', 'unseen', 'WATER']: \n                walkable = False\n            # Ledges are complicated, treat as obstacles for simple pathfinding unless we want to handle one-way logic\n            if 'LEDGE' in t_type:\n                walkable = False\n                \n            # Check for objects (which act as walls)\n            # Note: We do NOT filter out the target tile if it has an object/warp, \n            # because sometimes we want to path TO an object to interact.\n            # But we can't stand ON it.\n            # For this 'movement' tool, we assume we want to stand on the target.\n            # If target has object, we effectively can't go there.\n            \n            has_object = False\n            if tile.find('Object') is not None:\n                has_object = True\n            if tile.attrib.get('has-object') == 'true':\n                has_object = True\n            \n            if has_object:\n                walkable = False\n\n            grid[(x, y)] = walkable\n\n    if player_pos is None:\n        print(json.dumps({\"error\": \"Player position not found in XML.\"}))\n        return []\n\n    start = player_pos\n    goal = (target_x, target_y)\n\n    if start == goal:\n        return []\n        \n    # Check if goal is walkable according to our strict grid\n    if not grid.get(goal, False):\n        # Optional: Print why it failed for debugging, but return empty list to not break schema\n        # print(f\"Target {goal} is not walkable.\")\n        return []\n\n    # BFS\n    queue = deque([(start, [])])\n    visited = {start}\n    \n    while queue:\n        (cx, cy), path = queue.popleft()\n        \n        if (cx, cy) == goal:\n            return path\n        \n        moves = [\n            (0, -1, 'Up'),\n            (0, 1, 'Down'),\n            (-1, 0, 'Left'),\n            (1, 0, 'Right')\n        ]\n        \n        for dx, dy, direction in moves:\n            nx, ny = cx + dx, cy + dy\n            \n            if 0 <= nx < width and 0 <= ny < height:\n                if grid.get((nx, ny), False):\n                    if (nx, ny) not in visited:\n                        visited.add((nx, ny))\n                        queue.append(((nx, ny), path + [direction]))\n                        \n    # No path found\n    return []\n\nprint(json.dumps(pathfind(target_x, target_y, autopress_buttons)))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T09:01:19.563Z",
        "action_counter": 33384
      },
      {
        "commit_message": "Fixed NameError by using globals().get() to safely retrieve injected arguments. Added autopress_buttons support.",
        "timestamp": "2026-01-11T16:48:12.265Z",
        "action_counter": 34015
      },
      {
        "commit_message": "Refined JSON output compliance using json.dumps to avoid parsing errors.",
        "timestamp": "2026-01-11T16:49:46.390Z",
        "action_counter": 34017
      },
      {
        "commit_message": "Added debug logic to inspect available variables if arguments are missing.",
        "timestamp": "2026-01-11T16:50:53.134Z",
        "action_counter": 34018
      },
      {
        "commit_message": "Updated to retrieve arguments from `input_data` global dictionary.",
        "timestamp": "2026-01-11T16:51:34.865Z",
        "action_counter": 34019
      },
      {
        "commit_message": "Fixed XML parsing logic to correctly iterate Rows and Tiles instead of using unsupported '..' XPath.",
        "timestamp": "2026-01-11T16:52:03.375Z",
        "action_counter": 34020
      },
      {
        "commit_message": "Added WARP_CARPET_* and DOOR types to traversable list.",
        "timestamp": "2026-01-11T17:10:57.545Z",
        "action_counter": 34044
      },
      {
        "commit_message": "Fixing pathfind tool to return valid JSON array on failure instead of an object, preventing schema validation errors.",
        "timestamp": "2026-01-12T04:10:40.878Z",
        "action_counter": 34986
      },
      {
        "commit_message": "Fixed 'pathfind' tool by explicitly accessing 'target_x' and 'target_y' from the 'input_data' dictionary, resolving the NameError.",
        "timestamp": "2026-01-12T04:13:03.377Z",
        "action_counter": 34988
      },
      {
        "commit_message": "Fixed XML parsing, added proper grid construction checking for walls, objects, and ledges, and implemented BFS for shortest path.",
        "timestamp": "2026-01-12T09:14:34.850Z",
        "action_counter": 35403
      },
      {
        "commit_message": "Fixed NameError by explicitly retrieving arguments from the `input_data` dictionary.",
        "timestamp": "2026-01-12T09:15:49.641Z",
        "action_counter": 35405
      }
    ]
  },
  "zigzag_sweep": {
    "description": "Generates and executes a zigzag button sequence to sweep a rectangular area. Useful for hunting in grass patches.",
    "input_schema": {
      "type": "object",
      "properties": {
        "cols": {
          "type": "integer",
          "description": "Number of columns (width) of the area."
        },
        "rows": {
          "type": "integer",
          "description": "Number of rows (height) of the area."
        },
        "start_side": {
          "type": "string",
          "enum": [
            "left",
            "right"
          ],
          "default": "left",
          "description": "The side you are starting on. 'left' means Top-Left, 'right' means Top-Right."
        }
      },
      "required": [
        "cols",
        "rows"
      ]
    },
    "python_script": "import json\n\nbuttons = []\ncols = int(input_data['cols'])\nrows = int(input_data['rows'])\nstart_side = input_data.get('start_side', 'left')\n\nfor r in range(rows):\n    if start_side == 'left':\n        # Even rows (0, 2): Right\n        # Odd rows (1, 3): Left\n        direction = 'Right' if r % 2 == 0 else 'Left'\n    else:\n        # Even rows (0, 2): Left\n        # Odd rows (1, 3): Right\n        direction = 'Left' if r % 2 == 0 else 'Right'\n        \n    for _ in range(cols - 1):\n        buttons.append(direction)\n        \n    if r < rows - 1:\n        buttons.append('Down')\n\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T19:32:17.062Z",
        "action_counter": 34231
      }
    ]
  },
  "scan_unseen_tiles": {
    "description": "Analyzes the current map to identify which 'unseen' tiles are currently reachable by the player using a BFS traversal. This helps prioritize exploration and dismiss unreachable areas.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef is_walkable(type_str):\n    # Basic list of walkable types. Expand as needed based on game logic.\n    walkable = [\"FLOOR\", \"TALL_GRASS\", \"LONG_GRASS\", \"PUDDLE\", \"GRASS\", \"SAND\", \"FLOOR_UP_WALL\", \"FLOOR_DOWN_WALL\", \"FLOOR_LEFT_WALL\", \"FLOOR_RIGHT_WALL\"]\n    return type_str in walkable\n\ndef solve():\n    if 'map_xml_string' not in globals():\n        print(\"Error: map_xml_string not found.\")\n        return\n\n    try:\n        root = ET.fromstring(map_xml_string)\n        # width = int(root.attrib['width'])\n        # height = int(root.attrib['height'])\n        \n        grid = {} # (x,y) -> tile_element\n        player_pos = None\n        \n        # Parse tiles\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                grid[(x,y)] = tile\n                \n                if tile.get('has-player') == 'true':\n                    player_pos = (x, y)\n                if tile.find('Player') is not None:\n                    player_pos = (x, y)\n\n        if not player_pos:\n            print(\"Error: Player position not found in map data.\")\n            return\n\n        # BFS to find all reachable tiles\n        queue = deque([player_pos])\n        visited = set([player_pos])\n        reachable_tiles = set([player_pos])\n        \n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n        \n        while queue:\n            cx, cy = queue.popleft()\n            \n            for dx, dy in directions:\n                nx, ny = cx + dx, cy + dy\n                \n                if (nx, ny) in grid and (nx, ny) not in visited:\n                    tile = grid[(nx, ny)]\n                    tile_type = tile.attrib['type']\n                    \n                    # Check if walkable and no blocking object\n                    # Simplified: assume all objects block for now (unless we want to interact)\n                    has_object = tile.get('has-object') == 'true' or len(tile.findall('Object')) > 0\n                    \n                    if is_walkable(tile_type) and not has_object:\n                        visited.add((nx, ny))\n                        reachable_tiles.add((nx, ny))\n                        queue.append((nx, ny))\n                    elif has_object:\n                         # Reachable for interaction, but not passable\n                         visited.add((nx, ny))\n                         reachable_tiles.add((nx, ny))\n\n        # Check for unseen tiles adjacent to reachable tiles\n        reachable_unseen = []\n        \n        for (rx, ry) in reachable_tiles:\n            for dx, dy in directions:\n                nx, ny = rx + dx, ry + dy\n                if (nx, ny) in grid:\n                    neighbor = grid[(nx, ny)]\n                    if neighbor.attrib.get('seen') == 'false':\n                        if (nx, ny) not in reachable_unseen:\n                            reachable_unseen.append((nx, ny))\n\n        reachable_unseen.sort()\n        print(f\"Reachable Unseen Tiles: {reachable_unseen}\")\n        \n    except Exception as e:\n        print(f\"Error parsing map or processing: {e}\")\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-12T14:58:55.507Z",
        "action_counter": 35770
      }
    ]
  }
}