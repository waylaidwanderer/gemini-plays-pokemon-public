{
  "find_path_v2": {
    "description": "Finds a path from the player's current position to a target coordinate on the current map using BFS. Returns a list of coordinate dictionaries, or a list of button strings if autopress_buttons is true. If the target is impassable, it finds a path to an adjacent traversable tile. Handles 'unseen' tiles as potentially walkable for exploration. Correctly handles one-way ledge mechanics.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "description": "If true and the tool returns a list of buttons, they will be pressed automatically.",
          "type": "boolean"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y",
        "autopress_buttons"
      ],
      "type": "object"
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\nimport json\n\ndef solve():\n    try:\n        if not map_xml_string:\n            print(\"Error: map_xml_string is empty.\")\n            return\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        print(f\"Error parsing XML: {e}\")\n        return\n\n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n        autopress = input_data.get('autopress_buttons', False)\n    except (KeyError, ValueError) as e:\n        print(f\"Error in input data: {e}\")\n        return\n    \n    tiles = {}\n    start_x, start_y = None, None\n    for row in root.findall('Row'):\n        row_id_attr = row.attrib.get('id')\n        if row_id_attr is None: continue\n        y = int(row_id_attr)\n        for tile in row.findall('Tile'):\n            tile_id_attr = tile.attrib.get('id')\n            if tile_id_attr is None: continue\n            x = int(tile_id_attr)\n            tiles[(x, y)] = tile\n            if tile.find('Player') is not None:\n                start_x, start_y = x, y\n    \n    if start_x is None:\n        print(\"Error: Player position not found in XML.\")\n        return\n    \n    queue = collections.deque([(start_x, start_y, [{\"x\": start_x, \"y\": start_y}])])\n    visited = set([(start_x, start_y)])\n    reachable = {}\n    \n    impassable_types = [\"WALL\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"WATER\", \"BOOKSHELF\", \"WINDOW\", \"TRASHCAN\", \"PC\", \"BOOKSHELVES\", \"VOID\"]\n    \n    while queue:\n        x, y, path = queue.popleft()\n        reachable[(x, y)] = path\n        if x == target_x and y == target_y:\n            break\n            \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) in visited: continue\n            \n            tile = tiles.get((nx, ny))\n            if tile is None: continue\n            \n            tile_type = tile.attrib.get('type', 'unseen').strip().upper()\n            \n            # Ledge check\n            if \"LEDGE\" in tile_type:\n                can_jump = False\n                if tile_type == \"LEDGE_HOP_DOWN\" and dy == 1: can_jump = True\n                elif tile_type == \"LEDGE_HOP_UP\" and dy == -1: can_jump = True\n                elif tile_type == \"LEDGE_HOP_LEFT\" and dx == -1: can_jump = True\n                elif tile_type == \"LEDGE_HOP_RIGHT\" and dx == 1: can_jump = True\n                \n                if can_jump:\n                    lx, ly = nx + dx, ny + dy\n                    landing_tile = tiles.get((lx, ly))\n                    if landing_tile is not None:\n                        landing_type = landing_tile.attrib.get('type', 'unseen').strip().upper()\n                        if landing_type not in impassable_types and landing_tile.attrib.get('has-object') != 'true' and (lx, ly) not in visited:\n                            visited.add((nx, ny))\n                            visited.add((lx, ly))\n                            new_path = path + [{\"x\": nx, \"y\": ny}, {\"x\": lx, \"y\": ly}]\n                            queue.append((lx, ly, new_path))\n                continue\n\n            if tile_type in impassable_types or tile.attrib.get('has-object') == 'true':\n                continue\n\n            visited.add((nx, ny))\n            queue.append((nx, ny, path + [{\"x\": nx, \"y\": ny}]))\n            \n    final_path = reachable.get((target_x, target_y))\n    \n    if final_path is None:\n        best_dist = float('inf')\n        for (rx, ry), rpath in reachable.items():\n            dist = abs(rx - target_x) + abs(ry - target_y)\n            if dist < best_dist:\n                best_dist = dist\n                final_path = rpath\n                \n    if final_path is None:\n        print(\"Error: No reachable tiles found.\")\n        return\n\n    if autopress:\n        buttons = []\n        for i in range(len(final_path) - 1):\n            curr = final_path[i]\n            next_t = final_path[i+1]\n            if next_t['x'] > curr['x']: buttons.append(\"Right\")\n            elif next_t['x'] < curr['x']: buttons.append(\"Left\")\n            elif next_t['y'] > curr['y']: buttons.append(\"Down\")\n            elif next_t['y'] < curr['y']: buttons.append(\"Up\")\n        print(json.dumps(buttons))\n    else:\n        print(json.dumps(final_path))\n\nsolve()",
    "history": [
      {
        "commit_message": "Refined find_path to handle potential map XML structure variations and ensure the Player location is detected accurately. Added more robust logging for debugging.",
        "timestamp": "2025-12-17T23:52:03.099Z",
        "action_counter": 203
      }
    ]
  },
  "list_unseen_reachable": {
    "description": "Identifies 'unseen' tiles that are adjacent to reachable, traversable tiles on the current map. This helps prioritize exploration targets.",
    "input_schema": {
      "properties": {},
      "type": "object"
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\nimport json\n\ndef solve():\n    try:\n        if not map_xml_string:\n            print(\"[]\")\n            return\n        root = ET.fromstring(map_xml_string)\n    except:\n        print(\"[]\")\n        return\n\n    tiles = {}\n    player_pos = None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tiles[(x, y)] = tile\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n    \n    if not player_pos:\n        print(\"[]\")\n        return\n\n    # BFS to find all reachable tiles\n    queue = collections.deque([player_pos])\n    visited = {player_pos}\n    reachable = set()\n    \n    impassable_types = [\"WALL\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"WATER\", \"BOOKSHELF\", \"WINDOW\", \"TRASHCAN\", \"PC\", \"BOOKSHELVES\", \"VOID\"]\n    \n    while queue:\n        curr = queue.popleft()\n        reachable.add(curr)\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = curr[0] + dx, curr[1] + dy\n            if (nx, ny) in visited: continue\n            \n            tile = tiles.get((nx, ny))\n            if not tile or tile.attrib.get('seen') == 'false': continue\n            \n            tile_type = tile.attrib.get('type', '').strip().upper()\n            if tile_type in impassable_types or tile.attrib.get('has-object') == 'true':\n                continue\n            \n            visited.add((nx, ny))\n            queue.append((nx, ny))\n\n    # Find unseen tiles adjacent to reachable tiles\n    unseen_targets = set()\n    for rx, ry in reachable:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = rx + dx, ry + dy\n            tile = tiles.get((nx, ny))\n            if tile and tile.attrib.get('seen') == 'false':\n                unseen_targets.add((nx, ny))\n                \n    print(json.dumps([{\"x\": x, \"y\": y} for x, y in sorted(list(unseen_targets))]))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version of list_unseen_reachable tool to identify potentially reachable unexplored areas.",
        "timestamp": "2025-12-18T00:25:09.921Z",
        "action_counter": 259
      }
    ]
  },
  "get_path_coords": {
    "description": "Finds a path of coordinates from the player's current position to a target (x, y) on the current map using BFS. Returns a JSON array of coordinate objects.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef main():\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    \n    grid = {}\n    start = None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            has_obj = tile.attrib.get('has-object') == 'true'\n            if tile.find('Player') is not None:\n                start = (x, y)\n            grid[(x, y)] = (t_type, has_obj)\n\n    if start is None:\n        print(json.dumps([]))\n        return\n\n    queue = deque([(start, [start])])\n    visited = {start}\n    \n    while queue:\n        (x, y), path = queue.popleft()\n        \n        if (x, y) == (target_x, target_y):\n            formatted_path = [{\"x\": p[0], \"y\": p[1]} for p in path]\n            print(json.dumps(formatted_path))\n            return\n            \n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) in grid:\n                t_type, has_obj = grid[(nx, ny)]\n                \n                # Traversal rules\n                if t_type in ['WALL', 'HEADBUTT_TREE', 'WATER', 'COUNTER', 'BOOKSHELF', 'WINDOW', 'TREE', 'HEDGE']:\n                    continue\n                if has_obj:\n                    continue\n                \n                # Ledge handling (Down)\n                if t_type == 'LEDGE_HOP_DOWN' and dy == 1:\n                    nnx, nny = nx, ny + 1\n                    if (nnx, nny) in grid:\n                        tt, ho = grid[(nnx, nny)]\n                        if tt in ['FLOOR', 'TALL_GRASS'] and not ho:\n                            if (nnx, nny) not in visited:\n                                visited.add((nnx, nny))\n                                queue.append(((nnx, nny), path + [(nx, ny), (nnx, nny)]))\n                    continue\n\n                if (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append(((nx, ny), path + [(nx, ny)]))\n    print(json.dumps([]))\n\nmain()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T01:50:43.934Z",
        "action_counter": 425
      }
    ]
  }
}