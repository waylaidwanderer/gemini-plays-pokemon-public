{
  "route_finder": {
    "description": "Finds a path between two maps using the World Knowledge Graph.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_map_id": {
          "type": "string"
        },
        "end_map_id": {
          "type": "string"
        }
      },
      "required": [
        "start_map_id",
        "end_map_id"
      ]
    },
    "python_script": "import json\nimport heapq\n\nworld_knowledge_graph_json_string = globals().get('world_knowledge_graph_json_string')\nworld_knowledge = json.loads(world_knowledge_graph_json_string)\nnodes = world_knowledge['nodes']\nedges = world_knowledge['edges']\n\nstart_map = input_data['start_map_id']\nend_map = input_data['end_map_id']\n\ngraph = {}\nfor node in nodes:\n    graph[node['id']] = {'map_id': node['map_id'], 'name': node['name'], 'edges': []}\n\nfor edge in edges:\n    if edge['source_node_id'] in graph and edge['destination_node_id'] in graph:\n        graph[edge['source_node_id']]['edges'].append(edge['destination_node_id'])\n        if not edge.get('is_one_way', False):\n            graph[edge['destination_node_id']]['edges'].append(edge['source_node_id'])\n\nstart_node_id = None\nfor node_id, node_data in graph.items():\n    if node_data['map_id'] == start_map:\n        start_node_id = node_id\n        break\n\nif not start_node_id:\n    print(f'Start node for map {start_map} not found in World Knowledge Graph.')\n    exit()\n\nqueue = [(0, [start_node_id])]\nvisited = {start_node_id}\n\nwhile queue:\n    cost, path = heapq.heappop(queue)\n    current_node_id = path[-1]\n\n    if graph[current_node_id]['map_id'] == end_map:\n        path_details = []\n        for node_id in path:\n            node_info = next((n for n in nodes if n['id'] == node_id), None)\n            if node_info:\n                path_details.append(f\"{node_info['name']} ({node_info['map_id']})\")\n        print(' -> '.join(path_details))\n        exit()\n\n    for neighbor_id in graph[current_node_id]['edges']:\n        if neighbor_id not in visited:\n            visited.add(neighbor_id)\n            new_path = list(path)\n            new_path.append(neighbor_id)\n            heapq.heappush(queue, (cost + 1, new_path))\n\nprint(f'No path found from map {start_map} to {end_map}.')"
  },
  "path_finder": {
    "description": "A robust pathfinding tool using A* algorithm that correctly handles one-way tiles like ledges and hop tiles, as well as all impassable objects and terrain.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\nmap_xml_string = globals().get(\"map_xml_string\")\ninput_data = globals().get(\"input_data\")\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.attrib['width'])\n    map_height = int(root.attrib['height'])\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\nexcept (ValueError, KeyError) as e:\n    print(f\"Error: Invalid input data. {e}\")\n    exit()\n\ngrid = [['UNSEEN' for _ in range(map_width + 1)] for _ in range(map_height + 1)]\nobstacles = set()\nimpassable_types = {\n    'WALL', 'VOID', 'PILLAR', 'COUNTER', 'MART_SHELF', 'BOOKSHELF', 'TV', \n    'RADIO', 'PC', 'TOWN_MAP', 'WINDOW', 'PAINTING', 'CUT_TREE', 'WATER', \n    'BUOY', 'STATUE', 'HEADBUTT_TREE'\n}\n\nfor row in root.findall('Row'):\n    y = int(row.attrib['id'])\n    for tile in row.findall('Tile'):\n        x = int(tile.attrib['id'])\n        grid[y][x] = tile.attrib['type']\n        if tile.attrib.get('has-object') == 'true':\n            obstacles.add((x, y))\n        for marker in tile.findall('Marker'):\n            if marker.attrib['emoji'] == '☠️':\n                obstacles.add((x, y))\n\ndef is_valid(coord):\n    x, y = coord\n    return 1 <= x <= map_width and 1 <= y <= map_height\n\ndef is_impassable(coord):\n    if not is_valid(coord):\n        return True\n    x, y = coord\n    tile_type = grid[y][x]\n    if tile_type == 'UNSEEN' or tile_type in impassable_types or coord in obstacles:\n        return True\n    return False\n\ndef get_neighbors(coord):\n    x, y = coord\n    current_tile_type = grid[y][x]\n    \n    # Handle being ON a one-way tile\n    if 'FLOOR_HOP_DOWN' in current_tile_type: return [(x, y + 1)]\n    if 'FLOOR_HOP_UP' in current_tile_type: return [(x, y - 1)]\n    if 'FLOOR_HOP_LEFT' in current_tile_type: return [(x - 1, y)]\n    if 'FLOOR_HOP_RIGHT' in current_tile_type: return [(x + 1, y)]\n\n    potential_neighbors = []\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        neighbor_coord = (x + dx, y + dy)\n        if is_impassable(neighbor_coord):\n            continue\n        \n        neighbor_tile_type = grid[neighbor_coord[1]][neighbor_coord[0]]\n        \n        # Handle moving TO a one-way tile\n        if 'FLOOR_HOP' in neighbor_tile_type: continue\n        if 'LEDGE' in neighbor_tile_type and dy != 1: continue\n        if 'FLOOR_UP_WALL' in neighbor_tile_type and dy != -1: continue # Can only move UP onto this tile\n\n        potential_neighbors.append(neighbor_coord)\n    return potential_neighbors\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\nif is_impassable(end_node):\n    original_end_node = end_node\n    found_new_target = False\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        new_end = (original_end_node[0] + dx, original_end_node[1] + dy)\n        if not is_impassable(new_end):\n            end_node = new_end\n            found_new_target = True\n            break\n    if not found_new_target:\n        print(f\"Error: No traversable tiles adjacent to {original_end_node}.\")\n        exit()\n\nopen_set = [(0, start_node)]\ncame_from = {}\ng_score = {start_node: 0}\n\nwhile open_set:\n    _, current = heapq.heappop(open_set)\n\n    if current == end_node:\n        path = []\n        temp = current\n        while temp in came_from:\n            path.append(f\"{temp[0]},{temp[1]}\")\n            temp = came_from[temp]\n        path.append(f\"{start_node[0]},{start_node[1]}\")\n        print(','.join(path[::-1]))\n        exit()\n\n    for neighbor in get_neighbors(current):\n        tentative_g_score = g_score.get(current, float('inf')) + 1\n        if tentative_g_score < g_score.get(neighbor, float('inf')):\n            came_from[neighbor] = current\n            g_score[neighbor] = tentative_g_score\n            heapq.heappush(open_set, (tentative_g_score + heuristic(neighbor, end_node), neighbor))\n\nprint(f\"Error: No path found from {start_node} to {end_node}.\")"
  }
}