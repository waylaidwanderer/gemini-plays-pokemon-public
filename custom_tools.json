{
  "find_path": {
    "description": "Finds the shortest path on the current map using BFS. Avoids impassable tiles, objects, and unseen areas.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef find_path_logic(map_xml_string, start_x, start_y, end_x, end_y):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = [['' for _ in range(width + 1)] for _ in range(height + 1)]\n    \n    impassable_tiles = {'WALL', 'HEADBUTT_TREE', 'CUT_TREE', 'WATER', 'COUNTER', 'MART_SHELF', 'BUOY', 'TOWN_MAP', 'WINDOW', 'BOOKSHELF', 'TV', 'RADIO', 'VOID'}\n    \n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id'])\n            tile_type = tile_elem.attrib['type']\n            seen = tile_elem.attrib['seen']\n            \n            if seen == 'false' or tile_elem.find('Object') is not None or tile_type in impassable_tiles:\n                grid[y][x] = 'WALL'\n            else:\n                grid[y][x] = tile_type\n\n    start = (start_x, start_y)\n    end = (end_x, end_y)\n    \n    if not (1 <= start[0] <= width and 1 <= start[1] <= height and 1 <= end[0] <= width and 1 <= end[1] <= height):\n        return json.dumps({\"error\": \"Start or end coordinates are out of bounds.\"})\n\n    if grid[start[1]][start[0]] == 'WALL' or grid[end[1]][end[0]] == 'WALL':\n        return json.dumps({\"error\": \"Start or end tile is impassable.\"})\n\n    queue = deque([(start, [start])])\n    visited = {start}\n    \n    while queue:\n        (current_x, current_y), path = queue.popleft()\n        \n        if (current_x, current_y) == end:\n            return json.dumps([{'x': p[0], 'y': p[1]} for p in path])\n            \n        moves = [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]\n        \n        for dx, dy, move_dir in moves:\n            next_x, next_y = current_x + dx, current_y + dy\n            \n            if not (1 <= next_x <= width and 1 <= next_y <= height):\n                continue\n\n            if (next_x, next_y) in visited:\n                continue\n\n            next_tile_type = grid[next_y][next_x]\n            if next_tile_type == 'WALL':\n                continue\n            \n            current_tile_type = grid[current_y][current_x]\n            if dy == 1 and 'LEDGE' in current_tile_type: \n                pass\n            elif dy == -1 and 'LEDGE' in grid[next_y][next_x]:\n                continue\n\n            visited.add((next_x, next_y))\n            new_path = list(path)\n            new_path.append((next_x, next_y))\n            queue.append(((next_x, next_y), new_path))\n            \n    return json.dumps({\"error\": \"No path found.\"})\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nresult = find_path_logic(map_xml_string, start_x, start_y, end_x, end_y)\nprint(result)"
  },
  "path_master": {
    "description": "Finds the shortest path on the current map using A*. Avoids impassable static tiles, objects, and unseen areas. **Warning: Does not account for moving NPCs and may fail.**",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\ndef find_path(map_xml_string, start_x, start_y, end_x, end_y):\n    impassable_tiles = ['WALL', 'COUNTER', 'MART_SHELF', 'BUOY', 'TOWN_MAP', 'WINDOW', 'BOOKSHELF', 'TV', 'RADIO', 'VOID', 'FRUIT_TREE', 'CUT_TREE', 'WATER', 'HEADBUTT_TREE']\n    root = ET.fromstring(map_xml_string)\n    \n    grid = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            seen = tile_elem.get('seen') == 'true'\n            has_object = tile_elem.find('Object') is not None\n            \n            is_walkable = True\n            if tile_type in impassable_tiles or not seen or has_object:\n                is_walkable = False\n            \n            grid[(x, y)] = is_walkable\n\n    start = (start_x, start_y)\n    end = (end_x, end_y)\n\n    if not grid.get(start, False) or not grid.get(end, False):\n        print('No path found: Start or end tile is not walkable.')\n        return\n\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {pos: float('inf') for pos in grid}\n    g_score[start] = 0\n    f_score = {pos: float('inf') for pos in grid}\n    f_score[start] = abs(start[0] - end[0]) + abs(start[1] - end[1])\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == end:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            path_str = ' -> '.join([f'({x},{y})' for x, y in path[::-1]])\n            print(f'Path found: {path_str}')\n            return\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n\n            if neighbor in grid and grid[neighbor]:\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = tentative_g_score + abs(neighbor[0] - end[0]) + abs(neighbor[1] - end[1])\n                    if neighbor not in [i[1] for i in open_set]:\n                        heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    print('No path found.')\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nfind_path(map_xml_string, start_x, start_y, end_x, end_y)"
  },
  "unstick_me_tool": {
    "description": "Analyzes the map XML to find the nearest cluster of 'unseen' tiles when stuck. Returns coordinates for a new navigation goal. Can also check for softlock conditions (e.g., no path to any warp/exit).",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef find_unseen_logic(map_xml_string, start_x, start_y):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = [['' for _ in range(width + 1)] for _ in range(height + 1)]\n    unseen_coords = set()\n    impassable_tiles = {'WALL', 'HEADBUTT_TREE', 'CUT_TREE', 'WATER', 'COUNTER', 'MART_SHELF', 'BUOY', 'TOWN_MAP', 'WINDOW', 'BOOKSHELF', 'TV', 'RADIO', 'VOID'}\n    \n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id'])\n            tile_type = tile_elem.attrib['type']\n            seen = tile_elem.attrib['seen']\n            \n            if seen == 'false':\n                unseen_coords.add((x, y))\n                grid[y][x] = 'UNSEEN'\n            elif tile_elem.find('Object') is not None or tile_type in impassable_tiles:\n                grid[y][x] = 'WALL'\n            else:\n                grid[y][x] = tile_type\n\n    start = (start_x, start_y)\n    if not (1 <= start[0] <= width and 1 <= start[1] <= height):\n        return json.dumps({\"error\": \"Start coordinates are out of bounds.\"})\n\n    if not unseen_coords:\n        return json.dumps({\"error\": \"No unseen tiles on the map.\"})\n\n    queue = deque([start])\n    visited = {start}\n    \n    while queue:\n        (current_x, current_y) = queue.popleft()\n        \n        moves = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n        \n        for dx, dy in moves:\n            next_x, next_y = current_x + dx, current_y + dy\n            \n            if not (1 <= next_x <= width and 1 <= next_y <= height):\n                continue\n\n            if (next_x, next_y) in unseen_coords:\n                return json.dumps({\"goal_x\": current_x, \"goal_y\": current_y})\n\n            next_tile_type = grid[next_y][next_x]\n            if (next_x, next_y) not in visited and next_tile_type != 'WALL' and next_tile_type != 'UNSEEN':\n                # Add ledge check\n                current_tile_type = grid[current_y][current_x]\n                if dy == -1 and 'LEDGE' in next_tile_type: # Trying to move up a ledge\n                    continue\n\n                visited.add((next_x, next_y))\n                queue.append((next_x, next_y))\n            \n    return json.dumps({\"error\": \"No path to any unseen tile found.\"})\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\n\nresult = find_unseen_logic(map_xml_string, start_x, start_y)\nprint(result)"
  }
}