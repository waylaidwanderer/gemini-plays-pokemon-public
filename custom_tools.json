{
  "find_path_v4": {
    "description": "Finds the shortest path to a target coordinate. Correctly handles walls, NPCs, items, and unseen tiles. If the target is impassable, finds a path to an adjacent tile.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    \n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = [[True for _ in range(width)] for _ in range(height)]\n    impassable_types = ['WALL', 'HEADBUTT_TREE', 'MART_SHELF', 'COUNTER', 'WATER', 'BOULDER', 'TABLE', 'PC', 'STAIRS_UP', 'STAIRS_DOWN', 'BOOKSHELF']\n    \n    start_pos = None\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib.get('type', 'unseen')\n            \n            if t_type in impassable_types:\n                grid[y][x] = False\n            \n            if tile.attrib.get('has-object') == 'true':\n                grid[y][x] = False\n                \n            for marker in tile.findall('Marker'):\n                if 'Wall' in marker.text or 'ðŸ§±' in marker.attrib.get('emoji', ''):\n                    grid[y][x] = False\n            \n            if tile.find('Player') is not None:\n                start_pos = (x, y)\n                grid[y][x] = True\n                \n    if start_pos is None:\n        print(json.dumps([]))\n        return\n\n    queue = deque([(start_pos, [])])\n    visited = {start_pos}\n    \n    if not grid[target_y][target_x]:\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = target_x + dx, target_y + dy\n            if 0 <= nx < width and 0 <= ny < height and grid[ny][nx]:\n                target_x, target_y = nx, ny\n                break\n        else:\n            print(json.dumps([]))\n            return\n\n    while queue:\n        (cx, cy), path = queue.popleft()\n        \n        if (cx, cy) == (target_x, target_y):\n            print(json.dumps(path))\n            return\n            \n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < width and 0 <= ny < height and grid[ny][nx] and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [btn]))\n                \n    print(json.dumps([]))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-21T06:11:17.104Z",
        "action_counter": 8161
      },
      {
        "commit_message": "Fixed find_path_v4: removed non-standard getparent() call and improved player position detection. Consolidated grid construction and BFS.",
        "timestamp": "2025-12-21T06:23:10.110Z",
        "action_counter": 8180
      },
      {
        "commit_message": "Ensure tool correctly returns a list of button strings for overworld navigation when autopress_buttons is true. Fixes previous formatting issues.",
        "timestamp": "2025-12-22T02:53:22.052Z",
        "action_counter": 10751
      },
      {
        "commit_message": "Fix player position detection in find_path_v4 to avoid TypeError when start_row is not found via XPath. Use a more robust loop-based approach.",
        "timestamp": "2025-12-22T02:54:08.460Z",
        "action_counter": 10753
      },
      {
        "commit_message": "Improved traversable types to include 'unseen' for optimistic pathfinding and added logic to path to adjacent tiles if the target is impassable (e.g., an NPC or wall).",
        "timestamp": "2025-12-22T05:52:22.947Z",
        "action_counter": 11104
      },
      {
        "commit_message": "Added MART_SHELF and COUNTER to impassable types and improved object/marker collision handling.",
        "timestamp": "2025-12-23T00:55:17.780Z",
        "action_counter": 13197
      }
    ]
  },
  "pacer": {
    "description": "Generates a sequence of back-and-forth movement buttons for wild encounter hunting. Returns a JSON array of button strings.",
    "input_schema": {
      "type": "object",
      "properties": {
        "dir1": {
          "type": "string",
          "enum": [
            "Up",
            "Down",
            "Left",
            "Right"
          ]
        },
        "dir2": {
          "type": "string",
          "enum": [
            "Up",
            "Down",
            "Left",
            "Right"
          ]
        },
        "steps": {
          "type": "integer"
        }
      },
      "required": [
        "steps",
        "dir1",
        "dir2"
      ]
    },
    "python_script": "import json\n\n# input_data is a globally available dictionary in define_tool scripts\ntry:\n    steps = int(input_data.get('steps', 10))\n    dir1 = input_data.get('dir1', 'Left')\n    dir2 = input_data.get('dir2', 'Right')\n    \n    buttons = []\n    for i in range(steps):\n        if i % 2 == 0:\n            buttons.append(dir1)\n        else:\n            buttons.append(dir2)\n    \n    print(json.dumps(buttons))\nexcept Exception as e:\n    # Error must be a JSON array of strings\n    print(json.dumps([f\"Error: {str(e)}\"]))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-23T06:17:26.805Z",
        "action_counter": 13771
      },
      {
        "commit_message": "Fixing input_data access and logic.",
        "timestamp": "2025-12-23T06:19:43.707Z",
        "action_counter": 13776
      }
    ]
  },
  "use_sweet_scent_v2": {
    "description": "Uses Sweet Scent from KIMCHI (slot 6). Requires cursor to be on Slot 1 (POKEDEX) of the Start menu or in the overworld with the cursor already at Slot 1.",
    "input_schema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "python_script": "import json\n# Sequence:\n# 1. Clear menus (B x3)\n# 2. Open Start menu (Start)\n# 3. Move to POKEMON (Down x1) and select (A)\n# 4. Move to Slot 6 - KIMCHI (Down x5) and select (A)\n# 5. Select first field move - SWEET SCENT (A)\n# 6. Clear text boxes (A x4)\nbtns = [\"B\", \"B\", \"B\", \"Start\", \"sleep 500\", \n        \"Down\", \"A\", \"sleep 500\", \n        \"Down\", \"Down\", \"Down\", \"Down\", \"Down\", \"A\", \"sleep 500\", \n        \"A\", \"sleep 500\", \"A\", \"A\", \"A\", \"A\"]\nprint(json.dumps(btns))",
    "history": [
      {
        "commit_message": "Final robustness update: starts with 3 B-presses to clear menus, resets cursor in Start menu, navigates to slot 6 (KIMCHI), and uses Sweet Scent. Includes multiple A-presses to clear encounter text.",
        "timestamp": "2025-12-23T08:38:34.048Z",
        "action_counter": 13986
      },
      {
        "commit_message": "Fixed menu navigation logic to handle 8 items and used a more robust reset sequence.",
        "timestamp": "2025-12-23T09:35:53.123Z",
        "action_counter": 14104
      },
      {
        "commit_message": "Refined Sweet Scent tool with robust menu reset logic (Down-mashing to EXIT/CANCEL) and corrected Start menu selection (slot 2 for POKEMON).",
        "timestamp": "2025-12-23T09:37:19.794Z",
        "action_counter": 14106
      },
      {
        "commit_message": "Refined Sweet Scent tool with robust menu reset logic and corrected Start menu selection. Assumes cursor starts on PACK or GEAR after item usage.",
        "timestamp": "2025-12-23T09:43:08.784Z",
        "action_counter": 14119
      },
      {
        "commit_message": "Refined Sweet Scent tool to be truly robust by using directional mashing to reset cursor positions in both the Start and Party menus. Now handles any initial cursor state.",
        "timestamp": "2025-12-23T09:45:07.508Z",
        "action_counter": 14123
      },
      {
        "commit_message": "Corrected Sweet Scent selection logic: KIMCHI (slot 6) has field moves listed after STATS. Sequence now moves Down once after selecting KIMCHI to hit SWEET SCENT.",
        "timestamp": "2025-12-23T09:49:15.055Z",
        "action_counter": 14126
      },
      {
        "commit_message": "Refined Sweet Scent tool to be more robust. Now uses a sequence of B-presses to clear menus and assumes the cursor is on Slot 7 (OPTION) of the Start menu, which is common after settings changes.",
        "timestamp": "2025-12-23T09:54:29.909Z",
        "action_counter": 14132
      },
      {
        "commit_message": "Updated requirements: assumes cursor starts on Slot 1 (POKEDEX) of the Start menu. Corrected navigation to KIMCHI and move selection.",
        "timestamp": "2025-12-23T09:57:20.200Z",
        "action_counter": 14136
      },
      {
        "commit_message": "Refined Sweet Scent tool: selects first field move (Slot 1) after selecting KIMCHI. Assumes cursor starts on Slot 1 (POKEDEX) of Start menu.",
        "timestamp": "2025-12-23T09:57:44.066Z",
        "action_counter": 14137
      }
    ]
  },
  "get_type_effectiveness_gen2": {
    "description": "Returns the type effectiveness multiplier for an attack in Gen 2 Pokemon Crystal.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacking_type": {
          "type": "string",
          "description": "The type of the move being used."
        },
        "defending_type1": {
          "type": "string",
          "description": "The first type of the defending Pokemon."
        },
        "defending_type2": {
          "type": "string",
          "description": "The second type of the defending Pokemon (optional).",
          "nullable": true
        }
      },
      "required": [
        "attacking_type",
        "defending_type1"
      ]
    },
    "python_script": "import json\n\ndef get_effectiveness(attacking_type, defending_type1, defending_type2=None):\n    # Gen 2 Type Chart\n    chart = {\n        \"NORMAL\": {\"ROCK\": 0.5, \"GHOST\": 0, \"STEEL\": 0.5},\n        \"FIRE\": {\"FIRE\": 0.5, \"WATER\": 0.5, \"GRASS\": 2, \"ICE\": 2, \"BUG\": 2, \"ROCK\": 0.5, \"DRAGON\": 0.5, \"STEEL\": 2},\n        \"WATER\": {\"FIRE\": 2, \"WATER\": 0.5, \"GRASS\": 0.5, \"GROUND\": 2, \"ROCK\": 2, \"DRAGON\": 0.5},\n        \"ELECTRIC\": {\"WATER\": 2, \"ELECTRIC\": 0.5, \"GRASS\": 0.5, \"GROUND\": 0, \"FLYING\": 2, \"DRAGON\": 0.5},\n        \"GRASS\": {\"FIRE\": 0.5, \"WATER\": 2, \"GRASS\": 0.5, \"POISON\": 0.5, \"GROUND\": 2, \"FLYING\": 0.5, \"BUG\": 0.5, \"ROCK\": 2, \"DRAGON\": 0.5, \"STEEL\": 0.5},\n        \"ICE\": {\"FIRE\": 0.5, \"WATER\": 0.5, \"GRASS\": 2, \"ICE\": 0.5, \"GROUND\": 2, \"FLYING\": 2, \"DRAGON\": 2, \"STEEL\": 0.5},\n        \"FIGHTING\": {\"NORMAL\": 2, \"ICE\": 2, \"POISON\": 0.5, \"FLYING\": 0.5, \"PSYCHIC\": 0.5, \"BUG\": 0.5, \"ROCK\": 2, \"GHOST\": 0, \"DARK\": 2, \"STEEL\": 2},\n        \"POISON\": {\"GRASS\": 2, \"POISON\": 0.5, \"GROUND\": 0.5, \"ROCK\": 0.5, \"GHOST\": 0.5, \"STEEL\": 0},\n        \"GROUND\": {\"FIRE\": 2, \"ELECTRIC\": 2, \"GRASS\": 0.5, \"POISON\": 2, \"FLYING\": 0, \"BUG\": 0.5, \"ROCK\": 2, \"STEEL\": 2},\n        \"FLYING\": {\"ELECTRIC\": 0.5, \"GRASS\": 2, \"FIGHTING\": 2, \"BUG\": 2, \"ROCK\": 0.5, \"STEEL\": 0.5},\n        \"PSYCHIC\": {\"FIGHTING\": 2, \"POISON\": 2, \"PSYCHIC\": 0.5, \"DARK\": 0, \"STEEL\": 0.5},\n        \"BUG\": {\"FIRE\": 0.5, \"GRASS\": 2, \"FIGHTING\": 0.5, \"POISON\": 0.5, \"FLYING\": 0.5, \"PSYCHIC\": 2, \"GHOST\": 0.5, \"DARK\": 2, \"STEEL\": 0.5},\n        \"ROCK\": {\"FIRE\": 2, \"ICE\": 2, \"FIGHTING\": 0.5, \"GROUND\": 0.5, \"FLYING\": 2, \"BUG\": 2, \"STEEL\": 0.5},\n        \"GHOST\": {\"NORMAL\": 0, \"PSYCHIC\": 2, \"GHOST\": 2, \"DARK\": 0.5, \"STEEL\": 0.5},\n        \"DRAGON\": {\"DRAGON\": 2, \"STEEL\": 0.5},\n        \"STEEL\": {\"FIRE\": 0.5, \"WATER\": 0.5, \"ELECTRIC\": 0.5, \"ICE\": 2, \"ROCK\": 2, \"STEEL\": 0.5},\n        \"DARK\": {\"FIGHTING\": 0.5, \"PSYCHIC\": 2, \"GHOST\": 2, \"DARK\": 0.5, \"STEEL\": 0.5}\n    }\n    \n    atk = attacking_type.upper()\n    def1 = defending_type1.upper()\n    \n    mult = chart.get(atk, {}).get(def1, 1.0)\n    if defending_type2:\n        def2 = defending_type2.upper()\n        mult *= chart.get(atk, {}).get(def2, 1.0)\n        \n    return mult\n\nif __name__ == \"__main__\":\n    attacking_type = input_data.get(\"attacking_type\")\n    defending_type1 = input_data.get(\"defending_type1\")\n    defending_type2 = input_data.get(\"defending_type2\")\n    \n    if attacking_type and defending_type1:\n        result = get_effectiveness(attacking_type, defending_type1, defending_type2)\n        print(json.dumps({\"multiplier\": result}))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-23T09:05:37.668Z",
        "action_counter": 14041
      },
      {
        "commit_message": "Fixed the tool to actually print the result using input_data.",
        "timestamp": "2025-12-23T09:26:49.920Z",
        "action_counter": 14085
      }
    ]
  },
  "calculate_capture_rate_gen2": {
    "description": "Calculates the catch probability in Pokemon Crystal (Gen 2). Uses the standard capture formula.",
    "input_schema": {
      "type": "object",
      "properties": {
        "max_hp": {
          "type": "integer"
        },
        "curr_hp": {
          "type": "integer"
        },
        "base_rate": {
          "type": "integer",
          "description": "Base catch rate of the Pokemon (e.g. 3 for Suicune)."
        },
        "ball": {
          "type": "string",
          "enum": [
            "POKE BALL",
            "GREAT BALL",
            "ULTRA BALL",
            "MASTER BALL"
          ]
        },
        "status": {
          "type": "string",
          "enum": [
            "SLEEP",
            "FREEZE",
            "PARALYSIS",
            "POISON",
            "BURN",
            "NONE"
          ]
        }
      },
      "required": [
        "max_hp",
        "curr_hp",
        "base_rate",
        "ball",
        "status"
      ]
    },
    "python_script": "import json\ndef calculate():\n    try:\n        max_hp = int(input_data['max_hp'])\n        curr_hp = int(input_data['curr_hp'])\n        base_rate = int(input_data['base_rate'])\n        ball = input_data['ball'].upper()\n        status = input_data['status'].upper()\n        ball_mods = {'POKE BALL': 1.0, 'GREAT BALL': 1.5, 'ULTRA BALL': 2.0, 'MASTER BALL': 255.0}\n        status_mods = {'SLEEP': 10, 'FREEZE': 10, 'PARALYSIS': 0, 'POISON': 0, 'BURN': 0, 'NONE': 0}\n        b_mod = ball_mods.get(ball, 1.0)\n        s_mod = status_mods.get(status, 0)\n        # Gen 2 Catch Formula: a = floor((3*max_hp - 2*curr_hp) * base_rate * ball_mod / (3*max_hp)) + status_mod\n        a = int((3 * max_hp - 2 * curr_hp) * base_rate * b_mod / (3 * max_hp)) + s_mod\n        a = max(1, min(255, a))\n        chance = (a + 1) / 256.0\n        print(json.dumps({'capture_value': a, 'chance_percent': round(chance * 100, 2)}))\n    except Exception as e:\n        print(json.dumps({'error': str(e)}))\ncalculate()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-23T09:34:58.349Z",
        "action_counter": 14103
      },
      {
        "commit_message": "Initial version of the capture rate calculator using the standard Gen 2 formula.",
        "timestamp": "2025-12-23T09:37:19.795Z",
        "action_counter": 14106
      },
      {
        "commit_message": "Robust version of the capture rate calculator using the standard Gen 2 formula. Casts all inputs to integers.",
        "timestamp": "2025-12-23T09:50:45.722Z",
        "action_counter": 14127
      }
    ]
  }
}