{
  "find_path_v2": {
    "description": "Finds the shortest path between two coordinates on the current map using BFS, considering walls, objects, hazardous tiles, and one-way ledges as obstacles/transitions. Returns a JSON array of buttons.",
    "input_schema": {
      "type": "object",
      "properties": {
        "autopress_buttons": {
          "default": false,
          "type": "boolean"
        },
        "avoid_warps": {
          "default": true,
          "type": "boolean"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "autopress_buttons"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef solve():\n    tree = ET.fromstring(map_xml_string)\n    width = int(tree.attrib['width'])\n    height = int(tree.attrib['height'])\n    \n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    avoid_warps = input_data.get('avoid_warps', True)\n    \n    traversable_types = {'FLOOR', 'TALL_GRASS', 'LONG_GRASS', 'WARP_CARPET_UP', 'WARP_CARPET_DOWN', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'CAVE', 'DOOR', 'STAIRS', 'LADDER', 'FLOOR_UP_WALL', 'FLOOR_DOWN_WALL', 'FLOOR_LEFT_WALL', 'FLOOR_RIGHT_WALL'}\n    warp_types = {'WARP_CARPET_UP', 'WARP_CARPET_DOWN', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'CAVE', 'DOOR', 'STAIRS', 'LADDER'}\n    \n    grid = {}\n    for row in tree.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            grid[(x, y)] = {'type': t_type, 'has_obj': tile.find('Object') is not None}\n\n    queue = deque([(start_x, start_y, [])])\n    visited = {(start_x, start_y)}\n    \n    while queue:\n        cx, cy, path = queue.popleft()\n        if cx == end_x and cy == end_y:\n            print(json.dumps(path))\n            return\n            \n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = cx + dx, cy + dy\n            \n            # Boundary check\n            if not (0 <= nx < width and 0 <= ny < height):\n                continue\n                \n            tile = grid.get((nx, ny))\n            if not tile: continue\n            \n            t_type = tile['type']\n            \n            # Ledge Handling\n            if t_type == 'LEDGE_HOP_DOWN' and btn == 'Down':\n                nx, ny = nx, ny + 1 # Jump over the ledge\n                if not (0 <= nx < width and 0 <= ny < height): continue\n                tile = grid.get((nx, ny))\n                if not tile: continue\n                t_type = tile['type']\n            elif t_type == 'LEDGE_HOP_LEFT' and btn == 'Left':\n                nx, ny = nx - 1, ny\n                if not (0 <= nx < width and 0 <= ny < height): continue\n                tile = grid.get((nx, ny))\n                if not tile: continue\n                t_type = tile['type']\n            elif t_type == 'LEDGE_HOP_RIGHT' and btn == 'Right':\n                nx, ny = nx + 1, ny\n                if not (0 <= nx < width and 0 <= ny < height): continue\n                tile = grid.get((nx, ny))\n                if not tile: continue\n                t_type = tile['type']\n            elif t_type in {'LEDGE_HOP_DOWN', 'LEDGE_HOP_LEFT', 'LEDGE_HOP_RIGHT'}:\n                # Cannot move onto a ledge from any other direction\n                continue\n\n            # Standard collision\n            if t_type not in traversable_types:\n                if not (nx == end_x and ny == end_y):\n                    continue\n            \n            # Warp avoidance\n            if avoid_warps and t_type in warp_types and (nx != end_x or ny != end_y):\n                continue\n                \n            # Object collision\n            if tile['has_obj'] and (nx != start_x or ny != start_y):\n                if not (nx == end_x and ny == end_y):\n                    continue\n            \n            if (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, path + [btn]))\n                \n    print(json.dumps({\"error\": \"No path found\"}))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T20:27:16.465Z",
        "action_counter": 29425
      },
      {
        "commit_message": "Refined to correctly identify objects using 'has-object' attribute and added logic for boulder bridges in pits.",
        "timestamp": "2025-12-28T20:30:14.390Z",
        "action_counter": 29431
      },
      {
        "commit_message": "Refined to correctly handle autopress_buttons by outputting button strings and fixed pathfinding logic for boulder bridges.",
        "timestamp": "2025-12-28T20:30:50.776Z",
        "action_counter": 29432
      },
      {
        "commit_message": "Refined to handle boulder bridges in Blackthorn Gym 1F and improved object detection.",
        "timestamp": "2025-12-28T20:47:40.334Z",
        "action_counter": 29458
      },
      {
        "commit_message": "Fixing missing commit message and improving tile passability logic.",
        "timestamp": "2025-12-28T22:59:48.479Z",
        "action_counter": 29673
      },
      {
        "commit_message": "Fix find_path_v2 by providing a commit message and using input_data correctly.",
        "timestamp": "2025-12-29T03:29:03.821Z",
        "action_counter": 30041
      },
      {
        "commit_message": "Refine find_path_v2 to treat PIT and LADDER tiles as obstacles by default to prevent accidental warps, unless they are the intended destination.",
        "timestamp": "2025-12-29T04:09:14.393Z",
        "action_counter": 30092
      },
      {
        "commit_message": "Refine find_path_v2 to treat all warp tiles (PIT, LADDER) as obstacles unless they are the specific destination, and correctly identify objects using 'has-object'.",
        "timestamp": "2025-12-29T04:10:34.909Z",
        "action_counter": 30094
      },
      {
        "commit_message": "Initial definition with ledge handling.",
        "timestamp": "2026-01-06T20:56:57.721Z",
        "action_counter": 30778
      },
      {
        "commit_message": "Added commit message to update tool.",
        "timestamp": "2026-01-06T21:16:09.438Z",
        "action_counter": 30812
      },
      {
        "commit_message": "Refined ledge handling: ledges are now impassable from all directions except the jump direction. Added more impassable tile types.",
        "timestamp": "2026-01-06T21:17:48.184Z",
        "action_counter": 30816
      },
      {
        "commit_message": "Added CAVE and WARP to impassable tiles to prevent accidental map transitions.",
        "timestamp": "2026-01-06T21:27:34.747Z",
        "action_counter": 30833
      },
      {
        "commit_message": "Added avoid_warps parameter and object detection logic. Refined ledge and warp handling.",
        "timestamp": "2026-01-06T21:37:49.308Z",
        "action_counter": 30841
      },
      {
        "commit_message": "Removed 'unseen' from impassable_base to allow exploration pathing.",
        "timestamp": "2026-01-06T21:53:26.245Z",
        "action_counter": 30871
      },
      {
        "commit_message": "Removed 'unseen' from impassable tiles to allow exploration pathing. Added avoid_warps parameter. Refined ledge and object handling.",
        "timestamp": "2026-01-06T21:58:47.153Z",
        "action_counter": 30880
      },
      {
        "commit_message": "Initial definition with correct schema and logic.",
        "timestamp": "2026-01-07T09:27:38.973Z",
        "action_counter": 32021
      },
      {
        "commit_message": "Refined find_path_v2 to treat HEADBUTT_TREE as an obstacle and allow player to move from their current tile.",
        "timestamp": "2026-01-07T12:10:42.415Z",
        "action_counter": 32283
      },
      {
        "commit_message": "Refined find_path_v2 to handle ledge hopping (LEDGE_HOP_DOWN, LEFT, RIGHT) as one-way jump transitions.",
        "timestamp": "2026-01-07T12:55:12.814Z",
        "action_counter": 32363
      }
    ]
  },
  "press_menu_buttons": {
    "description": "Presses a sequence of buttons to navigate menus, bypassing the directional/action mixing restriction. Use for menu navigation ONLY. Returns the sequence of buttons as a JSON array.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nprint(json.dumps(input_data['buttons']))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-29T01:56:30.654Z",
        "action_counter": 29934
      }
    ]
  },
  "grind_encounters": {
    "description": "Paces back and forth to trigger wild encounters.",
    "input_schema": {
      "properties": {
        "steps": {
          "default": 10,
          "description": "The number of steps to pace (total).",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "python_script": "import json\nsteps = int(input_data.get('steps', 10))\nbuttons = []\nfor _ in range(steps // 2):\n    buttons.extend([\"Left\", \"Right\"])\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-07T15:39:09.904Z",
        "action_counter": 32671
      }
    ]
  },
  "solve_gym_puzzle": {
    "description": "Finds the shortest sequence of pushes to put 3 boulders into pits in Blackthorn Gym 2F. Returns a JSON array of buttons.",
    "input_schema": {
      "properties": {
        "player_x": {
          "type": "integer"
        },
        "player_y": {
          "type": "integer"
        }
      },
      "required": [
        "player_x",
        "player_y"
      ],
      "type": "object"
    },
    "python_script": "import collections\nimport json\nimport sys\nimport xml.etree.ElementTree as ET\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get(\"width\"))\n        height = int(root.get(\"height\"))\n        \n        walls = set()\n        pits = set()\n        boulders = []\n        npcs = set()\n        player_pos = None\n        \n        for row in root.findall(\"Row\"):\n            y = int(row.get(\"id\"))\n            for tile in row.findall(\"Tile\"):\n                x = int(tile.get(\"id\"))\n                t_type = tile.get(\"type\")\n                if t_type in [\"WALL\", \"VOID\"]:\n                    walls.add((x, y))\n                elif t_type == \"PIT\":\n                    pits.add((x, y))\n                \n                if tile.get(\"has-player\") == \"true\":\n                    player_pos = (x, y)\n                \n                # Boulders from objects\n                for obj in tile.findall(\"Object\"):\n                    obj_name = obj.get(\"id-name\", \"\").upper()\n                    if \"BOULDER\" in obj_name:\n                        boulders.append((x, y))\n                    else:\n                        npcs.add((x, y))\n                \n                # Boulders from markers (if object not rendered)\n                for marker in tile.findall(\"Marker\"):\n                    if \"Boulder\" in marker.text:\n                        if (x, y) not in boulders:\n                            boulders.append((x, y))\n\n        # Fallbacks for off-screen/reset boulders\n        original_starts = [(3, 3), (6, 1), (8, 14)]\n        if len(boulders) < 3:\n            for s in original_starts:\n                if s not in boulders and s not in pits:\n                    boulders.append(s)\n                    if len(boulders) == 3: break\n\n        if not player_pos:\n            input_str = sys.stdin.read()\n            input_data = json.loads(input_str) if input_str else {}\n            player_pos = (input_data.get('player_x', 5), input_data.get('player_y', 1))\n\n    except:\n        return []\n\n    ladders = {(1, 7), (7, 9)}\n    start_b = tuple(sorted(boulders[:3]))\n    \n    q = collections.deque([( player_pos, start_b, (), [] )])\n    v = {( player_pos, start_b, () )}\n    \n    limit = 500000\n    while q and limit > 0:\n        limit -= 1\n        (px, py), b, f, path = q.popleft()\n        if len(f) == 3: return path\n        for dx, dy, btn in [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n            nx, ny = px + dx, py + dy\n            cur_p = (nx, ny)\n            if cur_p in ladders:\n                cur_p = (ladders - {cur_p}).pop()\n\n            if (nx, ny) in b:\n                bx, by = nx + dx, ny + dy\n                if 0 <= bx < width and 0 <= by < height and (bx, by) not in walls and (bx, by) not in b and (bx, by) not in npcs and (bx, by) not in f:\n                    nb = list(b); nb.remove((nx, ny))\n                    nf = list(f)\n                    if (bx, by) in pits: nf.append((bx, by))\n                    else: nb.append((bx, by))\n                    st = (cur_p, tuple(sorted(nb)), tuple(sorted(nf)))\n                    if st not in v:\n                        v.add(st)\n                        q.append((st[0], st[1], st[2], path + [btn]))\n            elif 0 <= nx < width and 0 <= ny < height and (nx, ny) not in walls and (nx, ny) not in npcs and ((nx, ny) not in pits or (nx, ny) in f):\n                st = (cur_p, b, f)\n                if st not in v:\n                    v.add(st)\n                    q.append((st[0], st[1], st[2], path + [btn]))\n    return []\n\nprint(json.dumps(solve()))",
    "history": [
      {
        "commit_message": "Refining solve_gym_puzzle to use live map data and higher search depth.",
        "timestamp": "2026-01-08T06:05:50.551Z",
        "action_counter": 34100
      },
      {
        "commit_message": "Correcting tile check for reachability (checking for '.' instead of 'FLOOR').",
        "timestamp": "2026-01-08T06:06:40.103Z",
        "action_counter": 34101
      },
      {
        "commit_message": "Fixing solve_gym_puzzle to use correct tile type strings (FLOOR, LADDER) and increasing search depth.",
        "timestamp": "2026-01-08T06:12:40.566Z",
        "action_counter": 34105
      },
      {
        "commit_message": "Finalizing solve_gym_puzzle with live map data, markers, and robust BFS logic.",
        "timestamp": "2026-01-08T06:18:44.717Z",
        "action_counter": 34111
      },
      {
        "commit_message": "Fixing tool to return a JSON array of buttons instead of a dictionary, and increasing iteration limit for the complex puzzle.",
        "timestamp": "2026-01-08T06:53:34.236Z",
        "action_counter": 34146
      },
      {
        "commit_message": "Updating solve_gym_puzzle to dynamically parse boulder positions from the map XML, ensuring it uses the most up-to-date state.",
        "timestamp": "2026-01-08T06:57:31.362Z",
        "action_counter": 34150
      },
      {
        "commit_message": "Correcting fallback boulder positions to their original coordinates (3,3), (6,1), (8,14) for when they are off-screen.",
        "timestamp": "2026-01-08T07:04:21.751Z",
        "action_counter": 34158
      },
      {
        "commit_message": "Refining solve_gym_puzzle to correctly handle the connection between the two sides of the gym via ladders and 1F traversal, and fixing a syntax error in the BFS state check.",
        "timestamp": "2026-01-08T07:16:16.836Z",
        "action_counter": 34168
      },
      {
        "commit_message": "Refining solve_gym_puzzle to correctly parse boulder positions from Mental Map markers (for off-screen boulders), allowing movement on filled pits (bridges), and increasing the iteration limit for the 3-boulder BFS.",
        "timestamp": "2026-01-08T07:17:48.571Z",
        "action_counter": 34169
      },
      {
        "commit_message": "Refining solve_gym_puzzle to handle ladder warps as player-only transitions and use markers for off-screen boulders. Iteration limit increased for multi-boulder solution.",
        "timestamp": "2026-01-08T07:41:01.264Z",
        "action_counter": 34201
      },
      {
        "commit_message": "Refining solve_gym_puzzle to correctly handle filled pits as traversable bridges and improving the BFS logic for single-boulder targeting to avoid complexity issues.",
        "timestamp": "2026-01-08T07:44:34.386Z",
        "action_counter": 34207
      },
      {
        "commit_message": "Refining solve_gym_puzzle to handle ladder warps as player-only transitions and use markers for off-screen boulders. Iteration limit increased for multi-boulder solution.",
        "timestamp": "2026-01-08T07:47:29.866Z",
        "action_counter": 34210
      },
      {
        "commit_message": "Refining solve_gym_puzzle to dynamically parse player and boulder positions from the Mental Map XML, handle ladder warps correctly, and include fallbacks for off-screen boulders.",
        "timestamp": "2026-01-08T08:07:39.720Z",
        "action_counter": 34231
      }
    ]
  },
  "solve_blackthorn_boulders_v3": {
    "description": "Finds the shortest sequence of buttons to solve the Blackthorn Gym boulder puzzle by parsing the map XML. Accounts for the 'move into spot' push mechanic: pushing a boulder moves it one tile and the player moves into the boulder's previous tile. Requires all 3 boulders to be visible on the map (or marked).",
    "input_schema": {
      "type": "object",
      "properties": {
        "player_x": {
          "type": "integer"
        },
        "player_y": {
          "type": "integer"
        }
      },
      "required": [
        "player_x",
        "player_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\nimport json\nimport sys\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.attrib['width'])\n        height = int(root.attrib['height'])\n        \n        input_data = json.loads(sys.argv[1])\n        start_px = input_data['player_x']\n        start_py = input_data['player_y']\n        \n        # 0: floor/ladder, 1: wall/NPC, 2: pit\n        grid = [[1 for _ in range(width)] for _ in range(height)]\n        pits = []\n        boulders = set()\n        \n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                t_type = tile.attrib['type']\n                if t_type in ['FLOOR', 'LADDER']:\n                    grid[y][x] = 0\n                elif t_type == 'PIT':\n                    grid[y][x] = 2\n                    pits.append((x, y))\n                \n                for obj in tile.findall('Object'):\n                    name = obj.attrib.get('id-name')\n                    if name == 'BOULDER':\n                        boulders.add((x, y))\n                    elif name not in ['ITEM']:\n                        grid[y][x] = 1\n                \n                for marker in tile.findall('Marker'):\n                    if 'Boulder' in marker.text:\n                        boulders.add((x, y))\n\n        b_list = list(boulders)\n        if len(b_list) < 3:\n            reset_pos = [(3, 3), (6, 1), (8, 14)]\n            for rp in reset_pos:\n                if len(b_list) < 3 and rp not in b_list:\n                    b_list.append(rp)\n        \n        b_list = b_list[:3]\n        start_b = tuple(sorted(b_list))\n        queue = collections.deque([( (start_px, start_py), start_b, tuple(), [] )])\n        visited = { ( (start_px, start_py), start_b, tuple() ) }\n        \n        limit = 800000\n        while queue and limit > 0:\n            limit -= 1\n            (px, py), cur_b, filled, path = queue.popleft()\n            if len(filled) == 3:\n                print(json.dumps(path))\n                return\n\n            for dx, dy, name in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n                nx, ny = px + dx, py + dy\n                if 0 <= nx < width and 0 <= ny < height and grid[ny][nx] == 0:\n                    if (nx, ny) in cur_b:\n                        nbx, nby = nx + dx, ny + dy\n                        if 0 <= nbx < width and 0 <= nby < height:\n                            if grid[nby][nbx] == 2 and (nbx, nby) not in filled:\n                                new_b = tuple(sorted([b for b in cur_b if b != (nx, ny)]))\n                                new_f = tuple(sorted(list(filled) + [(nbx, nby)]))\n                                new_state = ((nx, ny), new_b, new_f)\n                                if new_state not in visited:\n                                    visited.add(new_state)\n                                    queue.append(( new_state, path + [name] ))\n                            elif grid[nby][nbx] == 0 and (nbx, nby) not in cur_b:\n                                new_b = tuple(sorted([b if b != (nx, ny) else (nbx, nby) for b in cur_b]))\n                                new_state = ((nx, ny), new_b, filled)\n                                if new_state not in visited:\n                                    visited.add(new_state)\n                                    queue.append(( new_state, path + [name] ))\n                    else:\n                        new_state = ((nx, ny), cur_b, filled)\n                        if new_state not in visited: \n                            visited.add(new_state)\n                            queue.append(( new_state, path + [name] ))\n        print(\"[]\")\n    except Exception:\n        print(\"[]\")\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-08T09:00:53.549Z",
        "action_counter": 34291
      },
      {
        "commit_message": "Fix boulder and pit detection in solve_blackthorn_boulders_v3. Detect boulders from markers and pits from tile types. Corrected state representation to ensure player position is tracked correctly.",
        "timestamp": "2026-01-08T09:01:37.089Z",
        "action_counter": 34293
      },
      {
        "commit_message": "Update solve_blackthorn_boulders_v3 to treat any non-floor/non-pit/non-ladder tile as a wall. Corrected object detection to handle off-screen fallbacks if necessary, though visiting the boulders is preferred.",
        "timestamp": "2026-01-08T09:15:13.681Z",
        "action_counter": 34307
      },
      {
        "commit_message": "Update solve_blackthorn_boulders_v3 to reflect that the player moves into the boulder's previous tile upon pushing. This is the standard Strength mechanic for Gen 2.",
        "timestamp": "2026-01-08T09:20:08.147Z",
        "action_counter": 34312
      },
      {
        "commit_message": "Revert solve_blackthorn_boulders_v3 to 'player stays in place' mechanic, as verified in Turn 34280 and 34285. This is the correct mechanic for Pokemon Crystal.",
        "timestamp": "2026-01-08T09:25:39.107Z",
        "action_counter": 34318
      },
      {
        "commit_message": "Refine solve_blackthorn_boulders_v3 to use robust XML parsing for walls, pits, and NPCs. It now correctly implements the 'player stays in place' mechanic for boulder pushes and uses original positions as a fallback only if 3 boulders aren't visible in the XML. Removed brittle hardcoded fallbacks that were causing empty results.",
        "timestamp": "2026-01-08T09:28:09.962Z",
        "action_counter": 34323
      },
      {
        "commit_message": "Clean up solve_blackthorn_boulders_v3. Removed hardcoded fallbacks. It now strictly uses the map XML to identify walls, pits, NPCs, and current boulder positions. Implements the verified 'player stays in place' mechanic.",
        "timestamp": "2026-01-08T09:28:59.880Z",
        "action_counter": 34325
      },
      {
        "commit_message": "Refine solve_blackthorn_boulders_v3 to include marker parsing and a minimal reset fallback. This ensures the tool can find a solution even if boulders are off-screen, while still prioritizing XML data.",
        "timestamp": "2026-01-08T09:33:33.907Z",
        "action_counter": 34332
      },
      {
        "commit_message": "Clean up solve_blackthorn_boulders_v3. Removed hardcoded fallbacks. It now strictly uses the map XML to identify walls, pits, NPCs, and current boulder positions. Implements the verified 'player stays in place' mechanic. Added marker support for off-screen boulders.",
        "timestamp": "2026-01-08T09:34:00.434Z",
        "action_counter": 34333
      },
      {
        "commit_message": "Correct solve_blackthorn_boulders_v3 to use 'move into spot' mechanic, as verified by turn history. Refined XML parsing and added fallback for reset positions.",
        "timestamp": "2026-01-08T09:37:34.000Z",
        "action_counter": 34339
      }
    ]
  }
}