{
  "find_closest_unseen_tile": {
    "description": "Finds the closest reachable unseen tile and a reachable adjacent tile to pathfind to. This version correctly handles player movement state (walking/surfing) and various tile types.",
    "input_schema": {
      "type": "object",
      "properties": {
        "party_data": {
          "type": "string"
        },
        "movement_state": {
          "type": "string"
        }
      },
      "required": [
        "party_data",
        "movement_state"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport collections\nimport heapq\n\ndef parse_party_data(party_data_str):\n    try:\n        party_data = json.loads(party_data_str)\n        hms_known = set()\n        for pokemon in party_data:\n            for move in pokemon.get('moves', []):\n                if isinstance(move, dict):\n                    move_name = move.get('name', '').upper()\n                    if move_name == 'CUT':\n                        hms_known.add('cut')\n                    elif move_name == 'SURF':\n                        hms_known.add('surf')\n        return hms_known\n    except (json.JSONDecodeError, TypeError):\n        return set()\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(start, goal, grid, map_width, map_height, hms_known, movement_state):\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {start: 0}\n    f_score = {start: heuristic(start, goal)}\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == goal:\n            return True\n\n        current_tile_info = grid.get(current, {})\n        is_on_ledge = current_tile_info.get('type') == 'ledge'\n        \n        if is_on_ledge:\n            neighbors = [(current[0], current[1] + 1)]\n        else:\n            neighbors = [(current[0] + dx, current[1] + dy) for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]]\n\n        for neighbor in neighbors:\n            if not (1 <= neighbor[0] <= map_width and 1 <= neighbor[1] <= map_height):\n                continue\n\n            neighbor_info = grid.get(neighbor, {})\n            neighbor_type = neighbor_info.get('type')\n            is_neighbor_impassable = neighbor_info.get('impassable', True)\n            \n            if is_neighbor_impassable:\n                continue\n            \n            if neighbor_type == 'ledge' and current[1] != neighbor[1] - 1:\n                continue\n\n            is_neighbor_water = neighbor_type == 'water'\n            is_neighbor_cuttable = neighbor_type == 'cuttable'\n\n            can_move = False\n            if movement_state == 'surfing':\n                if is_neighbor_water or not is_neighbor_impassable:\n                    can_move = True\n            else: # walking\n                if is_neighbor_water:\n                    if 'surf' in hms_known:\n                        can_move = True\n                elif is_neighbor_cuttable:\n                    if 'cut' in hms_known:\n                        can_move = True\n                else:\n                    can_move = True\n            \n            if not can_move:\n                continue\n\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    return False\n\ntry:\n    party_data_str = input_data['party_data']\n    movement_state = input_data['movement_state']\n    hms = parse_party_data(party_data_str)\n    \n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.attrib['width'])\n    map_height = int(root.attrib['height'])\n\n    player_pos = None\n    unseen_tiles = []\n    grid = {}\n\n    for tile in root.findall('.//Tile'):\n        x, y = int(tile.get('id')), int(tile.get('coordinate').split(',')[1].strip(')'))\n        tile_type = tile.get('type')\n        obj = tile.find('Object')\n        is_impassable_obj = obj is not None and obj.get('id-name') != 'Pikachu'\n        is_impassable_tile = tile_type in ['impassable', 'boulder_barrier', 'closed_gate', 'unknown']\n        \n        grid[(x, y)] = {\n            'type': tile_type,\n            'impassable': is_impassable_tile or is_impassable_obj\n        }\n\n        if tile.get('seen') != 'true':\n            unseen_tiles.append((x, y))\n        if tile.find('Player') is not None:\n            player_pos = (x, y)\n\n    if not player_pos:\n        print(json.dumps({'error': 'Player not found.'}))\n    else:\n        reachable_unseen = []\n        for ux, uy in unseen_tiles:\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adj_tile = (ux + dx, uy + dy)\n                if not (1 <= adj_tile[0] <= map_width and 1 <= adj_tile[1] <= map_height):\n                    continue\n                \n                adj_info = grid.get(adj_tile, {})\n                if adj_info.get('impassable') or adj_info.get('type') == 'unknown':\n                    continue\n                \n                if a_star_search(player_pos, adj_tile, grid, map_width, map_height, hms, movement_state):\n                    dist = heuristic(player_pos, adj_tile)\n                    reachable_unseen.append({'unseen': (ux, uy), 'adj': adj_tile, 'dist': dist})\n                    break\n\n        if not reachable_unseen:\n            print(json.dumps({'message': 'No reachable unseen tiles found.'}))\n        else:\n            closest = min(reachable_unseen, key=lambda x: x['dist'])\n            print(json.dumps({\n                'closest_reachable_unseen_tile': {'x': closest['unseen'][0], 'y': closest['unseen'][1]},\n                'adjacent_tile': {'x': closest['adj'][0], 'y': closest['adj'][1]}\n            }))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))"
  },
  "reachable_shoreline_finder": {
    "description": "Analyzes the map_xml_string to identify all reachable water-adjacent ground tiles from the player's current position. This version correctly handles elevation changes via 'steps' tiles.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\n\nroot = ET.fromstring(map_xml_string)\nmap_width = int(root.attrib['width'])\nmap_height = int(root.attrib['height'])\n\ngrid = {}\nplayer_start = None\n\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.attrib['id'])\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.attrib['id'])\n        tile_type = tile_elem.attrib['type']\n        has_object = tile_elem.find('Object') is not None\n        \n        is_impassable = tile_type in ['impassable', 'boulder_barrier', 'closed_gate', 'unknown'] or has_object\n        if has_object and tile_elem.find('Object').attrib.get('id-name') == 'Pikachu':\n            is_impassable = False\n\n        grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n        if tile_elem.find('Player') is not None:\n            player_start = (x, y)\n\nif not player_start:\n    print(\"Error: Player position not found.\")\nelse:\n    queue = collections.deque([player_start])\n    visited = {player_start}\n    \n    # Walkable tiles for BFS. This is the key fix.\n    walkable_types = ['ground', 'elevated_ground', 'steps', 'grass', 'cleared_boulder_barrier', 'boulder_switch', 'open_gate', 'gate_offscreen']\n\n    while queue:\n        cx, cy = queue.popleft()\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            neighbor_coord = (nx, ny)\n            \n            if 1 <= nx <= map_width and 1 <= ny <= map_height and neighbor_coord not in visited:\n                neighbor_tile = grid.get(neighbor_coord, {})\n                if not neighbor_tile.get('impassable') and neighbor_tile.get('type') in walkable_types:\n                    visited.add(neighbor_coord)\n                    queue.append(neighbor_coord)\n\n    shoreline_tiles = []\n    land_types_for_surfing = ['ground', 'elevated_ground', 'steps', 'grass'] # Tiles you can stand on to initiate Surf\n\n    for x, y in sorted(list(visited)):\n        current_tile = grid.get((x,y), {})\n        if current_tile.get('type') in land_types_for_surfing:\n            is_shore = False\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 1 <= nx <= map_width and 1 <= ny <= map_height:\n                    if grid.get((nx, ny), {}).get('type') == 'water':\n                        is_shore = True\n                        break\n            if is_shore:\n                shoreline_tiles.append((x, y))\n\n    if shoreline_tiles:\n        print(f\"Reachable shoreline tiles found: {shoreline_tiles}\")\n    else:\n        print(\"No reachable shoreline tiles found from the current position.\")"
  },
  "robust_pathfinder": {
    "description": "A robust A* pathfinding tool that handles mixed movement (walking/surfing), avoids hazards, and navigates spinner mazes.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "party_data": {
          "type": "string"
        },
        "hazard_coords": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "target_x",
        "target_y",
        "party_data"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef find_path(map_xml_string, target_x, target_y, party_data_str, hazard_coords_str=None):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = [['' for _ in range(width + 1)] for _ in range(height + 1)]\n    elevations = [[0 for _ in range(width + 1)] for _ in range(height + 1)]\n    spinner_data = {}\n    objects = set()\n    start_x, start_y = -1, -1\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            grid[y][x] = tile_type\n\n            if tile_elem.get('has-player') == 'true':\n                start_x, start_y = x, y\n\n            if tile_elem.find('Object') is not None:\n                obj_elem = tile_elem.find('Object')\n                if obj_elem.get('id-name') != 'Pikachu':\n                    objects.add((x, y))\n            if tile_type == 'elevated_ground':\n                elevations[y][x] = 1\n            \n            spinner_elem = tile_elem.find('Spinner')\n            if spinner_elem is not None and 'end-coordinate' in spinner_elem.attrib:\n                end_coord_str = spinner_elem.get('end-coordinate').replace('(', '').replace(')', '')\n                end_x, end_y = map(int, end_coord_str.split(','))\n                spinner_data[(x, y)] = (end_x, end_y)\n    \n    if start_x == -1:\n        return \"Player tile not found in map XML.\"\n\n    party_data = json.loads(party_data_str)\n    can_surf = any(move.get('name') == 'SURF' for p in party_data for move in p.get('moves', []))\n    \n    player_tile_type = grid[start_y][start_x]\n    movement_state = 'surfing' if player_tile_type == 'water' else 'walking'\n\n    hazard_coords = set()\n    if hazard_coords_str:\n        try:\n            hazards = json.loads(hazard_coords_str)\n            for h in hazards:\n                hazard_coords.add(tuple(h))\n        except (json.JSONDecodeError, TypeError):\n            pass\n\n    open_set = []\n    heapq.heappush(open_set, (0, (start_x, start_y)))\n    came_from = {}\n    g_score = {(x, y): float('inf') for x in range(width + 2) for y in range(height + 2)}\n    g_score[(start_x, start_y)] = 0\n    f_score = {(x, y): float('inf') for x in range(width + 2) for y in range(height + 2)}\n    f_score[(start_x, start_y)] = abs(start_x - target_x) + abs(start_y - target_y)\n\n    traversable_walking = ['ground', 'grass', 'steps', 'cleared_boulder_barrier', 'hole', 'spinner_stop', 'open_gate', 'gate_offscreen', 'elevated_ground', 'ladder_up', 'ladder_down']\n    traversable_surfing = ['water']\n    \n    target_tile_type = grid[target_y][target_x]\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == (target_x, target_y):\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append((start_x, start_y))\n            return path[::-1]\n\n        x, y = current\n        \n        if current in spinner_data:\n            neighbors = [spinner_data[current]]\n        else:\n            neighbors = []\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 1 <= nx <= width and 1 <= ny <= height:\n                    if grid[y][x] != 'ledge' and grid[ny][nx] == 'ledge' and dy == 1:\n                        if 1 <= ny + 1 <= height:\n                            neighbors.append((nx, ny + 1))\n                    elif not (grid[y][x] == 'ledge' and dy == -1):\n                        neighbors.append((nx, ny))\n        \n        for neighbor in neighbors:\n            nx, ny = neighbor\n            \n            if not (1 <= nx <= width and 1 <= ny <= height):\n                continue\n            \n            if (nx, ny) in hazard_coords or (nx, ny) in objects:\n                continue\n\n            current_elevation = elevations[y][x]\n            neighbor_elevation = elevations[ny][nx]\n            \n            is_traversable = False\n            \n            # If starting and ending on land, do not enter water.\n            if movement_state == 'walking' and target_tile_type != 'water':\n                if grid[ny][nx] in traversable_walking or grid[ny][nx].startswith('spinner'):\n                    is_traversable = True\n            else:\n                if movement_state == 'walking':\n                    if grid[ny][nx] in traversable_walking or grid[ny][nx].startswith('spinner'):\n                        is_traversable = True\n                    elif grid[ny][nx] == 'water' and can_surf and grid[y][x] in ['ground', 'steps', 'water']:\n                         is_traversable = True\n                elif movement_state == 'surfing':\n                    if grid[ny][nx] in traversable_surfing:\n                        is_traversable = True\n                    elif grid[ny][nx] in traversable_walking and grid[y][x] in ['ground', 'steps', 'water']:\n                        is_traversable = True\n                    \n            if abs(current_elevation - neighbor_elevation) > 0 and grid[y][x] != 'steps' and grid[ny][nx] != 'steps':\n                is_traversable = False\n            \n            if is_traversable:\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = tentative_g_score + abs(nx - target_x) + abs(ny - target_y)\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n                    \n    return None\n\ntry:\n    path = find_path(map_xml_string, int(input_data['target_x']), int(input_data['target_y']), input_data['party_data'], input_data.get('hazard_coords'))\n    \n    if isinstance(path, list):\n        buttons = []\n        current_x, current_y = path[0]\n        for next_x, next_y in path[1:]:\n            if abs(next_y - current_y) > 1 and next_y > current_y:\n                buttons.append('Down')\n            elif next_x > current_x: buttons.append('Right')\n            elif next_x < current_x: buttons.append('Left')\n            elif next_y > current_y: buttons.append('Down')\n            elif next_y < current_y: buttons.append('Up')\n            current_x, current_y = next_x, next_y\n        print(json.dumps(buttons))\n    elif path is None:\n        print(json.dumps(['path not found']))\n    else:\n        print(json.dumps([f'error: {path}']))\n\nexcept Exception as e:\n    print(json.dumps([f'error: {str(e)}']))",
    "history": [
      {
        "commit_message": "fix: Prevent invalid water entry from elevated ground. The pathfinder was incorrectly allowing movement from 'elevated_ground' tiles directly to 'water' tiles. This commit adds a check to the A* algorithm to explicitly disallow entering water from any tile type other than 'water', 'steps', or 'ground', which are the only valid entry points for Surf. This will prevent the tool from generating invalid paths and causing movement loops.",
        "timestamp": "2025-07-23T02:45:55.283Z",
        "action_counter": 94248
      },
      {
        "commit_message": "fix: Prevent pathfinding over water when walking. The tool was incorrectly generating paths that included water tiles even when the player was not surfing. This commit adds a check to the A* algorithm to treat water tiles as impassable if the player's current movement state is 'walking'. It also infers the movement state based on the player's current tile type from the map XML.",
        "timestamp": "2025-07-23T04:34:15.655Z",
        "action_counter": 94472
      },
      {
        "commit_message": "feat: Integrate spinner maze logic. This refactor merges the functionality of the deprecated `spinner_maze_pathfinder` directly into `robust_pathfinder`. The tool now checks if a tile is a spinner with a defined end-coordinate and treats it as a forced-movement warp, adding only the destination as a neighbor. This consolidates pathfinding logic into a single, more capable tool, eliminating redundancy and streamlining maintenance as per procedural best practices.",
        "timestamp": "2025-07-23T06:08:10.566Z",
        "action_counter": 94651
      },
      {
        "commit_message": "fix: Add check for missing player tile. The tool previously failed with a NoneType error if the player's tile was not found in the map XML. This commit adds a check to handle this case gracefully and return an informative error message, preventing the tool from crashing and improving its robustness.",
        "timestamp": "2025-07-23T06:23:31.661Z",
        "action_counter": 94681
      },
      {
        "commit_message": "fix: Correct player coordinate finding. The tool was failing with a NoneType error because it used an unsupported XPath selector ('..') to find the player's parent tile for the y-coordinate. This commit refactors the logic to find the player's start_x and start_y coordinates by iterating through the grid during the initial map parsing. This is a more robust method that avoids the API limitation and resolves the crash.",
        "timestamp": "2025-07-23T06:25:50.168Z",
        "action_counter": 94684
      },
      {
        "commit_message": "fix: Correct player coordinate finding. The tool was failing with a NoneType error because it used an unsupported XPath selector ('..') to find the player's parent tile for the y-coordinate. This commit refactors the logic to find the player's start_x and start_y coordinates by iterating through the grid during the initial map parsing. This is a more robust method that avoids the API limitation and resolves the crash.",
        "timestamp": "2025-07-23T06:26:27.962Z",
        "action_counter": 94685
      },
      {
        "commit_message": "fix: Correct `can_surf` boolean logic. The tool was failing with a `'bool' object is not iterable` error because the `can_surf` check was incorrectly structured as `any('SURF' in [...])`, which passes a boolean to `any()`. This commit corrects the logic to use a proper generator expression, `any(move.get('name') == 'SURF' for ...)` which provides a valid iterable for the `any()` function and resolves the crash.",
        "timestamp": "2025-07-23T06:27:52.740Z",
        "action_counter": 94687
      },
      {
        "commit_message": "fix: Prevent pathfinding over water for land-based targets. The tool was generating invalid paths that included water segments for land-to-land navigation. This commit adds a check to see if the target tile is on land. If both the player's start and end points are on land, water tiles are treated as impassable, forcing a land-only route.",
        "timestamp": "2025-07-23T06:46:55.555Z",
        "action_counter": 94717
      }
    ]
  }
}