{
  "calculate_xp_requirements": {
    "description": "Calculates the experience points required for the next level for a given Pokémon species and its current level and experience. Supports the four standard experience curves found in Pokémon Crystal (Fast, Medium Fast, Medium Slow, Slow).",
    "input_schema": {
      "type": "object",
      "properties": {
        "growth_rate": {
          "type": "string",
          "enum": [
            "Fast",
            "Medium Fast",
            "Medium Slow",
            "Slow"
          ]
        },
        "current_level": {
          "type": "integer"
        },
        "current_exp": {
          "type": "integer"
        }
      },
      "required": [
        "growth_rate",
        "current_level",
        "current_exp"
      ]
    },
    "python_script": "import json\n\ngrowth_rate = input_data[\"growth_rate\"]\ncurrent_level = int(input_data[\"current_level\"])\ncurrent_exp = int(input_data[\"current_exp\"])\n\ndef get_total_exp(n, rate):\n    if rate == \"Fast\":\n        return int(0.8 * (n ** 3))\n    elif rate == \"Medium Fast\":\n        return n ** 3\n    elif rate == \"Medium Slow\":\n        return int(1.2 * (n ** 3) - 15 * (n ** 2) + 100 * n - 140)\n    elif rate == \"Slow\":\n        return int(1.25 * (n ** 3))\n    return 0\n\nnext_level = current_level + 1\ntarget_exp = get_total_exp(next_level, growth_rate)\nremaining = max(0, target_exp - current_exp)\n\nresult = {\n    \"growth_rate\": growth_rate,\n    \"current_level\": current_level,\n    \"current_exp\": current_exp,\n    \"next_level\": next_level,\n    \"total_exp_next_level\": target_exp,\n    \"exp_remaining\": remaining\n}\nprint(json.dumps(result))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T04:58:09.193Z",
        "action_counter": 817
      },
      {
        "commit_message": "Added calculate_xp_requirements tool to automate experience tracking.",
        "timestamp": "2025-12-18T14:00:59.942Z",
        "action_counter": 1772
      }
    ]
  },
  "list_reachable_unseen_v3": {
    "description": "Finds all 'unseen' tiles that are currently reachable from the player's position, correctly handling ledges and objects. Returns a list of (x, y) coordinates. If autopress_buttons is true, it returns a list of buttons to the nearest unseen tile.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef solve():\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    matrix = [[None for _ in range(width)] for _ in range(height)]\n    player_pos = None\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tile_type = tile.attrib['type']\n            seen = tile.attrib['seen'] == 'true'\n            has_object = tile.attrib.get('has-object') == 'true'\n            \n            matrix[y][x] = {\n                'type': tile_type,\n                'seen': seen,\n                'has_object': has_object\n            }\n            \n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n\n    if not player_pos:\n        print(json.dumps([]))\n        return\n\n    def is_passable(x, y, from_x, from_y):\n        if not (0 <= x < width and 0 <= y < height):\n            return False\n        tile = matrix[y][x]\n        if not tile['seen']:\n            return False\n        if tile['has_object']:\n            return False\n        \n        t_type = tile['type']\n        f_type = matrix[from_y][from_x]['type']\n        \n        # Basic wall check\n        if t_type in [\"WALL\", \"FLOOR_UP_WALL\", \"WATER\", \"ROCK\", \"INCENSE_BURNER\", \"COUNTER\", \"HEADBUTT_TREE\", \"CUT_TREE\"]:\n            return False\n            \n        # Ledge logic\n        if f_type == \"LEDGE_HOP_DOWN\" and y != from_y + 2: return False\n        if f_type == \"LEDGE_HOP_RIGHT\" and x != from_x + 2: return False\n        if f_type == \"LEDGE_HOP_LEFT\" and x != from_x - 2: return False\n        \n        if t_type == \"LEDGE_HOP_DOWN\" and y != from_y + 1: return False\n        if t_type == \"LEDGE_HOP_RIGHT\" and x != from_x + 1: return False\n        \n        return True\n\n    reachable_unseen = []\n    queue = deque([player_pos])\n    visited = {player_pos}\n    parent = {player_pos: None}\n    \n    unseen_coords = []\n\n    while queue:\n        curr_x, curr_y = queue.popleft()\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = curr_x + dx, curr_y + dy\n            \n            if 0 <= nx < width and 0 <= ny < height:\n                if not matrix[ny][nx]['seen']:\n                    if (nx, ny) not in unseen_coords:\n                        unseen_coords.append((nx, ny))\n                    continue\n                \n                if (nx, ny) not in visited and is_passable(nx, ny, curr_x, curr_y):\n                    visited.add((nx, ny))\n                    parent[(nx, ny)] = (curr_x, curr_y)\n                    queue.append((nx, ny))\n\n    if input_data.get('autopress_buttons'):\n        if not unseen_coords:\n            print(json.dumps([]))\n            return\n            \n        # Target the first unseen tile's parent (the traversable tile next to it)\n        # and return buttons to that tile, then one final press towards the unseen.\n        # For simplicity in this fix, I'll just return the coords as requested by the LLM \n        # but the system error was about the type.\n        # If the LLM wants buttons, it needs a path.\n        \n        # Find path to the first reachable point adjacent to an unseen tile\n        target_unseen = unseen_coords[0]\n        # We already found the path to 'curr_x, curr_y' which is adjacent to 'nx, ny'\n        # Let's find which visited tile is adjacent to target_unseen\n        best_neighbor = None\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            px, py = target_unseen[0] - dx, target_unseen[1] - dy\n            if (px, py) in visited:\n                best_neighbor = (px, py)\n                break\n        \n        if not best_neighbor:\n            print(json.dumps([]))\n            return\n            \n        path = []\n        curr = best_neighbor\n        while curr:\n            path.append(curr)\n            curr = parent[curr]\n        path.reverse()\n        \n        buttons = []\n        for i in range(len(path) - 1):\n            x1, y1 = path[i]\n            x2, y2 = path[i+1]\n            if x2 > x1: buttons.append(\"Right\")\n            elif x2 < x1: buttons.append(\"Left\")\n            elif y2 > y1: buttons.append(\"Down\")\n            elif y2 < y1: buttons.append(\"Up\")\n            \n        # Final move towards unseen\n        x1, y1 = best_neighbor\n        x2, y2 = target_unseen\n        if x2 > x1: buttons.append(\"Right\")\n        elif x2 < x1: buttons.append(\"Left\")\n        elif y2 > y1: buttons.append(\"Down\")\n        elif y2 < y1: buttons.append(\"Up\")\n        \n        print(json.dumps(buttons))\n    else:\n        print(json.dumps(unseen_coords))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T06:06:05.223Z",
        "action_counter": 935
      },
      {
        "commit_message": "Fixed list_reachable_unseen_v3 to return button strings when autopress_buttons is true, by pathing to the nearest unseen tile.",
        "timestamp": "2025-12-18T14:56:57.841Z",
        "action_counter": 1869
      }
    ]
  },
  "press_sequence": {
    "description": "Executes a specific sequence of button presses, allowing for mixed directional and action inputs. Useful for complex menu navigation.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nprint(json.dumps(input_data['buttons']))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T06:11:16.135Z",
        "action_counter": 948
      }
    ]
  },
  "find_path_v4": {
    "description": "Finds a shortest path to a target coordinate, correctly handling ledges as one-way traversal, objects as walls, markers as walls, and specific impassable tile types like FLOOR_UP_WALL and WATER. Returns a list of button strings.",
    "input_schema": {
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ],
      "type": "object"
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef find_path(map_xml, target_x, target_y):\n    root = ET.fromstring(map_xml)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = {}\n    player_pos = None\n    \n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            t_type = tile.get('type')\n            \n            # Impassable types\n            impassable_types = ['WALL', 'FLOOR_UP_WALL', 'WATER', 'HEADBUTT_TREE', 'CUT_TREE', 'ROCK', 'BOULDER', 'BOOKSHELF', 'RADIO', 'INCENSE_BURNER']\n            is_passable = t_type not in impassable_types\n            \n            # Objects and Markers are walls (unless target)\n            if (x, y) != (target_x, target_y):\n                if tile.find('Object') is not None or tile.find('Marker') is not None:\n                    is_passable = False\n                \n            grid[(x, y)] = {'passable': is_passable, 'type': t_type}\n            \n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n                \n    if not player_pos:\n        return []\n\n    # BFS\n    queue = deque([(player_pos, [])])\n    visited = {player_pos}\n    \n    while queue:\n        (x, y), path = queue.popleft()\n        \n        if (x, y) == (target_x, target_y):\n            return path\n            \n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:\n                tile_data = grid.get((nx, ny))\n                if not tile_data: continue\n                \n                can_enter = tile_data['passable']\n                curr_type = grid[(x, y)]['type']\n                target_type = tile_data['type']\n                \n                # Ledge Exit Logic (leaving curr_tile)\n                if curr_type == 'LEDGE_HOP_DOWN' and btn != 'Down': can_enter = False\n                if curr_type == 'LEDGE_HOP_RIGHT' and btn != 'Right': can_enter = False\n                if curr_type == 'LEDGE_HOP_LEFT' and btn != 'Left': can_enter = False\n                \n                # Ledge Entry Logic (entering target_tile)\n                if target_type == 'LEDGE_HOP_DOWN' and btn != 'Down': can_enter = False\n                if target_type == 'LEDGE_HOP_RIGHT' and btn != 'Right': can_enter = False\n                if target_type == 'LEDGE_HOP_LEFT' and btn != 'Left': can_enter = False\n                \n                if can_enter:\n                    visited.add((nx, ny))\n                    queue.append(((nx, ny), path + [btn]))\n    \n    return []\n\nimport os\ntarget_x = int(input_data['target_x'])\ntarget_y = int(input_data['target_y'])\npath = find_path(map_xml_string, target_x, target_y)\nprint(json.dumps(path))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T16:21:03.281Z",
        "action_counter": 2012
      },
      {
        "commit_message": "Added Marker support to find_path_v4 to account for off-screen obstacles.",
        "timestamp": "2025-12-18T16:23:18.646Z",
        "action_counter": 2014
      },
      {
        "commit_message": "Refined ledge logic to correctly handle entry/exit restrictions and fixed the 5-tool limit issue by ensuring only necessary tools are kept.",
        "timestamp": "2025-12-18T16:48:29.278Z",
        "action_counter": 2057
      }
    ]
  }
}