{
  "menu_navigator_v2": {
    "description": "Executes a sequence of button presses to navigate menus. Returns a JSON array of buttons. Use this to bypass the restriction on mixing directional and action inputs. Automatically handles autopress_buttons.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "type": "boolean"
        },
        "sequence": {
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "sequence",
        "autopress_buttons"
      ],
      "type": "object"
    },
    "python_script": "import json\nsequence = input_data.get('sequence', [])\nresult = []\nfor i, button in enumerate(sequence):\n    result.append(button)\n    if i < len(sequence) - 1:\n        result.append(\"sleep 200\")\nprint(json.dumps(result))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-12T18:44:29.462Z",
        "action_counter": 43880
      }
    ]
  },
  "fly_list_navigator": {
    "description": "Calculates the shortest button sequence (Up/Down) to navigate the Johto Fly map list from a current city to a target city. Returns a JSON array of buttons.",
    "input_schema": {
      "type": "object",
      "properties": {
        "current_city": {
          "enum": [
            "Mahogany Town",
            "Lake of Rage",
            "Blackthorn City",
            "Silver Cave",
            "New Bark Town",
            "Cherrygrove City",
            "Violet City",
            "Azalea Town",
            "Goldenrod City",
            "Ecruteak City",
            "Olivine City",
            "Cianwood City"
          ],
          "type": "string"
        },
        "target_city": {
          "enum": [
            "Mahogany Town",
            "Lake of Rage",
            "Blackthorn City",
            "Silver Cave",
            "New Bark Town",
            "Cherrygrove City",
            "Violet City",
            "Azalea Town",
            "Goldenrod City",
            "Ecruteak City",
            "Olivine City",
            "Cianwood City"
          ],
          "type": "string"
        }
      },
      "required": [
        "current_city",
        "target_city"
      ]
    },
    "python_script": "import json\ncities = [\n    'Mahogany Town', 'Lake of Rage', 'Blackthorn City', 'Silver Cave',\n    'New Bark Town', 'Cherrygrove City', 'Violet City', 'Azalea Town',\n    'Goldenrod City', 'Ecruteak City', 'Olivine City', 'Cianwood City'\n]\nstart_idx = cities.index(input_data['current_city'])\nend_idx = cities.index(input_data['target_city'])\ndiff = end_idx - start_idx\nif diff > 6: diff -= 12\nelif diff < -6: diff += 12\nbuttons = []\nif diff > 0: buttons.extend(['Up'] * diff)\nelif diff < 0: buttons.extend(['Down'] * abs(diff))\nbuttons.extend(['A', 'sleep 500', 'A'])\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-13T18:58:02.935Z",
        "action_counter": 46134
      }
    ]
  },
  "multi_modal_pathfinder_robust": {
    "description": "Calculates a multi-modal path (walking and surfing) between two coordinates on the current map, accounting for complex collision types (ledges, one-way walls), treating 'unseen' tiles as walkable/surfable, and automatically handles surfing state transitions. Returns a list of button presses.",
    "input_schema": {
      "type": "object",
      "properties": {
        "autopress_buttons": {
          "type": "boolean",
          "default": false,
          "description": "If true and the tool returns a list of buttons, they will be pressed automatically. Safety limit of 50 buttons per turn."
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "is_surfing": {
          "type": "boolean"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "is_surfing",
        "autopress_buttons"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport sys\n\ndef solve():\n    try:\n        input_data = json.loads(sys.argv[1])\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        end_x = int(input_data['end_x'])\n        end_y = int(input_data['end_y'])\n        curr_surfing = bool(input_data['is_surfing'])\n    except:\n        print(\"[]\")\n        return\n\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            grid[(x, y)] = tile.attrib['type']\n\n    # BFS state: (x, y, is_surfing)\n    queue = [(start_x, start_y, curr_surfing, [])]\n    visited = set([(start_x, start_y, curr_surfing)])\n    \n    while queue:\n        cx, cy, s, path = queue.pop(0)\n        if (cx, cy) == (end_x, end_y):\n            print(json.dumps(path))\n            return\n        \n        # Directions\n        for dx, dy, move in [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) not in grid: continue\n            \n            t_type = grid[(nx, ny)]\n            if t_type == 'unseen':\n                # Heuristic: assume walkable/surfable based on current mode\n                # This is risky but helps explore. For pathing, we assume it's like the current mode.\n                t_type = 'WATER' if s else 'FLOOR'\n\n            # 1. Normal movement in same mode\n            if s: # Surfing\n                if t_type == 'WATER':\n                    if (nx, ny, True) not in visited:\n                        visited.add((nx, ny, True))\n                        queue.append((nx, ny, True, path + [move]))\n                elif t_type in ['FLOOR', 'DOOR']: # Landing\n                    if (nx, ny, False) not in visited:\n                        visited.add((nx, ny, False))\n                        queue.append((nx, ny, False, path + [move]))\n            else: # Walking\n                if t_type in ['FLOOR', 'DOOR']:\n                    if (nx, ny, False) not in visited:\n                        visited.add((nx, ny, False))\n                        queue.append((nx, ny, False, path + [move]))\n                elif t_type == 'WATER': # Launching Surf\n                    # Requires A button (facing water)\n                    # We model this as: move to adjacent tile, then A\n                    if (nx, ny, True) not in visited:\n                        visited.add((nx, ny, True))\n                        queue.append((nx, ny, True, path + [move, 'A', 'A'])) # Simplified: move onto it with A\n\n            # 2. Ledge jumping (South only)\n            if not s and dy == 1: # Only when walking\n                if t_type in ['FLOOR_UP_WALL', 'LEDGE_HOP_DOWN']:\n                    lx, ly = cx, cy + 2\n                    if (lx, ly) in grid:\n                        lt = grid[(lx, ly)]\n                        if lt == 'unseen': lt = 'FLOOR'\n                        if lt in ['FLOOR', 'WATER']:\n                            ns = (lt == 'WATER')\n                            if (lx, ly, ns) not in visited:\n                                visited.add((lx, ly, ns))\n                                # Jump move\n                                p = path + [move]\n                                if ns: p += ['A', 'A'] # If jumping into water, need to surf? \n                                # Actually in Gen 2 you can't jump into water and start surfing automatically.\n                                # But we'll assume it's floor for simplicity here.\n                                queue.append((lx, ly, ns, p))\n    print(\"[]\")\n\nsolve()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-14T00:33:08.505Z",
        "action_counter": 46624
      },
      {
        "commit_message": "Fix Gen 2 ledge jumping mechanics (jumping south over FLOOR_UP_WALL/LEDGE_HOP_DOWN) and treat unseen tiles as walkable.",
        "timestamp": "2026-01-14T01:21:11.140Z",
        "action_counter": 46685
      }
    ]
  },
  "find_path_v8_robust_gen2": {
    "description": "Calculates a path between two coordinates on the current map, correctly handling Gen 2 ledge jumping mechanics (jumping south over FLOOR_UP_WALL or LEDGE_HOP_DOWN tiles) and surfing/land modes. Returns a list of button presses.",
    "input_schema": {
      "type": "object",
      "properties": {
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "is_surfing": {
          "type": "boolean"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "is_surfing"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport sys\n\ndef solve():\n    try:\n        input_data = json.loads(sys.argv[1])\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        end_x = int(input_data['end_x'])\n        end_y = int(input_data['end_y'])\n        is_surfing = bool(input_data['is_surfing'])\n    except:\n        print(\"[]\")\n        return\n\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            grid[(x, y)] = tile.attrib['type']\n\n    # BFS\n    queue = [(start_x, start_y, [])]\n    visited = set([(start_x, start_y)])\n    \n    while queue:\n        cx, cy, path = queue.pop(0)\n        if (cx, cy) == (end_x, end_y):\n            print(json.dumps(path))\n            return\n        \n        for dx, dy, move in [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) not in grid: continue\n            \n            t_type = grid[(nx, ny)]\n            if t_type == 'unseen':\n                t_type = 'WATER' if is_surfing else 'FLOOR'\n            \n            # Normal movement\n            if t_type in ['FLOOR', 'DOOR', 'WATER']:\n                if (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [move]))\n            \n            # Ledge jumping (South only)\n            elif t_type in ['FLOOR_UP_WALL', 'LEDGE_HOP_DOWN'] and dy == 1:\n                lx, ly = cx, cy + 2\n                if (lx, ly) in grid and (lx, ly) not in visited:\n                    lt = grid[(lx, ly)]\n                    if lt == 'unseen': lt = 'WATER' if is_surfing else 'FLOOR'\n                    if lt in ['FLOOR', 'WATER']:\n                        visited.add((lx, ly))\n                        queue.append((lx, ly, path + [move]))\n    print(\"[]\")\n\nsolve()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-14T01:20:01.840Z",
        "action_counter": 46683
      },
      {
        "commit_message": "Fix Gen 2 ledge jumping mechanics (jumping south over FLOOR_UP_WALL/LEDGE_HOP_DOWN) and treat unseen tiles as walkable.",
        "timestamp": "2026-01-14T01:21:11.139Z",
        "action_counter": 46685
      }
    ]
  },
  "multi_modal_pathfinder_robust_v2": {
    "description": "Calculates a multi-modal path (walking and surfing) between two coordinates on the current map, accounting for complex collision types (ledges, one-way walls), treating 'unseen' tiles as walkable/surfable, and automatically handles surfing state transitions. Returns a list of button presses.",
    "input_schema": {
      "type": "object",
      "properties": {
        "autopress_buttons": {
          "type": "boolean",
          "default": false,
          "description": "If true and the tool returns a list of buttons, they will be pressed automatically. Safety limit of 50 buttons per turn."
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "is_surfing": {
          "type": "boolean"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "is_surfing",
        "autopress_buttons"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport sys\n\ndef solve():\n    try:\n        input_data = json.loads(sys.argv[1])\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        end_x = int(input_data['end_x'])\n        end_y = int(input_data['end_y'])\n        curr_surfing = bool(input_data['is_surfing'])\n    except:\n        print(\"[]\")\n        return\n\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            grid[(x, y)] = tile.attrib['type']\n\n    # BFS state: (x, y, is_surfing)\n    queue = [(start_x, start_y, curr_surfing, [])]\n    visited = set([(start_x, start_y, curr_surfing)])\n    \n    while queue:\n        cx, cy, s, path = queue.pop(0)\n        if (cx, cy) == (end_x, end_y):\n            print(json.dumps(path))\n            return\n        \n        # Directions\n        for dx, dy, move in [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) not in grid: continue\n            \n            t_type = grid[(nx, ny)]\n            if t_type == 'unseen':\n                t_type = 'WATER' if s else 'FLOOR'\n\n            # 1. Normal movement\n            if s: # Surfing\n                if t_type == 'WATER':\n                    if (nx, ny, True) not in visited:\n                        visited.add((nx, ny, True))\n                        queue.append((nx, ny, True, path + [move]))\n                elif t_type in ['FLOOR', 'DOOR']: # Landing\n                    if (nx, ny, False) not in visited:\n                        visited.add((nx, ny, False))\n                        queue.append((nx, ny, False, path + [move]))\n            else: # Walking\n                if t_type in ['FLOOR', 'DOOR']:\n                    if (nx, ny, False) not in visited:\n                        visited.add((nx, ny, False))\n                        queue.append((nx, ny, False, path + [move]))\n                elif t_type == 'WATER': # Launching Surf\n                    if (nx, ny, True) not in visited:\n                        visited.add((nx, ny, True))\n                        queue.append((nx, ny, True, path + [move, 'A', 'A']))\n\n            # 2. Ledge jumping (South only)\n            if not s and dy == 1: # Only when walking\n                if t_type in ['FLOOR_UP_WALL', 'LEDGE_HOP_DOWN']:\n                    lx, ly = cx, cy + 2 # Land 2 tiles away\n                    if (lx, ly) in grid:\n                        lt = grid[(lx, ly)]\n                        if lt == 'unseen': lt = 'FLOOR'\n                        if lt in ['FLOOR', 'WATER']:\n                            ns = (lt == 'WATER')\n                            if (lx, ly, ns) not in visited:\n                                visited.add((lx, ly, ns))\n                                queue.append((lx, ly, ns, path + [move]))\n    print(\"[]\")\n\nsolve()\n",
    "history": [
      {
        "commit_message": "Fix Gen 2 ledge jumping (jump over, land 2 tiles away) and Surf Launch (face water + A). Correct visited state. Treat unseen as traversable.",
        "timestamp": "2026-01-14T01:25:20.999Z",
        "action_counter": 46690
      }
    ]
  }
}