{
  "find_path": {
    "description": "Finds the shortest path on the current map using BFS. Avoids impassable tiles, objects, and unseen areas.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef find_path_logic(map_xml_string, start_x, start_y, end_x, end_y):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = [['' for _ in range(width + 1)] for _ in range(height + 1)]\n    \n    impassable_tiles = {'WALL', 'HEADBUTT_TREE', 'CUT_TREE', 'WATER', 'COUNTER', 'MART_SHELF', 'BUOY', 'TOWN_MAP', 'WINDOW', 'BOOKSHELF', 'TV', 'RADIO', 'VOID'}\n    \n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id'])\n            tile_type = tile_elem.attrib['type']\n            seen = tile_elem.attrib['seen']\n            \n            if seen == 'false' or tile_elem.find('Object') is not None or tile_type in impassable_tiles:\n                grid[y][x] = 'WALL'\n            else:\n                grid[y][x] = tile_type\n\n    start = (start_x, start_y)\n    end = (end_x, end_y)\n    \n    if not (1 <= start[0] <= width and 1 <= start[1] <= height and 1 <= end[0] <= width and 1 <= end[1] <= height):\n        return json.dumps({\"error\": \"Start or end coordinates are out of bounds.\"})\n\n    if grid[start[1]][start[0]] == 'WALL' or grid[end[1]][end[0]] == 'WALL':\n        return json.dumps({\"error\": \"Start or end tile is impassable.\"})\n\n    queue = deque([(start, [start])])\n    visited = {start}\n    \n    while queue:\n        (current_x, current_y), path = queue.popleft()\n        \n        if (current_x, current_y) == end:\n            return json.dumps([{'x': p[0], 'y': p[1]} for p in path])\n            \n        moves = [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]\n        \n        for dx, dy, move_dir in moves:\n            next_x, next_y = current_x + dx, current_y + dy\n            \n            if not (1 <= next_x <= width and 1 <= next_y <= height):\n                continue\n\n            if (next_x, next_y) in visited:\n                continue\n\n            next_tile_type = grid[next_y][next_x]\n            if next_tile_type == 'WALL':\n                continue\n            \n            current_tile_type = grid[current_y][current_x]\n            if dy == 1 and 'LEDGE' in current_tile_type: \n                pass\n            elif dy == -1 and 'LEDGE' in grid[next_y][next_x]:\n                continue\n\n            visited.add((next_x, next_y))\n            new_path = list(path)\n            new_path.append((next_x, next_y))\n            queue.append(((next_x, next_y), new_path))\n            \n    return json.dumps({\"error\": \"No path found.\"})\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nresult = find_path_logic(map_xml_string, start_x, start_y, end_x, end_y)\nprint(result)"
  },
  "path_master": {
    "description": "Finds the shortest path on the current map using A*. Avoids impassable tiles, objects, and unseen areas. It also correctly handles one-way tiles like ledges.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\nimport json\n\ndef run_path_master(start_x_str, start_y_str, end_x_str, end_y_str):\n    start_x, start_y = int(start_x_str), int(start_y_str)\n    end_x, end_y = int(end_x_str), int(end_y_str)\n\n    try:\n        root = ET.fromstring(map_xml_string)\n    except ET.ParseError as e:\n        print(f\"Error parsing map_xml_string: {e}\")\n        return\n\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = [['VOID' for _ in range(width + 1)] for _ in range(height + 1)]\n    objects = set()\n\n    impassable_types = {'WALL', 'WATER', 'CUT_TREE', 'BUOY', 'TOWN_MAP', 'WINDOW', 'BOOKSHELF', 'TV', 'RADIO', 'VOID', 'MART_SHELF', 'COUNTER', 'PC', 'HEADBUTT_TREE', 'PILLAR'}\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            \n            grid[y][x] = tile_type\n            \n            if tile_elem.get('seen') == 'false':\n                grid[y][x] = 'unseen'\n            \n            if tile_elem.find('Object') is not None:\n                objects.add((y, x))\n\n    def get_possible_moves(y, x):\n        tile_type = grid[y][x]\n        if 'FLOOR_HOP_DOWN_LEDGE' in tile_type:\n            return [(1, 0)]\n        if 'FLOOR_HOP_RIGHT_LEDGE' in tile_type:\n            return [(0, 1)]\n        if 'FLOOR_HOP_LEFT_LEDGE' in tile_type:\n            return [(0, -1)]\n        if 'FLOOR_HOP_DOWN_OR_RIGHT_LEDGE' in tile_type:\n            return [(1, 0), (0, 1)]\n        if 'FLOOR_HOP_DOWN_OR_LEFT_LEDGE' in tile_type:\n            return [(1, 0), (0, -1)]\n        return [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    def is_traversable(y, x, from_y, from_x):\n        if not (0 <= y <= height and 0 <= x <= width):\n            return False\n        tile_type = grid[y][x]\n        if tile_type in impassable_types or tile_type == 'unseen' or (y, x) in objects:\n            return False\n        \n        if y < from_y and 'LEDGE' in tile_type:\n            return False\n\n        return True\n\n    start = (start_y, start_x)\n    end = (end_y, end_x)\n\n    if not (0 <= start[0] <= height and 0 <= start[1] <= width):\n        print(f\"Start {start_x, start_y} is out of bounds.\")\n        return\n\n    pq = [(0, start, [])]\n    visited = set()\n    cost_so_far = {start: 0}\n\n    while pq:\n        _, current, path = heapq.heappop(pq)\n        y, x = current\n\n        if current in visited:\n            continue\n        \n        visited.add(current)\n        new_path = path + [current]\n\n        if current == end:\n            path_coords = [{\"x\": px, \"y\": py} for py, px in new_path]\n            print(json.dumps(path_coords))\n            return\n\n        for dy, dx in get_possible_moves(y, x):\n            ny, nx = y + dy, x + dx\n            neighbor = (ny, nx)\n            \n            if is_traversable(ny, nx, y, x):\n                new_cost = cost_so_far[current] + 1\n                if neighbor not in cost_so_far or new_cost < cost_so_far[neighbor]:\n                    cost_so_far[neighbor] = new_cost\n                    heuristic = abs(ny - end[0]) + abs(nx - end[1])\n                    priority = new_cost + heuristic\n                    heapq.heappush(pq, (priority, neighbor, new_path))\n                \n    print(\"No path found\")\n\nrun_path_master(input_data['start_x'], input_data['start_y'], input_data['end_x'], input_data['end_y'])"
  },
  "unstick_me_tool": {
    "description": "Analyzes the map XML to find the nearest traversable tile adjacent to an 'unseen' area. Returns coordinates for a new navigation goal. Can also check for softlock conditions.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef find_unseen_cluster(start_x_str, start_y_str):\n    start_x, start_y = int(start_x_str), int(start_y_str)\n\n    try:\n        root = ET.fromstring(map_xml_string)\n    except ET.ParseError as e:\n        print(json.dumps({\"status\": \"error\", \"message\": f\"Error parsing map_xml_string: {e}\"}))\n        return\n\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = {}\n    objects = set()\n    unseen_tiles = set()\n    warps = set()\n\n    impassable_types = {'WALL', 'WATER', 'CUT_TREE', 'BUOY', 'TOWN_MAP', 'WINDOW', 'BOOKSHELF', 'TV', 'RADIO', 'VOID', 'MART_SHELF', 'COUNTER', 'PC', 'HEADBUTT_TREE', 'PILLAR'}\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            grid[(x, y)] = tile_elem.get('type')\n            if tile_elem.get('seen') == 'false':\n                unseen_tiles.add((x, y))\n            if tile_elem.find('Object') is not None:\n                objects.add((x, y))\n            if tile_elem.find('Warp') is not None:\n                warps.add((x, y))\n\n    def is_traversable(x, y):\n        if (x, y) not in grid:\n            return False\n        tile_type = grid.get((x, y))\n        if tile_type in impassable_types or (x, y) in objects or tile_type == 'unseen':\n            return False\n        return True\n\n    q = deque([(start_x, start_y, 0)])\n    visited = {(start_x, start_y)}\n    possible_goals = []\n\n    while q:\n        x, y, dist = q.popleft()\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) in unseen_tiles:\n                possible_goals.append({'x': x, 'y': y, 'dist': dist + 1})\n            elif is_traversable(nx, ny) and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                q.append((nx, ny, dist + 1))\n\n    if not possible_goals:\n        q_warp = deque([(start_x, start_y)])\n        visited_warp = {(start_x, start_y)}\n        has_path_to_warp = False\n        while q_warp:\n            x, y = q_warp.popleft()\n            if (x, y) in warps:\n                has_path_to_warp = True\n                break\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if is_traversable(nx, ny) and (nx, ny) not in visited_warp:\n                    visited_warp.add((nx, ny))\n                    q_warp.append((nx, ny))\n        if not has_path_to_warp:\n            print(json.dumps({\"status\": \"softlocked\", \"message\": \"No path to any warp or exit and no reachable unseen tiles.\"}))\n        else:\n            print(json.dumps({\"status\": \"no_unseen\", \"message\": \"No reachable unseen tiles found.\"}))\n        return\n\n    closest_goal = min(possible_goals, key=lambda p: p['dist'])\n    print(json.dumps({\"status\": \"found\", \"goal_x\": closest_goal['x'], \"goal_y\": closest_goal['y']}))\n\nfind_unseen_cluster(input_data['start_x'], input_data['start_y'])"
  },
  "run_code": {
    "description": "Runs the provided Python code. The variable `map_xml_string` is automatically available and contains the current map data as XML. The variable `world_knowledge_graph_json_string` is automatically available and contains your World Knowledge Graph as a JSON string. **Important**: Only `map_xml_string` and `world_knowledge_graph_json_string` are automatically provided. All other variables, imports, and data must be defined explicitly in your code.",
    "input_schema": {
      "type": "object",
      "properties": {
        "code": {
          "type": "string",
          "description": "The Python code to run."
        }
      },
      "required": [
        "code"
      ]
    },
    "python_script": "import json\nimport sys\n\ndef execute_code(code_str):\n    # This is a dictionary to hold the global variables for the exec call.\n    # It's populated with the provided game state variables.\n    safe_globals = {\n        'map_xml_string': map_xml_string,\n        'world_knowledge_graph_json_string': world_knowledge_graph_json_string,\n        'input_data': input_data,\n        'json': json,\n        'sys': sys\n    }\n    try:\n        exec(code_str, safe_globals)\n    except Exception as e:\n        print(f\"Error executing code: {e}\", file=sys.stderr)\n\n# The input_data dictionary holds the arguments passed to the tool.\n# We expect a 'code' key with the Python code string to execute.\nif 'code' in input_data:\n    execute_code(input_data['code'])\nelse:\n    print(\"Error: 'code' argument not provided.\", file=sys.stderr)"
  }
}