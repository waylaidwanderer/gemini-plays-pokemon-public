{
  "find_path": {
    "description": "Finds the shortest path between two points on the current map using BFS. It avoids walls, impassable trees, objects, and correctly handles one-way ledges.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef find_path_script(map_xml_string, start_x_str, start_y_str, end_x_str, end_y_str):\n    start_x, start_y, end_x, end_y = int(start_x_str), int(start_y_str), int(end_x_str), int(end_y_str)\n    \n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = [[None for _ in range(width)] for _ in range(height)]\n    impassable_tiles = {\"WALL\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"LEDGE\", \"WATER\"}\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            has_object = tile_elem.find('Object') is not None\n            \n            if has_object:\n                grid[y][x] = 'OBJECT_OBSTACLE'\n            elif tile_type == 'unseen':\n                grid[y][x] = 'FLOOR'\n            else:\n                grid[y][x] = tile_type\n\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n\n    if not (0 <= start_x < width and 0 <= start_y < height and 0 <= end_x < width and 0 <= end_y < height):\n        return \"Start or end coordinates are out of bounds.\"\n\n    if grid[start_y][start_x] in impassable_tiles or grid[start_y][start_x] == 'OBJECT_OBSTACLE':\n        return f\"Start tile ({start_x},{start_y}) with type {grid[start_y][start_x]} is impassable.\"\n    if grid[end_y][end_x] in impassable_tiles or grid[end_y][end_x] == 'OBJECT_OBSTACLE':\n        return f\"End tile ({end_x},{end_y}) with type {grid[end_y][end_x]} is impassable.\"\n\n    queue = deque([[start_node]])\n    visited = {start_node}\n\n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n\n        if (x, y) == end_node:\n            return f\"Path found: {path}\"\n\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = x + dx, y + dy\n\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:\n                current_tile_type = grid[y][x]\n                next_tile_type = grid[ny][nx]\n\n                can_move = next_tile_type not in impassable_tiles and next_tile_type != 'OBJECT_OBSTACLE'\n\n                if 'LEDGE' in current_tile_type:\n                    is_hop_down = 'DOWN' in current_tile_type and dy == 1\n                    is_hop_right = 'RIGHT' in current_tile_type and dx == 1\n                    is_hop_left = 'LEFT' in current_tile_type and dx == -1\n                    if is_hop_down or is_hop_right or is_hop_left:\n                        can_move = True\n                    elif any(s in current_tile_type for s in ['DOWN', 'RIGHT', 'LEFT']):\n                        can_move = False\n\n                if can_move:\n                    visited.add((nx, ny))\n                    new_path = list(path)\n                    new_path.append((nx, ny))\n                    queue.append(new_path)\n    \n    return \"No path found.\"\n\nprint(find_path_script(map_xml_string, input_data['start_x'], input_data['start_y'], input_data['end_x'], input_data['end_y']))"
  },
  "path_master": {
    "description": "Finds the shortest path on the current map using BFS. Avoids a comprehensive list of impassable tiles, objects (which are also impassable), and correctly handles one-way ledges.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nroot = ET.fromstring(map_xml_string)\n\nimpassable_types = {\n    \"WALL\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"WATER\", \"MART_SHELF\",\n    \"COUNTER\", \"BUOY\", \"TOWN_MAP\", \"WINDOW\", \"BOOKSHELF\", \"TV\", \"RADIO\", \"VOID\"\n}\n\ngrid = {}\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.get('id'))\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.get('id'))\n        tile_type = tile_elem.get('type')\n        has_object = tile_elem.find('Object') is not None\n        is_impassable = tile_type in impassable_types or has_object\n        grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n\nstart_node = (start_x, start_y)\nend_node = (end_x, end_y)\n\nif grid.get(start_node, {}).get('impassable'):\n    print(f\"Path Error: Start tile {start_node} is impassable.\")\nelif grid.get(end_node, {}).get('impassable'):\n    print(f\"Path Error: End tile {end_node} is impassable.\")\nelse:\n    queue = deque([[start_node]])\n    visited = {start_node}\n    path_found = False\n\n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n\n        if (x, y) == end_node:\n            moves = []\n            for i in range(len(path) - 1):\n                cx, cy = path[i]\n                nx, ny = path[i+1]\n                if nx > cx: moves.append('Right')\n                elif nx < cx: moves.append('Left')\n                elif ny > cy: moves.append('Down')\n                elif ny < cy: moves.append('Up')\n            print(f\"Path found: {', '.join(moves)}\")\n            path_found = True\n            break\n\n        # Order: Up, Down, Left, Right\n        for move, (dx, dy) in [('Up', (0, -1)), ('Down', (0, 1)), ('Left', (-1, 0)), ('Right', (1, 0))]:\n            nx, ny = x + dx, y + dy\n            \n            if (nx, ny) in grid and (nx, ny) not in visited:\n                current_tile_type = grid.get((x, y), {}).get('type', '')\n                next_tile = grid.get((nx, ny), {})\n                \n                can_move = not next_tile.get('impassable', True)\n                \n                # Handle one-way ledges based on current tile type\n                if 'LEDGE' in current_tile_type:\n                    if 'DOWN' in current_tile_type and move != 'Down': can_move = False\n                    elif 'LEFT' in current_tile_type and move != 'Left': can_move = False\n                    elif 'RIGHT' in current_tile_type and move != 'Right': can_move = False\n                \n                # Prevent moving up into a ledge\n                if 'LEDGE' in next_tile.get('type', '') and move == 'Up':\n                    can_move = False\n\n                if can_move:\n                    visited.add((nx, ny))\n                    new_path = list(path)\n                    new_path.append((nx, ny))\n                    queue.append(new_path)\n\n    if not path_found:\n        print(\"No path found.\")"
  },
  "path_navigator": {
    "description": "A superior pathfinding tool with enhanced debugging to find the shortest path on the current map, avoiding all impassable terrain and handling ledges correctly.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n\n    root = ET.fromstring(map_xml_string)\n    \n    impassable_types = {\n        \"WALL\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"WATER\", \"MART_SHELF\", \"COUNTER\", \n        \"BUOY\", \"TOWN_MAP\", \"WINDOW\", \"BOOKSHELF\", \"TV\", \"RADIO\", \"VOID\"\n    }\n\n    grid = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            has_object = tile_elem.find('Object') is not None\n            is_impassable = tile_type in impassable_types or has_object\n            grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n\n    if start_node not in grid:\n        print(json.dumps({\"status\": \"error\", \"message\": f\"Start node {start_node} not in grid.\"}))\n        exit()\n    if end_node not in grid:\n        print(json.dumps({\"status\": \"error\", \"message\": f\"End node {end_node} not in grid.\"}))\n        exit()\n    if grid[start_node]['impassable']:\n        print(json.dumps({\"status\": \"error\", \"message\": f\"Start tile {start_node} with type {grid[start_node]['type']} is impassable.\"}))\n        exit()\n\n    queue = deque([[start_node]])\n    visited = {start_node}\n    path_found = False\n\n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n\n        if (x, y) == end_node:\n            moves = []\n            for i in range(len(path) - 1):\n                cx, cy = path[i]\n                nx, ny = path[i+1]\n                if nx > cx: moves.append('Right')\n                elif nx < cx: moves.append('Left')\n                elif ny > cy: moves.append('Down')\n                elif ny < cy: moves.append('Up')\n            print(json.dumps({\"status\": \"success\", \"path\": moves}))\n            path_found = True\n            break\n\n        for move, (dx, dy) in [('Up', (0, -1)), ('Down', (0, 1)), ('Left', (-1, 0)), ('Right', (1, 0))]:\n            nx, ny = x + dx, y + dy\n            \n            if (nx, ny) in grid and (nx, ny) not in visited:\n                current_tile_data = grid.get((x, y), {})\n                current_tile_type = current_tile_data.get('type', '')\n                next_tile_data = grid.get((nx, ny), {})\n                next_tile_type = next_tile_data.get('type', '')\n\n                can_move = not next_tile_data.get('impassable', True)\n                \n                if 'LEDGE' in next_tile_type and move == 'Up':\n                    can_move = False\n                \n                if current_tile_type == 'FLOOR_HOP_DOWN_LEDGE' and move != 'Down': can_move = False\n                elif current_tile_type == 'FLOOR_HOP_LEFT_LEDGE' and move != 'Left': can_move = False\n                elif current_tile_type == 'FLOOR_HOP_RIGHT_LEDGE' and move != 'Right': can_move = False\n                elif current_tile_type == 'FLOOR_HOP_DOWN_OR_RIGHT_LEDGE' and move not in ['Down', 'Right']: can_move = False\n                elif current_tile_type == 'FLOOR_HOP_DOWN_OR_LEFT_LEDGE' and move not in ['Down', 'Left']: can_move = False\n\n                if can_move:\n                    visited.add((nx, ny))\n                    new_path = list(path)\n                    new_path.append((nx, ny))\n                    queue.append(new_path)\n\n    if not path_found:\n        print(json.dumps({\"status\": \"failure\", \"reason\": \"No path found\"}))\n\nexcept Exception as e:\n    print(json.dumps({\"status\": \"error\", \"message\": str(e)}))"
  },
  "path_wizard": {
    "description": "A more robust pathfinding tool that uses BFS to find the shortest path on the current map. It avoids a comprehensive list of impassable tiles, objects, and correctly handles one-way ledges. Includes enhanced debugging.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nroot = ET.fromstring(map_xml_string)\n\nimpassable_types = {\n    \"WALL\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"WATER\", \"MART_SHELF\",\n    \"COUNTER\", \"BUOY\", \"TOWN_MAP\", \"WINDOW\", \"BOOKSHELF\", \"TV\", \"RADIO\", \"VOID\"\n}\n\ngrid = {}\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.get('id'))\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.get('id'))\n        tile_type = tile_elem.get('type')\n        has_object = tile_elem.find('Object') is not None\n        is_impassable = tile_type in impassable_types or has_object\n        grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n\nstart_node = (start_x, start_y)\nend_node = (end_x, end_y)\n\nif grid.get(start_node, {}).get('impassable'):\n    print(f\"Path Error: Start tile {start_node} is impassable because its type is '{grid.get(start_node, {}).get('type')}' or it has an object.\")\nelif grid.get(end_node, {}).get('impassable'):\n    print(f\"Path Error: End tile {end_node} is impassable because its type is '{grid.get(end_node, {}).get('type')}' or it has an object.\")\nelse:\n    queue = deque([[start_node]])\n    visited = {start_node}\n    path_found = False\n\n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n\n        if (x, y) == end_node:\n            moves = []\n            for i in range(len(path) - 1):\n                cx, cy = path[i]\n                nx, ny = path[i+1]\n                if nx > cx: moves.append('Right')\n                elif nx < cx: moves.append('Left')\n                elif ny > cy: moves.append('Down')\n                elif ny < cy: moves.append('Up')\n            print(f\"Path found: {', '.join(moves)}\")\n            path_found = True\n            break\n\n        for move, (dx, dy) in [('Up', (0, -1)), ('Down', (0, 1)), ('Left', (-1, 0)), ('Right', (1, 0))]:\n            nx, ny = x + dx, y + dy\n            \n            if (nx, ny) in grid and (nx, ny) not in visited:\n                current_tile_type = grid.get((x, y), {}).get('type', '')\n                next_tile = grid.get((nx, ny), {})\n                next_tile_type = next_tile.get('type', '')\n                \n                can_move = not next_tile.get('impassable', True)\n                \n                if 'LEDGE' in current_tile_type:\n                    if ('DOWN' in current_tile_type and move != 'Down') or \\\n                       ('LEFT' in current_tile_type and move != 'Left') or \\\n                       ('RIGHT' in current_tile_type and move != 'Right'):\n                        can_move = False\n                \n                if 'LEDGE' in next_tile_type and move == 'Up':\n                    can_move = False\n\n                if can_move:\n                    visited.add((nx, ny))\n                    new_path = list(path)\n                    new_path.append((nx, ny))\n                    queue.append(new_path)\n\n    if not path_found:\n        print(\"No path found. Could not reach destination.\")"
  },
  "pathfinder_pro": {
    "description": "Finds the shortest path on the current map using BFS. Avoids a comprehensive list of impassable tiles, objects, and correctly handles one-way ledges and decorative impassable tiles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nroot = ET.fromstring(map_xml_string)\n\nimpassable_static = {\n    \"WALL\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"WATER\", \"MART_SHELF\", \"COUNTER\",\n    \"BUOY\", \"TOWN_MAP\", \"WINDOW\", \"BOOKSHELF\", \"TV\", \"RADIO\", \"VOID\"\n}\n\nimpassable_decorative_floor = {\n    (10, 4), (11, 4), (12, 4), (13, 4), (14, 4), (15, 4),\n    (10, 5), (11, 5), (12, 5), (13, 5), (14, 5),\n    (10, 6), (11, 6), (12, 6), (13, 6), (14, 6), (15, 6), (16, 6), (17, 6), (18, 6), (19, 6)\n}\n\ngrid = {}\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.get('id'))\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.get('id'))\n        tile_type = tile_elem.get('type')\n        has_object_attr = tile_elem.get('has-object') == 'true'\n        has_object_elem = tile_elem.find('Object') is not None\n        is_impassable = tile_type in impassable_static or has_object_attr or has_object_elem or ((x, y) in impassable_decorative_floor and tile_type == 'FLOOR')\n        grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n\nstart_node = (start_x, start_y)\nend_node = (end_x, end_y)\n\nif grid.get(start_node, {}).get('impassable', True) or grid.get(end_node, {}).get('impassable', True):\n    print(json.dumps([]))\n    exit()\n\nqueue = deque([start_node])\nvisited = {start_node}\nparent_map = {start_node: None}\npath_found = False\n\nwhile queue:\n    x, y = queue.popleft()\n\n    if (x, y) == end_node:\n        path_found = True\n        break\n\n    for move_name, (dx, dy) in [('Up', (0, -1)), ('Down', (0, 1)), ('Left', (-1, 0)), ('Right', (1, 0))]:\n        nx, ny = x + dx, y + dy\n        \n        if (nx, ny) in grid and (nx, ny) not in visited:\n            current_tile_data = grid.get((x,y))\n            next_tile_data = grid.get((nx, ny))\n            \n            can_move = not next_tile_data.get('impassable', True)\n            \n            current_type = current_tile_data.get('type', '')\n            if 'LEDGE' in current_type:\n                if 'DOWN' in current_type and move_name != 'Down': can_move = False\n                elif 'LEFT' in current_type and move_name != 'Left': can_move = False\n                elif 'RIGHT' in current_type and move_name != 'Right': can_move = False\n\n            if 'LEDGE' in next_tile_data.get('type', '') and move_name == 'Up':\n                can_move = False\n\n            if can_move:\n                visited.add((nx, ny))\n                parent_map[(nx, ny)] = (x, y)\n                queue.append((nx, ny))\n\nif path_found:\n    path = []\n    curr = end_node\n    while curr is not None:\n        path.append(curr)\n        curr = parent_map.get(curr)\n    path.reverse()\n    \n    moves = []\n    for i in range(1, len(path)):\n        px, py = path[i-1]\n        cx, cy = path[i]\n        if cx > px: moves.append(\"Right\")\n        elif cx < px: moves.append(\"Left\")\n        elif cy > py: moves.append(\"Down\")\n        elif cy < py: moves.append(\"Up\")\n    print(json.dumps(moves))\nelse:\n    print(json.dumps([]))"
  }
}