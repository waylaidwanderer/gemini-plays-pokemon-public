{
  "boulder_puzzle_solver": {
    "description": "Analyzes the map XML for a boulder puzzle and provides a step-by-step solution. This version includes A* pathfinding to ensure the player can reach the boulders before attempting a push. It correctly handles puzzles with more boulders than switches, includes an iteration limit, and validates that the player can reach the exact push position. **This version now correctly checks for the SURF HM and allows the player pathfinding to traverse water tiles AND handles elevation changes via steps tiles.**",
    "input_schema": {
      "type": "object",
      "properties": {
        "boulder_coords": {
          "type": "string"
        },
        "switch_coords": {
          "type": "string"
        },
        "party_data": {
          "type": "string"
        }
      },
      "required": [
        "boulder_coords",
        "switch_coords",
        "party_data"
      ]
    },
    "python_script": "import heapq\nimport json\nimport xml.etree.ElementTree as ET\nfrom itertools import permutations\n\ndef parse_party_data(party_data_str):\n    try:\n        party_data = json.loads(party_data_str)\n        hms_known = set()\n        for pokemon in party_data:\n            if not isinstance(pokemon, dict): continue\n            for move in pokemon.get('moves', []):\n                if isinstance(move, dict):\n                    move_name = move.get('name', '').upper()\n                    if move_name == 'SURF': hms_known.add('surf')\n        return hms_known\n    except (json.JSONDecodeError, TypeError): return set()\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star(start, goal, grid_data):\n    walls, water_tiles, ledges, ground_tiles, elevated_ground_tiles, steps_tiles, hms, map_width, map_height = grid_data\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {start: 0}\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n        if current == goal: return reconstruct_path(came_from, current)\n\n        neighbors = [(current[0] + dx, current[1] + dy) for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]]\n        if current in ledges: neighbors.append((current[0], current[1] + 1))\n\n        for neighbor in neighbors:\n            if not (1 <= neighbor[0] <= map_width and 1 <= neighbor[1] <= map_height): continue\n            if neighbor in ledges and current[1] != neighbor[1] - 1: continue\n            \n            is_invalid_elevation_change = False\n            if (current in elevated_ground_tiles and neighbor in ground_tiles) or (current in ground_tiles and neighbor in elevated_ground_tiles):\n                if neighbor not in steps_tiles and current not in steps_tiles: is_invalid_elevation_change = True\n            \n            if neighbor in walls or (neighbor in water_tiles and 'surf' not in hms) or is_invalid_elevation_change: continue\n\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                heapq.heappush(open_set, (tentative_g_score + heuristic(neighbor, goal), neighbor))\n    return None\n\ndef reconstruct_path(came_from, current):\n    path = []\n    while current in came_from: path.append(current); current = came_from[current]\n    return path[::-1]\n\ndef solve_puzzle(player_start, boulders, switches, grid_data, max_iterations=5000):\n    initial_state = (player_start, tuple(sorted(boulders)))\n    queue = [(0, [('start', player_start)], initial_state)]\n    visited = {initial_state}\n    iteration_count = 0\n\n    while queue:\n        iteration_count += 1\n        if iteration_count > max_iterations: return {'error': 'Iteration limit exceeded.'}\n        \n        _, history, current_state = heapq.heappop(queue)\n        player_pos, current_boulders = current_state\n\n        if set(current_boulders) == set(switches): return {'solution': history[1:]}\n\n        for i, boulder in enumerate(current_boulders):\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                push_pos = (boulder[0] - dx, boulder[1] - dy)\n                target_pos = (boulder[0] + dx, boulder[1] + dy)\n\n                temp_walls = grid_data[0].union(set(current_boulders) - {boulder})\n                path_to_push = a_star(player_pos, push_pos, (temp_walls, *grid_data[1:]))\n\n                if path_to_push and target_pos not in temp_walls and target_pos not in grid_data[1]:\n                    new_boulders = list(current_boulders)\n                    new_boulders[i] = target_pos\n                    new_boulders_tuple = tuple(sorted(new_boulders))\n                    new_state = (boulder, new_boulders_tuple)\n\n                    if new_state not in visited:\n                        visited.add(new_state)\n                        new_history = history + [('push', boulder, target_pos)]\n                        priority = len(new_history) + sum(min(heuristic(b, s) for s in switches) for b in new_boulders)\n                        heapq.heappush(queue, (priority, new_history, new_state))\n    return {'error': 'No solution found.'}\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.get('width'))\n    map_height = int(root.get('height'))\n    player_pos = None\n    walls, water_tiles, ledges, ground_tiles, elevated_ground_tiles, steps_tiles = set(), set(), set(), set(), set(), set()\n\n    for tile in root.findall('.//Tile'):\n        x, y = int(tile.get('id')), int(tile.get('coordinate').split(',')[1].strip(')'))\n        tile_type = tile.get('type')\n        if tile.find('Player') is not None: player_pos = (x, y)\n        if tile_type in ['impassable', 'boulder_barrier', 'closed_gate', 'unknown'] or (tile.find('Object') and tile.find('Object').get('id-name') != 'Pikachu'): walls.add((x,y))\n        elif tile_type == 'water': water_tiles.add((x,y))\n        elif tile_type == 'ledge': ledges.add((x,y))\n        elif tile_type == 'ground': ground_tiles.add((x,y))\n        elif tile_type == 'elevated_ground': elevated_ground_tiles.add((x,y))\n        elif tile_type == 'steps': steps_tiles.add((x,y))\n\n    hms = parse_party_data(input_data['party_data'])\n    boulders = [tuple(map(int, b.split(','))) for b in json.loads(input_data['boulder_coords'])]\n    switches = [tuple(map(int, s.split(','))) for s in json.loads(input_data['switch_coords'])]\n    \n    grid_data = (walls, water_tiles, ledges, ground_tiles, elevated_ground_tiles, steps_tiles, hms, map_width, map_height)\n    \n    if not player_pos: raise ValueError('Player position not found.')\n\n    solution = solve_puzzle(player_pos, boulders, switches, grid_data)\n    print(json.dumps(solution))\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))"
  },
  "find_closest_unseen_tile": {
    "description": "Finds the closest reachable unseen tile and a reachable adjacent tile to pathfind to. This version uses a more robust traversal logic that correctly handles non-adjacent traversals like warps and ladders.",
    "input_schema": {
      "type": "object",
      "properties": {
        "party_data": {
          "type": "string"
        }
      },
      "required": [
        "party_data"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport collections\nimport heapq\n\ndef parse_party_data(party_data_str):\n    try:\n        party_data = json.loads(party_data_str)\n        hms_known = set()\n        for pokemon in party_data:\n            for move in pokemon.get('moves', []):\n                if isinstance(move, dict):\n                    move_name = move.get('name', '').upper()\n                    if move_name == 'CUT':\n                        hms_known.add('cut')\n                    elif move_name == 'SURF':\n                        hms_known.add('surf')\n        return hms_known\n    except (json.JSONDecodeError, TypeError):\n        return set()\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(start, goal, walls, map_width, map_height, hms_known, water_tiles, cut_trees, ledges):\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {start: 0}\n    f_score = {start: heuristic(start, goal)}\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == goal:\n            return True # Path found\n\n        if current in ledges:\n            neighbors = [(current[0], current[1] + 1)]\n        else:\n            neighbors = [(current[0] + dx, current[1] + dy) for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]]\n\n        for neighbor in neighbors:\n            if not (1 <= neighbor[0] <= map_width and 1 <= neighbor[1] <= map_height):\n                continue\n\n            if neighbor in ledges and current[1] != neighbor[1] - 1:\n                continue\n\n            tentative_g_score = g_score[current] + 1\n\n            if tentative_g_score >= g_score.get(neighbor, float('inf')):\n                continue\n\n            if neighbor in walls or (neighbor in cut_trees and 'cut' not in hms_known) or (neighbor in water_tiles and 'surf' not in hms_known):\n                continue\n\n            came_from[neighbor] = current\n            g_score[neighbor] = tentative_g_score\n            f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n            heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    return False # No path found\n\ntry:\n    party_data_str = input_data['party_data']\n    hms = parse_party_data(party_data_str)\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.attrib['width'])\n    map_height = int(root.attrib['height'])\n\n    player_pos = None\n    unseen_tiles = []\n    walls = set()\n    water_tiles = set()\n    cut_trees = set()\n    ledges = set()\n\n    for tile in root.findall('.//Tile'):\n        x, y = int(tile.get('id')), int(tile.get('coordinate').split(',')[1].strip(')'))\n        tile_type = tile.get('type')\n\n        if tile.get('seen') != 'true':\n            unseen_tiles.append((x, y))\n        if tile.find('Player') is not None:\n            player_pos = (x, y)\n        \n        impassable_types = ['impassable', 'boulder_barrier', 'closed_gate', 'unknown']\n        obj = tile.find('Object')\n        is_impassable_obj = obj is not None and obj.get('id-name') != 'Pikachu'\n        if tile_type in impassable_types or is_impassable_obj:\n            walls.add((x, y))\n        elif tile_type == 'water':\n            water_tiles.add((x, y))\n        elif tile_type == 'cuttable':\n            cut_trees.add((x, y))\n        elif tile_type == 'ledge':\n            ledges.add((x, y))\n\n    if not player_pos:\n        print(json.dumps({'error': 'Player not found.'}))\n    else:\n        reachable_unseen = []\n        for ux, uy in unseen_tiles:\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adj_tile = (ux + dx, uy + dy)\n                if not (1 <= adj_tile[0] <= map_width and 1 <= adj_tile[1] <= map_height):\n                    continue\n                if adj_tile in walls or adj_tile in unseen_tiles:\n                    continue\n                \n                if a_star_search(player_pos, adj_tile, walls, map_width, map_height, hms, water_tiles, cut_trees, ledges):\n                    dist = heuristic(player_pos, adj_tile)\n                    reachable_unseen.append({'unseen': (ux, uy), 'adj': adj_tile, 'dist': dist})\n                    break\n\n        if not reachable_unseen:\n            print(json.dumps({'message': 'No reachable unseen tiles found.'}))\n        else:\n            closest = min(reachable_unseen, key=lambda x: x['dist'])\n            print(json.dumps({\n                'closest_reachable_unseen_tile': {'x': closest['unseen'][0], 'y': closest['unseen'][1]},\n                'adjacent_tile': {'x': closest['adj'][0], 'y': closest['adj'][1]}\n            }))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))"
  },
  "robust_pathfinder": {
    "description": "A more robust A* pathfinding tool that can be told to avoid specific 'hazard' coordinates. This version includes corrected ledge traversal logic and accounts for the player's movement state (walking vs. surfing).",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "party_data": {
          "type": "string"
        },
        "movement_state": {
          "type": "string"
        },
        "hazard_coords": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "target_x",
        "target_y",
        "party_data",
        "movement_state"
      ]
    },
    "python_script": "\nimport heapq\nimport xml.etree.ElementTree as ET\nimport json\n\ndef parse_party_data(party_data_str):\n    try:\n        party_data = json.loads(party_data_str)\n        hms_known = set()\n        for pokemon in party_data:\n            if not isinstance(pokemon, dict):\n                continue\n            for move in pokemon.get('moves', []):\n                if isinstance(move, dict):\n                    move_name = move.get('name', '').upper()\n                    if move_name == 'CUT':\n                        hms_known.add('cut')\n                    elif move_name == 'SURF':\n                        hms_known.add('surf')\n                    elif move_name == 'STRENGTH':\n                        hms_known.add('strength')\n        return hms_known\n    except (json.JSONDecodeError, TypeError):\n        return set()\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(start, goal, walls, map_width, map_height, hms_known, water_tiles, cut_trees, ledges, movement_state, ground_tiles, elevated_ground_tiles, steps_tiles):\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {start: 0}\n    f_score = {start: heuristic(start, goal)}\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            return path[::-1]\n\n        if current in ledges:\n            neighbors = [(current[0], current[1] + 1)]\n        else:\n            neighbors = [(current[0] + dx, current[1] + dy) for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]]\n\n        for neighbor in neighbors:\n            if not (1 <= neighbor[0] <= map_width and 1 <= neighbor[1] <= map_height):\n                continue\n\n            if neighbor in ledges and current[1] != neighbor[1] - 1:\n                continue\n\n            is_invalid_elevation_change = False\n            if (current in elevated_ground_tiles and neighbor in ground_tiles) or \\\n               (current in ground_tiles and neighbor in elevated_ground_tiles):\n                if neighbor not in steps_tiles and current not in steps_tiles:\n                    is_invalid_elevation_change = True\n\n            tentative_g_score = g_score[current] + 1\n\n            if tentative_g_score >= g_score.get(neighbor, float('inf')):\n                continue\n\n            is_water_impassable = (neighbor in water_tiles and movement_state == 'walking')\n            if neighbor in walls or (neighbor in cut_trees and 'cut' not in hms_known) or is_water_impassable or is_invalid_elevation_change:\n                continue\n\n            came_from[neighbor] = current\n            g_score[neighbor] = tentative_g_score\n            f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n            heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    return None\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.get('width'))\n    map_height = int(root.get('height'))\n    \n    player_pos = None\n    walls = set()\n    water_tiles = set()\n    cut_trees = set()\n    ledges = set()\n    ground_tiles = set()\n    elevated_ground_tiles = set()\n    steps_tiles = set()\n\n    for tile in root.findall('.//Tile'):\n        x_str = tile.get('id')\n        y_str_part = tile.get('coordinate').split(',')\n        if len(y_str_part) < 2:\n            continue\n        y_str = y_str_part[1].strip(')')\n        if not x_str or not y_str:\n            continue\n        x, y = int(x_str), int(y_str)\n        tile_type = tile.get('type')\n        \n        if tile.find('Player') is not None:\n            player_pos = (x, y)\n        \n        impassable_types = ['impassable', 'boulder_barrier', 'closed_gate', 'unknown']\n        obj = tile.find('Object')\n        is_impassable_obj = obj is not None and obj.get('id-name') != 'Pikachu'\n        if tile_type in impassable_types or is_impassable_obj:\n            walls.add((x, y))\n        elif tile_type == 'water':\n            water_tiles.add((x, y))\n        elif tile_type == 'cuttable':\n            cut_trees.add((x, y))\n        elif tile_type == 'ledge':\n            ledges.add((x,y))\n        elif tile_type == 'ground':\n            ground_tiles.add((x, y))\n        elif tile_type == 'elevated_ground':\n            elevated_ground_tiles.add((x, y))\n        elif tile_type == 'steps':\n            steps_tiles.add((x, y))\n\n    if 'hazard_coords' in input_data and input_data['hazard_coords']:\n        try:\n            hazards = json.loads(input_data['hazard_coords'])\n            for hx, hy in hazards:\n                walls.add((int(hx), int(hy)))\n        except (json.JSONDecodeError, ValueError, TypeError):\n            pass\n\n    start_pos = player_pos\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    goal_pos = (target_x, target_y)\n    \n    party_data_str = input_data.get('party_data', '[]')\n    hms = parse_party_data(party_data_str)\n    movement_state = input_data.get('movement_state', 'walking')\n\n    if not start_pos:\n        print(json.dumps({'error': 'Player position not found in map data.'}))\n    else:\n        path = a_star_search(start_pos, goal_pos, walls, map_width, map_height, hms, water_tiles, cut_trees, ledges, movement_state, ground_tiles, elevated_ground_tiles, steps_tiles)\n        if path:\n            final_path = []\n            i = 0\n            while i < len(path):\n                current_tile = path[i]\n                final_path.append(current_tile)\n                if current_tile in ledges and i > 0:\n                    if i + 1 < len(path):\n                        next_tile_on_path = path[i+1]\n                        if next_tile_on_path[0] == current_tile[0] and next_tile_on_path[1] == current_tile[1] + 1:\n                             i += 1\n                i += 1\n            print(json.dumps(final_path))\n        else:\n            print(json.dumps({'error': 'No path found.'}))\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))\n"
  }
}