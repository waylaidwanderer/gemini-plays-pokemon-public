{
  "check_reachability": {
    "description": "Determines which of the provided target coordinates are reachable from the current position using BFS. Useful for filtering lists of potential exploration targets. Returns a JSON list of reachable target objects.",
    "input_schema": {
      "type": "object",
      "properties": {
        "targets": {
          "type": "string",
          "description": "A JSON string representing a list of target objects, e.g. '[{\"x\": 1, \"y\": 2}]'"
        },
        "current_x": {
          "type": "integer"
        },
        "current_y": {
          "type": "integer"
        }
      },
      "required": [
        "targets",
        "current_x",
        "current_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\n# Parse inputs\ntargets = json.loads(input_data['targets'])\nstart_x = int(input_data['current_x'])\nstart_y = int(input_data['current_y'])\n\nroot = ET.fromstring(map_xml_string)\n\n# Build grid of passable tiles\ngrid = set()\nimpassable_types = {'WALL', 'HEADBUTT_TREE', 'WATER', 'DOOR', 'PC', 'TV', 'WINDOW', 'BOOKSHELF', 'VOID'}\n\nfor row in root.findall('Row'):\n    y = int(row.attrib['id'])\n    for tile in row.findall('Tile'):\n        x = int(tile.attrib['id'])\n        t_type = tile.attrib.get('type', 'WALL')\n        has_object = tile.attrib.get('has-object', 'false') == 'true'\n        \n        # Basic passability check\n        if t_type not in impassable_types and not has_object:\n            grid.add((x, y))\n\n# BFS to find all reachable tiles from start\nqueue = [(start_x, start_y)]\nvisited = {(start_x, start_y)}\n\nwhile queue:\n    curr_x, curr_y = queue.pop(0)\n    \n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nx, ny = curr_x + dx, curr_y + dy\n        if (nx, ny) in grid and (nx, ny) not in visited:\n            visited.add((nx, ny))\n            queue.append((nx, ny))\n\n# Filter targets\nreachable_targets = []\ntarget_set = {(t['x'], t['y']) for t in targets}\n\nfor t in targets:\n    if (t['x'], t['y']) in visited:\n        reachable_targets.append(t)\n\nprint(json.dumps(reachable_targets))",
    "history": [
      {
        "commit_message": "feat: Add check_reachability tool to filter target coordinates based on map accessibility.",
        "timestamp": "2025-11-14T07:46:43.297Z",
        "action_counter": 260
      }
    ]
  },
  "find_nearest_unseen": {
    "description": "Scans the map for 'unseen' tiles and uses BFS to find the nearest one that is reachable from the player's current position. Returns the coordinate of the target tile, or null if none are reachable.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.attrib['width'])\nheight = int(root.attrib['height'])\n\ngrid = {}\nunseen_tiles = set()\nstart_pos = None\n\nfor row in root.findall('Row'):\n    y = int(row.attrib['id'])\n    for tile in row.findall('Tile'):\n        x = int(tile.attrib['id'])\n        tile_type = tile.attrib.get('type', 'WALL')\n        is_unseen = tile.attrib.get('type') == 'unseen'\n        has_object = tile.attrib.get('has-object', 'false') == 'true'\n        \n        # Player position\n        if tile.find('Player') is not None:\n            start_pos = (x, y)\n            \n        # Passability (Allow walking on unseen for the purpose of 'finding' them)\n        # We consider unseen tiles as valid targets, so they are 'passable' for the *last* step\n        is_passable = (tile_type != 'WALL' and tile_type != 'VOID' and not has_object)\n        \n        grid[(x, y)] = is_passable\n        if is_unseen:\n            unseen_tiles.add((x, y))\n            grid[(x, y)] = True # Unseen tiles are potentially passable targets\n\nif start_pos is None:\n    print(json.dumps(None))\n    exit()\n\n# BFS\nqueue = [[start_pos]]\nvisited = {start_pos}\n\nwhile queue:\n    path = queue.pop(0)\n    current = path[-1]\n    \n    if current in unseen_tiles:\n        print(json.dumps({'x': current[0], 'y': current[1]}))\n        exit()\n    \n    neighbors = [\n        (current[0], current[1] - 1),\n        (current[0], current[1] + 1),\n        (current[0] - 1, current[1]),\n        (current[0] + 1, current[1])\n    ]\n    \n    for next_node in neighbors:\n        if next_node in grid and next_node not in visited:\n            if grid[next_node]:\n                visited.add(next_node)\n                new_path = list(path)\n                new_path.append(next_node)\n                queue.append(new_path)\n\nprint(json.dumps(None))",
    "history": [
      {
        "commit_message": "feat: Add find_nearest_unseen tool for automated exploration.",
        "timestamp": "2025-11-14T07:06:30.308Z",
        "action_counter": 207
      }
    ]
  },
  "find_path": {
    "description": "Finds a path from the player's current position to a target coordinate using BFS. Avoids Walls, Objects, Ledges, Water, and Trees.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string",
          "description": "Target X coordinate"
        },
        "target_y": {
          "type": "string",
          "description": "Target Y coordinate"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "# injected imports [\"sys\", \"json\"]\n# injected variables [\"map_xml_string\", \"input_data\"]\n\nimport xml.etree.ElementTree as ET\nimport json\n\ntarget_x = int(input_data['target_x'])\ntarget_y = int(input_data['target_y'])\n\nroot = ET.fromstring(map_xml_string)\n\n# Parse map to grid\ngrid = {}\nstart_pos = None\n\nfor row in root.findall('Row'):\n    y = int(row.attrib['id'])\n    for tile in row.findall('Tile'):\n        x = int(tile.attrib['id'])\n        tile_type = tile.attrib.get('type', 'WALL')\n        has_object = tile.attrib.get('has-object', 'false') == 'true'\n        \n        # Check for player\n        if tile.find('Player') is not None:\n            start_pos = (x, y)\n            \n        # Determine passability\n        # Explicitly adding tree types to obstacles\n        is_obstacle = (tile_type == 'WALL') or ('LEDGE' in tile_type) or (tile_type == 'WATER') or (tile_type == 'HEADBUTT_TREE') or (tile_type == 'CUT_TREE') or has_object\n        \n        # Store passability info. True = Passable, False = Impassable\n        grid[(x, y)] = not is_obstacle\n\nif start_pos is None:\n    print(json.dumps([]))\n    exit()\n\n# BFS\nqueue = [[start_pos]]\nvisited = {start_pos}\nfound_path = []\n\nwhile queue:\n    path = queue.pop(0)\n    current = path[-1]\n    \n    if current == (target_x, target_y):\n        found_path = path\n        break\n    \n    # Neighbors (Up, Down, Left, Right)\n    neighbors = [\n        (current[0], current[1] - 1),\n        (current[0], current[1] + 1),\n        (current[0] - 1, current[1]),\n        (current[0] + 1, current[1])\n    ]\n    \n    for next_node in neighbors:\n        if next_node in grid and next_node not in visited:\n            # We can move to the tile if it is passable OR if it is the final target (to bump/interact)\n            if grid[next_node] or next_node == (target_x, target_y):\n                visited.add(next_node)\n                new_path = list(path)\n                new_path.append(next_node)\n                queue.append(new_path)\n\n# Convert to required output format\noutput = []\nif found_path:\n    for p in found_path:\n        output.append({\"x\": p[0], \"y\": p[1]})\n\nprint(json.dumps(output))",
    "history": [
      {
        "commit_message": "feat: Initial implementation of find_path using BFS.",
        "timestamp": "2025-11-14T03:04:04.417Z",
        "action_counter": 47
      },
      {
        "commit_message": "feat: Initial implementation of find_path using BFS.",
        "timestamp": "2025-11-14T03:12:22.011Z",
        "action_counter": 55
      },
      {
        "commit_message": "fix: update find_path to treat LEDGE tiles as impassable obstacles to prevent invalid path generation (attempting to walk up ledges).",
        "timestamp": "2025-11-14T09:34:44.350Z",
        "action_counter": 373
      },
      {
        "commit_message": "fix: Add WATER to impassable tile types in find_path to prevent routing through ponds.",
        "timestamp": "2025-11-14T20:11:42.574Z",
        "action_counter": 451
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE and CUT_TREE to impassable tile types in find_path to prevent routing through trees.",
        "timestamp": "2025-11-14T20:32:52.236Z",
        "action_counter": 485
      }
    ]
  },
  "spam_button": {
    "description": "Generates a sequence of button presses to be executed automatically. Useful for mashing through text or menus. Can optionally include delays.",
    "input_schema": {
      "type": "object",
      "properties": {
        "button": {
          "type": "string",
          "enum": [
            "A",
            "B",
            "Start",
            "Select",
            "Up",
            "Down",
            "Left",
            "Right"
          ]
        },
        "times": {
          "type": "integer",
          "minimum": 1,
          "maximum": 20
        },
        "delay_ms": {
          "type": "integer",
          "default": 0,
          "maximum": 500
        }
      },
      "required": [
        "button",
        "times"
      ]
    },
    "python_script": "import json\nbutton = input_data['button']\ntimes = int(input_data['times'])\ndelay = int(input_data.get('delay_ms', 0))\n\npresses = []\nfor _ in range(times):\n    presses.append(button)\n    if delay > 0:\n        presses.append(f\"sleep {delay}\")\n\nprint(json.dumps(presses))",
    "history": [
      {
        "commit_message": "Initial definition of spam_button tool.",
        "timestamp": "2025-11-14T03:00:03.455Z",
        "action_counter": 42
      }
    ]
  },
  "type_text": {
    "description": "Generates the button sequence to type a given text string on the in-game keyboard. Assumes the standard Gen 2 keyboard layout (A-I, J-R, S-Z, symbols). Handles navigation between characters.",
    "input_schema": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string",
          "description": "The text to type."
        },
        "start_char": {
          "type": "string",
          "description": "The character the cursor is currently on. Default is 'A'."
        }
      },
      "required": [
        "text"
      ]
    },
    "python_script": "import json\n\ntext = input_data['text'].upper()\nstart_char = input_data.get('start_char', 'A').upper()\n\n# Keyboard layout mapping (Char -> (row, col))\nlayout = {}\nrows = [\n    \"ABCDEFGHI\",\n    \"JKLMNOPQR\",\n    \"STUVWXYZ \"\n]\n# Add letters\nfor r, row_str in enumerate(rows):\n    for c, char in enumerate(row_str):\n        if char != ' ':\n            layout[char] = (r, c)\n\n# Add special handling for other rows if needed, but focusing on letters for now\n# Current known layout covers A-Z.\n\nbuttons = []\ncurr_r, curr_c = layout.get(start_char, (0, 0))\n\nfor char in text:\n    if char not in layout:\n        continue # Skip unknown chars for now\n    \n    target_r, target_c = layout[char]\n    \n    # Vertical movement\n    dy = target_r - curr_r\n    if dy > 0:\n        buttons.extend(['Down'] * dy)\n    elif dy < 0:\n        buttons.extend(['Up'] * abs(dy))\n        \n    # Horizontal movement\n    dx = target_c - curr_c\n    if dx > 0:\n        buttons.extend(['Right'] * dx)\n    elif dx < 0:\n        buttons.extend(['Left'] * abs(dx))\n        \n    buttons.append('A')\n    curr_r, curr_c = target_r, target_c\n\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "feat: Add type_text tool to automate string entry on the keyboard grid.",
        "timestamp": "2025-11-14T22:08:22.338Z",
        "action_counter": 615
      }
    ]
  }
}