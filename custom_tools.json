{
  "unseen_tile_checker": {
    "description": "Analyzes the list of unseen tiles from a system alert and uses pathfinding logic to determine which are actually reachable from the player's current position.",
    "input_schema": {
      "type": "object",
      "properties": {
        "coordinates": {
          "type": "string",
          "description": "A stringified JSON array of coordinate objects, e.g., '[{\"x\":1,\"y\":2}]'"
        }
      },
      "required": [
        "coordinates"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\nimport json\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(start, goal, traversable, one_way_rules):\n    open_set = [(0 + heuristic(start, goal), 0, start)]\n    came_from = {}\n    g_score = {start: 0}\n\n    while open_set:\n        _, current_g, current_node = heapq.heappop(open_set)\n\n        if current_node == goal:\n            return True # Path found\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current_node[0] + dx, current_node[1] + dy)\n\n            if neighbor not in traversable and neighbor != goal: # Allow pathing to the goal even if it's not in the initial traversable set (e.g., unseen)\n                continue\n\n            if neighbor in one_way_rules:\n                allowed_from = one_way_rules[neighbor]\n                if (current_node[0] - neighbor[0], current_node[1] - neighbor[1]) != allowed_from:\n                    continue\n\n            tentative_g_score = current_g + 1\n\n            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                g_score[neighbor] = tentative_g_score\n                f_score = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_score, tentative_g_score, neighbor))\n                came_from[neighbor] = current_node\n\n    return False # No path found\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    player_x, player_y = -1, -1\n    traversable = set()\n    one_way_rules = {}\n\n    impassable_types = ['WALL', 'WINDOW', 'VOID', 'CUT_TREE', 'SIGN', 'BOOKSHELF', 'BLACKBOARD', 'MART_SHELF', 'BUOY', 'TV', 'TOWN_MAP', 'RADIO', 'INCENSE_BURNER', 'BIRD', 'HEADBUTT_TREE', 'FRUIT_TREE', 'COMPUTER', 'PRINTER', 'PC', 'COUNTER', 'CAVE']\n    one_way_types = {\n        'LEDGE_HOP_DOWN': (0, -1),\n        'LEDGE_HOP_LEFT': (1, 0),\n        'LEDGE_HOP_RIGHT': (-1, 0)\n    }\n\n    for row in root.findall('Row'):\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            y = int(row.get('id'))\n            tile_type = tile.get('type')\n\n            if tile.find('Player') is not None:\n                player_x, player_y = x, y\n\n            if tile_type not in impassable_types and tile.find('Object') is None:\n                traversable.add((x, y))\n                if tile_type in one_way_types:\n                    one_way_rules[(x, y)] = one_way_types[tile_type]\n\n    start_node = (player_x, player_y)\n    target_coordinates = json.loads(input_data['coordinates'])\n    reachable_tiles = []\n\n    if start_node == (-1, -1):\n        print('{\"error\": \"Player not found on the map.\"}')\n    else:\n        for coord in target_coordinates:\n            goal_node = (int(coord['x']), int(coord['y']))\n            if a_star_search(start_node, goal_node, traversable, one_way_rules):\n                reachable_tiles.append(coord)\n        print(json.dumps(reachable_tiles))\n\nexcept Exception as e:\n    print(f'{{\"error\": \"An unexpected error occurred in unseen_tile_checker: {str(e)}\"}}')\n",
    "history": [
      {
        "commit_message": "feat: Create unseen_tile_checker tool. This tool automates the process of checking which unseen tiles from a system alert are actually reachable, streamlining exploration and preventing wasted turns trying to path to disconnected areas.",
        "timestamp": "2025-07-29T03:31:55.070Z",
        "action_counter": 15144
      },
      {
        "commit_message": "feat: Create unseen_tile_checker tool. This tool automates the process of checking which unseen tiles from a system alert are actually reachable, streamlining exploration and preventing wasted turns trying to path to disconnected areas.",
        "timestamp": "2025-07-29T06:52:53.467Z",
        "action_counter": 15273
      }
    ]
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map using the A* algorithm, avoiding obstacles and impassable terrain.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nroot = ET.fromstring(map_xml_string)\n\nTRAVERSABLE_TILES = {\n    'FLOOR', 'TALL_GRASS', 'LONG_GRASS', 'DOOR', \n    'WARP_CARPET_DOWN', 'LADDER', 'WARP_CARPET_RIGHT', 'WARP_CARPET_LEFT',\n    'LEDGE_HOP_DOWN', 'LEDGE_HOP_RIGHT', 'LEDGE_HOP_LEFT'\n}\n\nONE_WAY_TILES = {\n    'LEDGE_HOP_DOWN': (0, 1),\n    'LEDGE_HOP_RIGHT': (-1, 0),\n    'LEDGE_HOP_LEFT': (1, 0)\n}\n\ndef is_traversable(x, y, from_x, from_y):\n    tile_element = root.find(f\".//Tile[@coordinate='({x}, {y})']\")\n    if tile_element is None:\n        return False\n\n    tile_type = tile_element.get('type')\n    if tile_element.find('Object') is not None or tile_element.find('Player') is not None:\n        if not (x == end_x and y == end_y):\n             return False\n\n    if tile_type in TRAVERSABLE_TILES:\n        # Check one-way tile logic\n        prev_tile_element = root.find(f\".//Tile[@coordinate='({from_x}, {from_y})']\")\n        if prev_tile_element is not None:\n            prev_tile_type = prev_tile_element.get('type')\n            if prev_tile_type in ONE_WAY_TILES:\n                allowed_move = ONE_WAY_TILES[prev_tile_type]\n                if (x - from_x, y - from_y) != allowed_move:\n                    return False # Trying to move incorrectly from a one-way tile\n\n        # Check special case for FLOOR_UP_WALL\n        if tile_type == 'FLOOR' and from_y > y: # moving up\n            target_tile_up = root.find(f\".//Tile[@coordinate='({x}, {y-1})']\")\n            if target_tile_up is not None and target_tile_up.get('type') == 'FLOOR_UP_WALL':\n                return False\n\n        return True\n    return False\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(start, end):\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {start: 0}\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == end:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            return path[::-1]\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if is_traversable(neighbor[0], neighbor[1], current[0], current[1]):\n                tentative_g_score = g_score[current] + 1\n                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                    g_score[neighbor] = tentative_g_score\n                    f_score = tentative_g_score + heuristic(neighbor, end)\n                    heapq.heappush(open_set, (f_score, neighbor))\n                    came_from[neighbor] = current\n    return None\n\nstart_node = (start_x, start_y)\nend_node = (end_x, end_y)\npath = a_star_search(start_node, end_node)\n\nif path:\n    print(f\"Path found: {path}\")\nelse:\n    print(\"No path found.\")",
    "history": [
      {
        "commit_message": "feat: Create robust pathfinder tool using A* algorithm. This tool is a direct response to repeated navigation failures and system critiques. It correctly handles known traversable and one-way tiles, and will serve as the foundation for all future movement, eliminating inefficient and error-prone manual pathing. This is a critical infrastructure upgrade.",
        "timestamp": "2025-07-29T09:27:18.707Z",
        "action_counter": 15399
      }
    ]
  }
}