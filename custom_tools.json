{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "gem_path_planner": {
    "description": "A custom pathfinding tool designed by Gem to be more robust than the default planner. It finds a path from a start to a target coordinate, avoiding impassable tiles and objects. This version correctly finds a path to a tile adjacent to an impassable target.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\n# --- Helper Functions ---\ndef parse_map_xml(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    grid = [['' for _ in range(width)] for _ in range(height)]\n    impassable = set()\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id')) - 1\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id')) - 1\n            tile_type = tile_elem.get('type')\n            grid[y][x] = tile_type\n            \n            is_impassable = tile_type in ['impassable', 'boulder_barrier', 'closed_gate', 'unknown']\n            has_blocking_object = tile_elem.find('Object') is not None and tile_elem.find('Object').get('id-name') != 'Pikachu'\n            \n            if is_impassable or has_blocking_object:\n                impassable.add((x + 1, y + 1))\n    return grid, impassable, width, height\n\ndef is_valid(x, y, width, height):\n    return 1 <= x <= width and 1 <= y <= height\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef get_neighbors(current_pos, grid, impassable, width, height):\n    x, y = current_pos\n    neighbors = []\n    for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n        nx, ny = x + dx, y + dy\n        if is_valid(nx, ny, width, height):\n            tile_type = grid[ny-1][nx-1]\n            # Ledge logic\n            if tile_type == 'ledge':\n                if dy == 1: # Moving down onto a ledge\n                    if is_valid(nx, ny + 1, width, height) and (nx, ny + 1) not in impassable:\n                        neighbors.append(((nx, ny + 1), move, 1))\n                # Otherwise, treat ledge as impassable from below/sides\n                continue\n            elif (nx, ny) not in impassable:\n                neighbors.append(((nx, ny), move, 1))\n    return neighbors\n\n# --- Main A* Algorithm ---\ndef a_star_search(start, target, grid, impassable, width, height):\n    target_is_impassable = target in impassable\n    \n    open_set = [(0, start)]\n    came_from = {}\n    g_score = {start: 0}\n    f_score = {start: heuristic(start, target)}\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        # Goal Check\n        if not target_is_impassable and current == target:\n            return reconstruct_path(came_from, current)\n        if target_is_impassable and heuristic(current, target) == 1:\n             return reconstruct_path(came_from, current)\n\n        for neighbor_pos, move, cost in get_neighbors(current, grid, impassable, width, height):\n            tentative_g_score = g_score[current] + cost\n            if tentative_g_score < g_score.get(neighbor_pos, float('inf')):\n                came_from[neighbor_pos] = (current, move)\n                g_score[neighbor_pos] = tentative_g_score\n                f_score[neighbor_pos] = tentative_g_score + heuristic(neighbor_pos, target)\n                heapq.heappush(open_set, (f_score[neighbor_pos], neighbor_pos))\n\n    return None # Path not found\n\ndef reconstruct_path(came_from, current):\n    path = []\n    while current in came_from:\n        current, move = came_from[current]\n        path.append(move)\n    return path[::-1]\n\n# --- Script Execution ---\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n\n    grid, impassable_tiles, map_width, map_height = parse_map_xml(map_xml_string)\n    \n    start_node = (start_x, start_y)\n    target_node = (target_x, target_y)\n\n    path = a_star_search(start_node, target_node, grid, impassable_tiles, map_width, map_height)\n\n    if path:\n        print(f\"Path found: {', '.join(path)}\")\n    else:\n        print(\"No path found.\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n"
  },
  "inventory_navigator_tool": {
    "description": "Calculates the optimal number of button presses (Up/Down) to navigate from a current selection to a target item in a list-based menu. This version correctly handles non-wrapping menus and provides a warning for long scrolls.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory_list": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "current_selection": {
          "type": "string"
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "inventory_list",
        "current_selection",
        "target_item"
      ]
    },
    "python_script": "import json\ntry:\n    inventory = json.loads(input_data['inventory_list'])\n    current_item = input_data['current_selection']\n    target_item = input_data['target_item']\n\n    if current_item not in inventory or target_item not in inventory:\n        print(json.dumps({'error': 'Item not found in inventory list.'}))\n    else:\n        current_idx = inventory.index(current_item)\n        target_idx = inventory.index(target_item)\n        \n        response = {}\n        if current_idx == target_idx:\n            response = {'direction': 'NONE', 'presses': 0}\n        elif target_idx > current_idx:\n            presses = target_idx - current_idx\n            response = {'direction': 'DOWN', 'presses': presses}\n        else: # target_idx < current_idx\n            presses = current_idx - target_idx\n            response = {'direction': 'UP', 'presses': presses}\n\n        if response.get('presses', 0) > 4:\n            response['note'] = 'Warning: This is a long scroll. Press Down in increments of 4 to navigate pages more effectively.'\n        \n        print(json.dumps(response))\nexcept Exception as e:\n    print(json.dumps({'error': str(e), 'type': type(e).__name__}))"
  },
  "inventory_scanner": {
    "description": "Scans the player's inventory list for a target item and returns whether it was found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory_list": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "inventory_list",
        "target_item"
      ]
    },
    "python_script": "import json\n\ntry:\n    inventory_list = json.loads(input_data['inventory_list'])\n    target_item = input_data['target_item']\n    found = False\n    for item in inventory_list:\n        if target_item.lower() in item.lower():\n            found = True\n            break\n    print(f'Item found: {found}')\nexcept Exception as e:\n    print(f'An error occurred: {e}')"
  },
  "menu_navigator": {
    "description": "Calculates the optimal number of button presses (Up/Down) to navigate from a current selection to a target item in a list-based menu, like the Fly menu or inventory.",
    "input_schema": {
      "type": "object",
      "properties": {
        "menu_items": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "current_selection": {
          "type": "string"
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "menu_items",
        "current_selection",
        "target_item"
      ]
    },
    "python_script": "import json\n\ndef get_presses(menu_items_str, current_selection, target_item):\n    try:\n        menu_items = json.loads(menu_items_str)\n        current_idx = menu_items.index(current_selection)\n        target_idx = menu_items.index(target_item)\n    except (ValueError, json.JSONDecodeError) as e:\n        return {'error': str(e)}\n\n    n = len(menu_items)\n    down_presses = (target_idx - current_idx + n) % n\n    up_presses = (current_idx - target_idx + n) % n\n\n    if down_presses <= up_presses:\n        return {'direction': 'Down', 'presses': down_presses}\n    else:\n        return {'direction': 'Up', 'presses': up_presses}\n\nresult = get_presses(input_data['menu_items'], input_data['current_selection'], input_data['target_item'])\nprint(json.dumps(result))"
  }
}