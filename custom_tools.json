{
  "pathfinding_tool": {
    "description": "Calculates the shortest path between two points on the current map using A* search and returns a comma-separated string of button presses (Up, Down, Left, Right). Parses the map without external libraries.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import heapq\n\ndef parse_map_from_xml_string(xml_string):\n    grid = []\n    try:\n        height = int(xml_string.split('height=\"')[1].split('\"')[0])\n        width = int(xml_string.split('width=\"')[1].split('\"')[0])\n        grid = [['' for _ in range(width)] for _ in range(height)]\n        rows = xml_string.split('<Row id=')\n        for row_str in rows[1:]:\n            y = int(row_str.split('\"')[1]) - 1\n            tiles = row_str.split('<Tile id=')\n            for tile_str in tiles[1:]:\n                x = int(tile_str.split('\"')[1]) - 1\n                tile_type = tile_str.split('type=\"')[1].split('\"')[0]\n                is_impassable = tile_type in ['impassable', 'water', 'unknown']\n                if 'has-object=\"true\"' in tile_str and 'id-name=\"Pikachu\"' not in tile_str:\n                    is_impassable = True\n                grid[y][x] = '#' if is_impassable else '.'\n    except (IndexError, ValueError):\n        return None\n    return grid\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(grid, start, end):\n    neighbors = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    close_set = set()\n    came_from = {}\n    gscore = {start: 0}\n    fscore = {start: heuristic(start, end)}\n    oheap = []\n    heapq.heappush(oheap, (fscore[start], start))\n    while oheap:\n        current = heapq.heappop(oheap)[1]\n        if current == end:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            return path[::-1]\n        close_set.add(current)\n        for i, j in neighbors:\n            neighbor = current[0] + i, current[1] + j\n            tentative_g_score = gscore[current] + 1\n            if 0 <= neighbor[0] < len(grid[0]) and 0 <= neighbor[1] < len(grid):\n                if grid[neighbor[1]][neighbor[0]] == '#':\n                    continue\n            else:\n                continue\n            if neighbor in close_set and tentative_g_score >= gscore.get(neighbor, 0):\n                continue\n            if tentative_g_score < gscore.get(neighbor, 0) or neighbor not in [i[1] for i in oheap]:\n                came_from[neighbor] = current\n                gscore[neighbor] = tentative_g_score\n                fscore[neighbor] = tentative_g_score + heuristic(neighbor, end)\n                heapq.heappush(oheap, (fscore[neighbor], neighbor))\n    return None\n\ndef path_to_buttons(path):\n    buttons = []\n    if not path or len(path) < 2:\n        return []\n    for i in range(len(path) - 1):\n        dx = path[i+1][0] - path[i][0]\n        dy = path[i+1][1] - path[i][1]\n        if dx == 1: buttons.append(\"Right\")\n        elif dx == -1: buttons.append(\"Left\")\n        elif dy == 1: buttons.append(\"Down\")\n        elif dy == -1: buttons.append(\"Up\")\n    return buttons\n\ntry:\n    start_x = int(input_data['start_x']) - 1\n    start_y = int(input_data['start_y']) - 1\n    end_x = int(input_data['end_x']) - 1\n    end_y = int(input_data['end_y']) - 1\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n    grid = parse_map_from_xml_string(map_xml_string)\n    if not grid:\n        print(\"Error: Failed to parse map XML.\")\n    else:\n        path = a_star_search(grid, start_node, end_node)\n        if path:\n            buttons = path_to_buttons(path)\n            print(','.join(buttons))\n        else:\n            print(\"Error: No path found.\")\nexcept Exception as e:\n    print(f\"Error: An unexpected error occurred - {str(e)}\")"
  }
}