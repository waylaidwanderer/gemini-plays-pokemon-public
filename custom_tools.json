{
  "master_navigator": {
    "description": "A consolidated navigation tool that handles pathfinding. It can find a path to a specific coordinate. It now considers map markers for obstacles and correctly handles ledges and transitions between different traversable tile types. Includes an option to ignore objects for testing purposes.",
    "input_schema": {
      "type": "object",
      "properties": {
        "mode": {
          "type": "string",
          "enum": [
            "pathfind"
          ]
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer",
          "nullable": true
        },
        "end_y": {
          "type": "integer",
          "nullable": true
        },
        "traversable_tiles": {
          "type": "string"
        },
        "ignore_objects": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "mode",
        "start_x",
        "start_y",
        "traversable_tiles"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\nimport sys\n\nsys.stderr = sys.stdout\n\ndef find_path(map_xml_string, start_x, start_y, end_x, end_y, traversable_tiles_str, ignore_objects_str):\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n\n        traversable_tiles = traversable_tiles_str.split(',')\n        ignore_objects = ignore_objects_str.lower() == 'true' if ignore_objects_str else False\n        \n        grid = [[None for _ in range(width)] for _ in range(height)]\n        \n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            if not (1 <= y <= height): continue\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                if not (1 <= x <= width): continue\n\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                is_player_tile = tile_elem.find('Player') is not None\n                \n                is_traversable = tile_type in traversable_tiles\n                \n                if has_object and not is_player_tile and not ignore_objects:\n                    is_traversable = False\n                \n                for marker in tile_elem.findall('Marker'):\n                    if marker.get('emoji') == 'ðŸš«':\n                        is_traversable = False\n                        break\n                \n                if is_traversable:\n                    grid[y-1][x-1] = tile_type\n\n        def heuristic(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n        start_0_idx = (start_x - 1, start_y - 1)\n        goal_0_idx = (end_x - 1, end_y - 1)\n\n        if not (0 <= start_0_idx[0] < width and 0 <= start_0_idx[1] < height):\n            return {\"error\": f\"Start coordinates ({start_x},{start_y}) are outside map boundaries.\"}\n        if not (0 <= goal_0_idx[0] < width and 0 <= goal_0_idx[1] < height):\n            return {\"error\": f\"Goal coordinates ({end_x},{end_y}) are outside map boundaries.\"}\n\n        if not grid[goal_0_idx[1]][goal_0_idx[0]]:\n            found_new_goal = False\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_goal_candidate = (goal_0_idx[0] + dx, goal_0_idx[1] + dy)\n                if 0 <= new_goal_candidate[0] < width and 0 <= new_goal_candidate[1] < height and grid[new_goal_candidate[1]][new_goal_candidate[0]]:\n                    goal_0_idx = new_goal_candidate\n                    found_new_goal = True\n                    break\n            if not found_new_goal:\n                 return {\"error\": f\"Goal ({end_x},{end_y}) and all adjacent tiles are not traversable.\"}\n\n        open_set = [(0, start_0_idx)]\n        came_from = {}\n        g_score = { (x,y): float('inf') for y in range(height) for x in range(width) }\n        g_score[start_0_idx] = 0\n        f_score = { (x,y): float('inf') for y in range(height) for x in range(width) }\n        f_score[start_0_idx] = heuristic(start_0_idx, goal_0_idx)\n        \n        while open_set:\n            _, current = heapq.heappop(open_set)\n\n            if current == goal_0_idx:\n                path = []\n                while current in came_from:\n                    path.append({'x': current[0] + 1, 'y': current[1] + 1})\n                    current = came_from[current]\n                path.append({'x': start_0_idx[0] + 1, 'y': start_0_idx[1] + 1})\n                return list(reversed(path))\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                neighbor = (current[0] + dx, current[1] + dy)\n                nx, ny = neighbor\n\n                if not (0 <= nx < width and 0 <= ny < height):\n                    continue\n                \n                if grid[ny][nx] is None:\n                    continue\n\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, goal_0_idx)\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n        \n        return {\"error\": \"No path found.\"}\n\n    except Exception as e:\n        import traceback\n        return {\"error\": str(e), \"traceback\": traceback.format_exc()}\n\ntry:\n    mode = input_data['mode']\n    if mode == 'pathfind':\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        end_x = int(input_data.get('end_x'))\n        end_y = int(input_data.get('end_y'))\n        traversable_tiles_str = input_data['traversable_tiles']\n        ignore_objects_str = input_data.get('ignore_objects')\n\n        path = find_path(map_xml_string, start_x, start_y, end_x, end_y, traversable_tiles_str, ignore_objects_str)\n\n        if isinstance(path, dict) and \"error\" in path:\n            print(json.dumps(path))\n        elif path:\n            print(json.dumps({\"path\": path}))\n        else:\n            print(json.dumps({\"error\": \"No path found.\"}))\n    else:\n        print(json.dumps({\"error\": f\"Invalid mode: {mode}\"}))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({\"error\": f\"Tool execution failed: {str(e)}\", \"traceback\": traceback.format_exc()}))"
  }
}