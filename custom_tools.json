{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "gem_path_planner": {
    "description": "A custom pathfinding tool designed by Gem to be more robust than the default planner. It finds a path from a start to a target coordinate, avoiding impassable tiles and objects. This version correctly finds a path to a tile adjacent to an impassable target.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import heapq\nimport json\nimport xml.etree.ElementTree as ET\n\nclass AStar:\n    def __init__(self, map_xml_string):\n        self.root = ET.fromstring(map_xml_string)\n        self.width = int(self.root.get('width'))\n        self.height = int(self.root.get('height'))\n        self.grid, self.tile_types = self._create_grid()\n\n    def _create_grid(self):\n        grid = [[0 for _ in range(self.width)] for _ in range(self.height)]\n        tile_types = {}\n        for row_elem in self.root.findall('Row'):\n            y = int(row_elem.get('id')) - 1\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id')) - 1\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                is_warp = tile_elem.get('is-warp') == 'true'\n                obj = tile_elem.find('Object')\n                is_pikachu = obj is not None and obj.get('id-name') == 'PIKACHU'\n\n                tile_types[(x, y)] = tile_type\n                cost = 1\n                if tile_type in ['impassable', 'unknown', 'closed_gate', 'boulder_barrier', 'water'] or (has_object and not is_pikachu):\n                    cost = float('inf')\n                elif is_warp:\n                    cost = 1000 # High cost to avoid pathing through warps unless necessary\n\n                grid[y][x] = cost\n        return grid, tile_types\n\n    def heuristic(self, a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def get_neighbors(self, node):\n        x, y = node\n        neighbors = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < self.width and 0 <= ny < self.height:\n                neighbor_tile_type = self.tile_types.get((nx, ny))\n                if neighbor_tile_type == 'ledge':\n                    if dy == 1: # Moving down from a ledge\n                        nnx, nny = nx, ny + 1\n                        if 0 <= nny < self.height:\n                            neighbors.append(((nnx, nny), 1))\n                        continue # Skip adding the ledge tile itself\n                    else: # Cannot move up or sideways onto a ledge\n                        continue\n                \n                neighbors.append(((nx, ny), 1))\n        return neighbors\n\n    def find_path(self, start, end):\n        start_node = (start[0] - 1, start[1] - 1)\n        end_node = (end[0] - 1, end[1] - 1)\n        \n        # If target is impassable, find a reachable adjacent tile\n        if self.grid[end_node[1]][end_node[0]] == float('inf'):\n            possible_targets = []\n            for neighbor, _ in self.get_neighbors(end_node):\n                if self.grid[neighbor[1]][neighbor[0]] != float('inf'):\n                    heapq.heappush(possible_targets, (self.heuristic(start_node, neighbor), neighbor))\n            \n            if not possible_targets:\n                return [{'error': 'Target and all adjacent tiles are unreachable'}]\n            \n            _, end_node = heapq.heappop(possible_targets) # Choose the closest valid neighbor\n\n        open_set = [(0, start_node)]\n        came_from = {}\n        g_score = { (c, r): float('inf') for r in range(self.height) for c in range(self.width) }\n        g_score[start_node] = 0\n        f_score = { (c, r): float('inf') for r in range(self.height) for c in range(self.width) }\n        f_score[start_node] = self.heuristic(start_node, end_node)\n\n        while open_set:\n            _, current = heapq.heappop(open_set)\n\n            if current == end_node:\n                return self.reconstruct_path(came_from, current)\n\n            for neighbor, move_cost in self.get_neighbors(current):\n                if self.grid[neighbor[1]][neighbor[0]] == float('inf'):\n                    continue\n                \n                tentative_g_score = g_score[current] + self.grid[neighbor[1]][neighbor[0]]\n\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = tentative_g_score + self.heuristic(neighbor, end_node)\n                    if neighbor not in [i[1] for i in open_set]:\n                        heapq.heappush(open_set, (f_score[neighbor], neighbor))\n        \n        return [{'error': 'No path found', 'start': start, 'end': (end_node[0]+1, end_node[1]+1)}]\n\n    def reconstruct_path(self, came_from, current):\n        path = []\n        while current in came_from:\n            path.append({'x': current[0] + 1, 'y': current[1] + 1})\n            current = came_from[current]\n        path.append({'x': current[0] + 1, 'y': current[1] + 1})\n        return path[::-1]\n\ndef convert_path_to_directions(path):\n    if not path or ('error' in path[0] if path else False):\n        return []\n    directions = []\n    for i in range(len(path) - 1):\n        current = path[i]\n        nxt = path[i+1]\n        dx = nxt['x'] - current['x']\n        dy = nxt['y'] - current['y']\n        if abs(dy) > 1: directions.append('Down')\n        elif dx == 1: directions.append('Right')\n        elif dx == -1: directions.append('Left')\n        elif dy == 1: directions.append('Down')\n        elif dy == -1: directions.append('Up')\n    return directions\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n\n    astar = AStar(map_xml_string)\n    path_coords = astar.find_path((start_x, start_y), (target_x, target_y))\n    \n    is_error = 'error' in path_coords[0] if path_coords else True\n    path_plan_output = {\n        \"path_found\": not is_error,\n        \"path_plan\": path_coords if not is_error else None,\n        \"path_directions\": convert_path_to_directions(path_coords) if not is_error else None,\n        \"error_info\": path_coords[0] if is_error else None\n    }\n    print(json.dumps(path_plan_output, indent=2))\n\nexcept Exception as e:\n    print(json.dumps({\"error\": str(e), \"path_found\": False}))"
  },
  "inventory_navigator_tool": {
    "description": "Calculates the optimal number of button presses (Up/Down) to navigate from a current selection to a target item in a list-based menu. This version correctly handles non-wrapping menus and provides a warning for long scrolls.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory_list": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "current_selection": {
          "type": "string"
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "inventory_list",
        "current_selection",
        "target_item"
      ]
    },
    "python_script": "import json\ntry:\n    inventory = json.loads(input_data['inventory_list'])\n    current_item = input_data['current_selection']\n    target_item = input_data['target_item']\n\n    if current_item not in inventory or target_item not in inventory:\n        print(json.dumps({'error': 'Item not found in inventory list.'}))\n    else:\n        current_idx = inventory.index(current_item)\n        target_idx = inventory.index(target_item)\n        \n        response = {}\n        if current_idx == target_idx:\n            response = {'direction': 'NONE', 'presses': 0}\n        elif target_idx > current_idx:\n            presses = target_idx - current_idx\n            response = {'direction': 'DOWN', 'presses': presses}\n        else: # target_idx < current_idx\n            presses = current_idx - target_idx\n            response = {'direction': 'UP', 'presses': presses}\n\n        if response.get('presses', 0) > 4:\n            response['note'] = 'Warning: This is a long scroll. Press Down in increments of 4 to navigate pages more effectively.'\n        \n        print(json.dumps(response))\nexcept Exception as e:\n    print(json.dumps({'error': str(e), 'type': type(e).__name__}))"
  },
  "inventory_scanner": {
    "description": "Scans the player's inventory list for a target item and returns whether it was found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory_list": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "inventory_list",
        "target_item"
      ]
    },
    "python_script": "import json\n\ninventory_list_str = input_data.get('inventory_list', '[]')\ntarget_item = input_data.get('target_item', '')\n\ntry:\n    inventory_list = json.loads(inventory_list_str.replace(\"'\", '\"'))\nexcept json.JSONDecodeError:\n    print(json.dumps({'item_found': False, 'error': 'Invalid JSON format for inventory_list.'}))\n\nitem_found = False\nfor item in inventory_list:\n    # Check if the target item is a substring of the inventory item (e.g., 'ESCAPE ROPE' in 'ESCAPE ROPE x1')\n    if target_item.lower() in item.lower():\n        item_found = True\n        break\n\nprint(json.dumps({'item_found': item_found}))"
  },
  "path_planner": {
    "description": "A robust pathfinding tool. Takes start and target coordinates and outputs a JSON-formatted path plan. This version correctly finds paths to tiles adjacent to impassable targets, avoids pathing through warp tiles and water tiles unless they are the destination, and handles off-screen gates. Includes enhanced debugging.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import heapq\nimport json\nimport xml.etree.ElementTree as ET\n\nclass AStar:\n    def __init__(self, map_xml_string):\n        self.root = ET.fromstring(map_xml_string)\n        self.width = int(self.root.get('width'))\n        self.height = int(self.root.get('height'))\n        self.grid, self.tile_types = self._create_grid()\n\n    def _create_grid(self):\n        grid = [[0 for _ in range(self.width)] for _ in range(self.height)]\n        tile_types = {}\n        for row_elem in self.root.findall('Row'):\n            y = int(row_elem.get('id')) - 1\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id')) - 1\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                is_warp = tile_elem.get('is-warp') == 'true'\n                obj = tile_elem.find('Object')\n                is_pikachu = obj is not None and obj.get('id-name') == 'PIKACHU'\n\n                tile_types[(x, y)] = tile_type\n                cost = 1\n                if tile_type in ['impassable', 'unknown', 'closed_gate', 'boulder_barrier', 'water']:\n                    cost = float('inf')\n                elif has_object and not is_pikachu:\n                    cost = float('inf')\n                elif is_warp:\n                    cost = 1000 # High cost to discourage pathing through warps unless necessary\n\n                grid[y][x] = cost\n        return grid, tile_types\n\n    def heuristic(self, a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def get_neighbors(self, node):\n        x, y = node\n        neighbors = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < self.width and 0 <= ny < self.height:\n                neighbor_tile_type = self.tile_types.get((nx, ny))\n                # Ledge logic\n                if neighbor_tile_type == 'ledge':\n                    if dy == 1: # Moving down onto a ledge\n                        nnx, nny = nx, ny + 1\n                        if 0 <= nny < self.height:\n                            neighbors.append(((nnx, nny), 1)) # Cost is 1 for the jump\n                        continue\n                    else: # Trying to move up or sideways onto a ledge is impossible\n                        continue\n                \n                neighbors.append(((nx, ny), 1))\n        return neighbors\n\n    def find_path(self, start, end):\n        start_node = (start[0] - 1, start[1] - 1)\n        end_node = (end[0] - 1, end[1] - 1)\n        \n        # If target is impassable, find a reachable adjacent tile\n        if self.grid[end_node[1]][end_node[0]] == float('inf'):\n            possible_targets = []\n            for neighbor, _ in self.get_neighbors(end_node):\n                if self.grid[neighbor[1]][neighbor[0]] != float('inf'):\n                    heapq.heappush(possible_targets, (self.heuristic(start_node, neighbor), neighbor))\n            \n            if not possible_targets:\n                return [{'error': 'Target and all adjacent tiles are unreachable'}]\n            \n            # Find the closest reachable neighbor to the start\n            _, end_node = heapq.heappop(possible_targets)\n\n        open_set = [(0, start_node)]\n        came_from = {}\n        g_score = { (c, r): float('inf') for r in range(self.height) for c in range(self.width) }\n        g_score[start_node] = 0\n        f_score = { (c, r): float('inf') for r in range(self.height) for c in range(self.width) }\n        f_score[start_node] = self.heuristic(start_node, end_node)\n\n        while open_set:\n            _, current = heapq.heappop(open_set)\n\n            if current == end_node:\n                return self.reconstruct_path(came_from, current)\n\n            for neighbor, move_cost in self.get_neighbors(current):\n                if self.grid[neighbor[1]][neighbor[0]] == float('inf'):\n                    continue\n                \n                tentative_g_score = g_score[current] + self.grid[neighbor[1]][neighbor[0]]\n\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = tentative_g_score + self.heuristic(neighbor, end_node)\n                    if neighbor not in [i[1] for i in open_set]:\n                        heapq.heappush(open_set, (f_score[neighbor], neighbor))\n        \n        return [{'error': 'No path found', 'start': start, 'end': (end_node[0]+1, end_node[1]+1)}]\n\n    def reconstruct_path(self, came_from, current):\n        path = []\n        while current in came_from:\n            path.append({'x': current[0] + 1, 'y': current[1] + 1})\n            current = came_from[current]\n        path.append({'x': current[0] + 1, 'y': current[1] + 1})\n        return path[::-1]\n\ndef convert_path_to_directions(path):\n    if not path or ('error' in path[0] if path else False):\n        return []\n    directions = []\n    for i in range(len(path) - 1):\n        current = path[i]\n        nxt = path[i+1]\n        dx = nxt['x'] - current['x']\n        dy = nxt['y'] - current['y']\n        if abs(dy) > 1: directions.append('Down') # Ledge jump\n        elif dx == 1: directions.append('Right')\n        elif dx == -1: directions.append('Left')\n        elif dy == 1: directions.append('Down')\n        elif dy == -1: directions.append('Up')\n    return directions\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n\n    astar = AStar(map_xml_string)\n    path_coords = astar.find_path((start_x, start_y), (target_x, target_y))\n    \n    is_error = 'error' in path_coords[0] if path_coords else True\n    path_plan_output = {\n        \"path_found\": not is_error,\n        \"path_plan\": path_coords if not is_error else None,\n        \"path_directions\": convert_path_to_directions(path_coords) if not is_error else None,\n        \"error_info\": path_coords[0] if is_error else None\n    }\n    print(json.dumps(path_plan_output, indent=2))\n\nexcept Exception as e:\n    print(json.dumps({\"error\": str(e), \"path_found\": False}))"
  }
}