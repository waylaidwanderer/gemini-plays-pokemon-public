{
  "find_path": {
    "description": "Finds a path using BFS, treating Walls, Objects, and specific Tiles as obstacles. Handles one-way ledges (HOP_DOWN) correctly by treating them as obstacles for now to prevent getting stuck.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "mode": {
          "type": "string",
          "enum": [
            "walking",
            "surfing"
          ],
          "default": "walking"
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y",
        "autopress_buttons"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\n# Ensure we catch ANY exception and print an empty list instead of crashing\ntry:\n    # Variables start_x, start_y, target_x, target_y, mode, autopress_buttons, map_xml_string are injected\n    \n    # Parse Map\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    tiles = {}\n    objects = set()\n    \n    for row in root.findall('Row'):\n        y_coord = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x_coord = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            tiles[(x_coord,y_coord)] = t_type\n            if tile.attrib.get('has-object') == 'true':\n                objects.add((x_coord,y_coord))\n                \n    # BFS\n    queue = deque([(start_x, start_y, [])])\n    visited = set([(start_x, start_y)])\n    passable_types = {\n        'FLOOR', 'TALL_GRASS', 'LONG_GRASS', \n        'WARP_CARPET_DOWN', 'WARP_CARPET_UP', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT',\n        'DOOR', 'STAIRS', 'CAVE'\n    }\n    \n    found_path = []\n    \n    while queue:\n        cx, cy, path = queue.popleft()\n        if cx == target_x and cy == target_y:\n            found_path = path\n            break\n            \n        # Directions: Up, Down, Left, Right\n        # Note: Using string buttons\n        moves = [\n            (0, -1, \"Up\"),\n            (0, 1, \"Down\"),\n            (-1, 0, \"Left\"),\n            (1, 0, \"Right\")\n        ]\n        \n        for dx, dy, btn in moves:\n            nx, ny = cx + dx, cy + dy\n            \n            # Bounds check\n            if 0 <= nx < width and 0 <= ny < height:\n                if (nx, ny) in visited:\n                    continue\n                \n                # Check passability\n                tile_type = tiles.get((nx, ny), 'void')\n                is_passable = tile_type in passable_types\n                if mode == 'surfing' and tile_type == 'WATER':\n                    is_passable = True\n                \n                # Check objects (unless it's the target)\n                if (nx, ny) in objects and (nx, ny) != (target_x, target_y):\n                    is_passable = False\n                \n                # Special checks for walls\n                if tile_type == 'WALL':\n                    is_passable = False\n\n                if is_passable:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [btn]))\n    \n    print(json.dumps(found_path))\n\nexcept Exception as e:\n    # In case of any error, print empty list so the tool doesn't crash the harness\n    print(json.dumps([]))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-25T07:15:45.339Z",
        "action_counter": 17440
      },
      {
        "commit_message": "Fixed JSON output format to ensure compatibility with autopress_buttons.",
        "timestamp": "2025-12-27T01:55:00.553Z",
        "action_counter": 20620
      },
      {
        "commit_message": "Fixed missing commit message and ensured robust integer parsing.",
        "timestamp": "2025-12-27T06:46:32.587Z",
        "action_counter": 21077
      },
      {
        "commit_message": "Initial definition of BFS pathfinding tool to automate navigation and reduce manual path planning errors.",
        "timestamp": "2025-12-27T11:00:12.805Z",
        "action_counter": 21424
      },
      {
        "commit_message": "Refined find_path to remove function wrapper, ensuring global variable access.",
        "timestamp": "2025-12-27T11:03:30.933Z",
        "action_counter": 21426
      },
      {
        "commit_message": "Fixing pathfinding tool: Added proper ledge jumping logic and commit message.",
        "timestamp": "2025-12-27T12:53:54.906Z",
        "action_counter": 21575
      },
      {
        "commit_message": "Fixed pathfinding to treat WATER tiles as obstacles for walking.",
        "timestamp": "2025-12-27T13:40:13.365Z",
        "action_counter": 21629
      },
      {
        "commit_message": "Initial definition of BFS pathfinding tool to automate navigation and reduce manual coordinate calculation errors.",
        "timestamp": "2025-12-27T15:04:50.460Z",
        "action_counter": 21725
      },
      {
        "commit_message": "Updated find_path to support movement modes ('walking', 'surfing') for context-aware navigation.",
        "timestamp": "2025-12-27T15:19:15.563Z",
        "action_counter": 21741
      },
      {
        "commit_message": "Updated to respect 'object_id' on map markers, treating them as obstacles to prevent pathing through off-screen defeated trainers.",
        "timestamp": "2025-12-28T15:35:37.133Z",
        "action_counter": 23584
      },
      {
        "commit_message": "Fixed syntax error in for loop (missing 'in moves').",
        "timestamp": "2025-12-28T15:36:09.577Z",
        "action_counter": 23585
      },
      {
        "commit_message": "Implemented robust BFS pathfinding with support for ledges, surfing, and object avoidance.",
        "timestamp": "2025-12-29T00:40:16.598Z",
        "action_counter": 24406
      },
      {
        "commit_message": "Fixed NameError by correctly accessing input arguments via input_data dictionary.",
        "timestamp": "2025-12-29T00:41:12.664Z",
        "action_counter": 24407
      },
      {
        "commit_message": "Fixed JSON output formatting by importing the json module and using json.dumps() to ensure compatibility with the autopress_buttons feature.",
        "timestamp": "2025-12-29T00:42:30.641Z",
        "action_counter": 24409
      },
      {
        "commit_message": "Added 'DOOR' and 'STAIRS' to the list of passable tile types for walking mode in the find_path tool.",
        "timestamp": "2025-12-29T00:56:27.344Z",
        "action_counter": 24427
      },
      {
        "commit_message": "Fixed JSON output format to ensure it always returns a valid JSON array, handling the 'No path found' case correctly.",
        "timestamp": "2025-12-29T03:38:28.516Z",
        "action_counter": 24638
      },
      {
        "commit_message": "Fixed Argument Access: Arguments are passed in the 'input_data' dictionary, not as global variables. Updated script to retrieve start_x, start_y, etc., from input_data to prevent NameErrors.",
        "timestamp": "2025-12-29T04:11:36.679Z",
        "action_counter": 24688
      },
      {
        "commit_message": "Fixed LEDGE_HOP_DOWN traversal logic to restrict movement to South-only (one-way).",
        "timestamp": "2025-12-29T06:41:38.404Z",
        "action_counter": 24903
      },
      {
        "commit_message": "Fixed NameError by extracting input arguments from the `input_data` dictionary at the beginning of the script.",
        "timestamp": "2025-12-29T06:42:56.018Z",
        "action_counter": 24905
      },
      {
        "commit_message": "Fix logic to correctly handle one-way ledges (LEDGE_HOP_*) by only allowing entry from the correct direction and forcing a jump to the next tile.",
        "timestamp": "2026-01-07T09:32:34.901Z",
        "action_counter": 26222
      },
      {
        "commit_message": "Fixed NameError by properly extracting arguments from the `input_data` dictionary.",
        "timestamp": "2026-01-07T09:35:36.040Z",
        "action_counter": 26224
      },
      {
        "commit_message": "Updated find_path to treat 'FLOOR_UP_WALL' as 'LEDGE_HOP_DOWN', ensuring the pathfinder correctly handles these south-facing ledges as one-way obstacles that block northward movement.",
        "timestamp": "2026-01-07T09:53:29.506Z",
        "action_counter": 26251
      },
      {
        "commit_message": "Fixed logic to treat FLOOR_UP_WALL as impassable in walking mode to prevent getting stuck on ledges.",
        "timestamp": "2026-01-07T10:34:11.875Z",
        "action_counter": 26295
      },
      {
        "commit_message": "Fixed NameError by extracting input arguments from the `input_data` dictionary.",
        "timestamp": "2026-01-07T10:35:41.639Z",
        "action_counter": 26297
      },
      {
        "commit_message": "Added 'CAVE' to the list of passable tile types for walking mode.",
        "timestamp": "2026-01-07T11:06:53.198Z",
        "action_counter": 26334
      },
      {
        "commit_message": "Added 'TALL_GRASS' and 'LONG_GRASS' to the list of passable tile types for walking mode.",
        "timestamp": "2026-01-07T11:23:21.980Z",
        "action_counter": 26357
      },
      {
        "commit_message": "Updated find_path to parse XML and treat tiles with 'has-object' or markers with 'object_id' as obstacles to prevent getting stuck on NPCs.",
        "timestamp": "2026-01-08T01:20:14.675Z",
        "action_counter": 27316
      },
      {
        "commit_message": "Fixed NameError by extracting input arguments from the `input_data` dictionary.",
        "timestamp": "2026-01-08T01:22:57.231Z",
        "action_counter": 27319
      },
      {
        "commit_message": "Fixed issue where pathfinding would attempt to traverse ledges backwards (e.g., moving UP through a HOP_DOWN tile). Added explicit checks for one-way tile mechanics.",
        "timestamp": "2026-01-08T02:14:04.507Z",
        "action_counter": 27391
      },
      {
        "commit_message": "Fixed 'find_path' crash by adding try-except block and ensuring valid JSON output.",
        "timestamp": "2026-01-08T05:07:01.449Z",
        "action_counter": 27542
      },
      {
        "commit_message": "Restored 'DOOR', 'STAIRS', and 'CAVE' to passable_types. These were accidentally removed in a previous update, causing pathfinding to fail when targeting buildings.",
        "timestamp": "2026-01-08T05:29:54.770Z",
        "action_counter": 27568
      }
    ]
  },
  "slow_press": {
    "description": "Presses a sequence of buttons with a configurable delay between each press. Input 'buttons' should be a list of button names (e.g., 'A', 'B', 'Up'). 'sleep' commands in the input list are ignored to prevent errors; use the 'delay' parameter instead.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "A",
              "B",
              "Select",
              "Start",
              "Right",
              "Left",
              "Up",
              "Down",
              "R",
              "L"
            ]
          }
        },
        "delay": {
          "type": "integer",
          "default": 500,
          "description": "Delay in milliseconds between presses."
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "buttons = input_data.get('buttons', [])\ndelay = input_data.get('delay', 500)\n\nsequence = []\nfor btn in buttons:\n    # Filter out any accidentally passed sleep commands or invalid strings\n    if btn in [\"A\", \"B\", \"Select\", \"Start\", \"Right\", \"Left\", \"Up\", \"Down\", \"R\", \"L\"]:\n        sequence.append(btn)\n        sequence.append(f\"sleep {delay}\")\n\n# Remove the trailing sleep if it exists\nif sequence and sequence[-1].startswith(\"sleep\"):\n    sequence.pop()\n\nprint(json.dumps(sequence))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-20T10:42:11.488Z",
        "action_counter": 8108
      },
      {
        "commit_message": "Refined slow_press to prevent consecutive sleep errors by sanitizing input and ensuring correct interleaving of delays.",
        "timestamp": "2025-12-26T10:25:26.235Z",
        "action_counter": 19531
      }
    ]
  },
  "try_cut_tree": {
    "description": "Checks the tile in front of the player for a cuttable tree and attempts to cut it. Returns true if a tree was cut, false otherwise.",
    "input_schema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "python_script": "# This script would ideally inspect the map data for a tree object.\n# Since we can't directly inspect live RAM, we'll try to press the button sequence for CUT.\n# \"Start\" -> \"Pokemon\" -> Select Oddish -> \"Cut\"\n# Or interacting with the tree \"A\".\n# In Gen 2, you can just press A on the tree.\n# So we will return the button \"A\".\nimport json\nprint(json.dumps([\"A\"]))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T17:46:48.214Z",
        "action_counter": 23754
      }
    ]
  },
  "navigate_menu": {
    "description": "Navigates menus by holding direction buttons for a specified duration to ensure registration, with delays between inputs. Useful for the Fly map and other sticky menus.",
    "input_schema": {
      "type": "object",
      "properties": {
        "directions": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "Up",
              "Down",
              "Left",
              "Right",
              "A",
              "B",
              "Start",
              "Select"
            ]
          }
        },
        "hold_ms": {
          "type": "integer",
          "default": 150
        },
        "interval_ms": {
          "type": "integer",
          "default": 300
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": true
        }
      },
      "required": [
        "directions",
        "autopress_buttons"
      ]
    },
    "python_script": "import json\n\n# Extract arguments from input_data\ndirections = input_data.get('directions', [])\nhold_ms = input_data.get('hold_ms', 150)\ninterval_ms = input_data.get('interval_ms', 300)\nautopress_buttons = input_data.get('autopress_buttons', True)\n\n# Frame duration is approx 16ms\nframes_to_hold = max(1, int(hold_ms / 16))\n\noutput_sequence = []\n\nfor btn in directions:\n    # Hold the button\n    for _ in range(frames_to_hold):\n        output_sequence.append(btn)\n    \n    # Release/Wait\n    if interval_ms > 0:\n        output_sequence.append(f\"sleep {interval_ms}\")\n        \nprint(json.dumps(output_sequence))",
    "history": [
      {
        "commit_message": "Defined a new tool 'navigate_menu' to reliably navigate menus by holding buttons for a specific duration, addressing input registration issues in emulated menus.",
        "timestamp": "2026-01-08T03:01:39.002Z",
        "action_counter": 27437
      },
      {
        "commit_message": "Fixed `navigate_menu` to correctly extract arguments from `input_data` and execute the logic, preventing 'Unexpected end of JSON input' errors.",
        "timestamp": "2026-01-08T03:03:15.631Z",
        "action_counter": 27439
      }
    ]
  },
  "assess_reachability": {
    "description": "Performs a flood-fill BFS starting from a given coordinate to determine all reachable tiles of a specific type (e.g., WATER). Returns the bounds of the reachable area, accessible warps, and adjacent unseen tiles. Useful for determining if a path exists through a maze.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "tile_type": {
          "type": "string",
          "default": "WATER"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef assess_reachability(map_xml_string, start_x, start_y, tile_type=\"WATER\"):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = {}\n    warps = {}\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib.get('type', 'unseen')\n            is_warp = tile.attrib.get('is-warp') == 'true'\n            \n            grid[(x, y)] = t_type\n            if is_warp:\n                # Check for warp details in children\n                warp_node = tile.find('Warp')\n                entry_point = warp_node.attrib.get('entry_point') if warp_node is not None else \"?\"\n                warps[(x, y)] = entry_point\n\n    if grid.get((start_x, start_y)) != tile_type and grid.get((start_x, start_y)) != \"WHIRLPOOL\":\n        print(f\"Error: Start position ({start_x}, {start_y}) is {grid.get((start_x, start_y))}, not {tile_type}.\")\n        return\n\n    queue = deque([(start_x, start_y)])\n    visited = set([(start_x, start_y)])\n    reachable_warps = []\n    reachable_unseen_adjacents = []\n    min_x, max_x, min_y, max_y = start_x, start_x, start_y, start_y\n    \n    # Allow WHIRLPOOL as traversable for surfing if tile_type is WATER\n    traversable_types = {tile_type}\n    if tile_type == \"WATER\":\n        traversable_types.add(\"WHIRLPOOL\")\n\n    while queue:\n        cx, cy = queue.popleft()\n        \n        min_x = min(min_x, cx)\n        max_x = max(max_x, cx)\n        min_y = min(min_y, cy)\n        max_y = max(max_y, cy)\n        \n        if (cx, cy) in warps:\n            reachable_warps.append({'x': cx, 'y': cy, 'entry': warps[(cx, cy)]})\n            \n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < width and 0 <= ny < height:\n                if (nx, ny) in visited:\n                    continue\n                \n                n_type = grid.get((nx, ny), 'unseen')\n                \n                if n_type in traversable_types:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n                elif n_type == 'unseen':\n                    reachable_unseen_adjacents.append({'x': nx, 'y': ny})\n                    # Don't traverse into unseen, just mark it as a frontier\n    \n    print(f\"Reachability Analysis from ({start_x}, {start_y}) for {tile_type}:\")\n    print(f\"  Bounds: X[{min_x}-{max_x}], Y[{min_y}-{max_y}]\")\n    print(f\"  Reachable Tiles Count: {len(visited)}\")\n    print(f\"  Reachable Warps: {reachable_warps}\")\n    print(f\"  Adjacent Unseen Tiles: {len(reachable_unseen_adjacents)} (First 5: {reachable_unseen_adjacents[:5]})\")\n\nassess_reachability(map_xml_string, input_data['start_x'], input_data['start_y'], input_data.get('tile_type', 'WATER'))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-08T11:22:54.983Z",
        "action_counter": 27988
      }
    ]
  }
}