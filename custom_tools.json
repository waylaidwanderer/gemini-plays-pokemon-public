{
  "buy_item_quantity": {
    "description": "Buys a specific quantity of the currently selected item in the shop menu. Assumes the 'How many?' prompt is open with 'x01' selected.",
    "input_schema": {
      "type": "object",
      "properties": {
        "quantity": {
          "type": "integer",
          "description": "The number of items to buy."
        }
      },
      "required": [
        "quantity"
      ]
    },
    "python_script": "import json\nquantity = int(input_data[\"quantity\"])\nbuttons = []\nif quantity > 1:\n    for _ in range(quantity - 1):\n        buttons.append(\"Up\")\nbuttons.append(\"A\")\nbuttons.append(\"A\")\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "feat: Add buy_item_quantity tool to automate purchasing multiple items in shops. This reduces repetitive button presses for stocking up on supplies.",
        "timestamp": "2025-11-21T09:07:28.956Z",
        "action_counter": 2285
      },
      {
        "commit_message": "feat: Add buy_item_quantity tool to automate purchasing multiple items in shops. This reduces repetitive button presses for stocking up on supplies.",
        "timestamp": "2025-11-21T22:16:51.727Z",
        "action_counter": 3066
      }
    ]
  },
  "find_interaction_point": {
    "description": "Calculates the best adjacent tile to stand on to interact with a specific map object. Supports searching by `object_id` (for sprites), `object_name` (for background objects), or explicit `target_x`/`target_y` coordinates. Returns the target coordinates (x, y) and the direction to face. Does NOT return button presses.",
    "input_schema": {
      "type": "object",
      "properties": {
        "object_id": {
          "type": "integer",
          "nullable": true
        },
        "object_name": {
          "type": "string",
          "nullable": true
        },
        "target_x": {
          "type": "integer",
          "nullable": true
        },
        "target_y": {
          "type": "integer",
          "nullable": true
        },
        "player_x": {
          "type": "integer"
        },
        "player_y": {
          "type": "integer"
        }
      },
      "required": [
        "player_x",
        "player_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport math\nimport json\n\ndef run(input_data):\n    try:\n        root = ET.fromstring(map_xml_string)\n        \n        target_x = None\n        target_y = None\n        \n        # Determine target coordinates\n        if input_data.get('target_x') is not None and input_data.get('target_y') is not None:\n            target_x = int(input_data['target_x'])\n            target_y = int(input_data['target_y'])\n        elif input_data.get('object_id') is not None:\n            obj_id = str(input_data['object_id'])\n            for obj in root.findall(f\".//Object[@id='{obj_id}']\"):\n                tile = obj.find(\"..\")\n                if tile is not None:\n                    coord = tile.get('coordinate') # \"(x, y)\"\n                    target_x, target_y = map(int, coord.strip('()').split(','))\n                    break\n        elif input_data.get('object_name') is not None:\n            obj_name = input_data['object_name']\n            # Try id-name first\n            for obj in root.findall(f\".//Object[@id-name='{obj_name}']\"):\n                tile = obj.find(\"..\")\n                if tile is not None:\n                    coord = tile.get('coordinate')\n                    target_x, target_y = map(int, coord.strip('()').split(','))\n                    break\n            if target_x is None:\n                # Try name attribute\n                for obj in root.findall(f\".//Object[@name='{obj_name}']\"):\n                    tile = obj.find(\"..\")\n                    if tile is not None:\n                        coord = tile.get('coordinate')\n                        target_x, target_y = map(int, coord.strip('()').split(','))\n                        break\n        \n        if target_x is None or target_y is None:\n            print(json.dumps({\"error\": \"Target not found\"}))\n            return\n\n        player_x = int(input_data['player_x'])\n        player_y = int(input_data['player_y'])\n        \n        # Neighbors: (dx, dy, face_direction)\n        # To interact with (tx, ty) from (tx, ty+1), look UP.\n        candidates = [\n            (target_x, target_y - 1, \"Down\"),\n            (target_x, target_y + 1, \"Up\"),\n            (target_x - 1, target_y, \"Right\"),\n            (target_x + 1, target_y, \"Left\")\n        ]\n        \n        valid_candidates = []\n        \n        for cx, cy, face in candidates:\n            # Check bounds and traversability\n            # In XML, rows are 0-indexed y, tiles 0-indexed x\n            # Assuming standard size, but safer to look up tile\n            tile = root.find(f\".//Row[@id='{cy}']/Tile[@id='{cx}']\")\n            if tile is not None:\n                t_type = tile.get('type')\n                has_object = tile.get('has-object') == 'true'\n                has_player = tile.get('has-player') == 'true'\n                \n                # Simple traversability check\n                if t_type != 'WALL' and (not has_object or has_player):\n                    dist = math.sqrt((cx - player_x)**2 + (cy - player_y)**2)\n                    valid_candidates.append({\"x\": cx, \"y\": cy, \"face\": face, \"dist\": dist})\n        \n        if not valid_candidates:\n            print(json.dumps({\"error\": \"No reachable interaction point found\"}))\n            return\n            \n        # Sort by distance\n        valid_candidates.sort(key=lambda c: c['dist'])\n        best = valid_candidates[0]\n        \n        print(json.dumps({\"x\": best['x'], \"y\": best['y'], \"face\": best['face']}))\n        \n    except Exception as e:\n        print(json.dumps({\"error\": str(e)}))\n\nrun(input_data)",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-11-20T01:27:19.980Z",
        "action_counter": 301
      },
      {
        "commit_message": "fix: Update find_interaction_point to support looking up objects by 'object_name' in addition to 'object_id'. This allows targeting background objects (like computers or signs) that lack numeric IDs.",
        "timestamp": "2025-11-20T02:46:50.280Z",
        "action_counter": 421
      },
      {
        "commit_message": "fix: Add debug output to find_interaction_point to verify target location logic.",
        "timestamp": "2025-11-22T04:35:50.805Z",
        "action_counter": 3661
      },
      {
        "commit_message": "fix: Add support for explicit target_x/target_y arguments to bypass XML search if needed. Add debug prints to trace object location and neighbor traversability.",
        "timestamp": "2025-11-22T04:39:05.076Z",
        "action_counter": 3665
      },
      {
        "commit_message": "fix: Add explicit coordinate support and debug prints to find_interaction_point.",
        "timestamp": "2025-11-22T04:47:49.445Z",
        "action_counter": 3683
      },
      {
        "commit_message": "fix: Remove debug prints that were causing JSON parsing errors. Improve robustness of target finding and coordinate parsing.",
        "timestamp": "2025-11-22T08:28:38.782Z",
        "action_counter": 3965
      }
    ]
  },
  "find_path": {
    "description": "Calculates a path from the player's current position to a target coordinate (x, y) using BFS. Returns a JSON array of button presses (e.g., [\"Up\", \"Right\"]) to reach the destination. If the target is blocked, attempts to path to an adjacent traversable tile. Treats tiles with objects or object-linked markers as obstacles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n        \n        # Get player position\n        p_tile = root.find(\".//Tile[@has-player='true']\")\n        if p_tile is None:\n            print(\"[]\")\n            return\n\n        start_x = int(p_tile.get('id'))\n        # coordinate=\"(16, 29)\" -> 29\n        start_y = int(p_tile.get('coordinate').split(',')[1].strip(') '))\n        \n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n        \n        grid = {}\n        # Obstacles list\n        obstacles = [\"WALL\", \"COUNTER\", \"PC\", \"SIGN\", \"TREE\", \"ROCK\", \"BOULDER\", \"WATER\", \"WHIRLPOOL\", \"LEDGE_DOWN\", \"LEDGE_UP\", \"LEDGE_LEFT\", \"LEDGE_RIGHT\", \"WINDOW\", \"DOOR_LOCKED\"]\n        \n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                x = int(tile.get('id'))\n                t_type = tile.get('type')\n                has_object = tile.get('has-object') == 'true'\n                \n                walkable = True\n                if t_type in obstacles:\n                    walkable = False\n                \n                # Check for objects (NPCs, items, etc) - they are walls\n                if has_object:\n                    walkable = False\n                \n                # Check for markers linked to objects (off-screen NPCs)\n                marker = tile.find('Marker')\n                if marker is not None and marker.get('object_id'):\n                    walkable = False\n                    \n                grid[(x, y)] = walkable\n\n        # Logic: If target is blocked, path to nearest adjacent walkable\n        target_walkable = grid.get((target_x, target_y), False)\n        targets = set()\n        \n        if target_walkable:\n            targets.add((target_x, target_y))\n        else:\n            # Target is blocked, look for neighbors\n            for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                nx, ny = target_x + dx, target_y + dy\n                if grid.get((nx, ny), False):\n                    targets.add((nx, ny))\n            \n            if not targets:\n                print(\"[]\")\n                return\n\n        # BFS\n        queue = deque([(start_x, start_y, [])])\n        visited = set([(start_x, start_y)])\n        \n        while queue:\n            cx, cy, path = queue.popleft()\n            \n            if (cx, cy) in targets:\n                # Reconstruct buttons\n                buttons = []\n                curr_x, curr_y = start_x, start_y\n                for (nx, ny) in path:\n                    if nx > curr_x: buttons.append(\"Right\")\n                    elif nx < curr_x: buttons.append(\"Left\")\n                    elif ny > curr_y: buttons.append(\"Down\")\n                    elif ny < curr_y: buttons.append(\"Up\")\n                    curr_x, curr_y = nx, ny\n                print(json.dumps(buttons))\n                return\n\n            for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                nx, ny = cx + dx, cy + dy\n                if (nx, ny) not in visited and grid.get((nx, ny), False):\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [(nx, ny)]))\n                    \n        print(\"[]\")\n\n    except Exception:\n        print(\"[]\")\n\nsolve()",
    "history": [
      {
        "commit_message": "feat: Add find_path tool. Calculates shortest path using BFS, handling walls, objects, and one-way ledges.",
        "timestamp": "2025-11-20T08:35:46.882Z",
        "action_counter": 924
      },
      {
        "commit_message": "fix: Add LADDER to traversable basic_types in find_path. Previously, the tool considered LADDER tiles as walls, preventing pathfinding to or from them.",
        "timestamp": "2025-11-20T10:46:07.670Z",
        "action_counter": 1068
      },
      {
        "commit_message": "fix: Add FLOOR_UP_WALL to traversable tiles when moving down. This tile type appears on Route 32 and visually resembles a ledge, so it is assumed to be jumpable from the north.",
        "timestamp": "2025-11-20T21:10:28.299Z",
        "action_counter": 1479
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. In-game testing proved this tile type blocks movement from the north, contrary to the initial hypothesis that it was a jumpable ledge.",
        "timestamp": "2025-11-20T21:14:51.875Z",
        "action_counter": 1484
      },
      {
        "commit_message": "fix: Reinforce object collision check in find_path and add debug prints for player's neighbors to diagnose issues where objects are ignored.",
        "timestamp": "2025-11-20T23:31:27.320Z",
        "action_counter": 1632
      },
      {
        "commit_message": "fix: Add CAVE to traversable basic_types. This tile type represents cave entrances (warps) and must be traversable to enter dungeons like Union Cave. Also removed debug prints.",
        "timestamp": "2025-11-20T23:38:16.306Z",
        "action_counter": 1641
      },
      {
        "commit_message": "fix: Enable FLOOR_UP_WALL as a traversable ledge when moving down. This is necessary to test if the western ledge at (12, 18) is jumpable, as the eastern path is blocked.",
        "timestamp": "2025-11-21T00:47:29.072Z",
        "action_counter": 1752
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. Verified in-game at (16, 21) that this tile type acts as a wall and cannot be jumped from the north.",
        "timestamp": "2025-11-21T00:59:17.529Z",
        "action_counter": 1768
      },
      {
        "commit_message": "fix: Ensure FLOOR_UP_WALL is treated as a wall. Previous testing at (16, 21) confirmed it is not jumpable from the north.",
        "timestamp": "2025-11-21T01:01:08.516Z",
        "action_counter": 1771
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. Verified in-game at (12, 17) -> (12, 18) that this tile type acts as a wall and cannot be jumped from the north.",
        "timestamp": "2025-11-21T01:05:06.366Z",
        "action_counter": 1776
      },
      {
        "commit_message": "feat: Allow movement UP onto FLOOR_UP_WALL tiles. Verified in-game at Union Cave (5, 19) -> (5, 18) that this tile type acts as a climbable ramp from the south.",
        "timestamp": "2025-11-21T02:01:30.245Z",
        "action_counter": 1847
      },
      {
        "commit_message": "feat: Allow horizontal movement on FLOOR_UP_WALL. The tiles at row 18 act as a traversable ridge connecting the west and east sides of the room.",
        "timestamp": "2025-11-21T02:05:19.643Z",
        "action_counter": 1850
      },
      {
        "commit_message": "feat: Update find_path to automatically target adjacent traversable tiles if the destination is blocked by a wall or object. This eliminates the need for manual coordinate guessing when targeting NPCs or obstacles.",
        "timestamp": "2025-11-22T00:45:06.962Z",
        "action_counter": 3307
      },
      {
        "commit_message": "feat: Enhance find_path to treat tiles with object-linked markers as obstacles. This prevents the pathfinder from routing through off-screen NPCs or objects that are known to exist but not currently rendered in the viewport.",
        "timestamp": "2025-11-22T02:29:58.782Z",
        "action_counter": 3465
      },
      {
        "commit_message": "refactor: Change output format from coordinates to button presses (e.g. [\"Up\", \"Right\"]). This enables compatibility with the `autopress_buttons: true` feature for automated navigation.",
        "timestamp": "2025-11-22T06:33:20.386Z",
        "action_counter": 3846
      },
      {
        "commit_message": "fix: Update find_path to return a JSON array of button strings (e.g. ['Up', 'Right']) instead of coordinates, enabling compatibility with autopress_buttons. Also re-implements logic to path to adjacent tiles if the target is blocked.",
        "timestamp": "2025-11-22T06:37:44.405Z",
        "action_counter": 3851
      },
      {
        "commit_message": "fix: Rewrite find_path to output a JSON array of button strings (e.g. [\"Up\", \"Right\"]) instead of coordinate objects. Adds logic to automatically path to an adjacent tile if the target is blocked by a wall, object, or marker.",
        "timestamp": "2025-11-22T06:42:53.734Z",
        "action_counter": 3857
      }
    ]
  },
  "scan_reachable_unseen": {
    "description": "Identifies unseen tiles that are reachable from the player's current position using a flood fill algorithm on traversable tiles. Returns a list of coordinates.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef is_traversable(tile_type):\n    traversable_types = [\n        \"FLOOR\", \"TALL_GRASS\", \"LONG_GRASS\", \"STAIRS\", \n        \"WARP_CARPET_DOWN\", \"WARP_CARPET_UP\", \"WARP_CARPET_LEFT\", \"WARP_CARPET_RIGHT\",\n        \"DOOR\", \"OPEN_DOOR\"\n    ]\n    return tile_type in traversable_types\n\nmap_data = ET.fromstring(map_xml_string)\nwidth = int(map_data.get(\"width\"))\nheight = int(map_data.get(\"height\"))\n\ngrid = [[None for _ in range(width)] for _ in range(height)]\nplayer_pos = None\n\nfor row in map_data.findall(\"Row\"):\n    y = int(row.get(\"id\"))\n    for tile in row.findall(\"Tile\"):\n        x = int(tile.get(\"id\"))\n        grid[y][x] = tile\n        if tile.find(\"Player\") is not None:\n            player_pos = (x, y)\n\nif not player_pos:\n    print(\"Player not found\")\n    exit()\n\nvisited = set()\nqueue = deque([player_pos])\nvisited.add(player_pos)\nreachable_unseen = []\n\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\nwhile queue:\n    cx, cy = queue.popleft()\n    \n    for dx, dy in directions:\n        nx, ny = cx + dx, cy + dy\n        \n        if 0 <= nx < width and 0 <= ny < height:\n            if (nx, ny) in visited:\n                continue\n                \n            tile = grid[ny][nx]\n            tile_type = tile.get(\"type\")\n            is_seen = tile.get(\"seen\") == \"true\"\n            has_object = tile.get(\"has-object\") == \"true\"\n            \n            if not is_seen:\n                reachable_unseen.append((nx, ny))\n                visited.add((nx, ny))\n                continue\n            \n            if is_traversable(tile_type) and not has_object:\n                visited.add((nx, ny))\n                queue.append((nx, ny))\n\nprint(f\"Reachable unseen tiles: {reachable_unseen}\")",
    "history": [
      {
        "commit_message": "feat: Add scan_reachable_unseen tool to identify reachable unseen tiles for exploration.",
        "timestamp": "2025-11-19T22:54:46.456Z",
        "action_counter": 59
      },
      {
        "commit_message": "feat: Add scan_reachable_unseen tool to identify reachable unseen tiles for exploration.",
        "timestamp": "2025-11-19T23:51:32.034Z",
        "action_counter": 153
      }
    ]
  },
  "sequence_press": {
    "description": "Executes a sequence of button presses provided as a comma-separated string. Essential for navigating menus or keyboards where mixing directional and action inputs is required in a single turn.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "string",
          "description": "Comma-separated list of buttons to press, e.g., 'A, Down, Down, A'"
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nbuttons_str = input_data.get('buttons', '')\nif not buttons_str:\n    print('[]')\nelse:\n    button_list = [btn.strip() for btn in buttons_str.split(',')]\n    print(json.dumps(button_list))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-11-22T06:30:16.355Z",
        "action_counter": 3843
      }
    ]
  }
}