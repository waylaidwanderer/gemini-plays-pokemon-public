{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "boulder_push_planner": {
    "description": "Analyzes the map to find a sequence of moves for the player to push a specific boulder to a specific hole. It considers impassable terrain and other objects.",
    "input_schema": {
      "type": "object",
      "properties": {
        "boulder_start_x": {
          "type": "string"
        },
        "boulder_start_y": {
          "type": "string"
        },
        "hole_x": {
          "type": "string"
        },
        "hole_y": {
          "type": "string"
        },
        "player_x": {
          "type": "string"
        },
        "player_y": {
          "type": "string"
        }
      },
      "required": [
        "boulder_start_x",
        "boulder_start_y",
        "hole_x",
        "hole_y",
        "player_x",
        "player_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\ngrid = [['' for _ in range(width)] for _ in range(height)]\nimpassable_tiles = set()\n\nfor r_idx, row_elem in enumerate(root.findall('Row')):\n    y = int(row_elem.get('id')) - 1\n    for c_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n        x = int(tile_elem.get('id')) - 1\n        tile_type = tile_elem.get('type')\n        grid[y][x] = tile_type\n        if tile_type in ['impassable', 'boulder_barrier', 'closed_gate'] or tile_elem.find('Object') is not None:\n            impassable_tiles.add((x, y))\n\nboulder_start_x, boulder_start_y = int(input_data['boulder_start_x']) - 1, int(input_data['boulder_start_y']) - 1\nhole_x, hole_y = int(input_data['hole_x']) - 1, int(input_data['hole_y']) - 1\nplayer_x, player_y = int(input_data['player_x']) - 1, int(input_data['player_y']) - 1\n\ndef bfs_path(start, end, obstacles):\n    queue = deque([(start, [])])\n    visited = {start}\n    while queue:\n        (cx, cy), path = queue.popleft()\n        if (cx, cy) == end:\n            return path\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            if (0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited and (nx, ny) not in obstacles):\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [(nx, ny)]))\n    return None\n\ndef find_boulder_path():\n    initial_state = (player_x, player_y, boulder_start_x, boulder_start_y)\n    queue = deque([(initial_state, [])])\n    visited_states = {initial_state}\n    \n    while queue:\n        (px, py, bx, by), plan = queue.popleft()\n\n        if (bx, by) == (hole_x, hole_y):\n            return plan\n\n        for move_dir in [('Up', 0, -1), ('Down', 0, 1), ('Left', -1, 0), ('Right', 1, 0)]:\n            move_name, dx, dy = move_dir\n            player_push_pos = (bx - dx, by - dy)\n            \n            if not (0 <= player_push_pos[0] < width and 0 <= player_push_pos[1] < height):\n                continue\n\n            path_to_push_pos = bfs_path((px, py), player_push_pos, impassable_tiles | {(bx, by)})\n\n            if path_to_push_pos is not None:\n                new_bx, new_by = bx + dx, by + dy\n\n                if not (0 <= new_bx < width and 0 <= new_by < height) or (new_bx, new_by) in impassable_tiles:\n                    continue\n\n                new_state = (bx, by, new_bx, new_by)\n                if new_state not in visited_states:\n                    visited_states.add(new_state)\n                    new_plan = plan + [{'path_to_push': [{'x': x+1, 'y': y+1} for x, y in path_to_push_pos], 'push_direction': move_name}]\n                    queue.append((new_state, new_plan))\n\n    return None\n\npath_result = find_boulder_path()\nif path_result:\n    print(json.dumps({'plan': path_result, 'reasoning': 'Found a valid plan to push the boulder.'}))\nelse:\n    print(json.dumps({'plan': [], 'reasoning': 'Could not find a valid plan to push the boulder.'}))"
  },
  "find_path": {
    "description": "A consolidated pathfinding tool. Finds a path to specified X, Y coordinates, considering the current movement state (walking or surfing). It can now avoid a specified list of coordinates. If no end coordinates are provided, it finds a path to the nearest reachable unseen tile. It automatically paths to an adjacent tile if the target is impassable. It can handle elevation changes via steps. This version includes fixes for tile traversal logic and input validation.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string",
          "nullable": true
        },
        "end_y": {
          "type": "string",
          "nullable": true
        },
        "movement_mode": {
          "type": "string",
          "enum": [
            "walking",
            "surfing"
          ]
        },
        "avoid_coords": {
          "type": "string",
          "nullable": true,
          "description": "A JSON string representing a list of coordinate objects, e.g., '[{\"x\":\"10\",\"y\":\"12\"}]'"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "movement_mode"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef find_path(map_xml_string, start_x, start_y, end_x, end_y, movement_mode, avoid_coords_str=None):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = [[None for _ in range(width + 1)] for _ in range(height + 1)]\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            grid[y][x] = tile_elem\n\n    avoid_set = set()\n    if avoid_coords_str and avoid_coords_str.lower() != 'null':\n        try:\n            avoid_coords = json.loads(avoid_coords_str)\n            for coord in avoid_coords:\n                avoid_set.add((int(coord['x']), int(coord['y'])))\n        except (json.JSONDecodeError, TypeError):\n            print(f'Error: Invalid JSON format for avoid_coords: {avoid_coords_str}')\n            return None\n\n    def is_traversable(x, y, mode):\n        if not (1 <= x <= width and 1 <= y <= height): return False\n        tile = grid[y][x]\n        if tile is None or (x, y) in avoid_set: return False\n        \n        tile_type = tile.get('type')\n        has_object = tile.find('Object') is not None\n        \n        if has_object:\n            obj = tile.find('Object')\n            if obj.get('id-name') != 'Pikachu': return False\n\n        walkable_types = ['ground', 'grass', 'steps', 'elevated_ground', 'open_gate', 'gate_offscreen', 'cleared_boulder_barrier', 'boulder_switch', 'teleport', 'hole', 'ladder_up', 'ladder_down']\n        surfable_types = ['water']\n\n        if mode == 'walking': return tile_type in walkable_types\n        if mode == 'surfing': return tile_type in surfable_types\n        return False\n\n    def get_neighbors(x, y, mode):\n        neighbors = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if not (1 <= nx <= width and 1 <= ny <= height): continue\n\n            next_tile = grid[ny][nx]\n            if next_tile is None: continue\n            \n            next_tile_type = next_tile.get('type')\n\n            if mode == 'walking' and next_tile_type == 'ledge' and dy == 1:\n                if is_traversable(nx, ny + 1, mode):\n                    neighbors.append((nx, ny + 1))\n                continue\n\n            if is_traversable(nx, ny, mode) and next_tile_type != 'ledge':\n                neighbors.append((nx, ny))\n        return neighbors\n\n    def heuristic(a, b): return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def a_star(start, goal_func, goal_for_heuristic):\n        open_set = [(0, start)]\n        came_from = {}\n        g_score = {start: 0}\n\n        while open_set:\n            _, current = heapq.heappop(open_set)\n\n            if goal_func(current):\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                return path[::-1]\n\n            for neighbor in get_neighbors(current[0], current[1], movement_mode):\n                tentative_g_score = g_score.get(current, float('inf')) + 1\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score = tentative_g_score + heuristic(neighbor, goal_for_heuristic)\n                    heapq.heappush(open_set, (f_score, neighbor))\n        return None\n\n    start_node = (start_x, start_y)\n    \n    if end_x is None or end_y is None:\n        print('Pathfinding to nearest unseen tile is not supported in this version.')\n        return None\n    else:\n        end_node = (end_x, end_y)\n        if not is_traversable(end_node[0], end_node[1], movement_mode):\n            potential_goals = []\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adj_x, adj_y = end_node[0] + dx, end_node[1] + dy\n                if is_traversable(adj_x, adj_y, movement_mode):\n                    potential_goals.append((adj_x, adj_y))\n            if not potential_goals:\n                print(f'Cannot find a traversable tile adjacent to the destination ({end_x}, {end_y}).')\n                return None\n            potential_goals.sort(key=lambda p: heuristic(start_node, p))\n            final_goal = potential_goals[0]\n        else:\n            final_goal = end_node\n\n        path = a_star(start_node, lambda pos: pos == final_goal, final_goal)\n        return path\n\nstart_x_str = input_data.get('start_x')\nstart_y_str = input_data.get('start_y')\nend_x_str = input_data.get('end_x')\nend_y_str = input_data.get('end_y')\nmovement_mode = input_data.get('movement_mode')\navoid_coords_str = input_data.get('avoid_coords')\n\nif not all([start_x_str, start_y_str, movement_mode]):\n    print(\"Error: Missing required arguments: start_x, start_y, or movement_mode.\")\nelse:\n    start_x = int(start_x_str)\n    start_y = int(start_y_str)\n    end_x = int(end_x_str) if end_x_str is not None else None\n    end_y = int(end_y_str) if end_y_str is not None else None\n    \n    path_result = find_path(map_xml_string, start_x, start_y, end_x, end_y, movement_mode, avoid_coords_str)\n\n    if path_result is None:\n        print('No path found.')\n    else:\n        path_json = [{'x': p[0], 'y': p[1]} for p in path_result]\n        print(json.dumps(path_json))"
  },
  "get_impassable_tiles": {
    "description": "Extracts and returns a JSON list of all impassable tile coordinates from the current map XML.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET; import json; root = ET.fromstring(map_xml_string); impassable_tiles = []; for row_elem in root.findall('Row'): y = int(row_elem.get('id')); for tile_elem in row_elem.findall('Tile'): x = int(tile_elem.get('id')); if tile_elem.get('type') == 'impassable' or tile_elem.find('Object') is not None: impassable_tiles.append({'x': x, 'y': y}); print(json.dumps(impassable_tiles))"
  }
}