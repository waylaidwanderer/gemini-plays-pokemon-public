{
  "find_path": {
    "description": "Finds a path from the player's current position to a target coordinate using BFS. Returns a JSON list of coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string",
          "description": "Target X coordinate"
        },
        "target_y": {
          "type": "string",
          "description": "Target Y coordinate"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntarget_x = int(input_data['target_x'])\ntarget_y = int(input_data['target_y'])\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.attrib['width'])\nheight = int(root.attrib['height'])\n\n# Parse map to grid\ngrid = {}\nstart_pos = None\n\nfor row in root.findall('Row'):\n    y = int(row.attrib['id'])\n    for tile in row.findall('Tile'):\n        x = int(tile.attrib['id'])\n        tile_type = tile.attrib.get('type', 'WALL')\n        has_object = tile.attrib.get('has-object', 'false') == 'true'\n        \n        # Check for player\n        if tile.find('Player') is not None:\n            start_pos = (x, y)\n            \n        # Determine passability\n        # Basic passability: Not a wall, no object.\n        # Note: We allow the target tile to be \"impassable\" (e.g. interacting with an object/wall)\n        # so the path can lead UP TO it.\n        is_passable = (tile_type != 'WALL') and (not has_object)\n        \n        grid[(x, y)] = is_passable\n\nif start_pos is None:\n    print(json.dumps([]))\n    exit()\n\n# BFS\nqueue = [[start_pos]]\nvisited = {start_pos}\nfound_path = []\n\nwhile queue:\n    path = queue.pop(0)\n    current = path[-1]\n    \n    if current == (target_x, target_y):\n        found_path = path\n        break\n    \n    # Neighbors (Up, Down, Left, Right)\n    neighbors = [\n        (current[0], current[1] - 1),\n        (current[0], current[1] + 1),\n        (current[0] - 1, current[1]),\n        (current[0] + 1, current[1])\n    ]\n    \n    for next_node in neighbors:\n        if next_node in grid and next_node not in visited:\n            # We can move to the tile if it is passable OR if it is the final target (to bump/interact)\n            if grid[next_node] or next_node == (target_x, target_y):\n                visited.add(next_node)\n                new_path = list(path)\n                new_path.append(next_node)\n                queue.append(new_path)\n\n# Convert to required output format\noutput = []\nif found_path:\n    for p in found_path:\n        output.append({\"x\": p[0], \"y\": p[1]})\n\nprint(json.dumps(output))",
    "history": [
      {
        "commit_message": "feat: Initial implementation of find_path using BFS.",
        "timestamp": "2025-11-14T03:04:04.417Z",
        "action_counter": 47
      },
      {
        "commit_message": "feat: Initial implementation of find_path using BFS.",
        "timestamp": "2025-11-14T03:12:22.011Z",
        "action_counter": 55
      }
    ]
  },
  "spam_button": {
    "description": "Generates a sequence of button presses to be executed automatically. Useful for mashing through text or menus. Can optionally include delays.",
    "input_schema": {
      "type": "object",
      "properties": {
        "button": {
          "type": "string",
          "enum": [
            "A",
            "B",
            "Start",
            "Select",
            "Up",
            "Down",
            "Left",
            "Right"
          ]
        },
        "times": {
          "type": "integer",
          "minimum": 1,
          "maximum": 20
        },
        "delay_ms": {
          "type": "integer",
          "default": 0,
          "maximum": 500
        }
      },
      "required": [
        "button",
        "times"
      ]
    },
    "python_script": "import json\nbutton = input_data['button']\ntimes = int(input_data['times'])\ndelay = int(input_data.get('delay_ms', 0))\n\npresses = []\nfor _ in range(times):\n    presses.append(button)\n    if delay > 0:\n        presses.append(f\"sleep {delay}\")\n\nprint(json.dumps(presses))",
    "history": [
      {
        "commit_message": "Initial definition of spam_button tool.",
        "timestamp": "2025-11-14T03:00:03.455Z",
        "action_counter": 42
      }
    ]
  },
  "find_nearest_unseen": {
    "description": "Scans the map for 'unseen' tiles and uses BFS to find the nearest one that is reachable from the player's current position. Returns the coordinate of the target tile, or null if none are reachable.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.attrib['width'])\nheight = int(root.attrib['height'])\n\ngrid = {}\nunseen_tiles = set()\nstart_pos = None\n\nfor row in root.findall('Row'):\n    y = int(row.attrib['id'])\n    for tile in row.findall('Tile'):\n        x = int(tile.attrib['id'])\n        tile_type = tile.attrib.get('type', 'WALL')\n        is_unseen = tile.attrib.get('type') == 'unseen'\n        has_object = tile.attrib.get('has-object', 'false') == 'true'\n        \n        # Player position\n        if tile.find('Player') is not None:\n            start_pos = (x, y)\n            \n        # Passability (Allow walking on unseen for the purpose of 'finding' them)\n        # We consider unseen tiles as valid targets, so they are 'passable' for the *last* step\n        is_passable = (tile_type != 'WALL' and tile_type != 'VOID' and not has_object)\n        \n        grid[(x, y)] = is_passable\n        if is_unseen:\n            unseen_tiles.add((x, y))\n            grid[(x, y)] = True # Unseen tiles are potentially passable targets\n\nif start_pos is None:\n    print(json.dumps(None))\n    exit()\n\n# BFS\nqueue = [[start_pos]]\nvisited = {start_pos}\n\nwhile queue:\n    path = queue.pop(0)\n    current = path[-1]\n    \n    if current in unseen_tiles:\n        print(json.dumps({'x': current[0], 'y': current[1]}))\n        exit()\n    \n    neighbors = [\n        (current[0], current[1] - 1),\n        (current[0], current[1] + 1),\n        (current[0] - 1, current[1]),\n        (current[0] + 1, current[1])\n    ]\n    \n    for next_node in neighbors:\n        if next_node in grid and next_node not in visited:\n            if grid[next_node]:\n                visited.add(next_node)\n                new_path = list(path)\n                new_path.append(next_node)\n                queue.append(new_path)\n\nprint(json.dumps(None))",
    "history": [
      {
        "commit_message": "feat: Add find_nearest_unseen tool for automated exploration.",
        "timestamp": "2025-11-14T07:06:30.308Z",
        "action_counter": 207
      }
    ]
  },
  "check_reachability": {
    "description": "Determines which of the provided target coordinates are reachable from the current position using BFS. Useful for filtering lists of potential exploration targets. Returns a JSON list of reachable target objects.",
    "input_schema": {
      "type": "object",
      "properties": {
        "targets": {
          "type": "string",
          "description": "A JSON string representing a list of target objects, e.g. '[{\"x\": 1, \"y\": 2}]'"
        },
        "current_x": {
          "type": "integer"
        },
        "current_y": {
          "type": "integer"
        }
      },
      "required": [
        "targets",
        "current_x",
        "current_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\n# Parse inputs\ntargets = json.loads(input_data['targets'])\nstart_x = int(input_data['current_x'])\nstart_y = int(input_data['current_y'])\n\nroot = ET.fromstring(map_xml_string)\n\n# Build grid of passable tiles\ngrid = set()\nimpassable_types = {'WALL', 'HEADBUTT_TREE', 'WATER', 'DOOR', 'PC', 'TV', 'WINDOW', 'BOOKSHELF', 'VOID'}\n\nfor row in root.findall('Row'):\n    y = int(row.attrib['id'])\n    for tile in row.findall('Tile'):\n        x = int(tile.attrib['id'])\n        t_type = tile.attrib.get('type', 'WALL')\n        has_object = tile.attrib.get('has-object', 'false') == 'true'\n        \n        # Basic passability check\n        if t_type not in impassable_types and not has_object:\n            grid.add((x, y))\n\n# BFS to find all reachable tiles from start\nqueue = [(start_x, start_y)]\nvisited = {(start_x, start_y)}\n\nwhile queue:\n    curr_x, curr_y = queue.pop(0)\n    \n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nx, ny = curr_x + dx, curr_y + dy\n        if (nx, ny) in grid and (nx, ny) not in visited:\n            visited.add((nx, ny))\n            queue.append((nx, ny))\n\n# Filter targets\nreachable_targets = []\ntarget_set = {(t['x'], t['y']) for t in targets}\n\nfor t in targets:\n    if (t['x'], t['y']) in visited:\n        reachable_targets.append(t)\n\nprint(json.dumps(reachable_targets))",
    "history": [
      {
        "commit_message": "feat: Add check_reachability tool to filter target coordinates based on map accessibility.",
        "timestamp": "2025-11-14T07:46:43.297Z",
        "action_counter": 260
      }
    ]
  }
}