{
  "sequence_press": {
    "description": "Executes a sequence of button presses to navigate menus or perform actions. Allows mixing directional and action buttons.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\ntry:\n    buttons = input_data['buttons']\n    print(json.dumps(buttons))\nexcept KeyError:\n    print(\"Error: 'buttons' key not found in input_data\")\n    print(f\"input_data keys: {input_data.keys()}\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T08:10:06.907Z",
        "action_counter": 33328
      },
      {
        "commit_message": "Initial definition of sequence_press tool",
        "timestamp": "2026-01-11T10:39:20.952Z",
        "action_counter": 33514
      },
      {
        "commit_message": "Debugging tool to find variable injection method",
        "timestamp": "2026-01-11T10:41:14.927Z",
        "action_counter": 33517
      },
      {
        "commit_message": "Fix variable access by using input_data dictionary",
        "timestamp": "2026-01-11T10:43:22.032Z",
        "action_counter": 33520
      }
    ]
  },
  "pathfind": {
    "description": "Finds a path from the player's current position to a target coordinate using BFS. Returns a list of coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "target_x",
        "target_y",
        "autopress_buttons"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\nimport json\nimport sys\n\n# Retrieve arguments from input_data\nargs = globals().get('input_data', {})\nt_x = args.get('target_x')\nt_y = args.get('target_y')\nautopress = args.get('autopress_buttons', False)\n\n# Fallback for direct injection\nif t_x is None: t_x = globals().get('target_x')\nif t_y is None: t_y = globals().get('target_y')\nif autopress is None: autopress = globals().get('autopress_buttons', False)\n\ndef get_path(map_xml, t_x, t_y, autopress):\n    if t_x is None or t_y is None:\n        return {\"error\": \"Missing target coordinates\"}\n        \n    try:\n        root = ET.fromstring(map_xml)\n        width = int(root.attrib['width'])\n        height = int(root.attrib['height'])\n        grid = [[False for _ in range(height)] for _ in range(width)]\n        player_pos = None\n        \n        traversable_types = {\n            'FLOOR', 'TALL_GRASS', 'SAND', 'PATH', 'SNOW', 'ICE', 'CARPET', 'MAT',\n            'STAIRS', 'GRASS', 'LONG_GRASS', 'BRIDGE', 'CAVE_FLOOR', 'PUDDLE', 'DIRT',\n            'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'WARP_CARPET_UP', 'WARP_CARPET_DOWN',\n            'WARP_CARPET_ENTRY', 'DOOR'\n        }\n        \n        # Iterate Rows then Tiles\n        for row in root.findall(\"Row\"):\n            y = int(row.attrib['id'])\n            for tile in row.findall(\"Tile\"):\n                x = int(tile.attrib['id'])\n                t_type = tile.attrib['type']\n                \n                is_walkable = t_type in traversable_types\n                \n                # Objects block (except Player, handled below)\n                if tile.find(\"Object\") is not None:\n                    is_walkable = False\n                \n                # Check for Player (overrides Object check if Player is the object, \n                # but Player is usually a separate child tag <Player />)\n                if tile.find(\"Player\") is not None:\n                    player_pos = (x, y)\n                    is_walkable = True\n\n                if 0 <= x < width and 0 <= y < height:\n                    grid[x][y] = is_walkable\n\n        if not player_pos:\n            return {\"error\": \"Player not found\"}\n        \n        queue = collections.deque([[player_pos]])\n        visited = {player_pos}\n        found_path = None\n        \n        while queue:\n            path = queue.popleft()\n            curr_x, curr_y = path[-1]\n            if curr_x == t_x and curr_y == t_y:\n                found_path = path\n                break\n            \n            for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                nx, ny = curr_x + dx, curr_y + dy\n                if 0 <= nx < width and 0 <= ny < height:\n                    if grid[nx][ny] and (nx, ny) not in visited:\n                        visited.add((nx, ny))\n                        new_path = list(path)\n                        new_path.append((nx, ny))\n                        queue.append(new_path)\n\n        if found_path:\n            buttons = []\n            if autopress:\n                for i in range(len(found_path) - 1):\n                    cx, cy = found_path[i]\n                    nx, ny = found_path[i+1]\n                    if nx > cx: buttons.append(\"Right\")\n                    elif nx < cx: buttons.append(\"Left\")\n                    elif ny > cy: buttons.append(\"Down\")\n                    elif ny < cy: buttons.append(\"Up\")\n                print(json.dumps(buttons))\n            return [list(p) for p in found_path]\n        else:\n            return {\"error\": \"No path found\"}\n\n    except Exception as e:\n        return {\"error\": str(e)}\n\nresult = get_path(map_xml_string, t_x, t_y, autopress)\nif not autopress and \"error\" not in result:\n    print(json.dumps(result))\nelif \"error\" in result:\n    print(json.dumps(result))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T09:01:19.563Z",
        "action_counter": 33384
      },
      {
        "commit_message": "Fixed NameError by using globals().get() to safely retrieve injected arguments. Added autopress_buttons support.",
        "timestamp": "2026-01-11T16:48:12.265Z",
        "action_counter": 34015
      },
      {
        "commit_message": "Refined JSON output compliance using json.dumps to avoid parsing errors.",
        "timestamp": "2026-01-11T16:49:46.390Z",
        "action_counter": 34017
      },
      {
        "commit_message": "Added debug logic to inspect available variables if arguments are missing.",
        "timestamp": "2026-01-11T16:50:53.134Z",
        "action_counter": 34018
      },
      {
        "commit_message": "Updated to retrieve arguments from `input_data` global dictionary.",
        "timestamp": "2026-01-11T16:51:34.865Z",
        "action_counter": 34019
      },
      {
        "commit_message": "Fixed XML parsing logic to correctly iterate Rows and Tiles instead of using unsupported '..' XPath.",
        "timestamp": "2026-01-11T16:52:03.375Z",
        "action_counter": 34020
      },
      {
        "commit_message": "Added WARP_CARPET_* and DOOR types to traversable list.",
        "timestamp": "2026-01-11T17:10:57.545Z",
        "action_counter": 34044
      }
    ]
  },
  "zigzag_sweep": {
    "description": "Generates and executes a zigzag button sequence to sweep a rectangular area. Useful for hunting in grass patches.",
    "input_schema": {
      "type": "object",
      "properties": {
        "cols": {
          "type": "integer",
          "description": "Number of columns (width) of the area."
        },
        "rows": {
          "type": "integer",
          "description": "Number of rows (height) of the area."
        },
        "start_side": {
          "type": "string",
          "enum": [
            "left",
            "right"
          ],
          "default": "left",
          "description": "The side you are starting on. 'left' means Top-Left, 'right' means Top-Right."
        }
      },
      "required": [
        "cols",
        "rows"
      ]
    },
    "python_script": "import json\n\nbuttons = []\ncols = int(input_data['cols'])\nrows = int(input_data['rows'])\nstart_side = input_data.get('start_side', 'left')\n\nfor r in range(rows):\n    if start_side == 'left':\n        # Even rows (0, 2): Right\n        # Odd rows (1, 3): Left\n        direction = 'Right' if r % 2 == 0 else 'Left'\n    else:\n        # Even rows (0, 2): Left\n        # Odd rows (1, 3): Right\n        direction = 'Left' if r % 2 == 0 else 'Right'\n        \n    for _ in range(cols - 1):\n        buttons.append(direction)\n        \n    if r < rows - 1:\n        buttons.append('Down')\n\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T19:32:17.062Z",
        "action_counter": 34231
      }
    ]
  },
  "sweep_route37": {
    "description": "Executes a fixed button sequence to sweep the northern grass patch of Route 37 and return to the gate. Assumes starting position at (8,0). Sequence: Down x2, Right, Down x3, Left x3, Up x3, Right x2, Up x2.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "python_script": "print('[\"Down\", \"Down\", \"Right\", \"Down\", \"Down\", \"Down\", \"Left\", \"Left\", \"Left\", \"Up\", \"Up\", \"Up\", \"Right\", \"Right\", \"Up\", \"Up\"]')",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T23:17:43.369Z",
        "action_counter": 34561
      }
    ]
  },
  "check_roamer_map": {
    "description": "From the Pokegear main menu (assuming cursor is on BACK), navigates to the Map card, opens it, waits 3 seconds for viewing, then exits back to the Overworld.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "python_script": "print('[\"Right\", \"sleep 500\", \"A\", \"sleep 3000\", \"B\", \"sleep 500\", \"B\"]')",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-12T00:14:14.818Z",
        "action_counter": 34655
      }
    ]
  }
}