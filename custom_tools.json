{
  "find_path_v4": {
    "description": "Finds the shortest path to a target coordinate. Correctly handles walls, NPCs, and items. Returns a JSON array of button strings if autopress_buttons is true.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef run():\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    \n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    # Get player position\n    start_x = -1\n    start_y = -1\n    for row in root.findall(\"Row\"):\n        tile = row.find(\"Tile[Player]\")\n        if tile is not None:\n            start_x = int(tile.get('id'))\n            start_y = int(row.get('id'))\n            break\n            \n    if start_x == -1:\n        print(json.dumps([]))\n        return\n\n    queue = deque([(start_x, start_y, [])])\n    visited = set([(start_x, start_y)])\n    \n    while queue:\n        curr_x, curr_y, path = queue.popleft()\n        \n        if curr_x == target_x and curr_y == target_y:\n            print(json.dumps(path))\n            return\n\n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = curr_x + dx, curr_y + dy\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:\n                tile = root.find(f\".//Row[@id='{ny}']/Tile[@id='{nx}']\")\n                if tile is not None and tile.get('type') == 'FLOOR' and not tile.get('has-object') == 'true':\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [btn]))\n\n    print(json.dumps([]))\n\nrun()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-21T06:11:17.104Z",
        "action_counter": 8161
      },
      {
        "commit_message": "Fixed find_path_v4: removed non-standard getparent() call and improved player position detection. Consolidated grid construction and BFS.",
        "timestamp": "2025-12-21T06:23:10.110Z",
        "action_counter": 8180
      },
      {
        "commit_message": "Ensure tool correctly returns a list of button strings for overworld navigation when autopress_buttons is true. Fixes previous formatting issues.",
        "timestamp": "2025-12-22T02:53:22.052Z",
        "action_counter": 10751
      },
      {
        "commit_message": "Fix player position detection in find_path_v4 to avoid TypeError when start_row is not found via XPath. Use a more robust loop-based approach.",
        "timestamp": "2025-12-22T02:54:08.460Z",
        "action_counter": 10753
      }
    ]
  },
  "battle_move_selector_v2": {
    "description": "Selects a move from the move selection menu in battle. Assumes the move selection menu is open. Calculates the shortest path between current_index and target_index in a wrapping menu of 4 moves. Includes an initial 1000ms safety delay.",
    "input_schema": {
      "type": "object",
      "properties": {
        "current_index": {
          "type": "integer",
          "description": "The current 0-indexed position of the cursor in the move menu."
        },
        "target_index": {
          "type": "integer",
          "description": "The 0-indexed position of the move to select (0-3)."
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "current_index",
        "target_index",
        "autopress_buttons"
      ]
    },
    "python_script": "import json\n\ndef main(input_data):\n    current = int(input_data['current_index'])\n    target = int(input_data['target_index'])\n    \n    # The menu is 2x2:\n    # 0 1\n    # 2 3\n    \n    path = []\n    # Initial safety delay\n    path.append(\"sleep 1000\")\n    \n    # Move vertically if needed\n    if (current // 2) != (target // 2):\n        path.append(\"Down\") # Down and Up are equivalent in a 2-row wrap\n        current = (current + 2) % 4\n        \n    # Move horizontally if needed\n    if (current % 2) != (target % 2):\n        path.append(\"Right\") # Right and Left are equivalent in a 2-column wrap\n        \n    path.append(\"A\")\n    print(json.dumps(path))\n\n# The harness provides input_data\nif __name__ == \"__main__\":\n    import sys\n    import json\n    # input_data is provided by the harness\n    main(input_data)\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-21T11:41:54.981Z",
        "action_counter": 8762
      },
      {
        "commit_message": "Corrected tool to use the 'input_data' variable for arguments instead of reading from stdin.",
        "timestamp": "2025-12-21T11:46:11.447Z",
        "action_counter": 8774
      },
      {
        "commit_message": "Added a safety delay (sleep 500) to ensure the move selection menu is fully active before button presses.",
        "timestamp": "2025-12-21T14:19:46.168Z",
        "action_counter": 9031
      },
      {
        "commit_message": "Fixed the tool by adding the necessary 'run(input_data)' call at the end of the script and added a cursor reset (3 Ups) to ensure it starts from move 0.",
        "timestamp": "2025-12-21T14:21:30.713Z",
        "action_counter": 9035
      },
      {
        "commit_message": "Increased initial safety delay to 1000ms to handle menu opening animations and added a 300ms delay after each move selection button to prevent input dropping.",
        "timestamp": "2025-12-21T14:22:49.888Z",
        "action_counter": 9037
      },
      {
        "commit_message": "Removed the faulty 'Up' reset logic which caused misclicks due to menu wrapping. Now relies on Gen 2's default behavior of resetting the cursor to 0 on menu open.",
        "timestamp": "2025-12-21T14:28:43.731Z",
        "action_counter": 9045
      },
      {
        "commit_message": "Re-added cursor reset (Up, Up, Up) with safety delays. In Gen 2, the move selection menu does NOT wrap, making this a reliable way to ensure the tool starts from move 0 even if the menu was already open.",
        "timestamp": "2025-12-21T14:31:21.406Z",
        "action_counter": 9048
      },
      {
        "commit_message": "Removed the faulty 'Up' reset logic and added a clear explanation in the description that the tool assumes the cursor starts at move index 0. This is necessary because the Gen 2 move menu wraps, making 'Up' resets unreliable.",
        "timestamp": "2025-12-21T14:32:49.857Z",
        "action_counter": 9049
      },
      {
        "commit_message": "Refined battle_move_selector_v2 to handle Gen 2's menu wrapping and memory. It now takes both current_index and target_index to calculate the most efficient path (Up or Down). Added safety delays.",
        "timestamp": "2025-12-21T14:44:07.047Z",
        "action_counter": 9061
      },
      {
        "commit_message": "Initial definition of battle move selector.",
        "timestamp": "2025-12-21T16:45:38.503Z",
        "action_counter": 9332
      }
    ]
  },
  "check_reachable_unseen_v1": {
    "description": "Finds all unseen tiles adjacent to reachable walkable tiles on the current map. Relies on verified traversable tile types from the notepad. Returns a list of coordinate dictionaries.",
    "input_schema": {
      "type": "object",
      "properties": {
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "autopress_buttons"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\n\ndef main():\n    # map_xml_string is automatically provided by the harness\n    root = ET.fromstring(map_xml_string)\n    \n    # Based on the notepad, these are traversable\n    walkable_types = [\"FLOOR\", \"STAIRCASE\", \"WARP_CARPET\", \"LADDER\"]\n    reachable_unseen = []\n    \n    # Create a lookup for tiles\n    tiles = {}\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tiles[(x, y)] = tile\n\n    # Find unseen tiles adjacent to seen walkable tiles\n    for (x, y), tile in tiles.items():\n        if tile.get('seen') == 'false':\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                neighbor = tiles.get((x + dx, y + dy))\n                if neighbor is not None and neighbor.get('seen') == 'true' and neighbor.get('type') in walkable_types:\n                    reachable_unseen.append({\"x\": x, \"y\": y})\n                    break\n    \n    print(json.dumps(reachable_unseen))\n\nif __name__ == \"__main__\":\n    main()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-21T13:00:01.847Z",
        "action_counter": 8888
      },
      {
        "commit_message": "Updated to find the map where the player is currently located and better handle traversable types.",
        "timestamp": "2025-12-21T13:01:21.398Z",
        "action_counter": 8891
      },
      {
        "commit_message": "Fixed map node detection to handle both <Map> as root or as a child of <MentalMap>.",
        "timestamp": "2025-12-21T13:01:56.860Z",
        "action_counter": 8892
      },
      {
        "commit_message": "Updated traversable types to include all WARP_CARPET variants and added a more robust player position detection.",
        "timestamp": "2025-12-21T15:01:02.663Z",
        "action_counter": 9075
      },
      {
        "commit_message": "Fixing tool definition by adding mandatory commit message.",
        "timestamp": "2025-12-21T15:48:45.536Z",
        "action_counter": 9183
      },
      {
        "commit_message": "Refining check_reachable_unseen_v1 to be more robust and handle potential edge cases in map XML parsing.",
        "timestamp": "2025-12-21T16:18:22.240Z",
        "action_counter": 9241
      },
      {
        "commit_message": "Initial definition of reachable unseen tile checker.",
        "timestamp": "2025-12-21T16:45:38.502Z",
        "action_counter": 9332
      }
    ]
  },
  "find_object_by_name_v1": {
    "description": "Finds the coordinates of map objects or background objects that match a given name. Returns a list of matches with their x, y, and type.",
    "input_schema": {
      "type": "object",
      "properties": {
        "object_name": {
          "type": "string",
          "description": "The name (or part of the name) of the object to find."
        }
      },
      "required": [
        "object_name"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\n\ndef main(input_data):\n    # map_xml_string is automatically provided by the harness\n    root = ET.fromstring(map_xml_string)\n    target_name = input_data['object_name'].upper()\n    results = []\n    \n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            \n            # Check Map Objects (NPCs, items)\n            for obj in tile.findall('Object'):\n                obj_name = obj.get('id-name', '').upper()\n                if target_name in obj_name:\n                    results.append({\"name\": obj.get('id-name'), \"x\": x, \"y\": y, \"type\": \"MapObject\"})\n                    \n            # Check Background Objects (Signs, PCs, Vending Machines)\n            bg_obj_name = tile.get('name', '').upper()\n            if target_name in bg_obj_name:\n                results.append({\"name\": tile.get('name'), \"x\": x, \"y\": y, \"type\": \"BackgroundObject\"})\n                \n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main(input_data)\n",
    "history": [
      {
        "commit_message": "Defining tool to find object coordinates by name.",
        "timestamp": "2025-12-21T16:55:46.570Z",
        "action_counter": 9353
      }
    ]
  },
  "shutter_status_report_v2": {
    "description": "Reports the status of the shutters in the Goldenrod Underground Switch Room. Scans Rows 6, 7, and 8 and prints whether each shutter tile is OPEN (FLOOR) or CLOSED (WALL).",
    "input_schema": {},
    "python_script": "import json\nimport xml.etree.ElementTree as ET\n\ndef run():\n    root = ET.fromstring(map_xml_string)\n    shutters = [(2, 6), (3, 6), (10, 6), (16, 6), (17, 6), (16, 7), (17, 7), (6, 8), (12, 8)]\n    report = {}\n    for x, y in shutters:\n        tile = root.find(f\".//Row[@id='{y}']/Tile[@id='{x}']\")\n        state = 'UNKNOWN'\n        if tile is not None:\n            state = 'OPEN' if tile.get('type') == 'FLOOR' else 'CLOSED'\n        report[f'({x}, {y})'] = state\n    \n    # Print the object for manual review\n    print(json.dumps(report, indent=2))\n    # Print an empty list for autopress_buttons compatibility\n    print(json.dumps([]))\n\nrun()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-22T00:23:40.610Z",
        "action_counter": 10387
      },
      {
        "commit_message": "Fixing XPath predicate error by using manual search for Player position.",
        "timestamp": "2025-12-22T00:27:21.579Z",
        "action_counter": 10397
      },
      {
        "commit_message": "Added scanning for Row 7 and comprehensive floor tile check to better detect open paths.",
        "timestamp": "2025-12-22T02:13:13.065Z",
        "action_counter": 10646
      },
      {
        "commit_message": "Removed hallucinated Row 7 shutters and focused on dynamic shutter tiles in Rows 6 and 8.",
        "timestamp": "2025-12-22T02:18:18.411Z",
        "action_counter": 10657
      },
      {
        "commit_message": "Fix JSON formatting error and remove unnecessary header to allow for clean parsing.",
        "timestamp": "2025-12-22T02:36:31.645Z",
        "action_counter": 10713
      },
      {
        "commit_message": "Fix JSON output format for compatibility with autopress_buttons.",
        "timestamp": "2025-12-22T02:45:25.686Z",
        "action_counter": 10734
      },
      {
        "commit_message": "Add dynamic shutter tiles at (16, 7) and (17, 7) to the status report.",
        "timestamp": "2025-12-22T03:12:33.832Z",
        "action_counter": 10801
      }
    ]
  }
}