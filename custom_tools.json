{
  "find_path": {
    "description": "Finds a path from a start to an end coordinate on the current map using the Breadth-First Search (BFS) algorithm.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef find_path_logic(map_xml_string, start_x, start_y, end_x, end_y):\n    root = ET.fromstring(map_xml_string)\n    IMPASSABLE_TILES = {\"WALL\", \"WATER\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"COUNTER\", \"TV\", \"BOOKSHELF\", \"RADIO\", \"TOWN_MAP\", \"WINDOW\", \"PC\"}\n    \n    grid = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            has_object = tile_elem.find('Object') is not None and tile_elem.find('Player') is None\n            is_impassable = tile_type in IMPASSABLE_TILES or has_object or tile_type == 'unseen'\n            grid[(x, y)] = not is_impassable\n\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n\n    if not grid.get(start_node, False):\n        return None\n\n    if not grid.get(end_node, False):\n        found_alternate = False\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            temp_end = (end_node[0] + dx, end_node[1] + dy)\n            if grid.get(temp_end, False):\n                end_node = temp_end\n                found_alternate = True\n                break\n        if not found_alternate:\n            return None\n\n    queue = deque([(start_node, [start_node])])\n    visited = {start_node}\n\n    while queue:\n        current, path = queue.popleft()\n        if current == end_node:\n            return path\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if grid.get(neighbor, False) and neighbor not in visited:\n                visited.add(neighbor)\n                new_path = list(path)\n                new_path.append(neighbor)\n                queue.append((neighbor, new_path))\n\n    return None\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\npath = find_path_logic(map_xml_string, start_x, start_y, end_x, end_y)\nif path:\n    print(json.dumps([{\"x\": p[0], \"y\": p[1]} for p in path]))\nelse:\n    print(\"No path found.\")\n",
    "history": [
      {
        "commit_message": "feat: Re-implement find_path tool from scratch. This is a complete rewrite of the A* algorithm to establish a simple, correct, and reliable foundation for navigation. This version handles basic impassable tiles and objects but omits complex logic for ledges and other special tiles, which will be added back incrementally after this core logic is proven to be stable. This action is a direct response to repeated tool failures and strategic critiques.",
        "timestamp": "2025-11-21T16:47:36.389Z",
        "action_counter": 4881
      },
      {
        "commit_message": "fix: Re-commit find_path tool. A debug trace via run_code confirmed the algorithm's logic is correct. The previous failure was likely due to a transient error during the initial tool definition. This commit re-establishes the known-good code to ensure reliable pathfinding.",
        "timestamp": "2025-11-21T16:49:59.218Z",
        "action_counter": 4886
      },
      {
        "commit_message": "fix: Add 'PC' to the set of impassable tiles. The pathfinder was incorrectly treating PC tiles as traversable, causing it to get stuck in an alcove in the Pokecenter2F. This fix correctly blocks paths through PCs.",
        "timestamp": "2025-11-21T17:02:02.801Z",
        "action_counter": 4915
      },
      {
        "commit_message": "refactor: Complete rewrite of the A* algorithm. The previous implementation had a persistent, subtle bug causing intermittent failures. This version is a textbook implementation, focusing on core correctness and removing complex logic like ledge handling for now. This establishes a reliable foundation to build upon.",
        "timestamp": "2025-11-21T17:03:13.635Z",
        "action_counter": 4917
      },
      {
        "commit_message": "fix: Correct A* open_set initialization. The open_set was being initialized with an f_score of 0 instead of the correct heuristic value, causing the algorithm to fail on complex paths. This fix ensures the starting node is correctly prioritized.",
        "timestamp": "2025-11-21T17:04:12.483Z",
        "action_counter": 4919
      },
      {
        "commit_message": "fix: Correct g_score lookup in A* algorithm. The g_score for the current node was being retrieved with a default value, which could lead to incorrect path costs. This fix ensures the g_score is always retrieved directly from the dictionary, preventing this potential bug.",
        "timestamp": "2025-11-21T17:11:15.358Z",
        "action_counter": 4933
      },
      {
        "commit_message": "fix: Correct g_score lookup in A* algorithm. The g_score for the current node was still being retrieved with a default value, which was incorrect and caused pathing failures. This fix ensures the g_score is always retrieved directly from the dictionary.",
        "timestamp": "2025-11-21T17:15:48.132Z",
        "action_counter": 4942
      },
      {
        "commit_message": "fix: Correct A* initialization logic. The previous implementation pre-populated the g_score and f_score dictionaries for all map tiles, which caused a latent bug preventing pathfinding on a valid path. This fix changes the initialization to be sparse, only adding the start_node initially, which is the standard and correct approach for A*. This resolves the critical pathfinding failure.",
        "timestamp": "2025-11-21T21:15:37.270Z",
        "action_counter": 5508
      },
      {
        "commit_message": "refactor: Add debug prints to A* algorithm. The pathfinder is failing on a visually clear path. This change adds extensive logging to trace the algorithm's execution, including the start/end nodes, alternate target selection, and a step-by-step log of visited nodes. This will help identify the logical error causing the failure.",
        "timestamp": "2025-11-21T22:55:10.281Z",
        "action_counter": 5746
      },
      {
        "commit_message": "refactor: Complete rewrite of the A* algorithm. The previous implementation had a persistent, subtle bug causing intermittent failures. This version is a textbook implementation, focusing on core correctness and removing complex logic like ledge handling for now. This establishes a reliable foundation to build upon.",
        "timestamp": "2025-11-21T22:56:18.708Z",
        "action_counter": 5747
      },
      {
        "commit_message": "fix: Correct A* algorithm logic. The previous implementation incorrectly used a hash set to prevent re-adding nodes to the priority queue, which is a flawed optimization. This prevented the algorithm from updating node priorities when a shorter path was found. The fix removes the hash set and allows nodes to be re-added to the heap with their new, lower f-scores, ensuring the algorithm can correctly explore optimal paths. This was identified by the python_code_debugger agent.",
        "timestamp": "2025-11-21T23:11:44.883Z",
        "action_counter": 5778
      },
      {
        "commit_message": "fix: Add closed set to A* algorithm. The previous implementation, while theoretically sound, was failing on this map. The debugger agent identified that the lack of a closed set to track fully processed nodes was causing the algorithm to get stuck in inefficient loops. This fix introduces a `closed_set` to ensure each node is processed only once via its optimal path, making the algorithm more robust and preventing these failures.",
        "timestamp": "2025-11-21T23:17:55.092Z",
        "action_counter": 5785
      },
      {
        "commit_message": "refactor: Complete rewrite of pathfinder using Breadth-First Search (BFS). The previous A* implementation was persistently buggy and deemed unsalvageable by system critiques. This new implementation uses the simpler and more robust BFS algorithm to ensure reliable pathfinding on this unweighted grid. This is a foundational reset to restore core navigation capabilities.",
        "timestamp": "2025-11-21T23:20:22.613Z",
        "action_counter": 5791
      }
    ]
  },
  "find_reachable_unseen_tiles": {
    "description": "Analyzes the current map to find all 'unseen' tiles that are adjacent to traversable tiles and reachable from the player's current position. Returns a list of coordinates for these tiles.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\nroot = ET.fromstring(map_xml_string)\nIMPASSABLE_TILES = {\"WALL\", \"WATER\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"COUNTER\", \"TV\", \"BOOKSHELF\", \"RADIO\", \"TOWN_MAP\", \"WINDOW\", \"PC\"}\n\ngrid = {}\nunseen_tiles = []\nstart_node = None\n\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.get('id'))\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.get('id'))\n        tile_type = tile_elem.get('type')\n        \n        if tile_elem.find('Player') is not None:\n            start_node = (x, y)\n            \n        if tile_type == 'unseen':\n            unseen_tiles.append((x, y))\n        \n        has_object = tile_elem.find('Object') is not None and tile_elem.find('Player') is None\n        is_impassable = tile_type in IMPASSABLE_TILES or has_object or tile_type == 'unseen'\n        grid[(x, y)] = not is_impassable\n\nif not start_node:\n    print(json.dumps([]))\nelse:\n    queue = deque([start_node])\n    reachable_tiles = {start_node}\n\n    while queue:\n        current = queue.popleft()\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if grid.get(neighbor, False) and neighbor not in reachable_tiles:\n                reachable_tiles.add(neighbor)\n                queue.append(neighbor)\n    \n    reachable_unseen = set()\n    for tile in reachable_tiles:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (tile[0] + dx, tile[1] + dy)\n            if neighbor in unseen_tiles:\n                reachable_unseen.add(neighbor)\n                \n    print(json.dumps([{\"x\": p[0], \"y\": p[1]} for p in sorted(list(reachable_unseen))]))",
    "history": [
      {
        "commit_message": "feat: Create tool to find reachable unseen tiles. This tool automates the process of identifying explorable areas by parsing the map, finding all unseen tiles, and using a BFS pathfinder to determine which ones are currently reachable from the player's position. This directly addresses a recurring system suggestion and will improve exploration efficiency.",
        "timestamp": "2025-11-21T18:40:14.393Z",
        "action_counter": 5140
      },
      {
        "commit_message": "fix: Correct pathfinding logic by treating 'unseen' tiles as impassable. The previous version allowed the BFS to path through unexplored areas, leading to incorrect reachability analysis. I also refactored the logic to perform a single BFS to find all reachable tiles first, then check which unseen tiles are adjacent to that area, which is more efficient.",
        "timestamp": "2025-11-21T19:55:55.594Z",
        "action_counter": 5345
      },
      {
        "commit_message": "feat: Create tool to find reachable unseen tiles. This tool automates the process of identifying explorable areas by parsing the map, finding all unseen tiles, and using a BFS pathfinder to determine which ones are currently reachable from the player's position. This directly addresses a recurring system suggestion and will improve exploration efficiency.",
        "timestamp": "2025-11-21T23:33:13.400Z",
        "action_counter": 5817
      }
    ]
  },
  "stealth_pathfinder": {
    "description": "Finds a path from a start to an end coordinate, avoiding a given list of 'forbidden' tiles representing NPC lines of sight.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "forbidden_tiles": {
          "type": "string",
          "description": "A JSON string of a list of [x, y] coordinates to avoid."
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "forbidden_tiles"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef find_path_logic(map_xml_string, start_x, start_y, end_x, end_y, forbidden_tiles_str):\n    root = ET.fromstring(map_xml_string)\n    IMPASSABLE_TILES = {\"WALL\", \"WATER\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"COUNTER\", \"TV\", \"BOOKSHELF\", \"RADIO\", \"TOWN_MAP\", \"WINDOW\", \"PC\"}\n    \n    try:\n        forbidden_tiles = {tuple(tile) for tile in json.loads(forbidden_tiles_str)}\n    except json.JSONDecodeError:\n        forbidden_tiles = set()\n\n    grid = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            has_object = tile_elem.find('Object') is not None and tile_elem.find('Player') is None\n            is_forbidden = (x, y) in forbidden_tiles\n            is_impassable = tile_type in IMPASSABLE_TILES or has_object or is_forbidden or tile_type == 'unseen'\n            grid[(x, y)] = not is_impassable\n\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n\n    if not grid.get(start_node, False):\n        return None\n\n    if not grid.get(end_node, False):\n        found_alternate = False\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            temp_end = (end_node[0] + dx, end_node[1] + dy)\n            if grid.get(temp_end, False):\n                end_node = temp_end\n                found_alternate = True\n                break\n        if not found_alternate:\n            return None\n\n    queue = deque([(start_node, [start_node])])\n    visited = {start_node}\n\n    while queue:\n        current, path = queue.popleft()\n        if current == end_node:\n            return path\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if grid.get(neighbor, False) and neighbor not in visited:\n                visited.add(neighbor)\n                new_path = list(path)\n                new_path.append(neighbor)\n                queue.append((neighbor, new_path))\n\n    return None\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\nforbidden_tiles_str = input_data['forbidden_tiles']\npath = find_path_logic(map_xml_string, start_x, start_y, end_x, end_y, forbidden_tiles_str)\nif path:\n    print(json.dumps([{\"x\": p[0], \"y\": p[1]} for p in path]))\nelse:\n    print(\"No path found.\")\n",
    "history": [
      {
        "commit_message": "feat: Create stealth_pathfinder tool. This tool adapts the existing BFS pathfinder to accept a list of 'forbidden' tiles, representing NPC lines of sight. This allows for proper testing of the stealth hypothesis for the B1F puzzle, breaking the current brute-force loop.",
        "timestamp": "2025-11-22T00:44:09.005Z",
        "action_counter": 5986
      }
    ]
  }
}