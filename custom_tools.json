{
  "unseen_tile_checker": {
    "description": "Analyzes the list of unseen tiles from a system alert and uses pathfinding logic to determine which are actually reachable from the player's current position.",
    "input_schema": {
      "type": "object",
      "properties": {
        "coordinates": {
          "type": "string",
          "description": "A stringified JSON array of coordinate objects, e.g., '[{\"x\":1,\"y\":2}]'"
        }
      },
      "required": [
        "coordinates"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET; from collections import deque; import json\n\ndef parse_map_xml(xml_string):\n    root = ET.fromstring(xml_string)\n    map_data = {}\n    map_data['width'] = int(root.attrib['width'])\n    map_data['height'] = int(root.attrib['height'])\n    map_data['tiles'] = {}\n    player_pos = None\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id'])\n            tile_type = tile_elem.attrib.get('type', 'unseen')\n            has_object = tile_elem.attrib.get('has-object') == 'true'\n            map_data['tiles'][(x, y)] = {'type': tile_type, 'has_object': has_object}\n            if tile_elem.find('Player') is not None:\n                player_pos = (x, y)\n    map_data['player_pos'] = player_pos\n    return map_data\n\ndef is_passable(x, y, dx, dy, map_data):\n    target_x, target_y = x + dx, y + dy\n    if not (1 <= target_x <= map_data['width'] and 1 <= target_y <= map_data['height']):\n        return False\n    target_tile = map_data['tiles'].get((target_x, target_y))\n    if not target_tile:\n        return False\n    current_tile = map_data['tiles'].get((x, y))\n    current_tile_type = current_tile.get('type') if current_tile else 'None'\n    target_tile_type = target_tile.get('type')\n    impassable_types = ['unseen', 'WALL', 'WINDOW', 'VOID', 'CUT_TREE', 'SIGN', 'BOOKSHELF', 'BLACKBOARD', 'MART_SHELF', 'BUOY', 'TV', 'TOWN_MAP', 'RADIO', 'INCENSE_BURNER', 'BIRD', 'HEADBUTT_TREE', 'FRUIT_TREE', 'COMPUTER', 'PRINTER', 'COUNTER', 'PC', 'WATER']\n    if target_tile_type in impassable_types:\n        return False\n    if target_tile.get('has_object'):\n        return False\n    if target_tile_type == 'LEDGE_HOP_DOWN' and dy != 1:\n        return False\n    if target_tile_type == 'LEDGE_HOP_RIGHT' and dx != 1:\n        return False\n    if target_tile_type == 'LEDGE_HOP_LEFT' and dx != -1:\n        return False\n    if current_tile_type == 'FLOOR' and target_tile_type == 'FLOOR_UP_WALL':\n        return False\n    if target_tile_type == 'FLOOR_UP_WALL' and dy == -1:\n        return False\n    return True\n\ndef find_path_bfs(start_pos, end_pos, map_data):\n    if not start_pos or not end_pos:\n        return None\n    queue = deque([[start_pos]])\n    visited = {start_pos}\n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n        if (x, y) == end_pos:\n            return path\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = x + dx, y + dy\n            if (next_x, next_y) not in visited and is_passable(x, y, dx, dy, map_data):\n                visited.add((next_x, next_y))\n                new_path = list(path)\n                new_path.append((next_x, next_y))\n                queue.append(new_path)\n    return None\n\nmap_data = parse_map_xml(map_xml_string)\nstart_pos = map_data.get('player_pos')\ncoordinates_to_check_str = input_data.get('coordinates')\nreachable_tiles = []\nif start_pos and coordinates_to_check_str:\n    try:\n        coordinates_to_check = json.loads(coordinates_to_check_str)\n        for coord in coordinates_to_check:\n            target_x = int(coord['x'])\n            target_y = int(coord['y'])\n            if find_path_bfs(start_pos, (target_x, target_y), map_data):\n                reachable_tiles.append(coord)\n    except (json.JSONDecodeError, TypeError):\n        pass # Ignore errors in parsing\nprint(json.dumps(reachable_tiles))",
    "history": [
      {
        "commit_message": "feat: Create unseen_tile_checker tool. This tool automates the process of checking which unseen tiles from a system alert are actually reachable, streamlining exploration and preventing wasted turns trying to path to disconnected areas.",
        "timestamp": "2025-07-29T03:31:55.070Z",
        "action_counter": 15144
      }
    ]
  },
  "pathfinder": {
    "description": "Finds the shortest path from the player's current position to a target coordinate on the current map using the A* algorithm. It avoids impassable tiles and respects one-way traversal rules.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\n\n# Heuristic function for A*\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n# A* pathfinding function\ndef a_star_search(start, goal, traversable, one_way_rules):\n    # Priority queue for open nodes: (f_score, g_score, current_node)\n    open_set = [(0 + heuristic(start, goal), 0, start)]\n    # Dictionary to store the path\n    came_from = {}\n    # Dictionary to store g_scores (cost from start to node)\n    g_score = {start: 0}\n\n    while open_set:\n        _, current_g, current_node = heapq.heappop(open_set)\n\n        if current_node == goal:\n            path = []\n            while current_node in came_from:\n                path.append(current_node)\n                current_node = came_from[current_node]\n            path.append(start)\n            return path[::-1] # Return reversed path\n\n        # Explore neighbors\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current_node[0] + dx, current_node[1] + dy)\n\n            # Check if neighbor is a valid, traversable tile\n            if neighbor not in traversable:\n                continue\n\n            # Check one-way traversal rules\n            if neighbor in one_way_rules:\n                allowed_from = one_way_rules[neighbor]\n                if (current_node[0] - neighbor[0], current_node[1] - neighbor[1]) != allowed_from:\n                    continue\n\n            tentative_g_score = current_g + 1\n\n            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                g_score[neighbor] = tentative_g_score\n                f_score = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_score, tentative_g_score, neighbor))\n                came_from[neighbor] = current_node\n\n    return None # No path found\n\n# Main script execution\ntry:\n    root = ET.fromstring(map_xml_string)\n    player_x, player_y = -1, -1\n    traversable = set()\n    one_way_rules = {}\n\n    impassable_types = ['WALL', 'WINDOW', 'VOID', 'CUT_TREE', 'SIGN', 'BOOKSHELF', 'BLACKBOARD', 'MART_SHELF', 'BUOY', 'TV', 'TOWN_MAP', 'RADIO', 'INCENSE_BURNER', 'BIRD', 'HEADBUTT_TREE', 'FRUIT_TREE', 'COMPUTER', 'PRINTER', 'PC', 'COUNTER', 'CAVE']\n    one_way_types = {\n        'LEDGE_HOP_DOWN': (0, -1), # Can only enter from above\n        'LEDGE_HOP_LEFT': (1, 0),  # Can only enter from the right\n        'LEDGE_HOP_RIGHT': (-1, 0) # Can only enter from the left\n    }\n\n    for row in root.findall('Row'):\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            y = int(row.get('id'))\n            tile_type = tile.get('type')\n\n            if tile.find('Player') is not None:\n                player_x, player_y = x, y\n\n            # Tile is traversable if not impassable and has no object\n            if tile_type not in impassable_types and tile.find('Object') is None:\n                traversable.add((x, y))\n                if tile_type in one_way_types:\n                    one_way_rules[(x, y)] = one_way_types[tile_type]\n\n    start_node = (player_x, player_y)\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    goal_node = (target_x, target_y)\n\n    if start_node == (-1, -1):\n        print('{\"error\": \"Player not found on the map.\"}')\n    elif goal_node not in traversable:\n        print('{\"error\": \"Target is not a traversable tile.\"}')\n    else:\n        path = a_star_search(start_node, goal_node, traversable, one_way_rules)\n        if path:\n            path_json = [{'x': p[0], 'y': p[1]} for p in path]\n            import json\n            print(json.dumps(path_json))\n        else:\n            print('[]') # No path found\n\nexcept Exception as e:\n    print(f'{{\"error\": \"An unexpected error occurred: {str(e)}\"}}')\n",
    "history": [
      {
        "commit_message": "feat: Recreate pathfinder tool after deletion. This is an attempt to resolve the persistent sandbox error by forcing a complete reset of the tool's environment. The script itself remains unchanged as it was previously functional.",
        "timestamp": "2025-07-29T06:31:10.732Z",
        "action_counter": 15245
      },
      {
        "commit_message": "fix: Overhaul pathfinder script for robustness. The previous 'sandbox not running' error was likely a red herring for a script that was crashing silently. This revision adds comprehensive error handling with a try-except block, explicit type casting for input data, and refined logic for parsing the map XML and identifying traversable tiles. This should resolve the persistent failures and restore pathfinding functionality.",
        "timestamp": "2025-07-29T06:51:09.535Z",
        "action_counter": 15271
      }
    ]
  }
}