{
  "wkg_updater": {
    "description": "Prepares the JSON payload for `manage_world_knowledge`. It verifies if a node or edge already exists and, if not, prints the exact JSON string needed to call the `manage_world_knowledge` tool. Now supports adding `tags` to nodes and `destination_entry_point` for warp edges, preventing duplicates and ensuring graph integrity. It also provides existing node IDs if found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "operation": {
          "type": "string",
          "enum": [
            "prepare_add_node",
            "prepare_add_edge"
          ]
        },
        "map_id": {
          "type": "string"
        },
        "x": {
          "type": "string"
        },
        "y": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "type": {
          "type": "string"
        },
        "tags": {
          "type": "string"
        },
        "source_map_id": {
          "type": "string"
        },
        "source_x": {
          "type": "string"
        },
        "source_y": {
          "type": "string"
        },
        "dest_map_id": {
          "type": "string"
        },
        "dest_x": {
          "type": "string"
        },
        "dest_y": {
          "type": "string"
        },
        "connection_type": {
          "type": "string"
        },
        "is_one_way": {
          "type": "string"
        },
        "destination_entry_point": {
          "type": "string"
        }
      },
      "required": [
        "operation"
      ]
    },
    "python_script": "import json\n\ndef find_node_by_coords(graph, map_id, x, y):\n    for node in graph.get('nodes', []):\n        if str(node.get('map_id')) == str(map_id) and node['coordinates']['x'] == x and node['coordinates']['y'] == y:\n            return node\n    return None\n\ndef find_edge(graph, source_id, dest_id):\n    for edge in graph.get('edges', []):\n        if (edge['source_node_id'] == source_id and edge['destination_node_id'] == dest_id) or \\\n           (edge['source_node_id'] == dest_id and edge['destination_node_id'] == source_id and not edge.get('is_one_way')):\n            return edge\n    return None\n\noperation = input_data['operation']\ngraph = json.loads(world_knowledge_graph_json_string)\n\nif operation == 'prepare_add_node':\n    map_id = input_data['map_id']\n    x = int(input_data['x'])\n    y = int(input_data['y'])\n    name = input_data['name']\n    node_type = input_data.get('type', '')\n    tags_str = input_data.get('tags', '[]')\n    tags = json.loads(tags_str) if isinstance(tags_str, str) else tags_str\n\n    existing_node = find_node_by_coords(graph, map_id, x, y)\n    if existing_node:\n        print(json.dumps({'action': 'do_nothing', 'reason': 'Node already exists.', 'node_id': existing_node['id']}))\n    else:\n        payload = {'map_id': map_id, 'name': name, 'coordinates': {'x': x, 'y': y}, 'type': node_type, 'tags': tags}\n        print(json.dumps({'action': 'call_tool', 'tool_name': 'manage_world_knowledge', 'tool_action': 'add_node', 'payload': json.dumps(payload)}))\n\nelif operation == 'prepare_add_edge':\n    source_map_id = input_data['source_map_id']\n    source_x = int(input_data['source_x'])\n    source_y = int(input_data['source_y'])\n    dest_map_id = input_data['dest_map_id']\n    dest_x = int(input_data['dest_x'])\n    dest_y = int(input_data['dest_y'])\n    connection_type = input_data['connection_type']\n    is_one_way = input_data.get('is_one_way', 'false').lower() == 'true'\n    dest_entry_point = input_data.get('destination_entry_point')\n    \n    source_node = find_node_by_coords(graph, source_map_id, source_x, source_y)\n    dest_node = find_node_by_coords(graph, dest_map_id, dest_x, dest_y)\n\n    if not source_node:\n        print(json.dumps({'action': 'error', 'reason': f'Source node at ({source_x},{source_y}) on map {source_map_id} not found.'}))\n    elif not dest_node:\n        print(json.dumps({'action': 'error', 'reason': f'Destination node at ({dest_x},{dest_y}) on map {dest_map_id} not found.'}))\n    else:\n        existing_edge = find_edge(graph, source_node['id'], dest_node['id'])\n        if existing_edge:\n            print(json.dumps({'action': 'do_nothing', 'reason': 'Edge already exists.', 'edge_id': existing_edge['id']}))\n        else:\n            payload = {\n                'source_node_id': source_node['id'],\n                'destination_node_id': dest_node['id'],\n                'connection_type': connection_type,\n                'source_coordinates': {'x': source_x, 'y': source_y, 'map_id': source_map_id},\n                'destination_coordinates': {'x': dest_x, 'y': dest_y, 'map_id': dest_map_id},\n                'is_one_way': is_one_way\n            }\n            if dest_entry_point is not None and connection_type == 'warp':\n                payload['destination_entry_point'] = int(dest_entry_point)\n\n            print(json.dumps({'action': 'call_tool', 'tool_name': 'manage_world_knowledge', 'tool_action': 'add_edge', 'payload': json.dumps(payload)}))\nelse:\n    print(json.dumps({'action': 'error', 'reason': 'Invalid operation.'}))"
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map. This is the correct tool for overworld navigation planning.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef parse_map_for_bfs(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    grid = set()\n    ledge_tiles = set()\n    traversable_types = ['ground', 'grass']\n\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tile_type = tile.attrib.get('type', 'impassable')\n            has_object = tile.attrib.get('has-object') == 'true'\n            is_warp = tile.attrib.get('is-warp') == 'true'\n            is_pikachu = False\n\n            if has_object:\n                object_element = tile.find('Object')\n                if object_element is not None and object_element.attrib.get('id-name') == 'Pikachu':\n                    is_pikachu = True\n\n            if tile_type == 'ledge':\n                ledge_tiles.add((x, y))\n\n            is_traversable = (tile_type in traversable_types or is_warp) and (not has_object or is_pikachu)\n            if is_traversable:\n                grid.add((x, y))\n                \n    return grid, width, height, ledge_tiles\n\ndef bfs_path(grid, start, end, width, height, ledge_tiles):\n    start_x, start_y = start\n    end_x, end_y = end\n\n    if not (1 <= start_x <= width and 1 <= start_y <= height) or start not in grid:\n        if not (start in ledge_tiles and start_y == end_y -1 and start_x == end_x):\n            print(f'Error: Start {start} is invalid or on an impassable tile.')\n            return None\n    if not (1 <= end_x <= width and 1 <= end_y <= height) or end not in grid:\n        print(f'Error: End {end} is invalid or on an impassable tile.')\n        return None\n\n    queue = deque([(start, [])])\n    visited = {start}\n\n    while queue:\n        (current_x, current_y), path = queue.popleft()\n        current_pos = (current_x, current_y)\n\n        if current_pos == end:\n            return path\n\n        for dx, dy, direction in [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n            next_x, next_y = current_x + dx, current_y + dy\n            next_pos = (next_x, next_y)\n            \n            if not (1 <= next_x <= width and 1 <= next_y <= height):\n                continue\n\n            if next_pos in visited:\n                continue\n\n            if next_pos in ledge_tiles:\n                if direction == 'Down':\n                    jump_pos = (next_x, next_y + 1)\n                    if jump_pos in grid and jump_pos not in visited:\n                        visited.add(jump_pos)\n                        new_path = path + [direction]\n                        queue.append((jump_pos, new_path))\n                continue\n            \n            if next_pos in grid:\n                visited.add(next_pos)\n                new_path = path + [direction]\n                queue.append((next_pos, new_path))\n    \n    return None\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\ngrid, width, height, ledge_tiles = parse_map_for_bfs(map_xml_string)\npath = bfs_path(grid, (start_x, start_y), (end_x, end_y), width, height, ledge_tiles)\n\nif path is not None:\n    print(f'Path found: {path}')\nelse:\n    print('No path found.')"
  }
}