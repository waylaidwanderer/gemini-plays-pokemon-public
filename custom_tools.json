{
  "find_path_v4": {
    "description": "Finds the shortest path to a target coordinate. Correctly handles walls, NPCs, items, and unseen tiles. If the target is impassable, finds a path to an adjacent tile.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    \n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = [[True for _ in range(width)] for _ in range(height)]\n    impassable_types = ['WALL', 'HEADBUTT_TREE', 'MART_SHELF', 'COUNTER', 'WATER', 'BOULDER', 'TABLE', 'PC', 'STAIRS_UP', 'STAIRS_DOWN', 'BOOKSHELF']\n    \n    start_pos = None\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib.get('type', 'unseen')\n            \n            if t_type in impassable_types:\n                grid[y][x] = False\n            \n            if tile.attrib.get('has-object') == 'true':\n                grid[y][x] = False\n                \n            for marker in tile.findall('Marker'):\n                if 'Wall' in marker.text or 'ðŸ§±' in marker.attrib.get('emoji', ''):\n                    grid[y][x] = False\n            \n            if tile.find('Player') is not None:\n                start_pos = (x, y)\n                grid[y][x] = True\n                \n    if start_pos is None:\n        print(json.dumps([]))\n        return\n\n    queue = deque([(start_pos, [])])\n    visited = {start_pos}\n    \n    if not grid[target_y][target_x]:\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = target_x + dx, target_y + dy\n            if 0 <= nx < width and 0 <= ny < height and grid[ny][nx]:\n                target_x, target_y = nx, ny\n                break\n        else:\n            print(json.dumps([]))\n            return\n\n    while queue:\n        (cx, cy), path = queue.popleft()\n        \n        if (cx, cy) == (target_x, target_y):\n            print(json.dumps(path))\n            return\n            \n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < width and 0 <= ny < height and grid[ny][nx] and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [btn]))\n                \n    print(json.dumps([]))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-21T06:11:17.104Z",
        "action_counter": 8161
      },
      {
        "commit_message": "Fixed find_path_v4: removed non-standard getparent() call and improved player position detection. Consolidated grid construction and BFS.",
        "timestamp": "2025-12-21T06:23:10.110Z",
        "action_counter": 8180
      },
      {
        "commit_message": "Ensure tool correctly returns a list of button strings for overworld navigation when autopress_buttons is true. Fixes previous formatting issues.",
        "timestamp": "2025-12-22T02:53:22.052Z",
        "action_counter": 10751
      },
      {
        "commit_message": "Fix player position detection in find_path_v4 to avoid TypeError when start_row is not found via XPath. Use a more robust loop-based approach.",
        "timestamp": "2025-12-22T02:54:08.460Z",
        "action_counter": 10753
      },
      {
        "commit_message": "Improved traversable types to include 'unseen' for optimistic pathfinding and added logic to path to adjacent tiles if the target is impassable (e.g., an NPC or wall).",
        "timestamp": "2025-12-22T05:52:22.947Z",
        "action_counter": 11104
      },
      {
        "commit_message": "Added MART_SHELF and COUNTER to impassable types and improved object/marker collision handling.",
        "timestamp": "2025-12-23T00:55:17.780Z",
        "action_counter": 13197
      }
    ]
  },
  "grass_dance_tool": {
    "description": "Returns a list of button presses to pace back and forth in tall grass to trigger a wild encounter.",
    "input_schema": {
      "type": "object",
      "properties": {
        "steps": {
          "type": "integer"
        }
      },
      "required": [
        "steps"
      ]
    },
    "python_script": "import json\ndef grass_dance(steps):\n    buttons = []\n    for i in range(steps // 2):\n        buttons.extend([\"Left\", \"Right\"])\n    if steps % 2 != 0:\n        buttons.append(\"Left\")\n    return buttons\n\nsteps = int(input_data['steps'])\nprint(json.dumps(grass_dance(steps)))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-22T14:41:14.078Z",
        "action_counter": 12241
      }
    ]
  },
  "use_super_repel_v9": {
    "description": "Uses a Super Repel from the Pack. Assumes cursor starts on POKEDEX in the Start menu. Robustly resets inventory cursor.",
    "input_schema": {},
    "python_script": "import json\n\ndef use_super_repel():\n    # Robust sequence: \n    # 1. Clear to overworld\n    # 2. Open Start Menu (Cursor starts on POKEDEX index 1)\n    # 3. Navigate to PACK (index 3) -> Down*2\n    # 4. Open PACK\n    # 5. Reset inventory cursor to Item 1 -> Up*20\n    # 6. Navigate to Item 13 (Super Repel) -> Down*12\n    # 7. Use item -> A, A\n    # 8. Exit menus -> B*3\n    buttons = [\"B\", \"sleep 100\", \"B\", \"sleep 100\", \"B\", \"sleep 500\", \"Start\", \"sleep 1000\", \"Down\", \"sleep 100\", \"Down\", \"sleep 100\", \"A\", \"sleep 1000\"]\n    for _ in range(20):\n        buttons.append(\"Up\")\n        buttons.append(\"sleep 50\")\n    for _ in range(12):\n        buttons.append(\"Down\")\n        buttons.append(\"sleep 100\")\n    buttons.extend([\"A\", \"sleep 500\", \"A\", \"sleep 1000\", \"B\", \"sleep 500\", \"B\", \"sleep 500\", \"B\"])\n    print(json.dumps(buttons))\n\nuse_super_repel()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-23T04:37:13.533Z",
        "action_counter": 13551
      }
    ]
  },
  "check_suicune_location_v12": {
    "description": "Robustly navigates from the overworld to Suicune's PokÃ©dex AREA map. Assumes cursor starts on POKEDEX in the Start menu.",
    "input_schema": {},
    "python_script": "import json\n\ndef check_suicune_location():\n    # Robust sequence:\n    # 1. Clear to overworld\n    # 2. Open Start Menu (Cursor on POKEDEX)\n    # 3. Open Pokedex -> A\n    # 4. Open entry (Suicune should be selected) -> A\n    # 5. Select AREA -> Right, A\n    # 6. Wait for observation -> sleep 3000\n    # 7. Exit menus -> B*4\n    buttons = [\"B\", \"sleep 100\", \"B\", \"sleep 100\", \"B\", \"sleep 500\", \"Start\", \"sleep 1000\", \"A\", \"sleep 1000\", \"A\", \"sleep 1000\", \"Right\", \"sleep 500\", \"A\", \"sleep 3000\", \"B\", \"sleep 500\", \"B\", \"sleep 500\", \"B\", \"sleep 500\", \"B\"]\n    print(json.dumps(buttons))\n\ncheck_suicune_location()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-23T04:37:13.533Z",
        "action_counter": 13551
      }
    ]
  },
  "use_super_repel_v10": {
    "description": "Uses a Super Repel from the Pack. Assumes cursor starts on POKEDEX in the Start menu. Robustly resets inventory cursor.",
    "input_schema": {},
    "python_script": "import json\n\ndef use_super_repel():\n    # Robust sequence: \n    # 1. Clear to overworld\n    # 2. Open Start Menu (Cursor on POKEDEX)\n    # 3. Navigate to PACK -> Down*2\n    # 4. Open PACK\n    # 5. Reset inventory cursor to Item 1 -> Up*20\n    # 6. Navigate to Item 15 (Super Repel) -> Down*14\n    # 7. Use item -> A, A\n    # 8. Exit menus -> B*3\n    buttons = [\"B\", \"sleep 100\", \"B\", \"sleep 100\", \"B\", \"sleep 500\", \"Start\", \"sleep 1000\", \"Down\", \"sleep 100\", \"Down\", \"sleep 100\", \"A\", \"sleep 1000\"]\n    for _ in range(20):\n        buttons.append(\"Up\")\n        buttons.append(\"sleep 50\")\n    for _ in range(14):\n        buttons.append(\"Down\")\n        buttons.append(\"sleep 100\")\n    buttons.extend([\"A\", \"sleep 500\", \"A\", \"sleep 1000\", \"B\", \"sleep 500\", \"B\", \"sleep 500\", \"B\"])\n    print(json.dumps(buttons))\n\nuse_super_repel()",
    "history": [
      {
        "commit_message": "Corrected item index for Super Repel (15th item = 14 Down presses). Robust cursor-independent reset.",
        "timestamp": "2025-12-23T04:39:40.706Z",
        "action_counter": 13553
      }
    ]
  }
}