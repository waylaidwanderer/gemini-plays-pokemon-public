{
  "marker_compliance_tool": {
    "description": "Parses map markers and checks for compliance with protocols defined in the notepad. Identifies markers with non-standard emojis or incorrect label formats.",
    "input_schema": {
      "type": "object",
      "properties": {
        "notepad_contents": {
          "type": "string"
        }
      },
      "required": [
        "notepad_contents"
      ]
    },
    "python_script": "import json\nimport re\n\ndef check_marker_compliance():\n    notepad_content = input_data['notepad_contents']\n    \n    protocol_emojis = []\n    teleporter_format_regex_str = ''\n\n    try:\n        protocol_line = \"\"\n        for line in notepad_content.splitlines():\n            if \"CRITICAL: Map Marker Protocol\" in line:\n                protocol_line = line\n                break\n        \n        if not protocol_line:\n            print(json.dumps({'error': 'Map Marker Protocol line not found in notepad.'}))\n            return\n\n        teleporter_format_regex_str = r\"ðŸšª Warp to/from \\(\\d+, \\d+\\) \\[(?:Bi-directional|One-way)\\]\"\n        teleporter_format_regex = re.compile(teleporter_format_regex_str)\n        protocol_emojis = re.findall(r\"'([^']*)'\", protocol_line)\n\n    except Exception as e:\n        print(json.dumps({'error': f'Failed to parse protocols from notepad: {e}'}))\n        return\n\n    non_compliant_markers = []\n    try:\n        tiles = map_xml_string.split('</Tile>')\n        for tile_str in tiles:\n            if '<Marker' in tile_str:\n                try:\n                    coord_match = re.search(r'coordinate=\"\\((\\d+), (\\d+)\\)\"', tile_str)\n                    if not coord_match: continue\n                    x, y = int(coord_match.group(1)), int(coord_match.group(2))\n                except (ValueError, IndexError):\n                    continue\n\n                marker_parts = tile_str.split('<Marker emoji=\"')\n                for part in marker_parts[1:]:\n                    try:\n                        emoji = part.split('\"')[0]\n                        label = part.split('>')[1].split('</Marker>')[0]\n                        \n                        is_compliant = False\n                        if emoji in protocol_emojis:\n                            if emoji == 'ðŸšª':\n                                if teleporter_format_regex.fullmatch(f\"{emoji} {label}\"):\n                                    is_compliant = True\n                            else:\n                                is_compliant = True\n                        \n                        if not is_compliant:\n                            non_compliant_markers.append({\n                                \"x\": x,\n                                \"y\": y,\n                                \"emoji\": emoji,\n                                \"label\": label,\n                                \"reason\": f\"Emoji '{emoji}' not in protocol or label format for 'ðŸšª' is incorrect.\"\n                            })\n                    except IndexError:\n                        continue\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': f'Error during XML parsing: {str(e)}', 'traceback': traceback.format_exc()}))\n        return\n        \n    print(json.dumps(non_compliant_markers))\n\ncheck_marker_compliance()"
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map using the A* algorithm. It correctly handles ledges (one-way traversal), can path to the nearest walkable tile if the destination is blocked, and correctly treats Pikachu as a walkable object. REFINED: Now uses a more robust XML parser instead of regex to prevent parsing failures.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import heapq\nimport json\nimport xml.etree.ElementTree as ET\n\ndef parse_map_with_xml_parser(xml_str):\n    grid = {}\n    try:\n        root = ET.fromstring(xml_str)\n        for row in root.findall('Row'):\n            for tile in row.findall('Tile'):\n                try:\n                    coord_str = tile.get('coordinate')\n                    x_str, y_str = coord_str.strip('()').split(',')\n                    x, y = int(x_str), int(y_str)\n                    \n                    tile_type = tile.get('type')\n                    \n                    obj_element = tile.find('Object')\n                    is_pikachu = False\n                    if obj_element is not None:\n                        id_name = obj_element.get('id-name')\n                        if id_name == \"Pikachu\":\n                            is_pikachu = True\n                    \n                    has_object = obj_element is not None\n\n                    impassable_types = ['impassable', 'unknown', 'closed_gate', 'water']\n                    is_impassable = tile_type in impassable_types or (has_object and not is_pikachu)\n                    \n                    grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n                except (ValueError, IndexError, AttributeError) as e:\n                    continue\n    except ET.ParseError as e:\n        return None, f\"XML Parse Error: {e}\"\n    \n    if not grid:\n        return None, \"Parser found no tiles.\"\n        \n    return grid, None\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef get_neighbors(grid, node):\n    neighbors = []\n    x, y = node\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n        nx, ny = x + dx, y + dy\n        neighbor_pos = (nx, ny)\n        if neighbor_pos in grid:\n            tile_data = grid[neighbor_pos]\n            if tile_data['type'] == 'ledge' and dy == 1 and y < ny:\n                landing_pos = (nx, ny + 1)\n                if landing_pos in grid and not grid[landing_pos].get('impassable', True):\n                    neighbors.append((landing_pos, 1))\n                continue\n            if not tile_data.get('impassable', True):\n                neighbors.append((neighbor_pos, 1))\n    return neighbors\n\ndef a_star_search(grid, start, end):\n    if not grid: return None, 'Grid is empty'\n    if grid.get(end, {}).get('impassable', True):\n        walkable_neighbors = [p for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)] if (p := (end[0] + dx, end[1] + dy)) in grid and not grid[p].get('impassable', True)]\n        if not walkable_neighbors:\n            return None, f'End point {end} is impassable and has no walkable neighbors.'\n        end = min(walkable_neighbors, key=lambda pos: heuristic(start, pos))\n\n    open_set = [(0, start)]\n    came_from = {}\n    g_score = {pos: float('inf') for pos in grid}\n    if start not in g_score: return None, f'Start point {start} not in g_score map.'\n    g_score[start] = 0\n    f_score = {pos: float('inf') for pos in grid}\n    f_score[start] = heuristic(start, end)\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n        if current == end:\n            path = [current]\n            while current in came_from:\n                current = came_from[current]\n                path.append(current)\n            return path[::-1], 'Path found.'\n        for neighbor, cost in get_neighbors(grid, current):\n            tentative_g_score = g_score[current] + cost\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, end)\n                heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    return None, 'No path found to destination.'\n\nstart_pos = (int(input_data['start_x']), int(input_data['start_y']))\nend_pos = (int(input_data['end_x']), int(input_data['end_y']))\ngame_map, error_msg = parse_map_with_xml_parser(map_xml_string)\n\nif error_msg:\n    print(json.dumps({'error': error_msg}))\nelif not game_map:\n    print(json.dumps({'error': 'Map parsing failed'}))\nelif start_pos not in game_map:\n    print(json.dumps({'error': f'Start position {start_pos} not found on map.'}))\nelif end_pos not in game_map:\n    print(json.dumps({'error': f'End position {end_pos} not found on map.'}))\nelse:\n    path_coords, msg = a_star_search(game_map, start_pos, end_pos)\n    if path_coords:\n        print(json.dumps([{'x': x, 'y': y} for x, y in path_coords]))\n    else:\n        print(json.dumps({'error': msg}))"
  },
  "systematic_searcher": {
    "description": "Calculates the next reachable, untested tile to check in a systematic sweep. It parses the map XML to find all walkable tiles and uses BFS to find the nearest target.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "tested_coords_json": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "tested_coords_json"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef parse_map_for_walkable(xml_str):\n    grid = {}\n    try:\n        root = ET.fromstring(xml_str)\n        for row in root.findall('Row'):\n            for tile in row.findall('Tile'):\n                try:\n                    coord_str = tile.get('coordinate')\n                    x_str, y_str = coord_str.strip('()').split(',')\n                    x, y = int(x_str), int(y_str)\n                    tile_type = tile.get('type')\n                    obj_element = tile.find('Object')\n                    is_pikachu = obj_element is not None and obj_element.get('id-name') == 'Pikachu'\n                    has_object = obj_element is not None\n                    impassable_types = ['impassable', 'unknown', 'closed_gate', 'water']\n                    is_impassable = tile_type in impassable_types or (has_object and not is_pikachu)\n                    grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n                except (ValueError, IndexError, AttributeError):\n                    continue\n    except ET.ParseError as e:\n        return None, f'XML Parse Error: {e}'\n    return grid, None\n\ndef bfs_nearest_untested(grid, start, tested_coords):\n    if start not in grid or grid[start]['impassable']:\n        return None, 'Start position is not on a walkable tile.'\n    \n    queue = deque([start])\n    visited = {start}\n    \n    while queue:\n        current = queue.popleft()\n        \n        if current not in tested_coords:\n            return current, 'Found nearest untested tile.'\n            \n        x, y = current\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            neighbor = (x + dx, y + dy)\n            if neighbor in grid and not grid[neighbor]['impassable'] and neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n                \n    return None, 'All reachable tiles have been tested.'\n\nstart_pos = (int(input_data['start_x']), int(input_data['start_y']))\n_tested_coords = json.loads(input_data['tested_coords_json'])\n_tested_coords_tuples = {tuple(c) for c in _tested_coords}\n\ngame_map, error_msg = parse_map_for_walkable(map_xml_string)\n\nif error_msg:\n    print(json.dumps({'error': error_msg}))\nelse:\n    next_target, msg = bfs_nearest_untested(game_map, start_pos, _tested_coords_tuples)\n    if next_target:\n        print(json.dumps({'x': next_target[0], 'y': next_target[1]}))\n    else:\n        print(json.dumps({'error': msg}))"
  },
  "find_next_exploration_target": {
    "description": "Analyzes unseen tiles and reachable barriers to suggest the most logical next exploration target. Prioritizes the closest unseen tile. If none exist, it finds the closest reachable barrier based on Manhattan distance from the player's current coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "unseen_tiles_json": {
          "type": "string"
        },
        "reachable_barriers_json": {
          "type": "string"
        },
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "unseen_tiles_json",
        "reachable_barriers_json",
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import json\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nunseen_tiles = json.loads(input_data['unseen_tiles_json'])\nreachable_barriers = json.loads(input_data['reachable_barriers_json'])\n\nstart_pos = (start_x, start_y)\nnext_target = None\nmin_dist = float('inf')\nreasoning = ''\n\nif unseen_tiles:\n    for tile in unseen_tiles:\n        dist = heuristic(start_pos, (tile['x'], tile['y']))\n        if dist < min_dist:\n            min_dist = dist\n            next_target = tile\n    if next_target:\n        reasoning = f'The closest unseen tile is at ({next_target[\"x\"]}, {next_target[\"y\"]}) with a distance of {min_dist}.'\n    else:\n        reasoning = 'No unseen tiles found.'\nelif reachable_barriers:\n    for barrier in reachable_barriers:\n        dist = heuristic(start_pos, (barrier['x'], barrier['y']))\n        if dist < min_dist:\n            min_dist = dist\n            next_target = barrier\n    if next_target:\n        reasoning = f'No unseen tiles. The closest reachable barrier is at ({next_target[\"x\"]}, {next_target[\"y\"]}) with a distance of {min_dist}.'\n    else:\n        reasoning = 'No reachable barriers found.'\nelse:\n    reasoning = 'No unseen tiles or reachable barriers to suggest.'\n\nif next_target:\n    print(json.dumps({'next_target_x': next_target['x'], 'next_target_y': next_target['y'], 'reasoning': reasoning}))\nelse:\n    print(json.dumps({'next_target_x': None, 'next_target_y': None, 'reasoning': reasoning}))"
  },
  "gate_navigator": {
    "description": "Calculates the shortest path to an adjacent, walkable tile of a specified gate. Useful for navigating to gates that are visually open but still marked as 'closed_gate' in the map data.",
    "input_schema": {
      "type": "object",
      "properties": {
        "gate_x": {
          "type": "string"
        },
        "gate_y": {
          "type": "string"
        }
      },
      "required": [
        "gate_x",
        "gate_y"
      ]
    },
    "python_script": "import heapq\nimport json\nimport xml.etree.ElementTree as ET\n\ndef parse_map_for_nav(xml_str):\n    grid = {}\n    player_pos = None\n    try:\n        root = ET.fromstring(xml_str)\n        for row in root.findall('Row'):\n            for tile in row.findall('Tile'):\n                coord_str = tile.get('coordinate')\n                x_str, y_str = coord_str.strip('()').split(',')\n                x, y = int(x_str), int(y_str)\n                tile_type = tile.get('type')\n                if tile.find('Player') is not None:\n                    player_pos = (x, y)\n                obj_element = tile.find('Object')\n                is_pikachu = False\n                if obj_element is not None and obj_element.get('id-name') == 'Pikachu':\n                    is_pikachu = True\n                has_object = obj_element is not None\n                impassable_types = ['impassable', 'unknown', 'closed_gate', 'water']\n                is_impassable = tile_type in impassable_types or (has_object and not is_pikachu)\n                grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n    except Exception as e:\n        return None, None, f'XML Parse Error: {e}'\n    return grid, player_pos, None\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(grid, start, end):\n    open_set = [(0, start)]\n    came_from = {}\n    g_score = {pos: float('inf') for pos in grid}\n    g_score[start] = 0\n    f_score = {pos: float('inf') for pos in grid}\n    f_score[start] = heuristic(start, end)\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n        if current == end:\n            path = [current]\n            while current in came_from:\n                current = came_from[current]\n                path.append(current)\n            return path[::-1], 'Path found.'\n        \n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if neighbor in grid and not grid[neighbor]['impassable']:\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, end)\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    return None, 'No path found.'\n\ntry:\n    gate_x = int(input_data['gate_x'])\n    gate_y = int(input_data['gate_y'])\n    gate_pos = (gate_x, gate_y)\n\n    game_map, start_pos, error_msg = parse_map_for_nav(map_xml_string)\n\n    if error_msg:\n        print(json.dumps({'error': error_msg}))\n    elif not start_pos:\n        print(json.dumps({'error': 'Player start position not found in map data.'}))\n    else:\n        walkable_neighbors = []\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            neighbor = (gate_pos[0] + dx, gate_pos[1] + dy)\n            if neighbor in game_map and not game_map[neighbor]['impassable']:\n                walkable_neighbors.append(neighbor)\n        \n        if not walkable_neighbors:\n            print(json.dumps({'error': f'Gate at {gate_pos} has no walkable neighbors.'}))\n        else:\n            target_pos = min(walkable_neighbors, key=lambda pos: heuristic(start_pos, pos))\n            path_coords, msg = a_star_search(game_map, start_pos, target_pos)\n            if path_coords:\n                print(json.dumps([{'x': x, 'y': y} for x, y in path_coords]))\n            else:\n                print(json.dumps({'error': msg}))\nexcept Exception as e:\n    print(json.dumps({'error': f'An unexpected error occurred: {e}'}))"
  }
}