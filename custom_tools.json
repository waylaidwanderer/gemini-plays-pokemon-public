{
  "find_path_bfs": {
    "description": "Finds a path from the player's current position to a target coordinate using Breadth-First Search (BFS). It correctly handles one-way ledges and other obstacles (including marked, off-screen objects), and will find a path to an adjacent tile if the target is impassable.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef parse_map(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    tiles = {}\n    player_pos = None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tiles[(x, y)] = tile\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n    return tiles, player_pos, width, height\n\ndef is_obstacle(tile):\n    if tile is None: return True\n    tile_type = tile.attrib['type']\n    if tile_type in ['WALL', 'HEADBUTT_TREE', 'VOID', 'CUT_TREE', 'COUNTER', 'unseen'] or tile.find('Object') is not None or tile.find('Marker') is not None:\n        if tile.attrib.get('is-warp') == 'true':\n             return False\n        return True\n    return False\n\ndef bfs_search(tiles, start, goal, width, height):\n    neighbors = [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]\n\n    if is_obstacle(tiles.get(goal)):\n        potential_goals = []\n        for dx, dy, _ in neighbors:\n            adj_coord = (goal[0] + dx, goal[1] + dy)\n            if not is_obstacle(tiles.get(adj_coord)):\n                potential_goals.append(adj_coord)\n        if not potential_goals:\n            return None\n        potential_goals.sort(key=lambda p: abs(p[0] - start[0]) + abs(p[1] - start[1]))\n        goal = potential_goals[0]\n\n    queue = deque([[start]])\n    visited = {start}\n\n    while queue:\n        path = queue.popleft()\n        node = path[-1]\n\n        if node == goal:\n            return path\n\n        for i, j, move_dir in neighbors:\n            neighbor_coord = (node[0] + i, node[1] + j)\n            \n            if not (1 <= neighbor_coord[0] <= width and 1 <= neighbor_coord[1] <= height):\n                continue\n\n            if neighbor_coord in visited:\n                continue\n            \n            neighbor_tile = tiles.get(neighbor_coord)\n\n            if is_obstacle(neighbor_tile):\n                continue\n            \n            current_tile_type = tiles.get(node).attrib.get('type')\n            neighbor_tile_type = neighbor_tile.attrib.get('type')\n\n            if move_dir == 'Up' and neighbor_tile_type == 'LEDGE_HOP_DOWN': continue\n            if move_dir == 'Right' and neighbor_tile_type == 'LEDGE_HOP_LEFT': continue\n            if move_dir == 'Left' and neighbor_tile_type == 'LEDGE_HOP_RIGHT': continue\n\n            new_path = list(path)\n            new_path.append(neighbor_coord)\n            queue.append(new_path)\n            visited.add(neighbor_coord)\n            \n    return None\n\ntry:\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    tiles, player_pos, map_width, map_height = parse_map(map_xml_string)\n    if player_pos:\n        path = bfs_search(tiles, player_pos, (target_x, target_y), map_width, map_height)\n        if path:\n            path_coords = [{'x': p[0], 'y': p[1]} for p in path]\n            print(json.dumps(path_coords))\n        else:\n            print(json.dumps([]))\n    else:\n        print(json.dumps([]))\nexcept Exception as e:\n    import traceback\n    print(f'An error occurred: {e}\\n{traceback.format_exc()}')"
  },
  "find_reachable_unseen_tiles": {
    "description": "Finds all unseen tiles that are adjacent to currently reachable, seen, walkable tiles.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef parse_map(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    tiles = {}\n    player_pos = None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tiles[(x, y)] = tile\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n    return tiles, player_pos, width, height\n\ndef is_obstacle_for_reachability(tile):\n    if tile is None: return True\n    tile_type = tile.attrib['type']\n    if tile_type in ['WALL', 'HEADBUTT_TREE', 'VOID', 'CUT_TREE', 'COUNTER'] or tile.find('Object') is not None or tile.find('Marker') is not None:\n        if tile.attrib.get('is-warp') == 'true': return False\n        return True\n    return False\n\ndef find_all_reachable_seen_tiles(tiles, start, width, height):\n    queue = deque([start])\n    visited = {start}\n    reachable_seen = set()\n\n    while queue:\n        node = queue.popleft()\n        reachable_seen.add(node)\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor_coord = (node[0] + dx, node[1] + dy)\n            if not (1 <= neighbor_coord[0] <= width and 1 <= neighbor_coord[1] <= height):\n                continue\n            if neighbor_coord in visited:\n                continue\n            \n            neighbor_tile = tiles.get(neighbor_coord)\n            if is_obstacle_for_reachability(neighbor_tile) or neighbor_tile.attrib['seen'] == 'false':\n                continue\n            \n            # Ledge logic\n            move_dir = ''\n            if dy == 1: move_dir = 'Down'\n            elif dy == -1: move_dir = 'Up'\n            elif dx == 1: move_dir = 'Right'\n            elif dx == -1: move_dir = 'Left'\n            current_tile_type = tiles[node].attrib.get('type')\n            neighbor_tile_type = neighbor_tile.attrib.get('type')\n            if move_dir == 'Up' and neighbor_tile_type == 'LEDGE_HOP_DOWN': continue\n            if move_dir == 'Right' and neighbor_tile_type == 'LEDGE_HOP_LEFT': continue\n            if move_dir == 'Left' and neighbor_tile_type == 'LEDGE_HOP_RIGHT': continue\n\n            visited.add(neighbor_coord)\n            queue.append(neighbor_coord)\n    return reachable_seen\n\ntry:\n    tiles, player_pos, map_width, map_height = parse_map(map_xml_string)\n    if player_pos:\n        reachable_seen = find_all_reachable_seen_tiles(tiles, player_pos, map_width, map_height)\n        explorable_frontiers = set()\n        \n        for coord in reachable_seen:\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                neighbor_coord = (coord[0] + dx, coord[1] + dy)\n                neighbor_tile = tiles.get(neighbor_coord)\n                if neighbor_tile is not None and neighbor_tile.attrib['seen'] == 'false':\n                    explorable_frontiers.add(neighbor_coord)\n        \n        output = [{'x': x, 'y': y} for x, y in explorable_frontiers]\n        print(json.dumps(output))\n    else:\n        print(json.dumps([]))\nexcept Exception as e:\n    import traceback\n    print(f'An error occurred: {e}\\n{traceback.format_exc()}')"
  },
  "find_closest_unseen_tile": {
    "description": "Finds the closest reachable unseen tile from the player's current position.",
    "input_schema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef parse_map(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    tiles = {}\n    player_pos = None\n    unseen_tiles = []\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tiles[(x, y)] = tile\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n            if tile.attrib['seen'] == 'false':\n                unseen_tiles.append((x, y))\n    return tiles, player_pos, width, height, unseen_tiles\n\ndef is_obstacle(tile):\n    if tile is None: return True\n    tile_type = tile.attrib['type']\n    if tile_type in ['WALL', 'HEADBUTT_TREE', 'VOID', 'CUT_TREE', 'COUNTER', 'unseen'] or tile.find('Object') is not None:\n        if tile.attrib.get('is-warp') == 'true': return False\n        return True\n    return False\n\ndef bfs_search(tiles, start, goal, width, height):\n    neighbors = [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]\n    \n    queue = deque([[start]])\n    visited = {start}\n\n    if is_obstacle(tiles.get(goal)):\n        potential_goals = []\n        for dx, dy, _ in neighbors:\n            adj_coord = (goal[0] + dx, goal[1] + dy)\n            if not is_obstacle(tiles.get(adj_coord)):\n                potential_goals.append(adj_coord)\n        if not potential_goals: return None\n        \n        shortest_adj_path = None\n        for adj_goal in potential_goals:\n            path_to_adj = bfs_search(tiles, start, adj_goal, width, height)\n            if path_to_adj and (shortest_adj_path is None or len(path_to_adj) < len(shortest_adj_path)):\n                shortest_adj_path = path_to_adj\n        return shortest_adj_path\n\n    while queue:\n        path = queue.popleft()\n        node = path[-1]\n        if node == goal: return path\n        for i, j, move_dir in neighbors:\n            neighbor_coord = (node[0] + i, node[1] + j)\n            if not (1 <= neighbor_coord[0] <= width and 1 <= neighbor_coord[1] <= height): continue\n            if neighbor_coord in visited: continue\n            neighbor_tile = tiles.get(neighbor_coord)\n            if is_obstacle(neighbor_tile): continue\n            current_tile_type = tiles.get(node).attrib.get('type')\n            neighbor_tile_type = neighbor_tile.attrib.get('type')\n            if move_dir == 'Up' and neighbor_tile_type == 'LEDGE_HOP_DOWN': continue\n            if move_dir == 'Right' and neighbor_tile_type == 'LEDGE_HOP_LEFT': continue\n            if move_dir == 'Left' and neighbor_tile_type == 'LEDGE_HOP_RIGHT': continue\n            new_path = list(path)\n            new_path.append(neighbor_coord)\n            queue.append(new_path)\n            visited.add(neighbor_coord)\n    return None\n\ntiles, player_pos, map_width, map_height, unseen_tiles = parse_map(map_xml_string)\nshortest_path = None\n\nfor target in unseen_tiles:\n    path = bfs_search(tiles, player_pos, target, map_width, map_height)\n    if path and (shortest_path is None or len(path) < len(shortest_path)):\n        shortest_path = path\n\nif shortest_path:\n    path_coords = [{'x': p[0], 'y': p[1]} for p in shortest_path]\n    print(json.dumps(path_coords))\nelse:\n    print(json.dumps([]))"
  }
}