{
  "explore_unseen_v1": {
    "description": "Finds the nearest reachable 'unseen' tile and returns a list of button presses to reach it. Handles ledges, objects, and impassable tiles like WATER and HEADBUTT_TREE correctly. Treats 'unseen' tiles as impassable for traversal unless they are the target.",
    "input_schema": {
      "type": "object",
      "properties": {
        "autopress_buttons": {
          "type": "boolean",
          "default": false,
          "description": "If true and the tool returns a list of buttons, they will be pressed automatically."
        }
      },
      "required": [
        "autopress_buttons"
      ]
    },
    "python_script": "import json\nfrom collections import deque\nimport xml.etree.ElementTree as ET\n\ndef explore_unseen_tool(map_xml_string):\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    player_pos = None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tile_type = tile.attrib['type']\n            is_seen = tile.attrib['seen'] == 'true'\n            has_object = tile.find('Object') is not None\n            if has_object: tile_type = 'WALL'\n            grid[(x, y)] = {'type': tile_type, 'seen': is_seen}\n            if tile.find('Player') is not None: player_pos = (x, y)\n    if not player_pos: return []\n    queue = deque([(player_pos, [])])\n    visited = {player_pos}\n    while queue:\n        (curr_x, curr_y), path = queue.popleft()\n        for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = curr_x + dx, curr_y + dy\n            if (nx, ny) in grid:\n                target = grid[(nx, ny)]\n                if not target['seen']: return path + [move]\n                if (nx, ny) not in visited and target['type'] not in ['WALL', 'WATER']:\n                    visited.add((nx, ny))\n                    queue.append(((nx, ny), path + [move]))\n    return []\n\nprint(json.dumps(explore_unseen_tool(map_xml_string)))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T21:53:44.618Z",
        "action_counter": 2565
      },
      {
        "commit_message": "Included HEADBUTT_TREE, WATER, and CUT_TREE in impassable tiles list. Added check for unseen tiles.",
        "timestamp": "2025-12-19T04:48:43.614Z",
        "action_counter": 3272
      },
      {
        "commit_message": "Added missing solve(input_data) call to execute the script.",
        "timestamp": "2025-12-19T04:49:48.769Z",
        "action_counter": 3274
      },
      {
        "commit_message": "Refined find_path_v4 and explore_unseen_v1 to treat 'unseen' tiles as impassable for traversal. This prevents the tools from planning paths through areas that haven't been visually confirmed, avoiding collisions with unseen objects or walls. Added 'unseen' to the impassable set for both tools.",
        "timestamp": "2025-12-19T04:58:58.879Z",
        "action_counter": 3290
      },
      {
        "commit_message": "Added map boundary check to prevent walking off-map. (Turn 3292)",
        "timestamp": "2025-12-19T05:01:44.664Z",
        "action_counter": 3292
      },
      {
        "commit_message": "Fixed logic to properly identify reachable unseen tiles and return button presses.",
        "timestamp": "2025-12-19T22:12:35.382Z",
        "action_counter": 4509
      }
    ]
  },
  "find_path_v5_unseen_traversable": {
    "description": "Finds the shortest path to a target coordinate, correctly handling all collision types and treating 'unseen' tiles as traversable. Returns a list of button strings.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "description": "If true, the buttons will be pressed automatically.",
          "type": "boolean"
        },
        "target_x": {
          "description": "The x-coordinate of the target tile.",
          "type": "integer"
        },
        "target_y": {
          "description": "The y-coordinate of the target tile.",
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ],
      "type": "object"
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        print(f\"Error parsing map_xml_string: {e}\")\n        return\n\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    player_x, player_y = -1, -1\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            if tile.find('Player') is not None:\n                player_x = int(tile.attrib['id'])\n                player_y = y\n                break\n        if player_x != -1:\n            break\n            \n    if player_x == -1:\n        print(\"Player position not found.\")\n        return\n\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n\n    # Collision types that block movement\n    impassable_types = {\"WALL\", \"WATER\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"BOOKSHELF\", \"PC\", \"TOWN_MAP\", \"WINDOW\"}\n\n    # Map layout\n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            has_object = tile.attrib.get('has-object') == 'true'\n            \n            # Treat unseen as traversable for exploration\n            is_passable = t_type not in impassable_types and not has_object or t_type == \"unseen\"\n            grid[(x, y)] = is_passable\n\n    # BFS for shortest path\n    queue = deque([(player_x, player_y, [])])\n    visited = {(player_x, player_y)}\n    \n    while queue:\n        x, y, path = queue.popleft()\n        \n        if x == target_x and y == target_y:\n            print(json.dumps(path))\n            return\n            \n        for dx, dy, btn in [(0, -1, \"Up\"), (0, 1, \"Down\"), (-1, 0, \"Left\"), (1, 0, \"Right\")]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:\n                if grid.get((nx, ny), False) or (nx == target_x and ny == target_y):\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [btn]))\n\n    print(\"No path found.\")\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-19T06:27:37.692Z",
        "action_counter": 3482
      },
      {
        "commit_message": "Fix player position detection by avoiding parent navigation in XML.",
        "timestamp": "2025-12-19T06:28:11.213Z",
        "action_counter": 3484
      }
    ]
  },
  "give_item_v1_refined": {
    "description": "Gives an item from the PACK to a Pokémon. Assumes overworld. Parameters: item_index (0-indexed position in the current pocket), pokemon_index (1-indexed position in the party), current_menu_index (0-indexed position of the menu cursor, POKEDEX=0, EXIT=7).",
    "input_schema": {
      "type": "object",
      "properties": {
        "item_index": {
          "type": "integer",
          "description": "0-indexed position of the item in the current pocket"
        },
        "pokemon_index": {
          "type": "integer",
          "description": "1-indexed position of the Pokémon in the party"
        },
        "current_menu_index": {
          "type": "integer",
          "description": "0-indexed position of the current menu cursor (POKEDEX=0, EXIT=7)"
        }
      },
      "required": [
        "item_index",
        "pokemon_index",
        "current_menu_index"
      ]
    },
    "python_script": "\nimport json\n\ndef main():\n    item_index = int(input_data['item_index'])\n    pokemon_index = int(input_data['pokemon_index'])\n    current_menu_index = int(input_data['current_menu_index'])\n    \n    buttons = [\"Start\", \"sleep 500\"]\n    \n    # Navigate to Pack (index 2)\n    diff = 2 - current_menu_index\n    if diff > 0:\n        for _ in range(diff):\n            buttons.append(\"Down\")\n    elif diff < 0:\n        for _ in range(abs(diff)):\n            buttons.append(\"Up\")\n            \n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # Navigate to Item\n    for _ in range(item_index):\n        buttons.append(\"Down\")\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # Select GIVE (2nd option)\n    buttons.append(\"Down\")\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # Select Pokemon\n    for _ in range(pokemon_index - 1):\n        buttons.append(\"Down\")\n    buttons.append(\"A\")\n    buttons.append(\"sleep 1000\")\n    \n    # Clear text\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    buttons.append(\"A\")\n    \n    print(json.dumps(buttons))\n\nif __name__ == \"__main__\":\n    main()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-19T10:55:52.584Z",
        "action_counter": 3933
      }
    ]
  },
  "press_sequence": {
    "description": "Executes a specific sequence of button presses, allowing for mixed directional and action inputs. Useful for complex menu navigation.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nprint(json.dumps(input_data['buttons']))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T06:11:16.135Z",
        "action_counter": 948
      }
    ]
  }
}