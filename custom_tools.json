{
  "path_master_v8": {
    "description": "A superior pathfinding tool that uses BFS. It correctly handles one-way tiles, directional ledges, and avoids unintentionally stepping on directional warp tiles. This version has corrected logic for leaving ledge tiles and improved debugging.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "on_screen_impassable_coordinates": {
          "type": "string",
          "description": "A JSON string of a list of [x, y] coordinates for on-screen objects to treat as impassable."
        },
        "extra_impassable_coordinates": {
          "type": "string",
          "description": "A JSON string of a list of additional [x, y] coordinates to treat as impassable."
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef find_path_bfs(grid, start, end, all_impassable, debug_info):\n    impassable_base = {\n        'WALL', 'VOID', 'WATER', 'CUT_TREE', 'COUNTER', 'BUOY', 'HEADBUTT_TREE', 'unseen',\n        'MART_SHELF', 'BOOKSHELF', 'TV', 'RADIO', 'PC', 'TOWN_MAP', 'WINDOW', 'PAINTING', 'STATUE', 'PILLAR',\n        'BED', 'TABLE', 'CHAIR'\n    }\n    directional_warps = {'WARP_CARPET_DOWN', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT'}\n    \n    debug_info['impassable_base_types'] = list(impassable_base)\n    debug_info['impassable_coordinates_from_input'] = [list(coord) for coord in all_impassable]\n\n    if start not in grid:\n        debug_info['error'] = f'Start position {start} not in grid.'\n        return None\n    if end not in grid:\n        debug_info['error'] = f'End position {end} not in grid.'\n        return None\n\n    if grid.get(start, {}).get('type') in impassable_base or start in all_impassable:\n        debug_info['error'] = f'Start position {start} is on an impassable tile type or object.'\n        return None\n\n    queue = deque([(start, [start])])\n    visited = {start}\n\n    while queue:\n        current_pos, path = queue.popleft()\n\n        if current_pos == end:\n            return [list(p) for p in path]\n\n        current_type = grid.get(current_pos, {}).get('type')\n\n        for move_x, move_y, move_name in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            # Correctly scoped directional checks\n            if current_type == 'LEDGE_HOP_DOWN' and move_name != 'Down': continue\n            if current_type == 'LEDGE_HOP_LEFT' and move_name != 'Left': continue\n            if current_type == 'LEDGE_HOP_RIGHT' and move_name != 'Right': continue\n            if current_type == 'FLOOR_UP_WALL' and move_name in ['Up', 'Down']: continue\n\n            next_pos = (current_pos[0] + move_x, current_pos[1] + move_y)\n\n            if next_pos not in grid or next_pos in visited:\n                continue\n            \n            next_type = grid.get(next_pos, {}).get('type')\n            \n            if next_type in impassable_base:\n                continue\n\n            if next_type in directional_warps and next_pos != end:\n                continue\n\n            if next_pos in all_impassable and next_pos != end:\n                continue\n            \n            if next_type == 'FLOOR_UP_WALL' and move_name != 'Up': continue\n            \n            visited.add(next_pos)\n            new_path = list(path)\n            new_path.append(next_pos)\n            queue.append((next_pos, new_path))\n\n    debug_info['error'] = 'No path found to destination.'\n    debug_info['nodes_checked'] = len(visited)\n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    \n    on_screen_impassable_str = input_data.get('on_screen_impassable_coordinates') or '[]'\n    on_screen_impassable = {tuple(coord) for coord in json.loads(on_screen_impassable_str)}\n\n    extra_impassable_str = input_data.get('extra_impassable_coordinates') or '[]'\n    extra_impassable = {tuple(coord) for coord in json.loads(extra_impassable_str)}\n    \n    debug_info = {\n        \"inputs\": {\n            \"start\": [start_x, start_y],\n            \"end\": [end_x, end_y],\n            \"on_screen_impassable\": list(on_screen_impassable),\n            \"extra_impassable\": list(extra_impassable)\n        }\n    }\n\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    \n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            grid[(x, y)] = {'type': tile.get('type')}\n\n    all_impassable = on_screen_impassable.union(extra_impassable)\n    \n    path = find_path_bfs(grid, (start_x, start_y), (end_x, end_y), all_impassable, debug_info)\n    \n    print(json.dumps({'path': path if path else [], 'debug': debug_info}))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'path': [], 'debug': {'error': f\"An exception occurred: {str(e)}\\n{traceback.format_exc()}\"}}))"
  },
  "path_master_v9": {
    "description": "A superior pathfinding tool that uses BFS. It correctly handles one-way tiles, directional ledges, and avoids unintentionally stepping on directional warp tiles. This version has enhanced debugging.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "on_screen_impassable_coordinates": {
          "type": "string",
          "description": "A JSON string of a list of [x, y] coordinates for on-screen objects to treat as impassable."
        },
        "extra_impassable_coordinates": {
          "type": "string",
          "description": "A JSON string of a list of additional [x, y] coordinates to treat as impassable."
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "\nimport xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef find_path_bfs(grid, start, end, all_impassable, debug_info):\n    impassable_base = {\n        'WALL', 'VOID', 'WATER', 'CUT_TREE', 'COUNTER', 'BUOY', 'HEADBUTT_TREE', 'unseen',\n        'MART_SHELF', 'BOOKSHELF', 'TV', 'RADIO', 'PC', 'TOWN_MAP', 'WINDOW', 'PAINTING', 'STATUE', 'PILLAR',\n        'BED', 'TABLE', 'CHAIR'\n    }\n    directional_warps = {'WARP_CARPET_DOWN', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT'}\n    \n    debug_info['impassable_base_types'] = list(impassable_base)\n    debug_info['impassable_coordinates_from_input'] = [list(coord) for coord in all_impassable]\n    debug_info['rejection_log'] = []\n    debug_info['visit_log'] = []\n\n    if start not in grid:\n        debug_info['error'] = f'Start position {start} not in grid.'\n        return None\n    if end not in grid:\n        debug_info['error'] = f'End position {end} not in grid.'\n        return None\n\n    if grid.get(start, {}).get('type') in impassable_base or start in all_impassable:\n        debug_info['error'] = f'Start position {start} is on an impassable tile type or object.'\n        return None\n\n    queue = deque([(start, [start])])\n    visited = {start}\n\n    while queue:\n        current_pos, path = queue.popleft()\n        debug_info['visit_log'].append(list(current_pos))\n\n        if current_pos == end:\n            return [list(p) for p in path]\n\n        current_type = grid.get(current_pos, {}).get('type')\n\n        for move_x, move_y, move_name in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            next_pos = (current_pos[0] + move_x, current_pos[1] + move_y)\n            \n            rejection_reason = None\n            if current_type == 'LEDGE_HOP_DOWN' and move_name != 'Down': rejection_reason = f\"Cannot move {move_name} from LEDGE_HOP_DOWN\"\n            elif current_type == 'LEDGE_HOP_LEFT' and move_name != 'Left': rejection_reason = f\"Cannot move {move_name} from LEDGE_HOP_LEFT\"\n            elif current_type == 'LEDGE_HOP_RIGHT' and move_name != 'Right': rejection_reason = f\"Cannot move {move_name} from LEDGE_HOP_RIGHT\"\n            elif current_type == 'FLOOR_UP_WALL' and move_name in ['Up', 'Down']: rejection_reason = f\"Cannot move {move_name} from FLOOR_UP_WALL\"\n            elif next_pos not in grid: rejection_reason = \"Out of bounds\"\n            elif next_pos in visited: rejection_reason = \"Already visited\"\n            else:\n                next_type = grid.get(next_pos, {}).get('type')\n                if next_type in impassable_base: rejection_reason = f\"Impassable type: {next_type}\"\n                elif next_type in directional_warps and next_pos != end: rejection_reason = \"Directional warp\"\n                elif next_pos in all_impassable and next_pos != end: rejection_reason = \"Impassable coordinate\"\n                elif next_type == 'FLOOR_UP_WALL' and move_name != 'Up': rejection_reason = \"Cannot enter FLOOR_UP_WALL except by moving Up\"\n\n            if rejection_reason:\n                debug_info['rejection_log'].append(f\"Rejected {next_pos} from {current_pos}: {rejection_reason}\")\n                continue\n            \n            visited.add(next_pos)\n            new_path = list(path)\n            new_path.append(next_pos)\n            queue.append((next_pos, new_path))\n\n    debug_info['error'] = 'No path found to destination.'\n    debug_info['nodes_checked'] = len(visited)\n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    \n    on_screen_impassable_str = input_data.get('on_screen_impassable_coordinates') or '[]'\n    on_screen_impassable = {tuple(coord) for coord in json.loads(on_screen_impassable_str)}\n\n    extra_impassable_str = input_data.get('extra_impassable_coordinates') or '[]'\n    extra_impassable = {tuple(coord) for coord in json.loads(extra_impassable_str)}\n    \n    debug_info = {\n        \"inputs\": {\n            \"start\": [start_x, start_y],\n            \"end\": [end_x, end_y],\n            \"on_screen_impassable\": list(on_screen_impassable),\n            \"extra_impassable\": list(extra_impassable)\n        }\n    }\n\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    \n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            grid[(x, y)] = {'type': tile.get('type')}\n\n    all_impassable = on_screen_impassable.union(extra_impassable)\n    \n    path = find_path_bfs(grid, (start_x, start_y), (end_x, end_y), all_impassable, debug_info)\n    \n    print(json.dumps({'path': path if path else [], 'debug': debug_info}))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'path': [], 'debug': {'error': f\"An exception occurred: {str(e)}\\n{traceback.format_exc()}\"}}))\n"
  },
  "exploration_master": {
    "description": "Finds the shortest path to the nearest unseen tile on the current map. Takes the player's current coordinates and a JSON string of already visited coordinates as input.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "visited_coordinates": {
          "type": "string",
          "description": "A JSON string of a list of [x, y] coordinates that have been visited."
        }
      },
      "required": [
        "start_x",
        "start_y",
        "visited_coordinates"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef find_path_to_nearest_unseen(grid, start, visited_coords, impassable_types):\n    queue = deque([(start, [start])])\n    visited = {start}.union(visited_coords)\n    \n    while queue:\n        current_pos, path = queue.popleft()\n        \n        if grid.get(current_pos, {}).get('type') == 'unseen':\n            return [list(p) for p in path]\n        \n        for move_x, move_y in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            next_pos = (current_pos[0] + move_x, current_pos[1] + move_y)\n            \n            if next_pos in visited or next_pos not in grid or grid.get(next_pos, {}).get('type') in impassable_types:\n                continue\n            \n            visited.add(next_pos)\n            new_path = list(path)\n            new_path.append(next_pos)\n            queue.append((next_pos, new_path))\n            \n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    visited_coordinates_str = input_data.get('visited_coordinates') or '[]'\n    visited_coordinates = {tuple(coord) for coord in json.loads(visited_coordinates_str)}\n\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    impassable_base = {'WALL', 'VOID', 'WATER', 'CUT_TREE', 'COUNTER', 'BUOY', 'HEADBUTT_TREE'}\n    \n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            grid[(x, y)] = {'type': tile.get('type')}\n            \n    path = find_path_to_nearest_unseen(grid, (start_x, start_y), visited_coordinates, impassable_base)\n    \n    print(json.dumps({'path': path if path else []}))\n\nexcept Exception as e:\n    print(json.dumps({'path': [], 'error': str(e)}))\n"
  },
  "path_master_v10": {
    "description": "A superior pathfinding tool that uses BFS. It correctly handles one-way tiles, directional ledges, and avoids unintentionally stepping on directional warp tiles. This version has corrected logic for entering and leaving ledge tiles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "on_screen_impassable_coordinates": {
          "type": "string",
          "description": "A JSON string of a list of [x, y] coordinates for on-screen objects to treat as impassable."
        },
        "extra_impassable_coordinates": {
          "type": "string",
          "description": "A JSON string of a list of additional [x, y] coordinates to treat as impassable."
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef find_path_bfs(grid, start, end, all_impassable, debug_info):\n    impassable_base = {\n        'WALL', 'VOID', 'WATER', 'CUT_TREE', 'COUNTER', 'BUOY', 'HEADBUTT_TREE', 'unseen',\n        'MART_SHELF', 'BOOKSHELF', 'TV', 'RADIO', 'PC', 'TOWN_MAP', 'WINDOW', 'PAINTING', 'STATUE', 'PILLAR',\n        'BED', 'TABLE', 'CHAIR'\n    }\n    directional_warps = {'WARP_CARPET_DOWN', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT'}\n    \n    debug_info['impassable_base_types'] = list(impassable_base)\n    debug_info['impassable_coordinates_from_input'] = [list(coord) for coord in all_impassable]\n    debug_info['rejection_log'] = []\n    debug_info['visit_log'] = []\n\n    if start not in grid:\n        debug_info['error'] = f'Start position {start} not in grid.'\n        return None\n    if end not in grid:\n        debug_info['error'] = f'End position {end} not in grid.'\n        return None\n\n    if grid.get(start, {}).get('type') in impassable_base or start in all_impassable:\n        debug_info['error'] = f'Start position {start} is on an impassable tile type or object.'\n        return None\n\n    queue = deque([(start, [start])])\n    visited = {start}\n\n    while queue:\n        current_pos, path = queue.popleft()\n        debug_info['visit_log'].append(list(current_pos))\n\n        if current_pos == end:\n            return [list(p) for p in path]\n\n        current_type = grid.get(current_pos, {}).get('type')\n\n        for move_x, move_y, move_name in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            next_pos = (current_pos[0] + move_x, current_pos[1] + move_y)\n            \n            rejection_reason = None\n            # Rules for leaving a tile\n            if current_type == 'LEDGE_HOP_DOWN' and move_name != 'Down': rejection_reason = f\"Cannot move {move_name} from LEDGE_HOP_DOWN\"\n            elif current_type == 'LEDGE_HOP_LEFT' and move_name != 'Left': rejection_reason = f\"Cannot move {move_name} from LEDGE_HOP_LEFT\"\n            elif current_type == 'LEDGE_HOP_RIGHT' and move_name != 'Right': rejection_reason = f\"Cannot move {move_name} from LEDGE_HOP_RIGHT\"\n            elif current_type == 'FLOOR_UP_WALL' and move_name in ['Up', 'Down']: rejection_reason = f\"Cannot move {move_name} from FLOOR_UP_WALL\"\n            elif next_pos not in grid: rejection_reason = \"Out of bounds\"\n            elif next_pos in visited: rejection_reason = \"Already visited\"\n            else:\n                next_type = grid.get(next_pos, {}).get('type')\n                # Rules for entering a tile\n                if next_type in impassable_base: rejection_reason = f\"Impassable type: {next_type}\"\n                elif next_type in directional_warps and next_pos != end: rejection_reason = \"Directional warp\"\n                elif next_pos in all_impassable and next_pos != end: rejection_reason = \"Impassable coordinate\"\n                elif next_type == 'FLOOR_UP_WALL' and move_name != 'Up': rejection_reason = \"Cannot enter FLOOR_UP_WALL except by moving Up\"\n                elif next_type == 'LEDGE_HOP_LEFT' and move_name == 'Right': rejection_reason = f\"Cannot move Right onto a LEDGE_HOP_LEFT tile\"\n                elif next_type == 'LEDGE_HOP_RIGHT' and move_name == 'Left': rejection_reason = f\"Cannot move Left onto a LEDGE_HOP_RIGHT tile\"\n                elif next_type == 'LEDGE_HOP_DOWN' and move_name == 'Up': rejection_reason = f\"Cannot move Up onto a LEDGE_HOP_DOWN tile\"\n\n            if rejection_reason:\n                debug_info['rejection_log'].append(f\"Rejected {next_pos} from {current_pos}: {rejection_reason}\")\n                continue\n            \n            visited.add(next_pos)\n            new_path = list(path)\n            new_path.append(next_pos)\n            queue.append((next_pos, new_path))\n\n    debug_info['error'] = 'No path found to destination.'\n    debug_info['nodes_checked'] = len(visited)\n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    \n    on_screen_impassable_str = input_data.get('on_screen_impassable_coordinates') or '[]'\n    on_screen_impassable = {tuple(coord) for coord in json.loads(on_screen_impassable_str)}\n\n    extra_impassable_str = input_data.get('extra_impassable_coordinates') or '[]'\n    extra_impassable = {tuple(coord) for coord in json.loads(extra_impassable_str)}\n    \n    debug_info = {\n        \"inputs\": {\n            \"start\": [start_x, start_y],\n            \"end\": [end_x, end_y],\n            \"on_screen_impassable\": list(on_screen_impassable),\n            \"extra_impassable\": list(extra_impassable)\n        }\n    }\n\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    \n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            grid[(x, y)] = {'type': tile.get('type')}\n\n    all_impassable = on_screen_impassable.union(extra_impassable)\n    \n    path = find_path_bfs(grid, (start_x, start_y), (end_x, end_y), all_impassable, debug_info)\n    \n    print(json.dumps({'path': path if path else [], 'debug': debug_info}))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'path': [], 'debug': {'error': f\"An exception occurred: {str(e)}\\n{traceback.format_exc()}\"}}))\n"
  }
}