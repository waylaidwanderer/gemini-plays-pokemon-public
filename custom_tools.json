{
  "maze_solver": {
    "description": "Solves invisible arrow tile mazes. It simulates movement from a starting point and explores the maze using a Breadth-First Search, returning the sequence of directional inputs to reach a target coordinate. It requires the map XML and a list of known arrow tile behaviors.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "arrow_tiles_json": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "arrow_tiles_json"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.attrib['width'])\nheight = int(root.attrib['height'])\n\ngrid = {}\nimpassable = set()\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.attrib['id'])\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.attrib['id'])\n        grid[(x, y)] = tile_elem.attrib['type']\n        if grid[(x, y)] in ['WALL', 'COUNTER', 'PC', 'BOOKSHELF'] or tile_elem.find('Object') is not None:\n            impassable.add((x, y))\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\narrow_tiles = json.loads(input_data['arrow_tiles_json'])\n\narrow_map = { (t['start_x'], t['start_y']): (t['end_x'], t['end_y']) for t in arrow_tiles }\n\nqueue = deque([((start_x, start_y), [])])\nvisited = set([(start_x, start_y)])\n\nwhile queue:\n    (x, y), path = queue.popleft()\n\n    if x == end_x and y == end_y:\n        print(json.dumps(path))\n        exit()\n\n    # Check arrow tile\n    if (x, y) in arrow_map:\n        next_x, next_y = arrow_map[(x, y)]\n        if (next_x, next_y) not in visited:\n            visited.add((next_x, next_y))\n            new_path = path + [f\"Step on arrow at ({x}, {y})\"]\n            queue.append(((next_x, next_y), new_path))\n        continue\n\n    # Standard movement\n    for move, (dx, dy) in {'Up': (0, -1), 'Down': (0, 1), 'Left': (-1, 0), 'Right': (1, 0)}.items():\n        nx, ny = x + dx, y + dy\n        if (nx, ny) not in impassable and (nx, ny) not in visited:\n            visited.add((nx, ny))\n            new_path = path + [move]\n            queue.append(((nx, ny), new_path))\n\nprint(json.dumps([])) # No path found"
  },
  "puzzle_solver": {
    "description": "Solves Sokoban-style boulder puzzles. Takes optional start coordinates, but requires goal coordinates for the final boulder position. It uses a Breadth-First Search algorithm to find the optimal sequence of moves.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer",
          "nullable": true
        },
        "start_y": {
          "type": "integer",
          "nullable": true
        },
        "goal_x": {
          "type": "integer"
        },
        "goal_y": {
          "type": "integer"
        }
      },
      "required": [
        "goal_x",
        "goal_y"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\n\n# Parse map data\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\n\nwalls = set()\nboulders = []\nplayer_start = None\n\nfor r_idx, row_elem in enumerate(root.findall('Row')):\n    y = r_idx + 1\n    for t_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n        x = t_idx + 1\n        tile_type = tile_elem.get('type')\n        if tile_type == 'WALL':\n            walls.add((x, y))\n        if tile_elem.find('Object[@id-name=\"BOULDER\"]') is not None:\n            boulders.append((x, y))\n        if tile_elem.find('Player') is not None:\n            player_start = (x, y)\n\n# Override start position if provided\nif 'start_x' in input_data and input_data['start_x'] is not None:\n    player_start = (int(input_data['start_x']), int(input_data['start_y']))\n\ngoal_pos = (int(input_data['goal_x']), int(input_data['goal_y']))\n\n# --- BFS Solver ---\ninitial_state = (player_start, tuple(sorted(boulders)))\nqueue = collections.deque([(initial_state, [])])\nvisited = {initial_state}\n\npath_found = False\nwhile queue:\n    (current_player, current_boulders), path = queue.popleft()\n\n    # Check for goal state\n    if goal_pos in current_boulders:\n        print(f\"Solution found: {path}\")\n        path_found = True\n        break\n\n    # Explore neighbors\n    for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n        next_player_pos = (current_player[0] + dx, current_player[1] + dy)\n\n        # Simple move (no push)\n        if next_player_pos not in walls and next_player_pos not in current_boulders:\n            new_state = (next_player_pos, current_boulders)\n            if new_state not in visited:\n                visited.add(new_state)\n                queue.append((new_state, path + [move]))\n            continue\n\n        # Boulder push\n        if next_player_pos in current_boulders:\n            boulder_to_push = next_player_pos\n            next_boulder_pos = (boulder_to_push[0] + dx, boulder_to_push[1] + dy)\n\n            if next_boulder_pos not in walls and next_boulder_pos not in current_boulders:\n                new_boulders = list(current_boulders)\n                new_boulders.remove(boulder_to_push)\n                new_boulders.append(next_boulder_pos)\n                new_boulders_tuple = tuple(sorted(new_boulders))\n                \n                new_state = (next_player_pos, new_boulders_tuple)\n                if new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, path + [f\"Push {move}\"])) \n\nif not path_found:\n    print(\"No solution found.\")"
  },
  "dungeon_analyst": {
    "description": "Analyzes the connectivity of interconnected maps (like a dungeon) using their XML data. It builds a graph of all warps to identify partitioned areas, dead ends, and suggests an optimal exploration route to uncover the entire dungeon.",
    "input_schema": {
      "type": "object",
      "properties": {
        "maps": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "map_id": {
                "type": "string"
              },
              "map_xml": {
                "type": "string"
              }
            },
            "required": [
              "map_id",
              "map_xml"
            ]
          }
        }
      },
      "required": [
        "maps"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\nmaps_data = json.loads(input_data['maps'])\ngraph = {}\nmap_names = {m['map_id']: ET.fromstring(m['map_xml']).get('name') for m in maps_data}\n\nfor map_info in maps_data:\n    map_id = map_info['map_id']\n    root = ET.fromstring(map_info['map_xml'])\n    if map_id not in graph:\n        graph[map_id] = []\n    for warp in root.findall('.//Warp'):\n        dest_map_id = warp.get('dest_map_id')\n        if dest_map_id:\n            graph[map_id].append(dest_map_id)\n\n# Basic analysis for now, will be improved\nstart_map = maps_data[0]['map_id']\nqueue = [start_map]\nvisited = {start_map}\nexploration_route = [map_names[start_map]]\n\nwhile queue:\n    current_map = queue.pop(0)\n    for neighbor in graph.get(current_map, []):\n        if neighbor not in visited:\n            visited.add(neighbor)\n            queue.append(neighbor)\n            exploration_route.append(map_names[neighbor])\n\nall_maps = set(map_names.keys())\nunreachable = all_maps - visited\n\nanalysis = f\"Reachable maps: {[map_names[m] for m in visited]}. \"\nif unreachable:\n    analysis += f\"Unreachable maps: {[map_names[m] for m in unreachable]}.\"\nelse:\n    analysis += \"All maps are connected.\"\n\nprint(json.dumps({'connectivity_analysis': analysis, 'optimal_exploration_route': exploration_route}))"
  },
  "pathfinder_v3": {
    "description": "Finds the shortest path on the current map using A*. It avoids impassable tiles and can handle impassable destinations by finding a path to an adjacent traversable tile. This version is updated to treat one-way ledges as impassable and correctly handles coordinate systems. It now also accepts a list of coordinates to avoid.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "can_surf": {
          "type": "boolean",
          "default": false
        },
        "avoid_coords": {
          "type": "string",
          "description": "A JSON string of a list of [x, y] coordinates to avoid.",
          "default": "[]"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\nimport json\n\nclass Node:\n    def __init__(self, x, y, g_cost=0, h_cost=0, parent=None):\n        self.x = x\n        self.y = y\n        self.g_cost = g_cost\n        self.h_cost = h_cost\n        self.f_cost = g_cost + h_cost\n        self.parent = parent\n\n    def __lt__(self, other):\n        return self.f_cost < other.f_cost\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.attrib['width'])\nheight = int(root.attrib['height'])\ngrid = [['' for _ in range(width)] for _ in range(height)]\nimpassable_tiles = set()\n\navoid_coords_str = input_data.get('avoid_coords', '[]')\ntry:\n    coords_to_avoid = json.loads(avoid_coords_str)\n    for x, y in coords_to_avoid:\n        impassable_tiles.add((x, y))\nexcept json.JSONDecodeError:\n    pass\n\ncan_surf = input_data.get('can_surf', 'false').lower() == 'true'\n\nfor row in root.findall('Row'):\n    y = int(row.attrib['id'])\n    for tile in row.findall('Tile'):\n        x = int(tile.attrib['id'])\n        if 0 <= x < width and 0 <= y < height:\n            tile_type = tile.attrib['type']\n            grid[y][x] = tile_type\n            if tile_type in ['WALL', 'COUNTER', 'MART_SHELF', 'PC', 'BOOKSHELF', 'HEADBUTT_TREE', 'CUT_TREE', 'TV', 'TOWN_MAP', 'WINDOW', 'ROCK', 'BUOY', 'VOID']:\n                impassable_tiles.add((x, y))\n            if not can_surf and tile_type in ['WATER', 'SEA']:\n                impassable_tiles.add((x,y))\n            if tile.find('Object') is not None:\n                impassable_tiles.add((x, y))\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nstart_node = Node(start_x, start_y)\nend_node = Node(end_x, end_y)\n\ngoal_coords = set()\nif 0 <= end_x < width and 0 <= end_y < height and (end_x, end_y) not in impassable_tiles:\n    goal_coords.add((end_x, end_y))\nelse:\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        adj_x, adj_y = end_x + dx, end_y + dy\n        if (0 <= adj_x < width and 0 <= adj_y < height and (adj_x, adj_y) not in impassable_tiles):\n            goal_coords.add((adj_x, adj_y))\n\nif not goal_coords:\n    print('No path found')\n    exit()\n\nopen_list = []\nclosed_list = set()\nheapq.heappush(open_list, start_node)\n\nwhile open_list:\n    current_node = heapq.heappop(open_list)\n\n    if (current_node.x, current_node.y) in goal_coords:\n        path = []\n        while current_node:\n            path.append({'x': current_node.x, 'y': current_node.y})\n            current_node = current_node.parent\n        print(json.dumps(path[::-1]))\n        exit()\n\n    if (current_node.x, current_node.y) in closed_list:\n        continue\n    closed_list.add((current_node.x, current_node.y))\n\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        neighbor_x, neighbor_y = current_node.x + dx, current_node.y + dy\n\n        if not (0 <= neighbor_x < width and 0 <= neighbor_y < height):\n            continue\n\n        if (neighbor_x, neighbor_y) in impassable_tiles:\n            continue\n\n        if (neighbor_x, neighbor_y) in closed_list:\n            continue\n\n        current_tile_type = grid[current_node.y][current_node.x]\n        if current_tile_type.startswith('LEDGE_HOP_'):\n            ledge_direction = current_tile_type.split('_')[-1].lower()\n            if (ledge_direction == 'down' and (dx, dy) != (0, 1)) or \\\n               (ledge_direction == 'up' and (dx, dy) != (0, -1)) or \\\n               (ledge_direction == 'left' and (dx, dy) != (-1, 0)) or \\\n               (ledge_direction == 'right' and (dx, dy) != (1, 0)):\n                continue\n\n        g_cost = current_node.g_cost + 1\n        h_cost = abs(neighbor_x - end_node.x) + abs(neighbor_y - end_node.y)\n        neighbor_node = Node(neighbor_x, neighbor_y, g_cost, h_cost, current_node)\n        heapq.heappush(open_list, neighbor_node)\n\nprint('No path found')"
  },
  "maze_mapper": {
    "description": "Systematically explores a grid-based maze from a starting point. It takes the player's current coordinates and a list of already visited/tested coordinates. It uses a breadth-first search approach on unseen tiles to suggest the next logical tile to explore, prioritizing adjacent tiles. This helps to methodically map out an area without missing tiles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "visited_coords": {
          "type": "string",
          "description": "A JSON string of a list of [x, y] coordinates that have already been visited."
        }
      },
      "required": [
        "start_x",
        "start_y",
        "visited_coords"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nvisited_coords_str = input_data['visited_coords']\n\n# Parse the map XML\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.attrib['width'])\nheight = int(root.attrib['height'])\n\ngrid = [[(None, False) for _ in range(width + 1)] for _ in range(height + 1)]\nimpassable_types = {'WALL', 'COUNTER', 'MART_SHELF', 'PC', 'BOOKSHELF', 'HEADBUTT_TREE', 'CUT_TREE', 'TV', 'TOWN_MAP', 'WINDOW', 'ROCK', 'BUOY', 'VOID', 'RADIO', 'INCENSE_BURNER'}\n\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.attrib['id'])\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.attrib['id'])\n        tile_type = tile_elem.attrib['type']\n        has_object = tile_elem.find('Object') is not None\n        grid[y][x] = (tile_type, has_object)\n\n# Parse visited coordinates\nvisited = set()\nif visited_coords_str:\n    try:\n        visited_list = json.loads(visited_coords_str)\n        for coord in visited_list:\n            visited.add(tuple(coord))\n    except json.JSONDecodeError:\n        print('Error: Invalid JSON in visited_coords.')\n        exit()\n\n# BFS to find the nearest unseen, traversable tile\nqueue = [(start_x, start_y)]\nbfs_visited = set([(start_x, start_y)])\n\nif (start_x, start_y) not in visited:\n    visited.add((start_x, start_y))\n\nfound_target = False\nwhile queue:\n    cx, cy = queue.pop(0)\n\n    # Check neighbors\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]: # Up, Down, Left, Right\n        nx, ny = cx + dx, cy + dy\n\n        if 1 <= nx <= width and 1 <= ny <= height:\n            if (nx, ny) not in bfs_visited:\n                bfs_visited.add((nx, ny))\n                tile_type, has_object = grid[ny][nx]\n                is_traversable = tile_type not in impassable_types and not has_object\n\n                if is_traversable:\n                    if (nx, ny) not in visited:\n                        print(json.dumps({'next_x': nx, 'next_y': ny}))\n                        found_target = True\n                        break\n                    queue.append((nx, ny))\n    if found_target:\n        break\n\nif not found_target:\n    print(json.dumps({'next_x': None, 'next_y': None, 'message': 'All reachable tiles have been visited.'}))"
  }
}