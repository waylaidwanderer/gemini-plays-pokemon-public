{
  "find_reachable_unseen_tiles": {
    "description": "Identifies all unseen tiles on the current map that are adjacent to reachable walkable tiles. If autopress_buttons is true, returns a path to the nearest one.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "type": "boolean"
        },
        "current_x": {
          "type": "integer"
        },
        "current_y": {
          "type": "integer"
        }
      },
      "required": [
        "current_x",
        "current_y",
        "autopress_buttons"
      ],
      "type": "object"
    },
    "python_script": "import json\nfrom xml.etree import ElementTree as ET\n\ndef solve():\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    unseen = []\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            seen = tile.attrib['seen'] == 'true'\n            grid[(x, y)] = (t_type, seen)\n            if not seen:\n                unseen.append((x, y))\n                \n    start = (int(input_data['current_x']), int(input_data['current_y']))\n    \n    def get_path(target):\n        queue = [(start, [])]\n        visited = {start}\n        while queue:\n            (x, y), path = queue.pop(0)\n            if (x, y) == target:\n                return path\n            for dx, dy, btn in [(0, -1, \"Up\"), (0, 1, \"Down\"), (-1, 0, \"Left\"), (1, 0, \"Right\")]:\n                nx, ny = x + dx, y + dy\n                if (nx, ny) in grid and grid[(nx, ny)][0] not in ['WALL', 'BOOKSHELF', 'RADIO', 'TV', 'COUNTER'] and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append(((nx, ny), path + [btn]))\n        return None\n\n    reachable_unseen = []\n    for ux, uy in unseen:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = ux + dx, uy + dy\n            if (nx, ny) in grid and grid[(nx, ny)][0] not in ['WALL', 'BOOKSHELF', 'RADIO', 'TV', 'COUNTER'] and grid[(nx, ny)][1]:\n                path = get_path((nx, ny))\n                if path is not None:\n                    reachable_unseen.append({\"x\": ux, \"y\": uy})\n                    break\n                    \n    if input_data.get('autopress_buttons', False):\n        if not reachable_unseen:\n            print(json.dumps([]))\n            return\n        reachable_unseen.sort(key=lambda p: abs(p['x']-start[0]) + abs(p['y']-start[1]))\n        target_coords = (reachable_unseen[0]['x'], reachable_unseen[0]['y'])\n        \n        best_path = None\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = target_coords[0] + dx, target_coords[1] + dy\n            if (nx, ny) in grid and grid[(nx, ny)][0] not in ['WALL', 'BOOKSHELF', 'RADIO', 'TV', 'COUNTER'] and grid[(nx, ny)][1]:\n                path = get_path((nx, ny))\n                if path is not None:\n                    if best_path is None or len(path) < len(best_path):\n                        best_path = path\n        print(json.dumps(best_path if best_path else []))\n    else:\n        print(json.dumps(reachable_unseen))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T18:35:24.812Z",
        "action_counter": 41414
      },
      {
        "commit_message": "Refined logic to correctly identify unseen tiles adjacent to reachable walkable tiles. Removed 'unseen' from walkable types to ensure search only passes through confirmed traversable areas.",
        "timestamp": "2026-01-11T22:25:41.646Z",
        "action_counter": 41821
      },
      {
        "commit_message": "Fix find_reachable_unseen_tiles to return button strings when autopress_buttons is true.",
        "timestamp": "2026-01-12T01:57:28.881Z",
        "action_counter": 42305
      },
      {
        "commit_message": "Initial implementation of find_reachable_unseen_tiles. Fixed collision check to include BOOKSHELF.",
        "timestamp": "2026-01-12T04:26:41.177Z",
        "action_counter": 42572
      }
    ]
  },
  "find_path_v6_robust": {
    "description": "Finds a path between two coordinates on the current map, accounting for complex collision types (like one-way ledges and direction-specific walls) and treating 'unseen' tiles as walkable FLOOR for exploration.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "type": "boolean"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "autopress_buttons"
      ],
      "type": "object"
    },
    "python_script": "import json\nfrom xml.etree import ElementTree as ET\n\ndef solve():\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            grid[(x, y)] = tile\n\n    start = (int(input_data['start_x']), int(input_data['start_y']))\n    end = (int(input_data['end_x']), int(input_data['end_y']))\n    \n    def is_walkable(x, y, from_x, from_y):\n        if (x, y) not in grid: return False\n        tile = grid[(x, y)]\n        t_type = tile.attrib['type']\n        seen = tile.attrib['seen'] == 'true'\n        has_obj = tile.attrib.get('has-object') == 'true'\n        \n        if not seen: return True\n        if t_type in ['WALL', 'BOOKSHELF', 'RADIO', 'TV', 'COUNTER']: return False\n        if has_obj and (x, y) != end: return False\n        \n        if t_type == 'LEDGE_HOP_DOWN':\n            return y > from_y\n            \n        return True\n\n    queue = [(start, [])]\n    visited = {start}\n    \n    while queue:\n        (curr_x, curr_y), path = queue.pop(0)\n        if (curr_x, curr_y) == end:\n            print(json.dumps(path))\n            return\n            \n        for dx, dy, btn in [(0, -1, \"Up\"), (0, 1, \"Down\"), (-1, 0, \"Left\"), (1, 0, \"Right\")]:\n            nx, ny = curr_x + dx, curr_y + dy\n            if (nx, ny) not in visited and is_walkable(nx, ny, curr_x, curr_y):\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [btn]))\n                \n    print(json.dumps([]))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-12T03:28:58.212Z",
        "action_counter": 42451
      },
      {
        "commit_message": "Updated to handle CUT_TREE and WATER as impassable tiles.",
        "timestamp": "2026-01-12T03:56:06.060Z",
        "action_counter": 42503
      },
      {
        "commit_message": "Initial implementation of find_path_v6_robust. Fixed collision check to include BOOKSHELF and other impassable objects. Added handling for end-tile objects.",
        "timestamp": "2026-01-12T04:26:41.178Z",
        "action_counter": 42572
      }
    ]
  }
}