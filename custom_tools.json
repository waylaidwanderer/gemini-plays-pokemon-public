{
  "find_path": {
    "description": "Finds the shortest path on the current map using BFS. Avoids impassable tiles, objects, and unseen areas.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef find_path_logic(map_xml_string, start_x, start_y, end_x, end_y):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = [['' for _ in range(width + 1)] for _ in range(height + 1)]\n    \n    impassable_tiles = {'WALL', 'HEADBUTT_TREE', 'CUT_TREE', 'WATER', 'COUNTER', 'MART_SHELF', 'BUOY', 'TOWN_MAP', 'WINDOW', 'BOOKSHELF', 'TV', 'RADIO', 'VOID'}\n    \n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id'])\n            tile_type = tile_elem.attrib['type']\n            seen = tile_elem.attrib['seen']\n            \n            if seen == 'false' or tile_elem.find('Object') is not None or tile_type in impassable_tiles:\n                grid[y][x] = 'WALL'\n            else:\n                grid[y][x] = tile_type\n\n    start = (start_x, start_y)\n    end = (end_x, end_y)\n    \n    if not (1 <= start[0] <= width and 1 <= start[1] <= height and 1 <= end[0] <= width and 1 <= end[1] <= height):\n        return json.dumps({\"error\": \"Start or end coordinates are out of bounds.\"})\n\n    if grid[start[1]][start[0]] == 'WALL' or grid[end[1]][end[0]] == 'WALL':\n        return json.dumps({\"error\": \"Start or end tile is impassable.\"})\n\n    queue = deque([(start, [start])])\n    visited = {start}\n    \n    while queue:\n        (current_x, current_y), path = queue.popleft()\n        \n        if (current_x, current_y) == end:\n            return json.dumps([{'x': p[0], 'y': p[1]} for p in path])\n            \n        moves = [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]\n        \n        for dx, dy, move_dir in moves:\n            next_x, next_y = current_x + dx, current_y + dy\n            \n            if not (1 <= next_x <= width and 1 <= next_y <= height):\n                continue\n\n            if (next_x, next_y) in visited:\n                continue\n\n            next_tile_type = grid[next_y][next_x]\n            if next_tile_type == 'WALL':\n                continue\n            \n            current_tile_type = grid[current_y][current_x]\n            if dy == 1 and 'LEDGE' in current_tile_type: \n                pass\n            elif dy == -1 and 'LEDGE' in grid[next_y][next_x]:\n                continue\n\n            visited.add((next_x, next_y))\n            new_path = list(path)\n            new_path.append((next_x, next_y))\n            queue.append(((next_x, next_y), new_path))\n            \n    return json.dumps({\"error\": \"No path found.\"})\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nresult = find_path_logic(map_xml_string, start_x, start_y, end_x, end_y)\nprint(result)"
  },
  "path_master": {
    "description": "Finds the shortest path on the current map using A*. Avoids impassable tiles and objects. It can explore a limited number of unseen tiles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\nimport json\n\ndef run_path_master(start_x_str, start_y_str, end_x_str, end_y_str):\n    start_x, start_y = int(start_x_str), int(start_y_str)\n    end_x, end_y = int(end_x_str), int(end_y_str)\n\n    try:\n        root = ET.fromstring(map_xml_string)\n    except ET.ParseError as e:\n        print(f\"Error parsing map_xml_string: {e}\")\n        return\n\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = [['VOID' for _ in range(width + 1)] for _ in range(height + 1)]\n    objects = set()\n\n    impassable_types = {'WALL', 'WATER', 'CUT_TREE', 'BUOY', 'TOWN_MAP', 'WINDOW', 'BOOKSHELF', 'TV', 'RADIO', 'VOID', 'MART_SHELF', 'COUNTER', 'PC', 'HEADBUTT_TREE', 'PILLAR'}\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            \n            grid[y][x] = tile_type\n            \n            if tile_elem.get('seen') == 'false':\n                grid[y][x] = 'unseen'\n            \n            if tile_elem.find('Object') is not None:\n                objects.add((y, x))\n\n    def get_possible_moves(y, x):\n        tile_type = grid[y][x]\n        if 'FLOOR_HOP_DOWN_LEDGE' in tile_type:\n            return [(1, 0)]\n        if 'FLOOR_HOP_RIGHT_LEDGE' in tile_type:\n            return [(0, 1)]\n        if 'FLOOR_HOP_LEFT_LEDGE' in tile_type:\n            return [(0, -1)]\n        if 'FLOOR_HOP_DOWN_OR_RIGHT_LEDGE' in tile_type:\n            return [(1, 0), (0, 1)]\n        if 'FLOOR_HOP_DOWN_OR_LEFT_LEDGE' in tile_type:\n            return [(1, 0), (0, -1)]\n        return [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    def is_traversable(y, x, from_y, from_x, unseen_count):\n        if not (0 <= y <= height and 0 <= x <= width):\n            return False\n        tile_type = grid[y][x]\n        if tile_type in impassable_types or (y, x) in objects:\n            return False\n        \n        if y < from_y and 'LEDGE' in tile_type:\n            return False\n\n        if tile_type == 'unseen':\n            return unseen_count < 5\n\n        return True\n\n    start_node = (start_y, start_x)\n    end_node = (end_y, end_x)\n\n    if not (0 <= start_node[0] <= height and 0 <= start_node[1] <= width):\n        print(f\"Start {start_x, start_y} is out of bounds.\")\n        return\n\n    pq = [(0, start_node, [], 0)]\n    cost_so_far = {(start_node, 0): 0}\n\n    while pq:\n        _, current_coords, path, unseen_count = heapq.heappop(pq)\n        y, x = current_coords\n        current_state = (current_coords, unseen_count)\n\n        new_path = path + [current_coords]\n\n        if current_coords == end_node:\n            path_coords = [{'x': px, 'y': py} for py, px in new_path]\n            print(json.dumps(path_coords))\n            return\n\n        for dy, dx in get_possible_moves(y, x):\n            ny, nx = y + dy, x + dx\n            neighbor_coords = (ny, nx)\n            \n            next_unseen_count = unseen_count + 1 if grid[ny][nx] == 'unseen' else unseen_count\n            neighbor_state = (neighbor_coords, next_unseen_count)\n\n            if is_traversable(ny, nx, y, x, unseen_count):\n                new_cost = cost_so_far[current_state] + 1\n                if neighbor_state not in cost_so_far or new_cost < cost_so_far[neighbor_state]:\n                    cost_so_far[neighbor_state] = new_cost\n                    heuristic = abs(ny - end_node[0]) + abs(nx - end_node[1])\n                    priority = new_cost + heuristic\n                    heapq.heappush(pq, (priority, neighbor_coords, new_path, next_unseen_count))\n                \n    print(\"No path found\")\n\nrun_path_master(input_data['start_x'], input_data['start_y'], input_data['end_x'], input_data['end_y'])"
  },
  "unstick_me_tool": {
    "description": "Analyzes the map XML to find the nearest traversable tile adjacent to an 'unseen' area. Returns coordinates for a new navigation goal. Can also check for softlock conditions by analyzing warp connectivity.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport collections\n\ndef run_unstick_me_tool(start_x_str, start_y_str):\n    start_x, start_y = int(start_x_str), int(start_y_str)\n\n    try:\n        root = ET.fromstring(map_xml_string)\n        map_id = root.get('name')\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n    except ET.ParseError as e:\n        print(f\"Error parsing map_xml_string: {e}\")\n        return\n\n    grid = [['VOID' for _ in range(width + 1)] for _ in range(height + 1)]\n    objects = set()\n    unseen_tiles = []\n    warps = []\n\n    impassable_types = {'WALL', 'WATER', 'CUT_TREE', 'BUOY', 'TOWN_MAP', 'WINDOW', 'BOOKSHELF', 'TV', 'RADIO', 'VOID', 'MART_SHELF', 'COUNTER', 'PC', 'HEADBUTT_TREE', 'PILLAR'}\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            grid[y][x] = tile_type\n            if tile_elem.get('seen') == 'false':\n                unseen_tiles.append((x, y))\n            if tile_elem.find('Object') is not None:\n                objects.add((x, y))\n            if tile_elem.get('is-warp') == 'true':\n                warps.append((x, y))\n\n    def is_traversable(x, y):\n        if not (0 <= x < width and 0 <= y < height):\n            return False\n        return grid[y][x] not in impassable_types and (x, y) not in objects\n\n    # 1. Find nearest unseen tile\n    queue = collections.deque([((start_x, start_y), [])])\n    visited = {(start_x, start_y)}\n\n    while queue:\n        (x, y), path = queue.popleft()\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if is_traversable(nx, ny) and (nx, ny) not in visited:\n                if (nx, ny) in unseen_tiles:\n                    print(json.dumps({'status': 'unseen_found', 'goal': {'x': x, 'y': y}, 'path_to_goal': path + [(x,y)]}))\n                    return\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [(x, y)]))\n\n    # 2. If no unseen tiles are reachable, check for warp softlock\n    try:\n        wkg = json.loads(world_knowledge_graph_json_string)\n    except json.JSONDecodeError:\n        print(json.dumps({'status': 'error', 'message': 'Could not parse World Knowledge Graph.'}))\n        return\n\n    reachable_warps = []\n    for warp_x, warp_y in warps:\n        # Simple check if warp is adjacent to a visited tile\n        for vx, vy in visited:\n            if abs(vx - warp_x) + abs(vy - warp_y) == 1:\n                reachable_warps.append((warp_x, warp_y))\n                break\n\n    if not reachable_warps:\n        print(json.dumps({'status': 'softlocked', 'message': 'No reachable unseen tiles or warps found on this map.'}))\n        return\n\n    # Check if any reachable warps lead to a new map\n    current_map_nodes = {node['id']: node for node in wkg['nodes'] if node['map_id'] == map_id}\n    \n    for warp_x, warp_y in reachable_warps:\n        for node_id, node in current_map_nodes.items():\n            if node['coordinates']['x'] == warp_x and node['coordinates']['y'] == warp_y:\n                for edge in wkg['edges']:\n                    if edge['source_node_id'] == node_id:\n                        dest_node_id = edge['destination_node_id']\n                        dest_node = next((n for n in wkg['nodes'] if n['id'] == dest_node_id), None)\n                        if dest_node and dest_node['map_id'] != map_id:\n                            print(json.dumps({'status': 'warp_found', 'goal': {'x': warp_x, 'y': warp_y}, 'destination_map': dest_node['map_id']}))\n                            return\n\n    print(json.dumps({'status': 'no_escape', 'message': 'Reachable warps found, but none appear to lead to a new map according to the World Knowledge Graph.'}))\n\nrun_unstick_me_tool(input_data['start_x'], input_data['start_y'])"
  }
}