{
  "assess_reachability": {
    "description": "Performs a flood-fill BFS starting from a given coordinate to determine all reachable tiles of a specific type (e.g., WATER). Returns the bounds of the reachable area, accessible warps, and adjacent unseen tiles. Useful for determining if a path exists through a maze.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "tile_type": {
          "type": "string",
          "default": "WATER"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef assess_reachability(map_xml_string, start_x, start_y, tile_type=\"WATER\"):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = {}\n    warps = {}\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib.get('type', 'unseen')\n            is_warp = tile.attrib.get('is-warp') == 'true'\n            \n            grid[(x, y)] = t_type\n            if is_warp:\n                # Check for warp details in children\n                warp_node = tile.find('Warp')\n                entry_point = warp_node.attrib.get('entry_point') if warp_node is not None else \"?\"\n                warps[(x, y)] = entry_point\n\n    if grid.get((start_x, start_y)) != tile_type and grid.get((start_x, start_y)) != \"WHIRLPOOL\":\n        print(f\"Error: Start position ({start_x}, {start_y}) is {grid.get((start_x, start_y))}, not {tile_type}.\")\n        return\n\n    queue = deque([(start_x, start_y)])\n    visited = set([(start_x, start_y)])\n    reachable_warps = []\n    reachable_unseen_adjacents = []\n    min_x, max_x, min_y, max_y = start_x, start_x, start_y, start_y\n    \n    # Allow WHIRLPOOL as traversable for surfing if tile_type is WATER\n    traversable_types = {tile_type}\n    if tile_type == \"WATER\":\n        traversable_types.add(\"WHIRLPOOL\")\n\n    while queue:\n        cx, cy = queue.popleft()\n        \n        min_x = min(min_x, cx)\n        max_x = max(max_x, cx)\n        min_y = min(min_y, cy)\n        max_y = max(max_y, cy)\n        \n        if (cx, cy) in warps:\n            reachable_warps.append({'x': cx, 'y': cy, 'entry': warps[(cx, cy)]})\n            \n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < width and 0 <= ny < height:\n                if (nx, ny) in visited:\n                    continue\n                \n                n_type = grid.get((nx, ny), 'unseen')\n                \n                if n_type in traversable_types:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n                elif n_type == 'unseen':\n                    reachable_unseen_adjacents.append({'x': nx, 'y': ny})\n                    # Don't traverse into unseen, just mark it as a frontier\n    \n    print(f\"Reachability Analysis from ({start_x}, {start_y}) for {tile_type}:\")\n    print(f\"  Bounds: X[{min_x}-{max_x}], Y[{min_y}-{max_y}]\")\n    print(f\"  Reachable Tiles Count: {len(visited)}\")\n    print(f\"  Reachable Warps: {reachable_warps}\")\n    print(f\"  Adjacent Unseen Tiles: {len(reachable_unseen_adjacents)} (First 5: {reachable_unseen_adjacents[:5]})\")\n\nassess_reachability(map_xml_string, input_data['start_x'], input_data['start_y'], input_data.get('tile_type', 'WATER'))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-08T11:22:54.983Z",
        "action_counter": 27988
      }
    ]
  },
  "sequence_press": {
    "description": "Executes a sequence of button presses to navigate menus or perform actions. Allows mixing directional and action buttons.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\ntry:\n    buttons = input_data['buttons']\n    print(json.dumps(buttons))\nexcept KeyError:\n    print(\"Error: 'buttons' key not found in input_data\")\n    print(f\"input_data keys: {input_data.keys()}\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T08:10:06.907Z",
        "action_counter": 33328
      },
      {
        "commit_message": "Initial definition of sequence_press tool",
        "timestamp": "2026-01-11T10:39:20.952Z",
        "action_counter": 33514
      },
      {
        "commit_message": "Debugging tool to find variable injection method",
        "timestamp": "2026-01-11T10:41:14.927Z",
        "action_counter": 33517
      },
      {
        "commit_message": "Fix variable access by using input_data dictionary",
        "timestamp": "2026-01-11T10:43:22.032Z",
        "action_counter": 33520
      }
    ]
  },
  "pathfind": {
    "description": "Finds a path from the player's current position to a target coordinate using BFS. Returns a list of coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "target_x",
        "target_y",
        "autopress_buttons"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\nimport json\nimport sys\n\n# Retrieve arguments from input_data\nargs = globals().get('input_data', {})\nt_x = args.get('target_x')\nt_y = args.get('target_y')\nautopress = args.get('autopress_buttons', False)\n\n# Fallback for direct injection\nif t_x is None: t_x = globals().get('target_x')\nif t_y is None: t_y = globals().get('target_y')\nif autopress is None: autopress = globals().get('autopress_buttons', False)\n\ndef get_path(map_xml, t_x, t_y, autopress):\n    if t_x is None or t_y is None:\n        return {\"error\": \"Missing target coordinates\"}\n        \n    try:\n        root = ET.fromstring(map_xml)\n        width = int(root.attrib['width'])\n        height = int(root.attrib['height'])\n        grid = [[False for _ in range(height)] for _ in range(width)]\n        player_pos = None\n        \n        traversable_types = {\n            'FLOOR', 'TALL_GRASS', 'SAND', 'PATH', 'SNOW', 'ICE', 'CARPET', 'MAT',\n            'STAIRS', 'GRASS', 'LONG_GRASS', 'BRIDGE', 'CAVE_FLOOR', 'PUDDLE', 'DIRT',\n            'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'WARP_CARPET_UP', 'WARP_CARPET_DOWN',\n            'WARP_CARPET_ENTRY', 'DOOR'\n        }\n        \n        # Iterate Rows then Tiles\n        for row in root.findall(\"Row\"):\n            y = int(row.attrib['id'])\n            for tile in row.findall(\"Tile\"):\n                x = int(tile.attrib['id'])\n                t_type = tile.attrib['type']\n                \n                is_walkable = t_type in traversable_types\n                \n                # Objects block (except Player, handled below)\n                if tile.find(\"Object\") is not None:\n                    is_walkable = False\n                \n                # Check for Player (overrides Object check if Player is the object, \n                # but Player is usually a separate child tag <Player />)\n                if tile.find(\"Player\") is not None:\n                    player_pos = (x, y)\n                    is_walkable = True\n\n                if 0 <= x < width and 0 <= y < height:\n                    grid[x][y] = is_walkable\n\n        if not player_pos:\n            return {\"error\": \"Player not found\"}\n        \n        queue = collections.deque([[player_pos]])\n        visited = {player_pos}\n        found_path = None\n        \n        while queue:\n            path = queue.popleft()\n            curr_x, curr_y = path[-1]\n            if curr_x == t_x and curr_y == t_y:\n                found_path = path\n                break\n            \n            for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                nx, ny = curr_x + dx, curr_y + dy\n                if 0 <= nx < width and 0 <= ny < height:\n                    if grid[nx][ny] and (nx, ny) not in visited:\n                        visited.add((nx, ny))\n                        new_path = list(path)\n                        new_path.append((nx, ny))\n                        queue.append(new_path)\n\n        if found_path:\n            buttons = []\n            if autopress:\n                for i in range(len(found_path) - 1):\n                    cx, cy = found_path[i]\n                    nx, ny = found_path[i+1]\n                    if nx > cx: buttons.append(\"Right\")\n                    elif nx < cx: buttons.append(\"Left\")\n                    elif ny > cy: buttons.append(\"Down\")\n                    elif ny < cy: buttons.append(\"Up\")\n                print(json.dumps(buttons))\n            return [list(p) for p in found_path]\n        else:\n            return {\"error\": \"No path found\"}\n\n    except Exception as e:\n        return {\"error\": str(e)}\n\nresult = get_path(map_xml_string, t_x, t_y, autopress)\nif not autopress and \"error\" not in result:\n    print(json.dumps(result))\nelif \"error\" in result:\n    print(json.dumps(result))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T09:01:19.563Z",
        "action_counter": 33384
      },
      {
        "commit_message": "Fixed NameError by using globals().get() to safely retrieve injected arguments. Added autopress_buttons support.",
        "timestamp": "2026-01-11T16:48:12.265Z",
        "action_counter": 34015
      },
      {
        "commit_message": "Refined JSON output compliance using json.dumps to avoid parsing errors.",
        "timestamp": "2026-01-11T16:49:46.390Z",
        "action_counter": 34017
      },
      {
        "commit_message": "Added debug logic to inspect available variables if arguments are missing.",
        "timestamp": "2026-01-11T16:50:53.134Z",
        "action_counter": 34018
      },
      {
        "commit_message": "Updated to retrieve arguments from `input_data` global dictionary.",
        "timestamp": "2026-01-11T16:51:34.865Z",
        "action_counter": 34019
      },
      {
        "commit_message": "Fixed XML parsing logic to correctly iterate Rows and Tiles instead of using unsupported '..' XPath.",
        "timestamp": "2026-01-11T16:52:03.375Z",
        "action_counter": 34020
      },
      {
        "commit_message": "Added WARP_CARPET_* and DOOR types to traversable list.",
        "timestamp": "2026-01-11T17:10:57.545Z",
        "action_counter": 34044
      }
    ]
  },
  "zigzag_sweep": {
    "description": "Generates and executes a zigzag button sequence to sweep a rectangular area. Useful for hunting in grass patches.",
    "input_schema": {
      "type": "object",
      "properties": {
        "cols": {
          "type": "integer",
          "description": "Number of columns (width) of the area."
        },
        "rows": {
          "type": "integer",
          "description": "Number of rows (height) of the area."
        },
        "start_side": {
          "type": "string",
          "enum": [
            "left",
            "right"
          ],
          "default": "left",
          "description": "The side you are starting on. 'left' means Top-Left, 'right' means Top-Right."
        }
      },
      "required": [
        "cols",
        "rows"
      ]
    },
    "python_script": "import json\n\nbuttons = []\ncols = int(input_data['cols'])\nrows = int(input_data['rows'])\nstart_side = input_data.get('start_side', 'left')\n\nfor r in range(rows):\n    if start_side == 'left':\n        # Even rows (0, 2): Right\n        # Odd rows (1, 3): Left\n        direction = 'Right' if r % 2 == 0 else 'Left'\n    else:\n        # Even rows (0, 2): Left\n        # Odd rows (1, 3): Right\n        direction = 'Left' if r % 2 == 0 else 'Right'\n        \n    for _ in range(cols - 1):\n        buttons.append(direction)\n        \n    if r < rows - 1:\n        buttons.append('Down')\n\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T19:32:17.062Z",
        "action_counter": 34231
      }
    ]
  },
  "sweep_route37": {
    "description": "Executes a fixed button sequence to sweep the northern grass patch of Route 37 and return to the gate. Assumes starting position at (8,0). Sequence: Down x2, Right, Down x3, Left x3, Up x3, Right x2, Up x2.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "python_script": "print('[\"Down\", \"Down\", \"Right\", \"Down\", \"Down\", \"Down\", \"Left\", \"Left\", \"Left\", \"Up\", \"Up\", \"Up\", \"Right\", \"Right\", \"Up\", \"Up\"]')",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T23:17:43.369Z",
        "action_counter": 34561
      }
    ]
  }
}