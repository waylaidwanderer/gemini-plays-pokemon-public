{
  "find_path_v2": {
    "description": "Finds a path from the player's current position to a target coordinate on the current map using BFS. Returns a list of coordinate dictionaries, or a list of button strings if autopress_buttons is true. If the target is impassable, it finds a path to an adjacent traversable tile. Handles 'unseen' tiles as potentially walkable for exploration. Correctly handles one-way ledge mechanics.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "description": "If true and the tool returns a list of buttons, they will be pressed automatically.",
          "type": "boolean"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y",
        "autopress_buttons"
      ],
      "type": "object"
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\nimport json\n\ndef solve():\n    try:\n        if not map_xml_string:\n            print(\"Error: map_xml_string is empty.\")\n            return\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        print(f\"Error parsing XML: {e}\")\n        return\n\n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n        autopress = input_data.get('autopress_buttons', False)\n    except (KeyError, ValueError) as e:\n        print(f\"Error in input data: {e}\")\n        return\n    \n    tiles = {}\n    start_x, start_y = None, None\n    for row in root.findall('Row'):\n        row_id_attr = row.attrib.get('id')\n        if row_id_attr is None: continue\n        y = int(row_id_attr)\n        for tile in row.findall('Tile'):\n            tile_id_attr = tile.attrib.get('id')\n            if tile_id_attr is None: continue\n            x = int(tile_id_attr)\n            tiles[(x, y)] = tile\n            if tile.find('Player') is not None:\n                start_x, start_y = x, y\n    \n    if start_x is None:\n        print(\"Error: Player position not found in XML.\")\n        return\n    \n    queue = collections.deque([(start_x, start_y, [{\"x\": start_x, \"y\": start_y}])])\n    visited = set([(start_x, start_y)])\n    reachable = {}\n    \n    impassable_types = [\"WALL\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"WATER\", \"BOOKSHELF\", \"WINDOW\", \"TRASHCAN\", \"PC\", \"BOOKSHELVES\", \"VOID\"]\n    \n    while queue:\n        x, y, path = queue.popleft()\n        reachable[(x, y)] = path\n        if x == target_x and y == target_y:\n            break\n            \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) in visited: continue\n            \n            tile = tiles.get((nx, ny))\n            if tile is None: continue\n            \n            tile_type = tile.attrib.get('type', 'unseen').strip().upper()\n            \n            # Ledge check\n            if \"LEDGE\" in tile_type:\n                can_jump = False\n                if tile_type == \"LEDGE_HOP_DOWN\" and dy == 1: can_jump = True\n                elif tile_type == \"LEDGE_HOP_UP\" and dy == -1: can_jump = True\n                elif tile_type == \"LEDGE_HOP_LEFT\" and dx == -1: can_jump = True\n                elif tile_type == \"LEDGE_HOP_RIGHT\" and dx == 1: can_jump = True\n                \n                if can_jump:\n                    lx, ly = nx + dx, ny + dy\n                    landing_tile = tiles.get((lx, ly))\n                    if landing_tile is not None:\n                        landing_type = landing_tile.attrib.get('type', 'unseen').strip().upper()\n                        if landing_type not in impassable_types and landing_tile.attrib.get('has-object') != 'true' and (lx, ly) not in visited:\n                            visited.add((nx, ny))\n                            visited.add((lx, ly))\n                            new_path = path + [{\"x\": nx, \"y\": ny}, {\"x\": lx, \"y\": ly}]\n                            queue.append((lx, ly, new_path))\n                continue\n\n            if tile_type in impassable_types or tile.attrib.get('has-object') == 'true':\n                continue\n\n            visited.add((nx, ny))\n            queue.append((nx, ny, path + [{\"x\": nx, \"y\": ny}]))\n            \n    final_path = reachable.get((target_x, target_y))\n    \n    if final_path is None:\n        best_dist = float('inf')\n        for (rx, ry), rpath in reachable.items():\n            dist = abs(rx - target_x) + abs(ry - target_y)\n            if dist < best_dist:\n                best_dist = dist\n                final_path = rpath\n                \n    if final_path is None:\n        print(\"Error: No reachable tiles found.\")\n        return\n\n    if autopress:\n        buttons = []\n        for i in range(len(final_path) - 1):\n            curr = final_path[i]\n            next_t = final_path[i+1]\n            if next_t['x'] > curr['x']: buttons.append(\"Right\")\n            elif next_t['x'] < curr['x']: buttons.append(\"Left\")\n            elif next_t['y'] > curr['y']: buttons.append(\"Down\")\n            elif next_t['y'] < curr['y']: buttons.append(\"Up\")\n        print(json.dumps(buttons))\n    else:\n        print(json.dumps(final_path))\n\nsolve()",
    "history": [
      {
        "commit_message": "Refined find_path to handle potential map XML structure variations and ensure the Player location is detected accurately. Added more robust logging for debugging.",
        "timestamp": "2025-12-17T23:52:03.099Z",
        "action_counter": 203
      }
    ]
  },
  "list_unseen_reachable": {
    "description": "Identifies 'unseen' tiles that are adjacent to reachable, traversable tiles on the current map. This helps prioritize exploration targets.",
    "input_schema": {
      "properties": {},
      "type": "object"
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\nimport json\n\ndef solve():\n    try:\n        if not map_xml_string:\n            print(\"[]\")\n            return\n        root = ET.fromstring(map_xml_string)\n    except:\n        print(\"[]\")\n        return\n\n    tiles = {}\n    player_pos = None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tiles[(x, y)] = tile\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n    \n    if not player_pos:\n        print(\"[]\")\n        return\n\n    # BFS to find all reachable tiles\n    queue = collections.deque([player_pos])\n    visited = {player_pos}\n    reachable = set()\n    \n    impassable_types = [\"WALL\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"WATER\", \"BOOKSHELF\", \"WINDOW\", \"TRASHCAN\", \"PC\", \"BOOKSHELVES\", \"VOID\"]\n    \n    while queue:\n        curr = queue.popleft()\n        reachable.add(curr)\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = curr[0] + dx, curr[1] + dy\n            if (nx, ny) in visited: continue\n            \n            tile = tiles.get((nx, ny))\n            if not tile or tile.attrib.get('seen') == 'false': continue\n            \n            tile_type = tile.attrib.get('type', '').strip().upper()\n            if tile_type in impassable_types or tile.attrib.get('has-object') == 'true':\n                continue\n            \n            visited.add((nx, ny))\n            queue.append((nx, ny))\n\n    # Find unseen tiles adjacent to reachable tiles\n    unseen_targets = set()\n    for rx, ry in reachable:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = rx + dx, ry + dy\n            tile = tiles.get((nx, ny))\n            if tile and tile.attrib.get('seen') == 'false':\n                unseen_targets.add((nx, ny))\n                \n    print(json.dumps([{\"x\": x, \"y\": y} for x, y in sorted(list(unseen_targets))]))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version of list_unseen_reachable tool to identify potentially reachable unexplored areas.",
        "timestamp": "2025-12-18T00:25:09.921Z",
        "action_counter": 259
      }
    ]
  }
}