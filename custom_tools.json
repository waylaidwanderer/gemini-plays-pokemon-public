{
  "master_navigator": {
    "description": "A consolidated navigation tool that handles pathfinding. It can find a path to a specific coordinate. It now considers map markers for obstacles and correctly handles ledges and transitions between different traversable tile types. Includes an option to ignore objects for testing purposes. THIS IS A DEBUG VERSION.",
    "input_schema": {
      "type": "object",
      "properties": {
        "mode": {
          "type": "string",
          "enum": [
            "pathfind"
          ]
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer",
          "nullable": true
        },
        "end_y": {
          "type": "integer",
          "nullable": true
        },
        "traversable_tiles": {
          "type": "string"
        },
        "ignore_objects": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "mode",
        "start_x",
        "start_y",
        "traversable_tiles"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\nimport sys\n\nsys.stderr = sys.stdout\n\ndef find_path(map_xml_string, start_x, start_y, end_x, end_y, traversable_tiles_str, ignore_objects_str):\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n\n        traversable_tiles = traversable_tiles_str.split(',')\n        ignore_objects = ignore_objects_str.lower() == 'true' if ignore_objects_str else False\n        \n        print(f\"Master Navigator Debug: Start=({start_x},{start_y}), End=({end_x},{end_y}), Traversable={traversable_tiles}, IgnoreObjects={ignore_objects}\")\n\n        grid = [[False for _ in range(width)] for _ in range(height)]\n        \n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            if not (1 <= y <= height): continue\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                if not (1 <= x <= width): continue\n\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                is_player_tile = tile_elem.find('Player') is not None\n                \n                is_traversable = tile_type in traversable_tiles\n                \n                # DEBUG PRINT\n                print(f\"  Tile ({x},{y}): type={tile_type}, has_object={has_object}, is_player={is_player_tile}, initial_traversable={is_traversable}\")\n\n                if has_object and not is_player_tile and not ignore_objects:\n                    is_traversable = False\n                    print(f\"    -> Marked as NOT traversable due to object.\")\n                \n                # UPDATED LOGIC TO CHECK ALL OBJECT MARKERS\n                for marker in tile_elem.findall('Marker'):\n                    if marker.get('object_id') is not None and not ignore_objects:\n                        is_traversable = False\n                        print(f\"    -> Marked as NOT traversable due to object marker {marker.get('emoji')}.\")\n                        break\n                \n                if is_traversable or is_player_tile:\n                    grid[y-1][x-1] = True\n\n        def heuristic(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n        start = (start_x - 1, start_y - 1)\n        goal = (end_x - 1, end_y - 1)\n\n        if not (0 <= start[0] < width and 0 <= start[1] < height and grid[start[1]][start[0]]):\n            return {\"error\": f\"Start ({start_x},{start_y}) is not on a traversable tile.\"}\n        \n        if not (0 <= goal[0] < width and 0 <= goal[1] < height):\n            return {\"error\": f\"Goal ({end_x},{end_y}) is outside map boundaries.\"}\n\n        if not grid[goal[1]][goal[0]]:\n            found_new_goal = False\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_goal_candidate = (goal[0] + dx, goal[1] + dy)\n                if 0 <= new_goal_candidate[0] < width and 0 <= new_goal_candidate[1] < height and grid[new_goal_candidate[1]][new_goal_candidate[0]]:\n                    goal = new_goal_candidate\n                    found_new_goal = True\n                    break\n            if not found_new_goal:\n                 return {\"error\": f\"Goal ({end_x},{end_y}) and all adjacent tiles are not traversable.\"}\n\n        open_set = [(0, start)]\n        came_from = {}\n        g_score = { (c,r): float('inf') for r in range(height) for c in range(width) }\n        g_score[start] = 0\n        f_score = { (c,r): float('inf') for r in range(height) for c in range(width) }\n        f_score[start] = heuristic(start, goal)\n        \n        while open_set:\n            _, current = heapq.heappop(open_set)\n\n            if current == goal:\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(start)\n                path_coords = [{'x': x + 1, 'y': y + 1} for x, y in reversed(path)]\n                return path_coords\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                neighbor = (current[0] + dx, current[1] + dy)\n                nx, ny = neighbor\n\n                if not (0 <= nx < width and 0 <= ny < height and grid[ny][nx]):\n                    continue\n\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, goal)\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n        \n        return {\"error\": \"No path found.\"}\n\n    except Exception as e:\n        import traceback\n        return {\"error\": str(e), \"traceback\": traceback.format_exc()}\n\ntry:\n    mode = input_data['mode']\n    if mode == 'pathfind':\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        end_x = int(input_data.get('end_x'))\n        end_y = int(input_data.get('end_y'))\n        traversable_tiles_str = input_data['traversable_tiles']\n        ignore_objects_str = input_data.get('ignore_objects')\n\n        path = find_path(map_xml_string, start_x, start_y, end_x, end_y, traversable_tiles_str, ignore_objects_str)\n\n        if isinstance(path, dict) and \"error\" in path:\n            print(json.dumps(path))\n        elif path:\n            print(json.dumps({\"path\": path}))\n        else:\n            print(json.dumps({\"error\": \"No path found.\"}))\n    else:\n        print(json.dumps({\"error\": f\"Invalid mode: {mode}\"}))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({\"error\": f\"Tool execution failed: {str(e)}\", \"traceback\": traceback.format_exc()}))\n"
  },
  "boulder_solver": {
    "description": "Solves boulder puzzles using a search algorithm. Takes a grid, player position, and boulder positions, and returns a sequence of moves.",
    "input_schema": {
      "type": "object",
      "properties": {
        "grid_map": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "player_start": {
          "type": "array",
          "items": {
            "type": "integer"
          }
        },
        "boulders_start": {
          "type": "array",
          "items": {
            "type": "array",
            "items": {
              "type": "integer"
            }
          }
        },
        "goal": {
          "type": "array",
          "items": {
            "type": "integer"
          }
        }
      },
      "required": [
        "grid_map",
        "player_start",
        "boulders_start",
        "goal"
      ]
    },
    "python_script": "import collections\nimport json\n\ndef solve_boulder_puzzle(grid_map, player_start, boulders_start, goal):\n    rows, cols = len(grid_map), len(grid_map[0])\n    player_start = tuple(player_start)\n    boulders_start = frozenset(tuple(b) for b in boulders_start)\n    goal = tuple(goal)\n\n    q = collections.deque([(player_start, boulders_start, [])])\n    visited = set([(player_start, boulders_start)])\n\n    while q:\n        player_pos, boulders_pos, path = q.popleft()\n\n        if player_pos == goal:\n            return {'solution': path}\n\n        for move, (dx, dy) in {'Up': (0, -1), 'Down': (0, 1), 'Left': (-1, 0), 'Right': (1, 0)}.items():\n            next_player_pos = (player_pos[0] + dx, player_pos[1] + dy)\n            nx, ny = next_player_pos\n\n            if not (0 <= ny < rows and 0 <= nx < cols and grid_map[ny][nx] not in ['W', 'T']):\n                continue\n\n            if next_player_pos in boulders_pos:\n                next_boulder_pos = (nx + dx, ny + dy)\n                nbx, nby = next_boulder_pos\n                if not (0 <= nby < rows and 0 <= nbx < cols and grid_map[nby][nbx] not in ['W', 'T'] and next_boulder_pos not in boulders_pos):\n                    continue\n                \n                new_boulders_pos = set(boulders_pos)\n                new_boulders_pos.remove(next_player_pos)\n                new_boulders_pos.add(next_boulder_pos)\n                new_boulders_pos = frozenset(new_boulders_pos)\n\n                if (next_player_pos, new_boulders_pos) not in visited:\n                    visited.add((next_player_pos, new_boulders_pos))\n                    q.append((next_player_pos, new_boulders_pos, path + [move]))\n            else:\n                if (next_player_pos, boulders_pos) not in visited:\n                    visited.add((next_player_pos, boulders_pos))\n                    q.append((next_player_pos, boulders_pos, path + [move]))\n\n    return {'error': 'No solution found'}\n\ntry:\n    grid_map_str = input_data['grid_map']\n    player_start_str = input_data['player_start']\n    boulders_start_str = input_data['boulders_start']\n    goal_str = input_data['goal']\n\n    grid_map = json.loads(grid_map_str)\n    player_start = json.loads(player_start_str)\n    boulders_start = json.loads(boulders_start_str)\n    goal = json.loads(goal_str)\n\n    result = solve_boulder_puzzle(grid_map, player_start, boulders_start, goal)\n    print(json.dumps(result))\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))"
  }
}