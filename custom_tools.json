{
  "overworld_navigator": {
    "description": "Calculates a multi-map path between a start and end location using the World Knowledge Graph. This tool is designed for complex navigation that requires traversing between different map_ids via warps or map edges. It returns a sequence of actions, including local pathfinding on each map segment and the necessary warp/transition actions.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_map_id": {
          "type": "string"
        },
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_map_id": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_map_id",
        "start_x",
        "start_y",
        "end_map_id",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import json\nimport heapq\n\ndef heuristic(a, b):\n    return abs(a['x'] - b['x']) + abs(a['y'] - b['y'])\n\ndef a_star_search(graph, start_node_id, end_node_id):\n    nodes_by_id = {n['id']: n for n in graph['nodes']}\n    start_node = nodes_by_id.get(start_node_id)\n    end_node = nodes_by_id.get(end_node_id)\n    if not start_node or not end_node:\n        return None\n\n    open_set = [(0, start_node_id)]\n    came_from = {}\n    g_score = {node_id: float('inf') for node_id in nodes_by_id}\n    g_score[start_node_id] = 0\n    f_score = {node_id: float('inf') for node_id in nodes_by_id}\n    f_score[start_node_id] = heuristic(start_node['coordinates'], end_node['coordinates'])\n    open_set_hash = {start_node_id}\n\n    while open_set:\n        _, current_id = heapq.heappop(open_set)\n        open_set_hash.remove(current_id)\n\n        if current_id == end_node_id:\n            path = []\n            temp = current_id\n            while temp in came_from:\n                path.append(temp)\n                temp = came_from[temp]\n            path.append(start_node_id)\n            return path[::-1]\n\n        for edge in graph['edges']:\n            neighbor_id = None\n            if edge['source_node_id'] == current_id:\n                neighbor_id = edge['destination_node_id']\n            elif edge['destination_node_id'] == current_id and not edge.get('is_one_way', False):\n                neighbor_id = edge['source_node_id']\n\n            if neighbor_id:\n                tentative_g_score = g_score[current_id] + 1\n                if tentative_g_score < g_score[neighbor_id]:\n                    came_from[neighbor_id] = current_id\n                    g_score[neighbor_id] = tentative_g_score\n                    neighbor_node = nodes_by_id.get(neighbor_id)\n                    if neighbor_node:\n                        f_score[neighbor_id] = g_score[neighbor_id] + heuristic(neighbor_node['coordinates'], end_node['coordinates'])\n                        if neighbor_id not in open_set_hash:\n                            heapq.heappush(open_set, (f_score[neighbor_id], neighbor_id))\n                            open_set_hash.add(neighbor_id)\n    return None\n\ntry:\n    world_graph = json.loads(world_knowledge_graph_json_string)\n    start_map_id = input_data['start_map_id']\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_map_id = input_data['end_map_id']\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n\n    start_nodes_on_map = [n for n in world_graph.get('nodes', []) if n.get('map_id') == start_map_id]\n    end_nodes_on_map = [n for n in world_graph.get('nodes', []) if n.get('map_id') == end_map_id]\n\n    if not start_nodes_on_map or not end_nodes_on_map:\n        print(json.dumps({'path_found': False, 'path': [], 'error': 'Start or end map not found in World Knowledge Graph.'}))\n    else:\n        start_node = min(start_nodes_on_map, key=lambda n: heuristic(n['coordinates'], {'x': start_x, 'y': start_y}))\n        end_node = min(end_nodes_on_map, key=lambda n: heuristic(n['coordinates'], {'x': end_x, 'y': end_y}))\n        path_node_ids = a_star_search(world_graph, start_node['id'], end_node['id'])\n\n        if path_node_ids:\n            path_details = []\n            for node_id in path_node_ids:\n                node = next((n for n in world_graph['nodes'] if n['id'] == node_id), None)\n                if node:\n                    path_details.append({'map_id': node['map_id'], 'name': node['name'], 'x': node['coordinates']['x'], 'y': node['coordinates']['y']})\n            print(json.dumps({'path_found': True, 'path': path_details}))\n        else:\n            print(json.dumps({'path_found': False, 'path': [], 'error': 'No path found between nodes in World Knowledge Graph.'}))\nexcept Exception as e:\n    print(json.dumps({'path_found': False, 'path': [], 'error': str(e)}))\n"
  },
  "pathfinder": {
    "description": "Calculates the shortest path on the current map using BFS. Handles ledges. UNRELIABLE for maps with dynamic obstacles like puzzles or moving NPCs.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n\n    grid = {}\n    for r in root.findall('Row'):\n        y = int(r.get('id'))\n        for t in r.findall('Tile'):\n            x = int(t.get('id'))\n            has_impassable_object = False\n            obj_node = t.find('Object')\n            if obj_node is not None and obj_node.get('id-name') != 'Pikachu':\n                has_impassable_object = True\n            grid[(x, y)] = {\n                'type': t.get('type'),\n                'has_object': has_impassable_object\n            }\n\n    impassable_types = ['impassable', 'unknown', 'cuttable', 'water', 'closed_gate']\n\n    queue = deque([([ (start_x, start_y) ])])\n    visited = {(start_x, start_y)}\n\n    while queue:\n        path = queue.popleft()\n        cx, cy = path[-1]\n\n        if (cx, cy) == (end_x, end_y):\n            json_path = [{'x': p[0], 'y': p[1]} for p in path]\n            print(json.dumps({'path_found': True, 'path': json_path}))\n            exit()\n\n        current_tile = grid.get((cx, cy))\n        \n        if current_tile and current_tile['type'] == 'ledge':\n            nx, ny = cx, cy + 1\n            if (1 <= ny <= height):\n                landing_x, landing_y = nx, ny + 1\n                if (landing_x, landing_y) not in visited and (1 <= landing_y <= height):\n                     landing_tile = grid.get((landing_x, landing_y))\n                     if landing_tile and landing_tile['type'] not in impassable_types and not landing_tile['has_object']:\n                        visited.add((landing_x, landing_y))\n                        new_path = path + [(landing_x, landing_y)]\n                        queue.append(new_path)\n            continue\n\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = cx + dx, cy + dy\n\n            if not (1 <= nx <= width and 1 <= ny <= height) or (nx, ny) in visited:\n                continue\n\n            neighbor_tile = grid.get((nx, ny))\n            if not neighbor_tile:\n                continue\n\n            if neighbor_tile['type'] in impassable_types or neighbor_tile['has_object']:\n                continue\n            \n            if neighbor_tile['type'] == 'ledge':\n                if dy == -1 or dx != 0:\n                    continue\n            \n            visited.add((nx, ny))\n            new_path = path + [(nx, ny)]\n            queue.append(new_path)\n\n    print(json.dumps({'path_found': False, 'path': []}))\n\nexcept Exception as e:\n    print(json.dumps({'path_found': False, 'error': str(e)}))"
  },
  "select_battle_option": {
    "description": "Calculates and executes the button presses needed to select a specific option from the main battle menu (FIGHT, PKMN, ITEM, RUN).",
    "input_schema": {
      "type": "object",
      "properties": {
        "option_to_select": {
          "type": "string",
          "enum": [
            "FIGHT",
            "PKMN",
            "ITEM",
            "RUN"
          ]
        }
      },
      "required": [
        "option_to_select"
      ]
    },
    "python_script": "option = input_data['option_to_select']\noptions = [\"FIGHT\", \"PKMN\", \"ITEM\", \"RUN\"]\ncurrent_pos = 0 # Assume cursor starts on FIGHT\npresses = []\ntarget_pos = options.index(option)\n# Simplified logic: Assume cursor moves right and down\nif target_pos == 1: # PKMN\n    presses.append('Right')\nelif target_pos == 2: # ITEM\n    presses.append('Down')\nelif target_pos == 3: # RUN\n    presses.append('Right')\n    presses.append('Down')\npresses.append('A')\nimport json\nprint(json.dumps(presses))"
  },
  "map_segment_analyzer": {
    "description": "Analyzes the current map segment to find all reachable tiles, warps, and objects from the player's current position using a proper BFS. Handles `closed_gate` tiles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\nimport traceback\n\ndef analyze_segment_fixed(map_xml_string, start_x, start_y):\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        start_x, start_y = int(start_x), int(start_y)\n\n        grid = {}\n        for r in root.findall('Row'):\n            y = int(r.get('id'))\n            for t in r.findall('Tile'):\n                x = int(t.get('id'))\n                has_impassable_object = False\n                obj_node = t.find('Object')\n                if obj_node is not None and obj_node.get('id-name') != 'Pikachu':\n                    has_impassable_object = True\n                \n                grid[(x, y)] = {\n                    'type': t.get('type'),\n                    'has_object': has_impassable_object,\n                    'is_warp': t.get('is-warp') == 'true',\n                    'original_object_node': obj_node\n                }\n        \n        impassable_types = ['impassable', 'unknown', 'cuttable', 'water', 'closed_gate']\n        \n        queue = deque([(start_x, start_y)])\n        visited = set([(start_x, start_y)])\n        reachable_tiles_coords = set([(start_x, start_y)])\n        reachable_warps, reachable_objects = [], []\n\n        while queue:\n            cx, cy = queue.popleft()\n            \n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = cx + dx, cy + dy\n\n                if (nx, ny) not in visited:\n                    neighbor_data = grid.get((nx, ny))\n                    if neighbor_data:\n                        visited.add((nx, ny))\n                        if neighbor_data['type'] not in impassable_types and not neighbor_data['has_object']:\n                            reachable_tiles_coords.add((nx, ny))\n                            queue.append((nx, ny))\n        \n        for x, y in reachable_tiles_coords:\n            tile_data = grid.get((x, y))\n            if tile_data:\n                if tile_data['is_warp']:\n                    if {'x': x, 'y': y} not in reachable_warps:\n                        reachable_warps.append({'x': x, 'y': y})\n                \n                obj_node = tile_data['original_object_node']\n                if obj_node is not None:\n                    obj_data = {\n                        'id': obj_node.get('id'),\n                        'id-name': obj_node.get('id-name'),\n                        'name': obj_node.get('name'),\n                        'x': x,\n                        'y': y\n                    }\n                    if obj_data not in reachable_objects:\n                        reachable_objects.append(obj_data)\n\n        result = {\n            \"reachable_tiles_count\": len(reachable_tiles_coords),\n            \"reachable_warps\": reachable_warps,\n            \"reachable_objects\": reachable_objects,\n            \"segment_size\": len(reachable_tiles_coords)\n        }\n        return json.dumps(result, indent=2)\n        \n    except Exception as e:\n        return json.dumps({\"error\": str(e), \"traceback\": traceback.format_exc()})\n\nprint(analyze_segment_fixed(map_xml_string, input_data['start_x'], input_data['start_y']))"
  },
  "dungeon_navigator": {
    "description": "Calculates a comprehensive exploration path for a reachable map segment. It systematically generates moves to visit every single reachable tile, which is useful for finding hidden puzzle triggers or items in complex dungeons like Silph Co. It takes the start coordinates as input. This version avoids pathing over warp/teleporter tiles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef find_shortest_path(start, end, grid, width, height, impassable_types):\n    queue = deque([([start])])\n    visited = {start}\n    while queue:\n        path = queue.popleft()\n        cx, cy = path[-1]\n        if (cx, cy) == end:\n            return path\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            if not (1 <= nx <= width and 1 <= ny <= height) or (nx, ny) in visited:\n                continue\n            neighbor_tile = grid.get((nx, ny))\n            if not neighbor_tile or neighbor_tile['type'] in impassable_types or neighbor_tile['has_object'] or neighbor_tile['is_warp']:\n                continue\n            visited.add((nx, ny))\n            new_path = list(path)\n            new_path.append((nx, ny))\n            queue.append(new_path)\n    return None\n\ndef path_to_buttons(path):\n    buttons = []\n    if not path or len(path) < 2:\n        return []\n    for i in range(len(path) - 1):\n        x1, y1 = path[i]\n        x2, y2 = path[i+1]\n        if y2 < y1: buttons.append('Up')\n        elif y2 > y1: buttons.append('Down')\n        elif x2 < x1: buttons.append('Left')\n        elif x2 > x1: buttons.append('Right')\n    return buttons\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    grid = {}\n    for r in root.findall('Row'):\n        y = int(r.get('id'))\n        for t in r.findall('Tile'):\n            x = int(t.get('id'))\n            obj_node = t.find('Object')\n            has_impassable_object = obj_node is not None and obj_node.get('id-name') != 'Pikachu'\n            grid[(x, y)] = {\n                'type': t.get('type'), \n                'has_object': has_impassable_object,\n                'is_warp': t.get('is-warp') == 'true'\n            }\n\n    impassable_types = ['impassable', 'unknown', 'cuttable', 'water', 'closed_gate', 'ledge']\n\n    reachable_ground_tiles = set()\n    queue = deque([(start_x, start_y)])\n    visited_for_reachability = {(start_x, start_y)}\n    while queue:\n        cx, cy = queue.popleft()\n        tile_data = grid.get((cx,cy))\n        if tile_data and tile_data['type'] not in impassable_types and not tile_data['has_object'] and not tile_data['is_warp']:\n             reachable_ground_tiles.add((cx,cy))\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) not in visited_for_reachability and (1 <= nx <= width and 1 <= ny <= height):\n                visited_for_reachability.add((nx, ny))\n                neighbor_tile = grid.get((nx, ny))\n                if neighbor_tile and neighbor_tile['type'] not in impassable_types and not neighbor_tile['has_object'] and not neighbor_tile['is_warp']:\n                    queue.append((nx, ny))\n\n    tour_path = [(start_x, start_y)]\n    unvisited_tiles = reachable_ground_tiles - {(start_x, start_y)}\n    current_pos = (start_x, start_y)\n    while unvisited_tiles:\n        shortest_path_to_next = None\n        target_tile = None\n        # Find the nearest unvisited tile\n        for tile in sorted(list(unvisited_tiles), key=lambda t: (abs(t[0]-current_pos[0]) + abs(t[1]-current_pos[1]))):\n            path = find_shortest_path(current_pos, tile, grid, width, height, impassable_types)\n            if path:\n                shortest_path_to_next = path\n                target_tile = tile\n                break\n        if shortest_path_to_next:\n            tour_path.extend(shortest_path_to_next[1:])\n            current_pos = target_tile\n            # Mark all tiles in the path as visited\n            for step in shortest_path_to_next:\n                if step in unvisited_tiles:\n                    unvisited_tiles.remove(step)\n        else:\n            # No path to any remaining unvisited tiles\n            break\n\n    button_sequence = path_to_buttons(tour_path)\n    print(json.dumps({'path_found': True, 'buttons': button_sequence, 'tiles_to_visit': len(reachable_ground_tiles), 'path_length': len(button_sequence)}))\n\nexcept Exception as e:\n    print(json.dumps({'path_found': False, 'error': str(e)}))\n"
  }
}