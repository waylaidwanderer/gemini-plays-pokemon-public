{
  "find_path_v2": {
    "description": "Finds the shortest path between two coordinates on the current map using BFS, considering walls and objects as obstacles. Returns a JSON array of coordinates or buttons.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "type": "boolean"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "autopress_buttons"
      ],
      "type": "object"
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        \n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        end_x = int(input_data['end_x'])\n        end_y = int(input_data['end_y'])\n        \n        passable_tiles = set()\n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                x = int(tile.get('id'))\n                tile_type = tile.get('type')\n                has_object = tile.get('has-object') == 'true'\n                # Treat unseen tiles as potentially passable for pathfinding\n                # Row 0 is marked as WALL but might be passable\n                if tile_type in ['FLOOR', 'PIT', 'LADDER', 'ICE'] and not has_object:\n                    passable_tiles.add((x, y))\n                elif tile.get('seen') == 'false':\n                    passable_tiles.add((x, y))\n        \n        # Ensure start and end are considered passable for BFS\n        passable_tiles.add((start_x, start_y))\n        passable_tiles.add((end_x, end_y))\n\n        queue = deque([(start_x, start_y, [])])\n        visited = set([(start_x, start_y)])\n        \n        while queue:\n            x, y, path = queue.popleft()\n            if x == end_x and y == end_y:\n                full_path = [{\"x\": start_x, \"y\": start_y}] + path\n                if input_data.get('autopress_buttons'):\n                    buttons = []\n                    curr_x, curr_y = start_x, start_y\n                    for step in path:\n                        if step['x'] > curr_x: buttons.append('Right')\n                        elif step['x'] < curr_x: buttons.append('Left')\n                        elif step['y'] > curr_y: buttons.append('Down')\n                        elif step['y'] < curr_y: buttons.append('Up')\n                        curr_x, curr_y = step['x'], step['y']\n                    print(json.dumps(buttons))\n                else:\n                    print(json.dumps(full_path))\n                return\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < width and 0 <= ny < height and (nx, ny) in passable_tiles and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [{\"x\": nx, \"y\": ny}]))\n        \n        print(json.dumps({\"error\": \"No path found\"}))\n    except Exception as e:\n        print(json.dumps({\"error\": str(e)}))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T20:27:16.465Z",
        "action_counter": 29425
      },
      {
        "commit_message": "Refined to correctly identify objects using 'has-object' attribute and added logic for boulder bridges in pits.",
        "timestamp": "2025-12-28T20:30:14.390Z",
        "action_counter": 29431
      },
      {
        "commit_message": "Refined to correctly handle autopress_buttons by outputting button strings and fixed pathfinding logic for boulder bridges.",
        "timestamp": "2025-12-28T20:30:50.776Z",
        "action_counter": 29432
      },
      {
        "commit_message": "Refined to handle boulder bridges in Blackthorn Gym 1F and improved object detection.",
        "timestamp": "2025-12-28T20:47:40.334Z",
        "action_counter": 29458
      },
      {
        "commit_message": "Fixing missing commit message and improving tile passability logic.",
        "timestamp": "2025-12-28T22:59:48.479Z",
        "action_counter": 29673
      }
    ]
  },
  "solve_gym_puzzle_v3": {
    "description": "Calculates the sequence of button presses to solve the Blackthorn Gym boulder puzzle using persistent Mental Map data. Handles player movement and boulder pushing. Returns a JSON array of buttons.",
    "input_schema": {
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ],
      "type": "object"
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        \n        passable = set()\n        pits = set()\n        boulders = {}\n        \n        # Identify passable tiles and on-screen boulders\n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                x = int(tile.get('id'))\n                t_type = tile.get('type')\n                if t_type in ['FLOOR', 'LADDER', 'ICE']:\n                    has_obj = tile.get('has-object') == 'true'\n                    if has_obj:\n                        obj = tile.find('Object')\n                        if obj is not None and obj.get('id-name') == 'BOULDER':\n                            boulders[int(obj.get('id'))] = (x, y)\n                        else:\n                            continue\n                    passable.add((x, y))\n                elif t_type == 'PIT':\n                    pits.add((x, y))\n        \n        # Include off-screen boulders from markers\n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                x = int(tile.get('id'))\n                for marker in tile.findall('Marker'):\n                    if 'Boulder' in marker.text:\n                        bid = int(marker.get('object_id'))\n                        if bid not in boulders:\n                            boulders[bid] = (x, y)\n                            passable.add((x, y))\n\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        \n        def solve_one(b_id, current_boulders, p_pos):\n            bx, by = current_boulders[b_id]\n            others = {pos for id, pos in current_boulders.items() if id != b_id}\n            q = deque([(bx, by, p_pos[0], p_pos[1], [])])\n            v = set([(bx, by, p_pos[0], p_pos[1])])\n            while q:\n                cbx, cby, cpx, cpy, path = q.popleft()\n                if (cbx, cby) in pits: return path\n                if len(path) > 250: continue\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    npx, npy = cpx + dx, cpy + dy\n                    if 0 <= npx < width and 0 <= npy < height and (npx, npy) in passable and (npx, npy) not in others:\n                        if (npx, npy) == (cbx, cby):\n                            nbx, nby = cbx + dx, cby + dy\n                            if 0 <= nbx < width and 0 <= nby < height and ((nbx, nby) in passable or (nbx, nby) in pits) and (nbx, nby) not in others:\n                                if (nbx, nby, npx, npy) not in v:\n                                    v.add((nbx, nby, npx, npy))\n                                    btn = 'Up' if dy==-1 else 'Down' if dy==1 else 'Left' if dx==-1 else 'Right'\n                                    q.append((nbx, nby, npx, npy, path + [btn]))\n                        else:\n                            if (cbx, cby, npx, npy) not in v:\n                                v.add((cbx, cby, npx, npy))\n                                btn = 'Up' if dy==-1 else 'Down' if dy==1 else 'Left' if dx==-1 else 'Right'\n                                q.append((cbx, cby, npx, npy, path + [btn]))\n            return None\n\n        # Try to solve for each boulder in order\n        for b_id in sorted(boulders.keys()):\n            path = solve_one(b_id, boulders, (start_x, start_y))\n            if path:\n                print(json.dumps(path))\n                return\n        print(json.dumps({\"error\": \"No solution found\"}))\n    except Exception as e:\n        print(json.dumps({\"error\": str(e)}))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T23:28:51.968Z",
        "action_counter": 29702
      },
      {
        "commit_message": "Improving boulder puzzle solver to handle off-screen boulders via markers and increasing search depth.",
        "timestamp": "2025-12-28T23:36:42.932Z",
        "action_counter": 29717
      }
    ]
  },
  "analyze_missing_links": {
    "description": "Tests if making specific tiles passable would solve the boulder puzzle.",
    "input_schema": {
      "properties": {
        "test_tiles": {
          "items": {
            "properties": {
              "x": {
                "type": "integer"
              },
              "y": {
                "type": "integer"
              }
            },
            "required": [
              "x",
              "y"
            ],
            "type": "object"
          },
          "type": "array"
        }
      },
      "required": [
        "test_tiles"
      ],
      "type": "object"
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width, height = int(root.get('width')), int(root.get('height'))\n        passable, pits, boulders = set(), [(2, 5), (8, 3), (8, 7)], {6: (3, 3), 7: (6, 1), 8: (8, 14)}\n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                x = int(tile.get('id'))\n                if tile.get('type') in ['FLOOR', 'LADDER', 'ICE'] and (tile.get('has-object') != 'true' or (tile.find('Object') is not None and tile.find('Object').get('id-name') == 'BOULDER')):\n                    passable.add((x, y))\n        extra = {(t['x'], t['y']) for t in input_data['test_tiles']}\n        temp_passable = passable | extra\n        results = {}\n        for bid, bstart in boulders.items():\n            q, v = deque([bstart]), {bstart}\n            reachable_pit = None\n            while q:\n                bx, by = q.popleft()\n                if (bx, by) in pits: reachable_pit = (bx, by); break\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nbx, nby, px, py = bx + dx, by + dy, bx - dx, by - dy\n                    if 0 <= nbx < width and 0 <= nby < height and 0 <= px < width and 0 <= py < height and ((nbx, nby) in temp_passable or (nbx, nby) in pits) and (px, py) in temp_passable:\n                        if (nbx, nby) not in v:\n                            v.add((nbx, nby))\n                            q.append((nbx, nby))\n            results[bid] = str(reachable_pit) if reachable_pit else None\n        print(json.dumps(results))\n    except Exception as e:\n        print(json.dumps({'error': str(e)}))\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T23:46:49.073Z",
        "action_counter": 29731
      }
    ]
  },
  "solve_gym_puzzle_v4": {
    "description": "Calculates the sequence of button presses to solve the Blackthorn Gym boulder puzzle using persistent Mental Map data. Tracks all boulders simultaneously to handle interleaved sequences and bridges. Returns a JSON array of buttons.",
    "input_schema": {
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ],
      "type": "object"
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width, height = int(root.get('width')), int(root.get('height'))\n        passable, pits, initial_b_pos = set(), set(), {}\n        \n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                x = int(tile.get('id'))\n                t_type = tile.get('type')\n                if t_type in ['FLOOR', 'LADDER', 'ICE']:\n                    if tile.get('has-object') == 'true':\n                        obj = tile.find('Object')\n                        if obj is not None and obj.get('id-name') == 'BOULDER':\n                            initial_b_pos[int(obj.get('id'))] = (x, y)\n                        else: continue\n                    passable.add((x, y))\n                elif t_type == 'PIT': pits.add((x, y))\n        \n        for row in root.findall('Row'):\n            for tile in row.findall('Tile'):\n                for marker in tile.findall('Marker'):\n                    if 'Boulder' in marker.text:\n                        bid = int(marker.get('object_id'))\n                        if bid not in initial_b_pos:\n                            initial_b_pos[bid] = (int(tile.get('id')), int(row.get('id')))\n                            passable.add((int(tile.get('id')), int(row.get('id'))))\n\n        start_x, start_y = int(input_data['start_x']), int(input_data['start_y'])\n        b_ids = sorted(initial_b_pos.keys())\n        start_b_state = tuple(initial_b_pos[bid] for bid in b_ids)\n        \n        q = deque([(start_b_state, (start_x, start_y), [])])\n        v = set([(start_b_state, (start_x, start_y))])\n        \n        while q:\n            b_state, p_pos, path = q.popleft()\n            filled_pits = {pos for pos in b_state if pos in pits}\n            if len(filled_pits) == 3:\n                print(json.dumps(path))\n                return\n            if len(path) > 150: continue\n            \n            px, py = p_pos\n            current_passable = passable | filled_pits\n            \n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                npx, npy = px + dx, py + dy\n                if 0 <= npx < width and 0 <= npy < height and (npx, npy) in current_passable:\n                    b_idx = -1\n                    for i, pos in enumerate(b_state):\n                        if pos == (npx, npy) and pos not in pits:\n                            b_idx = i\n                            break\n                    if b_idx != -1:\n                        bx, by = b_state[b_idx]\n                        nbx, nby = bx + dx, by + dy\n                        if 0 <= nbx < width and 0 <= nby < height and (nbx, nby) not in b_state:\n                            if (nbx, nby) in current_passable or (nbx, nby) in pits:\n                                new_b_state = list(b_state)\n                                new_b_state[b_idx] = (nbx, nby)\n                                new_b_state = tuple(new_b_state)\n                                if (new_b_state, (npx, npy)) not in v:\n                                    v.add((new_b_state, (npx, npy)))\n                                    btn = 'Up' if dy==-1 else 'Down' if dy==1 else 'Left' if dx==-1 else 'Right'\n                                    q.append((new_b_state, (npx, npy), path + [btn]))\n                    else:\n                        if (b_state, (npx, npy)) not in v:\n                            v.add((b_state, (npx, npy)))\n                            btn = 'Up' if dy==-1 else 'Down' if dy==1 else 'Left' if dx==-1 else 'Right'\n                            q.append((b_state, (npx, npy), path + [btn]))\n        print(json.dumps({\"error\": \"No solution found\"}))\n    except Exception as e:\n        print(json.dumps({\"error\": str(e)}))\n\nsolve()",
    "history": [
      {
        "commit_message": "Upgrading boulder solver to a multi-boulder state-space search and cleaning up unused tools.",
        "timestamp": "2025-12-29T00:13:17.393Z",
        "action_counter": 29776
      },
      {
        "commit_message": "Fixed multi-boulder solver to handle filled pits as passable floor.",
        "timestamp": "2025-12-29T00:14:50.272Z",
        "action_counter": 29777
      }
    ]
  },
  "solve_blackthorn_boulders": {
    "description": "Calculates the sequence of button presses to solve the Blackthorn Gym boulder puzzle. This tool uses a breadth-first search (BFS) to find the shortest path of pushes to move all three boulders into their respective pits, considering all obstacles and the requirement to detour around boulders to push them. Returns a JSON array of buttons.",
    "input_schema": {
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ],
      "type": "object"
    },
    "python_script": "import collections\nimport json\n\ndef solve():\n    # Map dimensions\n    width, height = 10, 18\n    \n    # Grid representation (W=Wall, .=Floor, O=Pit, L=Ladder, F=NPC, M=NPC)\n    grid_str = [\n        \"WWWWWWWWWW\", # 0\n        \"..........\", # 1\n        \"WW..W.W...\", # 2\n        \"....W.W.O.\", # 3\n        \"....W.WWWW\", # 4\n        \"..O.W.....\", # 5\n        \"....W.WW..\", # 6\n        \".L..W...O.\", # 7\n        \"..WWW...W.\", # 8\n        \"....W..LW.\", # 9\n        \"..W.WW.W..\", # 10\n        \"..W....W..\", # 11\n        \"..W.WW...W\", # 12\n        \"..W......W\", # 13\n        \"..W....W.W\", # 14\n        \"..W....W.W\", # 15\n        \"..W..W...W\", # 16\n        \"..W..W...W\"  # 17\n    ]\n    \n    passable = set()\n    pits = set()\n    for y, row in enumerate(grid_str):\n        for x, char in enumerate(row):\n            if char in ['.', 'L']:\n                passable.add((x, y))\n            elif char == 'O':\n                pits.add((x, y))\n\n    # NPCs at (4, 1) and (4, 11) are walls\n    if (4, 1) in passable: passable.remove((4, 1))\n    if (4, 11) in passable: passable.remove((4, 11))\n\n    # Initial boulder positions\n    # Boulder 6: (3, 3), Boulder 7: (6, 1), Boulder 8: (8, 14)\n    b_init = tuple(sorted([(3, 3), (6, 1), (8, 14)]))\n    \n    # Start position from input\n    start_p = (int(input_data['start_x']), int(input_data['start_y']))\n    \n    # BFS state: (player_pos, tuple_of_active_boulders)\n    # Note: Boulders in pits are removed from the tuple.\n    start_state = (start_p, b_init)\n    queue = collections.deque([(start_state, [])])\n    visited = {start_state}\n    \n    while queue:\n        (p, b_list), path = queue.popleft()\n        \n        # Success condition: all boulders in pits\n        if not b_list:\n            print(json.dumps(path))\n            return\n\n        # Limit search depth for performance\n        if len(path) > 200: continue\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = p[0] + dx, p[1] + dy\n            move_name = { (0,1): \"Down\", (0,-1): \"Up\", (1,0): \"Right\", (-1,0): \"Left\" }[(dx, dy)]\n            \n            if (nx, ny) in passable:\n                if (nx, ny) in b_list:\n                    # Try to push\n                    bx, by = nx + dx, ny + dy\n                    if (bx, by) in pits:\n                        # Boulder falls in\n                        new_b = tuple(sorted([b for b in b_list if b != (nx, ny)]))\n                        if ((nx, ny), new_b) not in visited:\n                            visited.add(((nx, ny), new_b))\n                            queue.append((((nx, ny), new_b), path + [move_name]))\n                    elif (bx, by) in passable and (bx, by) not in b_list:\n                        # Regular push\n                        new_b = tuple(sorted([ (bx, by) if b == (nx, ny) else b for b in b_list ]))\n                        if ((nx, ny), new_b) not in visited:\n                            visited.add(((nx, ny), new_b))\n                            queue.append((((nx, ny), new_b), path + [move_name]))\n                else:\n                    # Regular move\n                    if ((nx, ny), b_list) not in visited:\n                        visited.add(((nx, ny), b_list))\n                        queue.append((((nx, ny), b_list), path + [move_name]))\n\n    print(json.dumps({\"error\": \"No solution found\"}))\n\nsolve()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-29T01:11:16.604Z",
        "action_counter": 29868
      }
    ]
  }
}