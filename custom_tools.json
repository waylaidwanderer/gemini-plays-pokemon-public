{
  "buy_item_quantity": {
    "description": "Buys a specific quantity of the currently selected item in the shop menu. Assumes the 'How many?' prompt is open with 'x01' selected.",
    "input_schema": {
      "type": "object",
      "properties": {
        "quantity": {
          "type": "integer",
          "description": "The number of items to buy."
        }
      },
      "required": [
        "quantity"
      ]
    },
    "python_script": "import json\n\nqty = int(input_data['quantity'])\nbuttons = []\n\n# Press Up (quantity - 1) times to reach the desired amount\nif qty > 1:\n    for _ in range(qty - 1):\n        buttons.append(\"Up\")\n\n# Confirm the purchase\nbuttons.append(\"A\")\n\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "feat: Add buy_item_quantity tool to automate purchasing multiple items in shops. This reduces repetitive button presses for stocking up on supplies.",
        "timestamp": "2025-11-21T09:07:28.956Z",
        "action_counter": 2285
      }
    ]
  },
  "find_interaction_point": {
    "description": "Calculates the best adjacent tile to stand on to interact with a specific map object. Supports searching by `object_id` (for sprites) or `object_name` (for background objects). Returns the target coordinates (x, y) and the direction to face.",
    "input_schema": {
      "type": "object",
      "properties": {
        "object_id": {
          "type": "integer",
          "nullable": true,
          "description": "The ID of the target object (for sprites)."
        },
        "object_name": {
          "type": "string",
          "nullable": true,
          "description": "The name of the target object (for background objects)."
        },
        "player_x": {
          "type": "integer",
          "description": "Current player X coordinate."
        },
        "player_y": {
          "type": "integer",
          "description": "Current player Y coordinate."
        }
      },
      "required": [
        "player_x",
        "player_y"
      ]
    },
    "python_script": "# injected imports [\"sys\", \"json\"]\n# injected variables [\"map_xml_string\", \"input_data\"]\n\nimport xml.etree.ElementTree as ET\nimport math\nimport json\n\nmap_data = ET.fromstring(map_xml_string)\nplayer_x = int(input_data['player_x'])\nplayer_y = int(input_data['player_y'])\n\noid = input_data.get('object_id')\ntarget_id = int(oid) if oid is not None and str(oid).lower() != 'none' and str(oid) != '' else -1\n\noname = input_data.get('object_name')\ntarget_name = str(oname) if oname is not None and str(oname).lower() != 'none' else None\n\ntarget_x = -1\ntarget_y = -1\nfound = False\n\n# Find target object\nfor row in map_data.findall('Row'):\n    y = int(row.get('id'))\n    for tile in row.findall('Tile'):\n        x = int(tile.get('id'))\n        if tile.get('has-object') == 'true':\n            for obj in tile.findall('Object'):\n                # Check ID\n                if target_id != -1 and obj.get('id') and int(obj.get('id')) == target_id:\n                    target_x = x\n                    target_y = y\n                    found = True\n                    break\n                # Check Name\n                if target_name:\n                    name = obj.get('name')\n                    id_name = obj.get('id-name')\n                    if (name and name == target_name) or (id_name and id_name == target_name):\n                        target_x = x\n                        target_y = y\n                        found = True\n                        break\n        if found: break\n    if found: break\n\nif not found:\n    print(json.dumps({\"error\": f\"Object not found. ID: {target_id}, Name: {target_name}\"}))\n    exit()\n\n# Directions: (dx, dy, face_direction)\ndirections = [\n    (0, -1, \"Down\"),  # Above target, face Down\n    (0, 1, \"Up\"),     # Below target, face Up\n    (-1, 0, \"Right\"), # Left of target, face Right\n    (1, 0, \"Left\")    # Right of target, face Left\n]\n\nbest_spot = None\nmin_dist = float('inf')\n\nfor dx, dy, face in directions:\n    nx, ny = target_x + dx, target_y + dy\n    \n    # Check bounds and traversability\n    is_traversable = False\n    for row in map_data.findall('Row'):\n        if int(row.get('id')) == ny:\n            for tile in row.findall('Tile'):\n                if int(tile.get('id')) == nx:\n                    t_type = tile.get('type')\n                    has_obj = tile.get('has-object') == 'true'\n                    has_player = tile.get('has-player') == 'true'\n                    \n                    # Simple traversability check\n                    if t_type in ['FLOOR', 'GRASS', 'SAND']:\n                         if not has_obj or has_player: # Allow if player is there, block if other object\n                             is_traversable = True\n                    break\n            break\n    \n    if is_traversable:\n        dist = math.sqrt((nx - player_x)**2 + (ny - player_y)**2)\n        if dist < min_dist:\n            min_dist = dist\n            best_spot = {\"x\": nx, \"y\": ny, \"face\": face}\n\nif best_spot:\n    print(json.dumps(best_spot))\nelse:\n    print(json.dumps({\"error\": \"No accessible adjacent tiles found\"}))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-11-20T01:27:19.980Z",
        "action_counter": 301
      },
      {
        "commit_message": "fix: Update find_interaction_point to support looking up objects by 'object_name' in addition to 'object_id'. This allows targeting background objects (like computers or signs) that lack numeric IDs.",
        "timestamp": "2025-11-20T02:46:50.280Z",
        "action_counter": 421
      }
    ]
  },
  "find_path": {
    "description": "Calculates a path from the player's current position to a target coordinate (x, y) using BFS. Accounts for walls, objects, one-way ledges, and CAVE tiles. Returns a JSON-compatible list of coordinate objects.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "# injected imports [\"sys\", \"json\"]\n# injected variables [\"map_xml_string\", \"input_data\"]\n\nimport xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef get_map_grid(map_data):\n    width = int(map_data.get(\"width\"))\n    height = int(map_data.get(\"height\"))\n    grid = [[None for _ in range(width)] for _ in range(height)]\n    player_pos = None\n    \n    for row in map_data.findall(\"Row\"):\n        y = int(row.get(\"id\"))\n        for tile in row.findall(\"Tile\"):\n            x = int(tile.get(\"id\"))\n            grid[y][x] = tile\n            if tile.find(\"Player\") is not None:\n                player_pos = (x, y)\n    return grid, width, height, player_pos\n\ndef get_neighbors(cx, cy, grid, width, height, player_pos):\n    neighbors = []\n    moves = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    \n    for dx, dy in moves:\n        nx, ny = cx + dx, cy + dy\n        \n        if 0 <= nx < width and 0 <= ny < height:\n            next_tile = grid[ny][nx]\n            if next_tile is None: continue\n            \n            next_type = next_tile.get(\"type\")\n            # Check for object blocking\n            has_object = next_tile.get(\"has-object\") == \"true\"\n            \n            can_enter = False\n            \n            basic_types = [\"FLOOR\", \"TALL_GRASS\", \"LONG_GRASS\", \"STAIRS\", \n                           \"WARP_CARPET_DOWN\", \"WARP_CARPET_UP\", \"WARP_CARPET_LEFT\", \"WARP_CARPET_RIGHT\",\n                           \"DOOR\", \"OPEN_DOOR\", \"LADDER\", \"CAVE\"]\n            \n            if next_type in basic_types:\n                can_enter = True\n            elif next_type == \"LEDGE_HOP_DOWN\" and dy == 1:\n                can_enter = True\n            elif next_type == \"LEDGE_HOP_LEFT\" and dx == -1:\n                can_enter = True\n            elif next_type == \"LEDGE_HOP_RIGHT\" and dx == 1:\n                can_enter = True\n            elif next_type == \"FLOOR_UP_WALL\" and (dy == -1 or dy == 0):\n                # Traversable from South (climb) or Horizontally (ridge)\n                can_enter = True\n            \n            # Strictly enforce object blocking\n            if can_enter and not has_object:\n                neighbors.append((nx, ny))\n                \n    return neighbors\n\ndef solve_path(start, target, grid, width, height):\n    queue = deque([(start, [start])])\n    visited = set([start])\n    \n    while queue:\n        current_pos, path = queue.popleft()\n        cx, cy = current_pos\n        \n        if current_pos == target:\n            return path\n        \n        for nx, ny in get_neighbors(cx, cy, grid, width, height, start):\n            if (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [(nx, ny)]))\n                \n    return None\n\nmap_data = ET.fromstring(map_xml_string)\ngrid, width, height, player_pos = get_map_grid(map_data)\n\ntarget_x = int(input_data[\"target_x\"])\ntarget_y = int(input_data[\"target_y\"])\ntarget = (target_x, target_y)\n\nif not player_pos:\n    print(\"Error: Player not found\")\nelse:\n    path = solve_path(player_pos, target, grid, width, height)\n    if path:\n        json_path = [{\"x\": x, \"y\": y} for x, y in path]\n        print(json.dumps(json_path))\n    else:\n        print(\"Error: No path found\")",
    "history": [
      {
        "commit_message": "feat: Add find_path tool. Calculates shortest path using BFS, handling walls, objects, and one-way ledges.",
        "timestamp": "2025-11-20T08:35:46.882Z",
        "action_counter": 924
      },
      {
        "commit_message": "fix: Add LADDER to traversable basic_types in find_path. Previously, the tool considered LADDER tiles as walls, preventing pathfinding to or from them.",
        "timestamp": "2025-11-20T10:46:07.670Z",
        "action_counter": 1068
      },
      {
        "commit_message": "fix: Add FLOOR_UP_WALL to traversable tiles when moving down. This tile type appears on Route 32 and visually resembles a ledge, so it is assumed to be jumpable from the north.",
        "timestamp": "2025-11-20T21:10:28.299Z",
        "action_counter": 1479
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. In-game testing proved this tile type blocks movement from the north, contrary to the initial hypothesis that it was a jumpable ledge.",
        "timestamp": "2025-11-20T21:14:51.875Z",
        "action_counter": 1484
      },
      {
        "commit_message": "fix: Reinforce object collision check in find_path and add debug prints for player's neighbors to diagnose issues where objects are ignored.",
        "timestamp": "2025-11-20T23:31:27.320Z",
        "action_counter": 1632
      },
      {
        "commit_message": "fix: Add CAVE to traversable basic_types. This tile type represents cave entrances (warps) and must be traversable to enter dungeons like Union Cave. Also removed debug prints.",
        "timestamp": "2025-11-20T23:38:16.306Z",
        "action_counter": 1641
      },
      {
        "commit_message": "fix: Enable FLOOR_UP_WALL as a traversable ledge when moving down. This is necessary to test if the western ledge at (12, 18) is jumpable, as the eastern path is blocked.",
        "timestamp": "2025-11-21T00:47:29.072Z",
        "action_counter": 1752
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. Verified in-game at (16, 21) that this tile type acts as a wall and cannot be jumped from the north.",
        "timestamp": "2025-11-21T00:59:17.529Z",
        "action_counter": 1768
      },
      {
        "commit_message": "fix: Ensure FLOOR_UP_WALL is treated as a wall. Previous testing at (16, 21) confirmed it is not jumpable from the north.",
        "timestamp": "2025-11-21T01:01:08.516Z",
        "action_counter": 1771
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. Verified in-game at (12, 17) -> (12, 18) that this tile type acts as a wall and cannot be jumped from the north.",
        "timestamp": "2025-11-21T01:05:06.366Z",
        "action_counter": 1776
      },
      {
        "commit_message": "feat: Allow movement UP onto FLOOR_UP_WALL tiles. Verified in-game at Union Cave (5, 19) -> (5, 18) that this tile type acts as a climbable ramp from the south.",
        "timestamp": "2025-11-21T02:01:30.245Z",
        "action_counter": 1847
      },
      {
        "commit_message": "feat: Allow horizontal movement on FLOOR_UP_WALL. The tiles at row 18 act as a traversable ridge connecting the west and east sides of the room.",
        "timestamp": "2025-11-21T02:05:19.643Z",
        "action_counter": 1850
      }
    ]
  },
  "scan_reachable_unseen": {
    "description": "Identifies unseen tiles that are reachable from the player's current position using a flood fill algorithm on traversable tiles. Returns a list of coordinates.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef is_traversable(tile_type):\n    traversable_types = [\n        \"FLOOR\", \"TALL_GRASS\", \"LONG_GRASS\", \"STAIRS\", \n        \"WARP_CARPET_DOWN\", \"WARP_CARPET_UP\", \"WARP_CARPET_LEFT\", \"WARP_CARPET_RIGHT\",\n        \"DOOR\", \"OPEN_DOOR\"\n    ]\n    return tile_type in traversable_types\n\nmap_data = ET.fromstring(map_xml_string)\nwidth = int(map_data.get(\"width\"))\nheight = int(map_data.get(\"height\"))\n\ngrid = [[None for _ in range(width)] for _ in range(height)]\nplayer_pos = None\n\nfor row in map_data.findall(\"Row\"):\n    y = int(row.get(\"id\"))\n    for tile in row.findall(\"Tile\"):\n        x = int(tile.get(\"id\"))\n        grid[y][x] = tile\n        if tile.find(\"Player\") is not None:\n            player_pos = (x, y)\n\nif not player_pos:\n    print(\"Player not found\")\n    exit()\n\nvisited = set()\nqueue = deque([player_pos])\nvisited.add(player_pos)\nreachable_unseen = []\n\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\nwhile queue:\n    cx, cy = queue.popleft()\n    \n    for dx, dy in directions:\n        nx, ny = cx + dx, cy + dy\n        \n        if 0 <= nx < width and 0 <= ny < height:\n            if (nx, ny) in visited:\n                continue\n                \n            tile = grid[ny][nx]\n            tile_type = tile.get(\"type\")\n            is_seen = tile.get(\"seen\") == \"true\"\n            has_object = tile.get(\"has-object\") == \"true\"\n            \n            if not is_seen:\n                reachable_unseen.append((nx, ny))\n                visited.add((nx, ny))\n                continue\n            \n            if is_traversable(tile_type) and not has_object:\n                visited.add((nx, ny))\n                queue.append((nx, ny))\n\nprint(f\"Reachable unseen tiles: {reachable_unseen}\")",
    "history": [
      {
        "commit_message": "feat: Add scan_reachable_unseen tool to identify reachable unseen tiles for exploration.",
        "timestamp": "2025-11-19T22:54:46.456Z",
        "action_counter": 59
      },
      {
        "commit_message": "feat: Add scan_reachable_unseen tool to identify reachable unseen tiles for exploration.",
        "timestamp": "2025-11-19T23:51:32.034Z",
        "action_counter": 153
      }
    ]
  },
  "type_nickname": {
    "description": "Generates the sequence of button presses to type a given nickname on the standard Gen 2 naming screen. Handles upper/lower case switching and navigation. Automatically presses END after typing.",
    "input_schema": {
      "type": "object",
      "properties": {
        "nickname": {
          "type": "string",
          "description": "The nickname to type."
        }
      },
      "required": [
        "nickname"
      ]
    },
    "python_script": "import json\n\n# Keyboard Layout Definition\nlayout_upper = {\n    'A':(0,0), 'B':(1,0), 'C':(2,0), 'D':(3,0), 'E':(4,0), 'F':(5,0), 'G':(6,0), 'H':(7,0), 'I':(8,0),\n    'J':(0,1), 'K':(1,1), 'L':(2,1), 'M':(3,1), 'N':(4,1), 'O':(5,1), 'P':(6,1), 'Q':(7,1), 'R':(8,1),\n    'S':(0,2), 'T':(1,2), 'U':(2,2), 'V':(3,2), 'W':(4,2), 'X':(5,2), 'Y':(6,2), 'Z':(7,2), ' ':(8,2),\n    '-':(0,3), '?':(1,3), '!':(2,3), '/':(3,3), '.':(4,3), ',':(5,3)\n}\n\nlayout_lower = {\n    'a':(0,0), 'b':(1,0), 'c':(2,0), 'd':(3,0), 'e':(4,0), 'f':(5,0), 'g':(6,0), 'h':(7,0), 'i':(8,0),\n    'j':(0,1), 'k':(1,1), 'l':(2,1), 'm':(3,1), 'n':(4,1), 'o':(5,1), 'p':(6,1), 'q':(7,1), 'r':(8,1),\n    's':(0,2), 't':(1,2), 'u':(2,2), 'v':(3,2), 'w':(4,2), 'x':(5,2), 'y':(6,2), 'z':(7,2), ' ':(8,2),\n    '-':(0,3), '?':(1,3), '!':(2,3), '/':(3,3), '.':(4,3), ',':(5,3)\n}\n\n# Special buttons (Row 4)\nBTN_CASE_SWITCH = (0, 4)\nBTN_DEL = (4, 4)\nBTN_END = (8, 4)\n\nbuttons = []\ncurrent_x, current_y = 0, 0  # Start at 'A'\nis_upper = True\n\ndef move_to(target_x, target_y):\n    global current_x, current_y\n    dx = target_x - current_x\n    dy = target_y - current_y\n    \n    # Vertical movement first\n    if dy > 0:\n        buttons.extend([\"Down\"] * dy)\n    elif dy < 0:\n        buttons.extend([\"Up\"] * abs(dy))\n        \n    # Horizontal movement\n    if dx > 0:\n        buttons.extend([\"Right\"] * dx)\n    elif dx < 0:\n        buttons.extend([\"Left\"] * abs(dx))\n        \n    current_x, current_y = target_x, target_y\n\nnickname = input_data[\"nickname\"]\n\nfor char in nickname:\n    target_pos = None\n    target_is_upper = True\n    \n    if char in layout_upper:\n        target_pos = layout_upper[char]\n        target_is_upper = True\n    elif char in layout_lower:\n        target_pos = layout_lower[char]\n        target_is_upper = False\n    else:\n        # Fallback for unknown chars, assume upper or ignore\n        continue\n        \n    # Handle Case Switch\n    if is_upper != target_is_upper:\n        move_to(BTN_CASE_SWITCH[0], BTN_CASE_SWITCH[1])\n        buttons.append(\"A\")\n        is_upper = not is_upper\n        \n    # Move to character and press A\n    move_to(target_pos[0], target_pos[1])\n    buttons.append(\"A\")\n\n# Finish by pressing END\nmove_to(BTN_END[0], BTN_END[1])\nbuttons.append(\"A\")\n\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-11-21T02:29:16.878Z",
        "action_counter": 1875
      }
    ]
  }
}