{
  "find_path": {
    "description": "Finds a path between two coordinates on the current map using BFS. Treats WALL tiles and Objects as obstacles. Accepts an optional list of tiles to avoid (e.g. for off-screen obstacles). Returns a list of coordinate dictionaries representing the path.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        },
        "avoid_tiles": {
          "type": "string",
          "description": "Optional JSON string of list of objects e.g. '[{\"x\": 1, \"y\": 1}]'"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef solve():\n    try:\n        sx = int(input_data['start_x'])\n        sy = int(input_data['start_y'])\n        tx = int(input_data['target_x'])\n        ty = int(input_data['target_y'])\n        avoid_tiles = []\n        if 'avoid_tiles' in input_data and input_data['avoid_tiles']:\n             try:\n                 avoid_tiles = json.loads(input_data['avoid_tiles'])\n             except:\n                 pass\n    except ValueError:\n        print(\"Error: Invalid coordinates\")\n        return\n\n    try:\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        print(f\"Error parsing XML: {e}\")\n        return\n\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    obstacles = set()\n\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib.get('type', 'WALL')\n            is_blocked = False\n            if 'WALL' in t_type or 'WINDOW' in t_type or 'TOWN_MAP' in t_type:\n                is_blocked = True\n            if not is_blocked:\n                for child in tile:\n                    if child.tag == 'Object':\n                        is_blocked = True\n                        break\n            if is_blocked:\n                obstacles.add((x, y))\n    \n    for t in avoid_tiles:\n        obstacles.add((int(t['x']), int(t['y'])))\n\n    start = (sx, sy)\n    target = (tx, ty)\n    if start in obstacles: obstacles.remove(start)\n\n    queue = deque([(start, [])])\n    visited = set([start])\n\n    while queue:\n        (curr_x, curr_y), path = queue.popleft()\n        if (curr_x, curr_y) == target:\n            formatted_path = [{'x': x, 'y': y} for x, y in path]\n            print(json.dumps(formatted_path))\n            return\n\n        moves = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n        for dx, dy in moves:\n            nx, ny = curr_x + dx, curr_y + dy\n            if 0 <= nx < width and 0 <= ny < height:\n                if (nx, ny) not in visited and (nx, ny) not in obstacles:\n                    visited.add((nx, ny))\n                    new_path = path + [(nx, ny)]\n                    queue.append(((nx, ny), new_path))\n    print(\"NO_PATH_FOUND\")\n\nsolve()",
    "history": [
      {
        "commit_message": "feat: Add find_path tool for BFS pathfinding.",
        "timestamp": "2025-11-23T04:11:56.198Z",
        "action_counter": 51
      },
      {
        "commit_message": "fix: Add avoid_tiles argument to find_path to allow navigation around off-screen obstacles like defeated trainers.",
        "timestamp": "2025-11-23T04:52:37.665Z",
        "action_counter": 103
      }
    ]
  }
}