{
  "find_reachable_unseen_tiles": {
    "description": "Analyzes the current map to find all unseen tiles that are adjacent to seen, traversable tiles and determines which of them are actually reachable from the player's current position by pathing only through seen tiles. Outputs a JSON list of coordinate dictionaries for reachable unseen tiles.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\n# Parse the map XML\ntree = ET.fromstring(map_xml_string)\nmap_width = int(tree.get('width'))\nmap_height = int(tree.get('height'))\n\n# Create a grid representation of the map\ngrid = [[None for _ in range(map_width + 1)] for _ in range(map_height + 1)]\nplayer_pos = None\n\nfor row_elem in tree.findall('Row'):\n    y = int(row_elem.get('id'))\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.get('id'))\n        grid[y][x] = tile_elem\n        if tile_elem.find('Player') is not None:\n            player_pos = (x, y)\n\nif not player_pos:\n    print(json.dumps([]))\n\n# Define traversable tiles\nTRAVERSABLE_TILES = {\n    'FLOOR', 'TALL_GRASS', 'DOOR', 'WARP_CARPET_DOWN', 'WARP_CARPET_LEFT',\n    'WARP_CARPET_RIGHT', 'LONG_GRASS', 'STAIRS'\n}\n\n# Special one-way tiles (can be entered, but not freely exited)\nONE_WAY_TILES = {\n    'LEDGE_HOP_DOWN': (0, 1),\n    'LEDGE_HOP_LEFT': (-1, 0),\n    'LEDGE_HOP_RIGHT': (1, 0)\n}\n\ndef is_traversable(x, y, from_x, from_y, grid):\n    if not (1 <= y < len(grid) and 1 <= x < len(grid[0])):\n        return False\n    tile = grid[y][x]\n    if tile is None or tile.get('seen') == 'false':\n        return False\n\n    tile_type = tile.get('type')\n    has_object = tile.get('has-object') == 'true'\n\n    if has_object:\n        return False\n\n    # Check standard traversable tiles\n    if tile_type in TRAVERSABLE_TILES:\n        return True\n\n    # Check one-way ledges\n    if tile_type in ONE_WAY_TILES:\n        dx, dy = ONE_WAY_TILES[tile_type]\n        # Can only move ONTO a ledge tile from the correct direction\n        if x == from_x + dx and y == from_y + dy:\n            return True\n\n    return False\n\nunseen_targets = []\nfor y in range(1, map_height + 1):\n    for x in range(1, map_width + 1):\n        tile = grid[y][x]\n        if tile is not None and tile.get('seen') == 'false':\n            # Check adjacent tiles\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adj_x, adj_y = x + dx, y + dy\n                if 1 <= adj_y < len(grid) and 1 <= adj_x < len(grid[0]):\n                    adj_tile = grid[adj_y][adj_x]\n                    if adj_tile is not None and adj_tile.get('seen') == 'true':\n                        adj_type = adj_tile.get('type')\n                        if adj_type in TRAVERSABLE_TILES:\n                             unseen_targets.append({'x': x, 'y': y})\n                             break # Move to next unseen tile once one valid neighbor is found\n\nreachable_unseen = []\nfor target in unseen_targets:\n    target_x, target_y = target['x'], target['y']\n    \n    # We need to find a path to a tile ADJACENT to the unseen tile, not the unseen tile itself\n    path_found = False\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        adj_to_unseen_x, adj_to_unseen_y = target_x + dx, target_y + dy\n        if not (1 <= adj_to_unseen_y < len(grid) and 1 <= adj_to_unseen_x < len(grid[0])):\n            continue\n\n        adj_tile = grid[adj_to_unseen_y][adj_to_unseen_x]\n        if adj_tile is not None and adj_tile.get('seen') == 'true' and adj_tile.get('type') in TRAVERSABLE_TILES:\n            # BFS from player to this adjacent tile\n            queue = deque([(player_pos, [])])\n            visited = {player_pos}\n\n            while queue:\n                (current_x, current_y), path = queue.popleft()\n\n                if (current_x, current_y) == (adj_to_unseen_x, adj_to_unseen_y):\n                    reachable_unseen.append(target)\n                    path_found = True\n                    break\n\n                for move_dx, move_dy in [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n                    next_x, next_y = current_x + move_dx, current_y + move_dy\n                    if (next_x, next_y) not in visited and is_traversable(next_x, next_y, current_x, current_y, grid):\n                        visited.add((next_x, next_y))\n                        queue.append(((next_x, next_y), path + [move_dy]))\n        if path_found:\n            break\n\n# Remove duplicates\nunique_reachable = [dict(t) for t in {tuple(d.items()) for d in reachable_unseen}]\n\nprint(json.dumps(unique_reachable))\n",
    "history": [
      {
        "commit_message": "feat: Create tool to find reachable unseen tiles. This tool performs a BFS from the player's position to every unseen tile that is adjacent to a seen, traversable tile. This will automate exploration and ensure no paths are missed.",
        "timestamp": "2025-07-23T08:08:37.279Z",
        "action_counter": 1217
      },
      {
        "commit_message": "fix: Prevent pathfinding through unseen tiles. The previous version of the tool was incorrectly finding paths through unseen areas, leading to invalid suggestions of unreachable tiles. This update incorporates the same seen-tile-only logic from the main pathfinder to ensure it only identifies truly reachable unseen tiles.",
        "timestamp": "2025-07-23T10:04:20.643Z",
        "action_counter": 1421
      },
      {
        "commit_message": "feat: Create tool to find reachable unseen tiles. This tool performs a BFS from the player's position to every unseen tile that is adjacent to a seen, traversable tile. This will automate exploration and ensure no paths are missed.",
        "timestamp": "2025-07-23T15:50:21.504Z",
        "action_counter": 2100
      },
      {
        "commit_message": "feat: Create tool to find reachable unseen tiles. This tool performs a BFS from the player's position to every unseen tile that is adjacent to a seen, traversable tile. This will automate exploration and ensure no paths are missed.",
        "timestamp": "2025-07-23T18:33:41.575Z",
        "action_counter": 2411
      }
    ]
  },
  "find_path_to_target": {
    "description": "Finds the shortest path from the player's current position to a specified target coordinate using a Breadth-First Search algorithm. It correctly handles one-way ledges and will find a path to a tile adjacent to the target if the target itself is impassable. It will not traverse unseen tiles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef find_path_to_target():\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.get('width'))\n    map_height = int(root.get('height'))\n\n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tile_type = tile.get('type')\n            seen = tile.get('seen') == 'true'\n            is_impassable = not seen or tile_type in ['WALL', 'WATER', 'COUNTER', 'HEADBUTT_TREE', 'CUT_TREE', 'CAVE', 'PC'] or tile.find('Object') is not None\n            grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n\n    player_tile = root.find('.//Player/..')\n    if not player_tile:\n        print(json.dumps([]))\n        return\n    start_x = int(player_tile.get('id'))\n    start_y = int(player_tile.get('coordinate').split(',')[1].strip(')'))\n    \n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n\n    queue = deque([[(start_x, start_y)]])\n    visited = {(start_x, start_y)}\n\n    is_target_impassable = grid.get((target_x, target_y), {'impassable': True})['impassable']\n    \n    destination_tiles = set()\n    if not is_target_impassable:\n        destination_tiles.add((target_x, target_y))\n    else:\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            adj_x, adj_y = target_x + dx, target_y + dy\n            adj_tile_info = grid.get((adj_x, adj_y))\n            if adj_tile_info and not adj_tile_info['impassable']:\n                destination_tiles.add((adj_x, adj_y))\n    \n    if not destination_tiles:\n        print(json.dumps([]))\n        return\n\n    while queue:\n        path = queue.popleft()\n        current_x, current_y = path[-1]\n\n        if (current_x, current_y) in destination_tiles:\n            print(json.dumps([{'x': p[0], 'y': p[1]} for p in path]))\n            return\n\n        for move, dx, dy in [('Up', 0, -1), ('Down', 0, 1), ('Left', -1, 0), ('Right', 1, 0)]:\n            next_x, next_y = current_x + dx, current_y + dy\n\n            if (next_x, next_y) in visited:\n                continue\n\n            next_tile_info = grid.get((next_x, next_y))\n            if not next_tile_info or next_tile_info['impassable']:\n                continue\n            \n            next_tile_type = next_tile_info.get('type')\n            if (next_tile_type == 'LEDGE_HOP_DOWN' and move == 'Up') or \\\n               (next_tile_type == 'LEDGE_HOP_LEFT' and move == 'Right') or \\\n               (next_tile_type == 'LEDGE_HOP_RIGHT' and move == 'Left'):\n                continue\n\n            new_path = list(path)\n            new_path.append((next_x, next_y))\n            visited.add((next_x, next_y))\n            queue.append(new_path)\n\n    print(json.dumps([]))\n\nfind_path_to_target()\n",
    "history": [
      {
        "commit_message": "feat: Create new pathfinding tool. This tool, `find_path_to_target`, replaces the old, buggy `find_path` tool. It uses a standard Breadth-First Search (BFS) algorithm to find the shortest path, properly handles one-way ledges, and can path to a tile adjacent to the target if the destination itself is blocked. This provides a more robust and reliable foundation for navigation.",
        "timestamp": "2025-07-23T08:07:27.131Z",
        "action_counter": 1215
      },
      {
        "commit_message": "refactor: Replace buggy pathfinder with a new, standard BFS implementation. The previous versions had a persistent, unidentified bug that caused pathing failures even on valid routes. This complete rewrite uses a textbook BFS algorithm to ensure reliability and correctness for future navigation.",
        "timestamp": "2025-07-23T08:10:32.846Z",
        "action_counter": 1220
      },
      {
        "commit_message": "fix: Prevent pathfinding through unseen tiles and improve adjacent pathing. The tool now treats any tile with `seen=\"false\"` as impassable, preventing illegal moves through the fog of war. It also uses a more robust method for finding paths to tiles adjacent to an impassable target, ensuring it finds a valid path if one exists.",
        "timestamp": "2025-07-23T09:01:19.031Z",
        "action_counter": 1304
      },
      {
        "commit_message": "fix: Add CAVE to impassable tiles. This prevents the pathfinder from accidentally routing through cave entrances, which are warps and should not be treated as normal floor tiles. This was causing repeated, unintentional entries into the Dark Cave.",
        "timestamp": "2025-07-23T10:40:27.223Z",
        "action_counter": 1501
      },
      {
        "commit_message": "fix: Add PC to impassable tiles. The pathfinder was incorrectly routing through PC terminals, causing movement to fail. This update adds 'PC' to the list of impassable tile types, ensuring the tool generates valid paths in areas like PokÃ©mon Centers.",
        "timestamp": "2025-07-23T12:32:35.999Z",
        "action_counter": 1733
      }
    ]
  }
}