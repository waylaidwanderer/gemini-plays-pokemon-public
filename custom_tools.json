{
  "get_reachable_unseen_tiles": {
    "description": "Finds all unseen tiles that are directly adjacent to reachable, passable tiles on the current map. Returns a JSON array of coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef run():\n    try:\n        root = ET.fromstring(map_xml_string)\n        player_pos = None\n        grid = {}\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                if tile.find('Player') is not None:\n                    player_pos = (x, y)\n                grid[(x, y)] = {\n                    'type': tile.attrib['type'],\n                    'seen': tile.attrib['seen'] == 'true',\n                    'has_object': tile.attrib.get('has-object') == 'true',\n                    'is_warp': tile.attrib.get('is-warp') == 'true'\n                }\n        \n        if not player_pos:\n            print(\"Error: Player pos not found.\")\n            return\n\n        passable_types = ['FLOOR', 'TALL_GRASS', 'LONG_GRASS', 'WARP_CARPET', 'WATER', 'ICE', 'LADDER', 'PIT']\n        \n        reachable = set()\n        queue = deque([player_pos])\n        visited = {player_pos}\n\n        while queue:\n            cx, cy = queue.popleft()\n            reachable.add((cx, cy))\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = cx + dx, cy + dy\n                if (nx, ny) in grid and (nx, ny) not in visited:\n                    tile = grid[(nx, ny)]\n                    if tile['seen'] and tile['type'] in passable_types and not tile['has_object'] and not tile['is_warp']:\n                        visited.add((nx, ny))\n                        queue.append((nx, ny))\n\n        unseen_reachable = set()\n        for rx, ry in reachable:\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = rx + dx, ry + dy\n                if (nx, ny) in grid and not grid[(nx, ny)]['seen']:\n                    unseen_reachable.add((nx, ny))\n\n        print(json.dumps(sorted(list(unseen_reachable))))\n    except Exception as e:\n        print(f\"Error: {str(e)}\")\n\nrun()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T06:20:54.963Z",
        "action_counter": 27975
      },
      {
        "commit_message": "Fixed the tool to execute the logic and print the result properly. Removed function wrapping to ensure execution in the harness environment.",
        "timestamp": "2025-12-28T06:21:58.588Z",
        "action_counter": 27977
      },
      {
        "commit_message": "Added 'ICE' and 'WARP_CARPET_DOWN' to passable types for better exploration.",
        "timestamp": "2025-12-28T07:02:21.682Z",
        "action_counter": 28055
      },
      {
        "commit_message": "Updating exploration tool to find reachable unseen tiles.",
        "timestamp": "2025-12-28T09:40:39.023Z",
        "action_counter": 28377
      },
      {
        "commit_message": "Refining exploration tool to accurately identify reachable unseen tiles from the current player position.",
        "timestamp": "2025-12-28T09:41:08.853Z",
        "action_counter": 28378
      }
    ]
  },
  "find_map_objects": {
    "description": "Finds all instances of a specific object type in the Mental Map and returns their coordinates and IDs.",
    "input_schema": {
      "type": "object",
      "properties": {
        "object_name": {
          "type": "string",
          "description": "The name or part of the name of the object to find (e.g., 'BOULDER', 'ITEM', 'NPC')"
        }
      },
      "required": [
        "object_name"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ndef run():\n    try:\n        root = ET.fromstring(map_xml_string)\n        target = input_data.get('object_name', 'BOULDER').upper()\n        found = []\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                obj = tile.find('Object')\n                if obj is not None:\n                    name = obj.attrib.get('id-name', '').upper()\n                    if target in name:\n                        found.append({\n                            'x': x, \n                            'y': y, \n                            'id': int(obj.attrib.get('id', 0)), \n                            'name': name\n                        })\n        print(json.dumps(found))\n    except Exception as e:\n        print(json.dumps({\"error\": str(e)}))\n\nrun()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T15:59:50.178Z",
        "action_counter": 28951
      }
    ]
  }
}