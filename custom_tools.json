{
  "dungeon_navigator": {
    "description": "Generates a full, systematic exploration path for the current map segment using a nearest-neighbor heuristic to visit every reachable, non-warp ground tile. This is the primary tool for clearing complex dungeons. The output is a JSON object with a 'path' key containing a list of coordinate objects, suitable for use with the `path_plan`.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\nimport traceback\n\ndef find_path_bfs(grid, start, end, width, height, impassable_types):\n    queue = deque([(start, [])])\n    visited = {start}\n    while queue:\n        (cx, cy), path = queue.popleft()\n        if (cx, cy) == end:\n            return path\n        for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = cx + dx, cy + dy\n            if 1 <= nx <= width and 1 <= ny <= height and (nx, ny) not in visited:\n                tile_data = grid.get((nx, ny))\n                if tile_data and tile_data['type'] not in impassable_types and not tile_data['has_object']:\n                    visited.add((nx, ny))\n                    new_path = path + [move]\n                    queue.append(((nx, ny), new_path))\n    return None\n\ndef dungeon_navigator_v11(map_xml_string, start_x_str, start_y_str):\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        start_x, start_y = int(start_x_str), int(start_y_str)\n        grid = {}\n        all_ground_tiles = []\n        for r in root.findall('Row'):\n            y = int(r.get('id'))\n            for t in r.findall('Tile'):\n                x = int(t.get('id'))\n                has_impassable_object = False\n                obj_node = t.find('Object')\n                if obj_node is not None and obj_node.get('id-name') != 'Pikachu':\n                    has_impassable_object = True\n                tile_type = t.get('type')\n                is_warp = t.get('is-warp') == 'true'\n                grid[(x, y)] = {'type': tile_type, 'has_object': has_impassable_object}\n                if tile_type not in ['impassable', 'unknown', 'cuttable', 'water', 'closed_gate'] and not is_warp:\n                    all_ground_tiles.append((x, y))\n        impassable_types = ['impassable', 'unknown', 'cuttable', 'water', 'closed_gate']\n        q = deque([(start_x, start_y)])\n        reachable_set = {(start_x, start_y)}\n        while q:\n            cx, cy = q.popleft()\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = cx + dx, cy + dy\n                if (nx, ny) in grid and (nx, ny) not in reachable_set:\n                    tile_data = grid[(nx, ny)]\n                    if tile_data['type'] not in impassable_types and not tile_data['has_object']:\n                        reachable_set.add((nx, ny))\n                        q.append((nx, ny))\n        exploration_targets = {t for t in all_ground_tiles if t in reachable_set}\n        if not exploration_targets:\n            return json.dumps({\"status\": \"info\", \"message\": \"No non-warp ground tiles to explore in this segment.\", \"path\": []})\n        full_path_coords = [(start_x, start_y)]\n        current_pos = (start_x, start_y)\n        while exploration_targets:\n            nearest_target = None\n            shortest_path_to_target = None\n            for target in list(exploration_targets):\n                path = find_path_bfs(grid, current_pos, target, width, height, impassable_types)\n                if path is not None:\n                    if shortest_path_to_target is None or len(path) < len(shortest_path_to_target):\n                        shortest_path_to_target = path\n                        nearest_target = target\n            if nearest_target is None:\n                break\n            temp_pos = current_pos\n            for move in shortest_path_to_target:\n                if move == 'Up': temp_pos = (temp_pos[0], temp_pos[1] - 1)\n                elif move == 'Down': temp_pos = (temp_pos[0], temp_pos[1] + 1)\n                elif move == 'Left': temp_pos = (temp_pos[0] - 1, temp_pos[1])\n                elif move == 'Right': temp_pos = (temp_pos[0] + 1, temp_pos[1])\n                full_path_coords.append(temp_pos)\n            current_pos = nearest_target\n            exploration_targets.remove(nearest_target)\n        json_path = [{'x': p[0], 'y': p[1]} for p in full_path_coords]\n        return json.dumps({\"status\": \"success\", \"path\": json_path})\n    except Exception as e:\n        return json.dumps({\"status\": \"error\", \"message\": str(e), \"traceback\": traceback.format_exc()})\n\nprint(dungeon_navigator_v11(map_xml_string, input_data['start_x'], input_data['start_y']))"
  },
  "map_segment_analyzer": {
    "description": "Analyzes the current map segment to find all reachable tiles, warps, and objects from the player's current position using a proper BFS. Handles `closed_gate` tiles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\nimport traceback\n\ndef analyze_segment_fixed(map_xml_string, start_x, start_y):\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        start_x, start_y = int(start_x), int(start_y)\n\n        grid = {}\n        for r in root.findall('Row'):\n            y = int(r.get('id'))\n            for t in r.findall('Tile'):\n                x = int(t.get('id'))\n                has_impassable_object = False\n                obj_node = t.find('Object')\n                if obj_node is not None and obj_node.get('id-name') != 'Pikachu':\n                    has_impassable_object = True\n                \n                grid[(x, y)] = {\n                    'type': t.get('type'),\n                    'has_object': has_impassable_object,\n                    'is_warp': t.get('is-warp') == 'true',\n                    'original_object_node': obj_node\n                }\n        \n        impassable_types = ['impassable', 'unknown', 'cuttable', 'water', 'closed_gate']\n        \n        queue = deque([(start_x, start_y)])\n        visited = set([(start_x, start_y)])\n        reachable_tiles_coords = set([(start_x, start_y)])\n        reachable_warps, reachable_objects = [], []\n\n        while queue:\n            cx, cy = queue.popleft()\n            \n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = cx + dx, cy + dy\n\n                if (nx, ny) not in visited:\n                    neighbor_data = grid.get((nx, ny))\n                    if neighbor_data:\n                        visited.add((nx, ny))\n                        if neighbor_data['type'] not in impassable_types and not neighbor_data['has_object']:\n                            reachable_tiles_coords.add((nx, ny))\n                            queue.append((nx, ny))\n        \n        for x, y in reachable_tiles_coords:\n            tile_data = grid.get((x, y))\n            if tile_data:\n                if tile_data['is_warp']:\n                    if {'x': x, 'y': y} not in reachable_warps:\n                        reachable_warps.append({'x': x, 'y': y})\n                \n                obj_node = tile_data['original_object_node']\n                if obj_node is not None:\n                    obj_data = {\n                        'id': obj_node.get('id'),\n                        'id-name': obj_node.get('id-name'),\n                        'name': obj_node.get('name'),\n                        'x': x,\n                        'y': y\n                    }\n                    if obj_data not in reachable_objects:\n                        reachable_objects.append(obj_data)\n\n        result = {\n            \"reachable_tiles_count\": len(reachable_tiles_coords),\n            \"reachable_warps\": reachable_warps,\n            \"reachable_objects\": reachable_objects,\n            \"segment_size\": len(reachable_tiles_coords)\n        }\n        return json.dumps(result, indent=2)\n        \n    except Exception as e:\n        return json.dumps({\"error\": str(e), \"traceback\": traceback.format_exc()})\n\nprint(analyze_segment_fixed(map_xml_string, input_data['start_x'], input_data['start_y']))"
  },
  "overworld_navigator": {
    "description": "Calculates a multi-map path between a start and end location using the World Knowledge Graph. This tool is designed for complex navigation that requires traversing between different map_ids via warps or map edges. It returns a sequence of actions, including local pathfinding on each map segment and the necessary warp/transition actions.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_map_id": {
          "type": "string"
        },
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_map_id": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_map_id",
        "start_x",
        "start_y",
        "end_map_id",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import json\nimport heapq\n\ndef heuristic(a, b):\n    return abs(a['x'] - b['x']) + abs(a['y'] - b['y'])\n\ndef a_star_search(graph, start_node_id, end_node_id):\n    nodes_by_id = {n['id']: n for n in graph['nodes']}\n    start_node = nodes_by_id.get(start_node_id)\n    end_node = nodes_by_id.get(end_node_id)\n    if not start_node or not end_node:\n        return None\n\n    open_set = [(0, start_node_id)]\n    came_from = {}\n    g_score = {node_id: float('inf') for node_id in nodes_by_id}\n    g_score[start_node_id] = 0\n    f_score = {node_id: float('inf') for node_id in nodes_by_id}\n    f_score[start_node_id] = heuristic(start_node['coordinates'], end_node['coordinates'])\n    open_set_hash = {start_node_id}\n\n    while open_set:\n        _, current_id = heapq.heappop(open_set)\n        open_set_hash.remove(current_id)\n\n        if current_id == end_node_id:\n            path = []\n            temp = current_id\n            while temp in came_from:\n                path.append(temp)\n                temp = came_from[temp]\n            path.append(start_node_id)\n            return path[::-1]\n\n        for edge in graph['edges']:\n            neighbor_id = None\n            if edge['source_node_id'] == current_id:\n                neighbor_id = edge['destination_node_id']\n            elif edge['destination_node_id'] == current_id and not edge.get('is_one_way', False):\n                neighbor_id = edge['source_node_id']\n\n            if neighbor_id:\n                tentative_g_score = g_score[current_id] + 1\n                if tentative_g_score < g_score[neighbor_id]:\n                    came_from[neighbor_id] = current_id\n                    g_score[neighbor_id] = tentative_g_score\n                    neighbor_node = nodes_by_id.get(neighbor_id)\n                    if neighbor_node:\n                        f_score[neighbor_id] = g_score[neighbor_id] + heuristic(neighbor_node['coordinates'], end_node['coordinates'])\n                        if neighbor_id not in open_set_hash:\n                            heapq.heappush(open_set, (f_score[neighbor_id], neighbor_id))\n                            open_set_hash.add(neighbor_id)\n    return None\n\ntry:\n    world_graph = json.loads(world_knowledge_graph_json_string)\n    start_map_id = input_data['start_map_id']\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_map_id = input_data['end_map_id']\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n\n    start_nodes_on_map = [n for n in world_graph.get('nodes', []) if n.get('map_id') == start_map_id]\n    end_nodes_on_map = [n for n in world_graph.get('nodes', []) if n.get('map_id') == end_map_id]\n\n    if not start_nodes_on_map or not end_nodes_on_map:\n        print(json.dumps({'path_found': False, 'path': [], 'error': 'Start or end map not found in World Knowledge Graph.'}))\n    else:\n        start_node = min(start_nodes_on_map, key=lambda n: heuristic(n['coordinates'], {'x': start_x, 'y': start_y}))\n        end_node = min(end_nodes_on_map, key=lambda n: heuristic(n['coordinates'], {'x': end_x, 'y': end_y}))\n        path_node_ids = a_star_search(world_graph, start_node['id'], end_node['id'])\n\n        if path_node_ids:\n            path_details = []\n            for node_id in path_node_ids:\n                node = next((n for n in world_graph['nodes'] if n['id'] == node_id), None)\n                if node:\n                    path_details.append({'map_id': node['map_id'], 'name': node['name'], 'x': node['coordinates']['x'], 'y': node['coordinates']['y']})\n            print(json.dumps({'path_found': True, 'path': path_details}))\n        else:\n            print(json.dumps({'path_found': False, 'path': [], 'error': 'No path found between nodes in World Knowledge Graph.'}))\nexcept Exception as e:\n    print(json.dumps({'path_found': False, 'path': [], 'error': str(e)}))\n"
  },
  "pathfinder": {
    "description": "Calculates the shortest path on the current map using BFS. Can optionally ignore certain impassable tile types.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "ignorable_impassable_types": {
          "type": "string",
          "description": "A comma-separated string of tile types to ignore as impassable (e.g., 'closed_gate,water')."
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    ignorable_types_str = input_data.get('ignorable_impassable_types', '')\n    ignorable_types = [t.strip() for t in ignorable_types_str.split(',') if t.strip()] if ignorable_types_str else []\n\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n\n    grid = {}\n    for r in root.findall('Row'):\n        y = int(r.get('id'))\n        for t in r.findall('Tile'):\n            x = int(t.get('id'))\n            has_impassable_object = False\n            obj_node = t.find('Object')\n            if obj_node is not None and obj_node.get('id-name') != 'Pikachu':\n                has_impassable_object = True\n            grid[(x, y)] = {\n                'type': t.get('type'),\n                'has_object': has_impassable_object\n            }\n\n    base_impassable = ['impassable', 'unknown', 'cuttable', 'water']\n    impassable_types = [t for t in base_impassable if t not in ignorable_types]\n    if 'closed_gate' not in ignorable_types:\n        impassable_types.append('closed_gate')\n\n    queue = deque([([ (start_x, start_y) ])])\n    visited = {(start_x, start_y)}\n\n    while queue:\n        path = queue.popleft()\n        cx, cy = path[-1]\n\n        if (cx, cy) == (end_x, end_y):\n            json_path = [{'x': p[0], 'y': p[1]} for p in path]\n            print(json.dumps({'path_found': True, 'path': json_path}))\n            exit()\n\n        current_tile = grid.get((cx, cy))\n        \n        if current_tile and current_tile['type'] == 'ledge':\n            nx, ny = cx, cy + 1\n            if (1 <= ny <= height):\n                landing_x, landing_y = nx, ny + 1\n                if (landing_x, landing_y) not in visited and (1 <= landing_y <= height):\n                     landing_tile = grid.get((landing_x, landing_y))\n                     if landing_tile and landing_tile['type'] not in impassable_types and not landing_tile['has_object']:\n                        visited.add((landing_x, landing_y))\n                        new_path = path + [(landing_x, landing_y)]\n                        queue.append(new_path)\n            continue\n\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = cx + dx, cy + dy\n\n            if not (1 <= nx <= width and 1 <= ny <= height) or (nx, ny) in visited:\n                continue\n\n            neighbor_tile = grid.get((nx, ny))\n            if not neighbor_tile:\n                continue\n\n            if neighbor_tile['type'] in impassable_types or neighbor_tile['has_object']:\n                continue\n            \n            if neighbor_tile['type'] == 'ledge':\n                if dy == -1 or dx != 0:\n                    continue\n            \n            visited.add((nx, ny))\n            new_path = path + [(nx, ny)]\n            queue.append(new_path)\n\n    print(json.dumps({'path_found': False, 'path': []}))\n\nexcept Exception as e:\n    print(json.dumps({'path_found': False, 'error': str(e)}))"
  },
  "wkg_checker": {
    "description": "Checks the World Knowledge Graph to see if a node or edge already exists based on its key properties, preventing duplicates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "element_type": {
          "type": "string",
          "enum": [
            "node",
            "edge"
          ]
        },
        "map_id": {
          "type": "string"
        },
        "x": {
          "type": "string"
        },
        "y": {
          "type": "string"
        },
        "to_map_id": {
          "type": "string"
        },
        "to_x": {
          "type": "string"
        },
        "to_y": {
          "type": "string"
        }
      },
      "required": [
        "element_type",
        "map_id",
        "x",
        "y"
      ]
    },
    "python_script": "import json\nwkg = json.loads(world_knowledge_graph_json_string)\nelement_type = input_data['element_type']\nmap_id = input_data['map_id']\nx = int(input_data['x'])\ny = int(input_data['y'])\nfound = False\nif element_type == 'node':\n    for node in wkg.get('nodes', []):\n        if node['map_id'] == map_id and node['coordinates']['x'] == x and node['coordinates']['y'] == y:\n            found = True\n            break\nelif element_type == 'edge':\n    to_map_id = input_data['to_map_id']\n    to_x = int(input_data['to_x'])\n    to_y = int(input_data['to_y'])\n    for edge in wkg.get('edges', []):\n        s = edge['source_coordinates']\n        d = edge['destination_coordinates']\n        if (s['map_id'] == map_id and s['x'] == x and s['y'] == y and \\\n            d['map_id'] == to_map_id and d['x'] == to_x and d['y'] == to_y) or \\\n           (s['map_id'] == to_map_id and s['x'] == to_x and s['y'] == to_y and \\\n            d['map_id'] == map_id and d['x'] == x and d['y'] == y):\n            found = True\n            break\nprint(json.dumps({'exists': found}))"
  }
}