{
  "reachable_shoreline_finder": {
    "description": "Analyzes the map_xml_string to identify all reachable water-adjacent ground tiles from the player's current position. This version correctly handles elevation changes via 'steps' tiles.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\n\nroot = ET.fromstring(map_xml_string)\nmap_width = int(root.attrib['width'])\nmap_height = int(root.attrib['height'])\n\ngrid = {}\nplayer_start = None\n\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.attrib['id'])\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.attrib['id'])\n        tile_type = tile_elem.attrib['type']\n        has_object = tile_elem.find('Object') is not None\n        \n        is_impassable = tile_type in ['impassable', 'boulder_barrier', 'closed_gate', 'unknown'] or has_object\n        if has_object and tile_elem.find('Object').attrib.get('id-name') == 'Pikachu':\n            is_impassable = False\n\n        grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n        if tile_elem.find('Player') is not None:\n            player_start = (x, y)\n\nif not player_start:\n    print(\"Error: Player position not found.\")\nelse:\n    queue = collections.deque([player_start])\n    visited = {player_start}\n    \n    # Walkable tiles for BFS. This is the key fix.\n    walkable_types = ['ground', 'elevated_ground', 'steps', 'grass', 'cleared_boulder_barrier', 'boulder_switch', 'open_gate', 'gate_offscreen']\n\n    while queue:\n        cx, cy = queue.popleft()\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            neighbor_coord = (nx, ny)\n            \n            if 1 <= nx <= map_width and 1 <= ny <= map_height and neighbor_coord not in visited:\n                neighbor_tile = grid.get(neighbor_coord, {})\n                if not neighbor_tile.get('impassable') and neighbor_tile.get('type') in walkable_types:\n                    visited.add(neighbor_coord)\n                    queue.append(neighbor_coord)\n\n    shoreline_tiles = []\n    land_types_for_surfing = ['ground', 'elevated_ground', 'steps', 'grass'] # Tiles you can stand on to initiate Surf\n\n    for x, y in sorted(list(visited)):\n        current_tile = grid.get((x,y), {})\n        if current_tile.get('type') in land_types_for_surfing:\n            is_shore = False\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 1 <= nx <= map_width and 1 <= ny <= map_height:\n                    if grid.get((nx, ny), {}).get('type') == 'water':\n                        is_shore = True\n                        break\n            if is_shore:\n                shoreline_tiles.append((x, y))\n\n    if shoreline_tiles:\n        print(f\"Reachable shoreline tiles found: {shoreline_tiles}\")\n    else:\n        print(\"No reachable shoreline tiles found from the current position.\")"
  },
  "gem_pathfinder": {
    "description": "A new, robust pathfinding tool that can handle all known tile types, ledges, surfing, spinners, ignorable objects, elevation, and can path to adjacent tiles if the target is impassable.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        },
        "party_data": {
          "type": "string"
        },
        "hazard_coords": {
          "type": "string",
          "nullable": true
        },
        "ignorable_coords": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "target_x",
        "target_y",
        "party_data"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef find_path(map_xml_string, target_x, target_y, party_data_str, hazard_coords_str=None, ignorable_coords_str=None):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = [['' for _ in range(width + 1)] for _ in range(height + 1)]\n    elevations = [[0 for _ in range(width + 1)] for _ in range(height + 1)]\n    spinner_data = {}\n    objects = set()\n    start_x, start_y = -1, -1\n\n    ignorable_coords = set()\n    if ignorable_coords_str:\n        try:\n            coords = json.loads(ignorable_coords_str)\n            for c in coords:\n                ignorable_coords.add(tuple(c))\n        except (json.JSONDecodeError, TypeError):\n            pass\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            grid[y][x] = tile_type\n\n            if tile_elem.get('has-player') == 'true':\n                start_x, start_y = x, y\n\n            if (x, y) not in ignorable_coords:\n                if tile_elem.find('Object') is not None or tile_elem.find('Boulder') is not None:\n                    obj_elem = tile_elem.find('Object')\n                    boulder_elem = tile_elem.find('Boulder')\n                    if (obj_elem is not None and obj_elem.get('id-name') != 'Pikachu') or boulder_elem is not None:\n                        objects.add((x, y))\n\n            if tile_type in ['elevated_ground', 'cleared_boulder_barrier']:\n                elevations[y][x] = 1\n            \n            spinner_elem = tile_elem.find('Spinner')\n            if spinner_elem is not None and 'end-coordinate' in spinner_elem.attrib:\n                end_coord_str = spinner_elem.get('end-coordinate').replace('(', '').replace(')', '')\n                end_x, end_y = map(int, end_coord_str.split(','))\n                spinner_data[(x, y)] = (end_x, end_y)\n    \n    if start_x == -1:\n        return \"Player tile not found in map XML.\"\n\n    party_list = []\n    try:\n        party_list = json.loads(party_data_str)\n    except json.JSONDecodeError:\n        return \"Invalid party_data JSON.\"\n\n    can_surf = any(move == 'SURF' for p in party_list for move in p.get('moves', []))\n    \n    hazard_coords = set()\n    if hazard_coords_str:\n        try:\n            hazards = json.loads(hazard_coords_str)\n            for h in hazards:\n                hazard_coords.add(tuple(h))\n        except (json.JSONDecodeError, TypeError):\n            pass\n\n    traversable_walking = ['ground', 'grass', 'steps', 'cleared_boulder_barrier', 'hole', 'spinner_stop', 'open_gate', 'gate_offscreen', 'elevated_ground', 'ladder_up', 'ladder_down', 'boulder_switch']\n    traversable_surfing = ['water']\n    valid_surf_start_tiles = ['ground', 'steps', 'grass']\n\n    is_target_impassable = (\n        grid[target_y][target_x] not in traversable_walking and\n        grid[target_y][target_x] not in traversable_surfing and\n        not grid[target_y][target_x].startswith('spinner')\n    ) or (target_x, target_y) in objects\n\n    original_target_x, original_target_y = target_x, target_y\n    destination_tiles = []\n\n    if is_target_impassable:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_x, adj_y = target_x + dx, target_y + dy\n            if 1 <= adj_x <= width and 1 <= adj_y <= height:\n                adj_tile_type = grid[adj_y][adj_x]\n                if (adj_tile_type in traversable_walking or adj_tile_type in traversable_surfing or adj_tile_type.startswith('spinner')) and (adj_x, adj_y) not in objects:\n                    destination_tiles.append((adj_x, adj_y))\n    else:\n        destination_tiles.append((target_x, target_y))\n\n    if not destination_tiles:\n        return \"No traversable tile adjacent to the impassable target.\"\n\n    open_set = []\n    heapq.heappush(open_set, (0, (start_x, start_y)))\n    came_from = {}\n    g_score = {(x, y): float('inf') for x in range(width + 2) for y in range(height + 2)}\n    g_score[(start_x, start_y)] = 0\n    f_score = {(x, y): float('inf') for x in range(width + 2) for y in range(height + 2)}\n    f_score[(start_x, start_y)] = min(abs(start_x - dx) + abs(start_y - dy) for dx, dy in destination_tiles)\n\n    final_destination = None\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current in destination_tiles:\n            final_destination = current\n            break\n\n        x, y = current\n        current_tile_type = grid[y][x]\n        \n        neighbors = []\n        if current in spinner_data:\n            neighbors.append(spinner_data[current])\n        else:\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if not (1 <= nx <= width and 1 <= ny <= height):\n                    continue\n                \n                neighbor_tile_type = grid[ny][nx]\n\n                if neighbor_tile_type == 'ledge':\n                    if dy == 1:\n                        if 1 <= ny + 1 <= height:\n                            neighbors.append((nx, ny + 1))\n                    continue\n                \n                if current_tile_type == 'ledge' and dy == -1:\n                    continue\n\n                neighbors.append((nx,ny))\n        \n        for neighbor in neighbors:\n            nx, ny = neighbor\n            \n            neighbor_tile_type = grid[ny][nx]\n\n            if neighbor_tile_type == 'impassable':\n                continue\n\n            if (nx, ny) in hazard_coords or (nx, ny) in objects:\n                continue\n\n            is_traversable = False\n            is_walking = current_tile_type != 'water'\n            is_surfing = not is_walking\n\n            if is_walking:\n                if neighbor_tile_type in traversable_walking or neighbor_tile_type.startswith('spinner'):\n                    is_traversable = True\n                elif neighbor_tile_type == 'water' and can_surf and current_tile_type in valid_surf_start_tiles:\n                    is_traversable = True\n            elif is_surfing:\n                if neighbor_tile_type in traversable_surfing or neighbor_tile_type in traversable_walking:\n                    is_traversable = True\n\n            if is_traversable:\n                current_elevation = elevations[y][x]\n                neighbor_elevation = elevations[ny][nx]\n                \n                can_traverse_elevation = False\n                if current_elevation == neighbor_elevation:\n                    can_traverse_elevation = True\n                elif 'steps' in (current_tile_type, neighbor_tile_type):\n                    can_traverse_elevation = True\n                \n                if not can_traverse_elevation:\n                    is_traversable = False\n            \n            if not is_traversable:\n                continue\n\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + min(abs(nx - dx) + abs(ny - dy) for dx, dy in destination_tiles)\n                heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    \n    if final_destination:\n        path = []\n        current = final_destination\n        while current in came_from:\n            path.append(current)\n            current = came_from[current]\n        path.append((start_x, start_y))\n        \n        reconstructed_path = path[::-1]\n        if is_target_impassable:\n            reconstructed_path.append((original_target_x, original_target_y))\n        \n        return reconstructed_path\n    \n    return None\n\ntry:\n    path = find_path(map_xml_string, int(input_data['target_x']), int(input_data['target_y']), input_data['party_data'], input_data.get('hazard_coords'), input_data.get('ignorable_coords'))\n    \n    if isinstance(path, list):\n        path_coords = [{'x': x, 'y': y} for x, y in path]\n        print(json.dumps(path_coords))\n    elif path is None:\n        print(json.dumps([{'error': 'path not found'}]))\n    else:\n        print(json.dumps([{'error': path}]))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps([{'error': str(e), 'traceback': traceback.format_exc()}]))",
    "history": [
      {
        "commit_message": "feat: Create new unified pathfinder 'gem_pathfinder'. This tool is a complete rewrite, consolidating all previously developed logic (ledges, surfing, spinners, elevation, ignorable objects) into a single, robust tool. It also introduces a critical new feature: if the target tile is impassable, it will find a path to the nearest reachable adjacent tile. This is a direct response to the persistent failures on Route 23 and the overwatch critique, representing a decisive action to restore core navigation capabilities.",
        "timestamp": "2025-07-23T11:15:27.975Z",
        "action_counter": 95191
      },
      {
        "commit_message": "fix: Remove faulty 'is_land_to_land' optimization. This check prevented the algorithm from exploring water tiles if the start and end points were both on land, causing it to fail on maps like Route 23 where surfing is a mandatory bridge between two land areas. Removing this allows the pathfinder to correctly find paths that require surfing.",
        "timestamp": "2025-07-23T11:17:26.254Z",
        "action_counter": 95194
      },
      {
        "commit_message": "feat: Add `cleared_boulder_barrier` as an elevation-traversable tile. My test on Victory Road 1F confirmed that these tiles, like 'steps', can connect areas of different elevations. This commit updates the pathfinder's logic to correctly handle this mechanic, preventing future navigation failures in similar puzzle areas.",
        "timestamp": "2025-07-23T13:03:56.183Z",
        "action_counter": 95391
      },
      {
        "commit_message": "fix: Overhaul ledge traversal logic. In response to an overwatch critique identifying persistent navigation failures, this commit refactors the neighbor generation logic. The new script explicitly identifies ledge tiles and only permits the one-way downward jump, treating them as impassable from all other directions (below and sides). This is a direct, high-priority fix to a core tool to prevent future pathing errors.",
        "timestamp": "2025-07-23T14:02:19.394Z",
        "action_counter": 95491
      },
      {
        "commit_message": "fix: Add 'grass' as a valid surf-starting tile. The tool was failing to find paths that required surfing from a grassy shoreline because it only considered 'ground' and 'steps' as valid starting points. This commit adds 'grass' to the list of valid tiles, resolving the critical navigation bug identified by the overwatch system and eliminating the need for inefficient workarounds.",
        "timestamp": "2025-07-23T14:31:35.773Z",
        "action_counter": 95524
      },
      {
        "commit_message": "fix: Correctly parse party_data JSON. The tool was failing because it was trying to operate on a JSON string directly instead of a parsed dictionary. This commit fixes the `find_path` function to correctly load the `party_data_str` into a dictionary using `json.loads()`, resolving the `AttributeError: 'list' object has no attribute 'get'`.",
        "timestamp": "2025-07-23T16:01:50.174Z",
        "action_counter": 95661
      },
      {
        "commit_message": "fix: Correctly parse party_data JSON. The tool was failing because it was trying to operate on a JSON string directly instead of a parsed dictionary. This commit fixes the `find_path` function to correctly load the `party_data_str` into a dictionary using `json.loads()` and then access the 'party' key, resolving the `AttributeError: 'str' object has no attribute 'get'`.",
        "timestamp": "2025-07-23T16:33:13.559Z",
        "action_counter": 95718
      },
      {
        "commit_message": "refactor: Add extensive debugging print statements. The pathfinder is failing to find routes that should be possible. This commit adds detailed logging to every step of the A* search—node expansion, neighbor evaluation, traversal checks, and scoring—to trace the execution flow and identify the specific point of failure in the logic.",
        "timestamp": "2025-07-23T16:34:24.176Z",
        "action_counter": 95720
      },
      {
        "commit_message": "fix: Refine elevation logic for cleared_boulder_barrier. The previous logic treated these tiles as two-way ramps, causing pathing failures. The new logic correctly models them as one-way ramps, only allowing upward movement from 'ground' to 'elevated_ground', which matches observed game mechanics and prevents the pathfinder from generating invalid routes.",
        "timestamp": "2025-07-23T18:03:38.928Z",
        "action_counter": 95888
      },
      {
        "commit_message": "fix: Restrict elevation change logic for cleared_boulder_barrier. The previous logic allowed moving from any adjacent ground tile onto a cleared barrier, which the game mechanics prohibit. This commit removes that special case, forcing the pathfinder to correctly use 'steps' tiles as the only means of changing elevation, which resolves the navigation failures on Victory Road 2F.",
        "timestamp": "2025-07-23T18:12:09.748Z",
        "action_counter": 95901
      },
      {
        "commit_message": "fix: Add explicit check to prevent pathing into 'impassable' tiles. The tool was generating invalid paths by routing through walls. This commit adds a hardcoded check at the start of the neighbor evaluation loop to immediately discard any neighbor with the type 'impassable', ensuring the algorithm only considers valid tiles. This is a critical fix to restore basic navigation functionality.",
        "timestamp": "2025-07-23T18:25:47.847Z",
        "action_counter": 95916
      },
      {
        "commit_message": "fix: Correctly parse party_data JSON. The tool was failing because it was trying to call the `.get()` method on a list object. The `party_data` input is a JSON array string, not a JSON object string containing a 'party' key. This commit changes the code to directly parse the JSON array into `party_list`, resolving the `AttributeError`.",
        "timestamp": "2025-07-23T19:19:33.930Z",
        "action_counter": 96002
      },
      {
        "commit_message": "fix: Add explicit check to prevent pathing into 'impassable' tiles. The tool was generating invalid paths by routing through walls. This commit adds a hardcoded check at the start of the neighbor evaluation loop to immediately discard any neighbor with the type 'impassable', ensuring the algorithm only considers valid tiles. This is a critical fix to restore basic navigation functionality.",
        "timestamp": "2025-07-23T22:27:06.927Z",
        "action_counter": 96324
      },
      {
        "commit_message": "fix: Prevent land-to-water pathing for land-based targets. The tool was generating invalid paths by allowing transitions from land to water even when the final destination was on land. This commit adds a check to only permit land-to-water transitions if the target is not on a land tile, preventing the tool from creating routes that require unnecessary surfing.",
        "timestamp": "2025-07-23T23:53:09.673Z",
        "action_counter": 96478
      },
      {
        "commit_message": "fix: Revert faulty land-to-water pathing restriction. The previous commit prevented the tool from finding paths that required crossing water to connect two landmasses, such as on Route 23. This commit removes the `is_target_on_land` check, restoring the tool's ability to correctly explore all valid surf transitions and find the optimal path.",
        "timestamp": "2025-07-24T00:02:46.644Z",
        "action_counter": 96492
      },
      {
        "commit_message": "fix: Correct SURF check logic. The previous version incorrectly tried to call `.get('name')` on move strings, causing a crash. This commit changes the check to a simple string comparison (`move == 'SURF'`), which correctly identifies the move and restores the tool's pathfinding functionality for water routes.",
        "timestamp": "2025-07-24T00:24:38.681Z",
        "action_counter": 96525
      },
      {
        "commit_message": "refactor: Add extensive debugging print statements. The pathfinder is failing to find routes that should be possible, specifically on Victory Road 1F. This commit adds detailed logging to every step of the A* search—node expansion, neighbor evaluation, traversal checks, and scoring—to trace the execution flow and identify the specific point of failure in the logic.",
        "timestamp": "2025-07-24T00:31:20.468Z",
        "action_counter": 96537
      },
      {
        "commit_message": "fix: Add 'boulder_switch' to the list of traversable tiles. The pathfinder was incorrectly treating boulder switches as impassable, causing it to fail to find valid paths in puzzle areas like Victory Road. This critical fix adds 'boulder_switch' to the `traversable_walking` list, restoring the tool's ability to navigate these areas correctly.",
        "timestamp": "2025-07-24T00:36:31.135Z",
        "action_counter": 96547
      }
    ]
  },
  "boulder_puzzle_solver": {
    "description": "Solves boulder puzzles by finding a sequence of player movements and boulder pushes. It takes the start coordinates of the player, boulder, and the target switch, and returns a list of moves. This version correctly handles player position after a push and allows specifying ignorable coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "boulder_x": {
          "type": "string"
        },
        "boulder_y": {
          "type": "string"
        },
        "switch_x": {
          "type": "string"
        },
        "switch_y": {
          "type": "string"
        },
        "ignorable_coords": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "boulder_x",
        "boulder_y",
        "switch_x",
        "switch_y"
      ]
    },
    "python_script": "# injected imports [\"sys\", \"json\"]\n# injected variables [\"map_xml_string\", \"input_data\"]\n\nimport xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef solve_boulder_puzzle(map_xml_string, boulder_x, boulder_y, switch_x, switch_y, ignorable_coords_str=None):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = [['' for _ in range(width + 1)] for _ in range(height + 1)]\n    elevations = [[0 for _ in range(width + 1)] for _ in range(height + 1)]\n    objects = set()\n    player_x, player_y = -1, -1\n\n    ignorable_coords = set()\n    if ignorable_coords_str:\n        try:\n            coords_list = json.loads(ignorable_coords_str)\n            for item in coords_list:\n                ignorable_coords.add(tuple(item))\n        except (json.JSONDecodeError, TypeError):\n            pass # Ignore if parsing fails\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            grid[y][x] = tile_type\n\n            if tile_elem.get('has-player') == 'true':\n                player_x, player_y = x, y\n\n            if tile_type in ['elevated_ground', 'cleared_boulder_barrier']:\n                elevations[y][x] = 1\n\n            if (x, y) in ignorable_coords:\n                continue\n\n            if tile_elem.find('Object') is not None or tile_elem.find('Boulder') is not None:\n                obj_elem = tile_elem.find('Object')\n                boulder_elem = tile_elem.find('Boulder')\n                if (obj_elem is not None and obj_elem.get('id-name') != 'Pikachu') or boulder_elem is not None:\n                    if not (x == boulder_x and y == boulder_y):\n                        objects.add((x, y))\n\n    traversable_tiles = ['ground', 'grass', 'steps', 'cleared_boulder_barrier', 'hole', 'spinner_stop', 'open_gate', 'gate_offscreen', 'elevated_ground', 'ladder_up', 'ladder_down', 'boulder_switch']\n\n    def is_valid(x, y, boulder_pos, current_pos=None):\n        if not (1 <= x <= width and 1 <= y <= height):\n            return False, 'bounds'\n        if grid[y][x] not in traversable_tiles:\n            return False, f'type:{grid[y][x]}'\n        if (x, y) in objects:\n            return False, 'object'\n        if boulder_pos and (x, y) == boulder_pos:\n            return False, 'boulder'\n        \n        if current_pos:\n            cx, cy = current_pos\n            current_elevation = elevations[cy][cx]\n            neighbor_elevation = elevations[y][x]\n            current_tile_type = grid[cy][cx]\n            neighbor_tile_type = grid[y][x]\n            \n            can_traverse_elevation = False\n            if current_elevation == neighbor_elevation:\n                can_traverse_elevation = True\n            elif 'steps' in (current_tile_type, neighbor_tile_type):\n                can_traverse_elevation = True\n            elif current_elevation == 0 and neighbor_elevation == 1 and neighbor_tile_type == 'cleared_boulder_barrier':\n                can_traverse_elevation = True\n            \n            if not can_traverse_elevation:\n                return False, f'elev:{current_elevation}->{neighbor_elevation}'\n\n        return True, 'valid'\n\n    def find_path_to_push_spot(start_pos, boulder_pos, push_spot):\n        q = deque([(start_pos, [])])\n        visited = {start_pos}\n        while q:\n            (cx, cy), path = q.popleft()\n            if (cx, cy) == push_spot:\n                return path + [(cx, cy)]\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = cx + dx, cy + dy\n                valid, reason = is_valid(nx, ny, boulder_pos, current_pos=(cx,cy))\n                if valid and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    q.append(((nx, ny), path + [(cx, cy)]))\n        return None\n\n    start_state = ((player_x, player_y), (boulder_x, boulder_y))\n    queue = deque([(start_state, [])])\n    visited_states = {start_state}\n\n    while queue:\n        (current_player_pos, current_boulder_pos), path = queue.popleft()\n\n        if current_boulder_pos == (switch_x, switch_y):\n            return path\n\n        bx, by = current_boulder_pos\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            push_spot = (bx - dx, by - dy)\n            new_boulder_pos = (bx + dx, by + dy)\n\n            valid_boulder_dest, _ = is_valid(new_boulder_pos[0], new_boulder_pos[1], None)\n            if not valid_boulder_dest:\n                continue\n\n            player_path = find_path_to_push_spot(current_player_pos, current_boulder_pos, push_spot)\n            if player_path:\n                new_player_pos = push_spot\n                new_state = (new_player_pos, new_boulder_pos)\n                if new_state not in visited_states:\n                    visited_states.add(new_state)\n                    new_path_segment = [{'type': 'move', 'path': player_path[1:]}, {'type': 'push', 'direction': (dx, dy)}]\n                    queue.append((new_state, path + new_path_segment))\n    \n    return None\n\ntry:\n    ignorable_coords_str = input_data.get('ignorable_coords')\n    solution = solve_boulder_puzzle(\n        map_xml_string, \n        int(input_data['boulder_x']), \n        int(input_data['boulder_y']), \n        int(input_data['switch_x']), \n        int(input_data['switch_y']),\n        ignorable_coords_str\n    )\n    if solution:\n        print(json.dumps(solution))\n    else:\n        print(json.dumps([{'error': 'No solution found for the boulder puzzle.'}]))\nexcept Exception as e:\n    import traceback\n    print(json.dumps([{'error': str(e), 'traceback': traceback.format_exc()}]))",
    "history": [
      {
        "commit_message": "feat: Create boulder_puzzle_solver tool. This tool uses a breadth-first search algorithm to find the optimal sequence of player movements and boulder pushes to solve puzzles. The state in the search space is defined by the player's and boulder's positions. This is a proactive measure to handle the complex boulder puzzle in Victory Road efficiently, avoiding error-prone manual planning.",
        "timestamp": "2025-07-23T11:44:20.841Z",
        "action_counter": 95239
      },
      {
        "commit_message": "fix: Correct player position tracking after a push. The previous version incorrectly assumed the player stayed at the push spot. The player actually moves into the tile the boulder just vacated. This commit updates the new player state to be the boulder's old position, ensuring accurate path generation for multi-step puzzles.",
        "timestamp": "2025-07-23T12:01:10.463Z",
        "action_counter": 95271
      },
      {
        "commit_message": "fix: Revert player position tracking logic. The player does NOT move into the boulder's old space after a push; they remain at the push spot. The previous 'fix' was based on a faulty assumption about game mechanics. This commit restores the original, correct logic where the player's new state is the spot they pushed from.",
        "timestamp": "2025-07-23T12:11:15.162Z",
        "action_counter": 95293
      },
      {
        "commit_message": "fix: Correct typo in variable name 'new_boulder_pos'. The tool was crashing due to a NameError. This commit fixes the typo, allowing the tool to correctly add new states to the search queue.",
        "timestamp": "2025-07-23T12:12:15.186Z",
        "action_counter": 95295
      },
      {
        "commit_message": "fix: Correct typo in variable name 'new_boulder_pos'. The tool was crashing due to a NameError. This commit fixes the typo, allowing the tool to correctly add new states to the search queue.",
        "timestamp": "2025-07-23T12:15:37.720Z",
        "action_counter": 95300
      },
      {
        "commit_message": "fix: Correct typo in variable name 'current_boulder_pos'. The tool was crashing due to a NameError because of a typo (`current_bolder_pos`). This commit fixes the variable name, allowing the tool to correctly check the win condition.",
        "timestamp": "2025-07-23T12:16:29.349Z",
        "action_counter": 95301
      },
      {
        "commit_message": "fix: Add elevation checking to internal pathfinder. The tool's pathing sub-function was generating invalid routes by ignoring elevation changes. This commit integrates the same elevation logic from the main `gem_pathfinder` tool, ensuring it only generates paths that correctly handle steps and one-way ramps, thus preventing future navigation failures during puzzle solving.",
        "timestamp": "2025-07-23T18:07:59.646Z",
        "action_counter": 95896
      },
      {
        "commit_message": "fix: Add extensive debugging print statements. The tool is failing to solve a puzzle that appears solvable. This commit adds detailed logging to the internal pathfinder and the main search loop to trace the execution and identify why it's failing to find a valid path for the player or the boulder.",
        "timestamp": "2025-07-23T20:36:14.952Z",
        "action_counter": 96134
      },
      {
        "commit_message": "fix: Add extensive debugging print statements. The tool is failing to solve a puzzle that appears solvable. This commit adds detailed logging to the internal pathfinder and the main search loop to trace the execution and identify why it's failing to find a valid path for the player or the boulder.",
        "timestamp": "2025-07-23T23:00:36.369Z",
        "action_counter": 96381
      },
      {
        "commit_message": "refactor: Make debug output more concise. The previous debug implementation was too verbose, causing the output to be truncated and hiding the root cause of pathing failures. This commit streamlines the logging to focus only on the reason for invalid moves, which will make it possible to diagnose the core issue in the tool's internal pathfinder.",
        "timestamp": "2025-07-23T23:02:43.942Z",
        "action_counter": 96384
      },
      {
        "commit_message": "refactor: Make debug output more concise. The previous debug implementation was too verbose, causing the output to be truncated and hiding the root cause of pathing failures. This commit streamlines the logging to focus only on the reason for invalid moves, which will make it possible to diagnose the core issue in the tool's internal pathfinder.",
        "timestamp": "2025-07-23T23:03:36.353Z",
        "action_counter": 96385
      },
      {
        "commit_message": "refactor: Make debug output more concise. The previous debug implementation was too verbose, causing the output to be truncated and hiding the root cause of pathing failures. This commit streamlines the logging to focus only on the reason for invalid moves, which will make it possible to diagnose the core issue in the tool's internal pathfinder.",
        "timestamp": "2025-07-23T23:04:54.482Z",
        "action_counter": 96387
      },
      {
        "commit_message": "feat: Add `ignorable_coords` parameter to handle defeated trainers. The previous version treated all NPCs as impassable, causing pathing failures. This update allows specifying a list of coordinates to ignore when building the set of impassable objects, enabling the solver to correctly find paths through areas with defeated trainers.",
        "timestamp": "2025-07-24T00:22:23.752Z",
        "action_counter": 96522
      }
    ]
  },
  "brute_force_explorer": {
    "description": "Systematically explores all reachable ground tiles in the current map area. For each reachable tile, it generates a path to it and then interacts with all four adjacent directions (north, south, east, west) to test for hidden mechanics. This is for use in confirmed dead-end areas where standard progression has failed. Returns a JSON list of button presses.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "start_facing": {
          "type": "string",
          "enum": [
            "up",
            "down",
            "left",
            "right"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "start_facing"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef find_path_bfs(grid, objects, start, end):\n    queue = deque([(start, [])])\n    visited = {start}\n    width = len(grid[0]) - 1\n    height = len(grid) - 1\n    while queue:\n        (x, y), path = queue.popleft()\n        if (x, y) == end:\n            return path\n        for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = x + dx, y + dy\n            if 1 <= nx <= width and 1 <= ny <= height and grid[ny][nx] == 'ground' and (nx, ny) not in objects and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                new_path = list(path)\n                new_path.append(move)\n                queue.append(((nx, ny), new_path))\n    return None\n\ndef get_turn_moves(current_facing, target_direction):\n    if current_facing == target_direction: return []\n    if current_facing == 'up':\n        return {'down': ['Down', 'Down'], 'left': ['Left'], 'right': ['Right']}[target_direction]\n    if current_facing == 'down':\n        return {'up': ['Up', 'Up'], 'left': ['Right'], 'right': ['Left']}[target_direction]\n    if current_facing == 'left':\n        return {'up': ['Right'], 'down': ['Left'], 'right': ['Right', 'Right']}[target_direction]\n    if current_facing == 'right':\n        return {'up': ['Left'], 'down': ['Right'], 'left': ['Left', 'Left']}[target_direction]\n    return []\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\ngrid = [['' for _ in range(width + 1)] for _ in range(height + 1)]\nobjects = set()\n\nfor r in root.findall('Row'):\n    y = int(r.get('id'))\n    for t in r.findall('Tile'):\n        x = int(t.get('id'))\n        grid[y][x] = t.get('type')\n        if (t.find('Object') is not None and t.find('Object').get('id-name') != 'Pikachu') or t.find('Boulder') is not None:\n            objects.add((x, y))\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\ncurrent_facing = input_data['start_facing']\n\nreachable_q = deque([(start_x, start_y)])\nreachable_visited = {(start_x, start_y)}\n\nwhile reachable_q:\n    x, y = reachable_q.popleft()\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n        nx, ny = x + dx, y + dy\n        if 1 <= nx <= width and 1 <= ny <= height and grid[ny][nx] == 'ground' and (nx, ny) not in objects and (nx, ny) not in reachable_visited:\n            reachable_visited.add((nx, ny))\n            reachable_q.append((nx, ny))\n\nreachable_tiles = sorted(list(reachable_visited), key=lambda p: (p[1], p[0]))\n\nfull_sequence = []\ncurrent_pos = (start_x, start_y)\n\nfor tile in reachable_tiles:\n    path_to_tile = find_path_bfs(grid, objects, current_pos, tile)\n    if path_to_tile is not None:\n        full_sequence.extend(path_to_tile)\n        if path_to_tile:\n            last_move = path_to_tile[-1]\n            if last_move == 'Up': current_facing = 'up'\n            elif last_move == 'Down': current_facing = 'down'\n            elif last_move == 'Left': current_facing = 'left'\n            elif last_move == 'Right': current_facing = 'right'\n        current_pos = tile\n\n    for direction in ['up', 'down', 'left', 'right']:\n        turn_moves = get_turn_moves(current_facing, direction)\n        full_sequence.extend(turn_moves)\n        full_sequence.append('A')\n        current_facing = direction\n\nprint(json.dumps(full_sequence))",
    "history": [
      {
        "commit_message": "feat: Create brute_force_explorer tool. This tool automates the process of systematically exploring a dead-end area by visiting every reachable tile and interacting with all four adjacent walls. This was created in response to an Overwatch critique pointing out the inefficiency of performing this task manually. This tool will significantly speed up the process of testing for hidden mechanics in the current Victory Road puzzle area.",
        "timestamp": "2025-07-24T02:22:42.246Z",
        "action_counter": 96721
      },
      {
        "commit_message": "fix: Add Boulders to obstacle list. The tool's internal pathfinder was not treating boulders as impassable objects, causing it to generate invalid paths that ran directly into them. This commit adds a check for `<Boulder>` tags when populating the `objects` set, ensuring boulders are correctly identified as obstacles and restoring the tool's ability to navigate puzzle areas.",
        "timestamp": "2025-07-24T02:29:53.922Z",
        "action_counter": 96732
      }
    ]
  }
}