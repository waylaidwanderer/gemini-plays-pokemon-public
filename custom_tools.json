{
  "maze_explorer_v5": {
    "description": "Finds the shortest path to the nearest *reachable* unseen tile. Iterates through all unseen tiles, finds paths to them, and returns the shortest valid path. This correctly handles disconnected map sections.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "impassable_coordinates": {
          "type": "string",
          "description": "A JSON string of a list of [x, y] coordinates to treat as impassable."
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef find_path_bfs(grid, start, end, all_impassable):\n    impassable_types = {\n        'WALL', 'VOID', 'WATER', 'CUT_TREE', 'COUNTER', 'BUOY', 'HEADBUTT_TREE',\n        'MART_SHELF', 'BOOKSHELF', 'TV', 'RADIO', 'PC', 'TOWN_MAP', 'WINDOW', 'PAINTING', 'STATUE', 'PILLAR',\n        'BED', 'TABLE', 'CHAIR', 'unseen'\n    }\n\n    if start not in grid or end not in grid:\n        return None\n\n    if grid.get(start, {}).get('type') in impassable_types or start in all_impassable:\n        return None\n\n    queue = deque([(start, [start])])\n    visited = {start}\n\n    while queue:\n        (current_pos, path) = queue.popleft()\n\n        if current_pos == end:\n            return path\n\n        current_type = grid.get(current_pos, {}).get('type')\n\n        for move_x, move_y, move_name in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            next_pos = (current_pos[0] + move_x, current_pos[1] + move_y)\n\n            if next_pos in visited or next_pos not in grid:\n                continue\n\n            next_type = grid.get(next_pos, {}).get('type')\n\n            if next_type in impassable_types:\n                continue\n            if next_pos in all_impassable and next_pos != end:\n                continue\n            \n            if current_type == 'LEDGE_HOP_DOWN' and move_name != 'Down': continue\n            if current_type == 'LEDGE_HOP_LEFT' and move_name != 'Left': continue\n            if current_type == 'LEDGE_HOP_RIGHT' and move_name != 'Right': continue\n            if next_type == 'LEDGE_HOP_DOWN' and move_name == 'Up': continue\n            if next_type == 'LEDGE_HOP_LEFT' and move_name == 'Right': continue\n            if next_type == 'LEDGE_HOP_RIGHT' and move_name == 'Left': continue\n            if current_type == 'FLOOR_UP_WALL' and move_name in ['Up', 'Down']: continue\n            if next_type == 'FLOOR_UP_WALL' and move_name != 'Up': continue\n\n            visited.add(next_pos)\n            new_path = list(path)\n            new_path.append(next_pos)\n            queue.append((next_pos, new_path))\n\n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    impassable_str = input_data.get('impassable_coordinates', '[]')\n    extra_impassable_coords = json.loads(impassable_str)\n    extra_impassable = {tuple(map(int, coord)) for coord in extra_impassable_coords}\n\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    unseen_tiles = []\n    map_objects_impassable = set()\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            grid[(x, y)] = {'type': tile_type}\n            if tile_type == 'unseen':\n                unseen_tiles.append((x, y))\n            if tile_elem.find('Object') is not None:\n                map_objects_impassable.add((x,y))\n    \n    all_impassable = map_objects_impassable.union(extra_impassable)\n\n    shortest_path = None\n\n    for unseen_x, unseen_y in unseen_tiles:\n        # Find path to an adjacent, traversable tile\n        for move_x, move_y in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            target_x, target_y = unseen_x + move_x, unseen_y + move_y\n            if grid.get((target_x, target_y), {}).get('type') not in ['unseen', 'WALL', 'VOID']:\n                path = find_path_bfs(grid, (start_x, start_y), (target_x, target_y), all_impassable)\n                if path:\n                    if shortest_path is None or len(path) < len(shortest_path):\n                        shortest_path = path\n\n    if shortest_path:\n        path_coords = [[p[0], p[1]] for p in shortest_path]\n        print(json.dumps({'path': path_coords, 'error': None}))\n    else:\n        print(json.dumps({'path': [], 'error': 'No reachable unseen tiles found.'}))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'path': [], 'error': f'An exception occurred: {str(e)}\\n{traceback.format_exc()}'}))"
  },
  "maze_explorer_v6": {
    "description": "Finds the shortest path to the nearest *reachable* unseen tile. Iterates through all unseen tiles, finds paths to them, and returns the shortest valid path. This correctly handles disconnected map sections.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "impassable_coordinates": {
          "type": "string",
          "description": "A JSON string of a list of [x, y] coordinates to treat as impassable."
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef find_path_bfs(grid, start, end, all_impassable):\n    impassable_types = {\n        'WALL', 'VOID', 'WATER', 'CUT_TREE', 'COUNTER', 'BUOY', 'HEADBUTT_TREE',\n        'MART_SHELF', 'BOOKSHELF', 'TV', 'RADIO', 'PC', 'TOWN_MAP', 'WINDOW', 'PAINTING', 'STATUE', 'PILLAR',\n        'BED', 'TABLE', 'CHAIR', 'unseen'\n    }\n\n    if start not in grid or end not in grid:\n        return None\n\n    if grid.get(start, {}).get('type') in impassable_types or start in all_impassable:\n        return None\n\n    queue = deque([(start, [start])])\n    visited = {start}\n\n    while queue:\n        (current_pos, path) = queue.popleft()\n\n        if current_pos == end:\n            return path\n\n        current_type = grid.get(current_pos, {}).get('type')\n\n        for move_x, move_y, move_name in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            next_pos = (current_pos[0] + move_x, current_pos[1] + move_y)\n\n            if next_pos in visited or next_pos not in grid:\n                continue\n\n            next_type = grid.get(next_pos, {}).get('type')\n\n            if next_type in impassable_types:\n                continue\n            if next_pos in all_impassable and next_pos != end:\n                continue\n            \n            if current_type == 'LEDGE_HOP_DOWN' and move_name != 'Down': continue\n            if current_type == 'LEDGE_HOP_LEFT' and move_name != 'Left': continue\n            if current_type == 'LEDGE_HOP_RIGHT' and move_name != 'Right': continue\n            if next_type == 'LEDGE_HOP_DOWN' and move_name == 'Up': continue\n            if next_type == 'LEDGE_HOP_LEFT' and move_name == 'Right': continue\n            if next_type == 'LEDGE_HOP_RIGHT' and move_name == 'Left': continue\n            if current_type == 'FLOOR_UP_WALL' and move_name in ['Up', 'Down']: continue\n            if next_type == 'FLOOR_UP_WALL' and move_name != 'Up': continue\n\n            visited.add(next_pos)\n            new_path = list(path)\n            new_path.append(next_pos)\n            queue.append((next_pos, new_path))\n\n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    impassable_str = input_data.get('impassable_coordinates', '[]')\n    extra_impassable_coords = json.loads(impassable_str)\n    extra_impassable = {tuple(map(int, coord)) for coord in extra_impassable_coords}\n\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    unseen_tiles = []\n    map_objects_impassable = set()\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            grid[(x, y)] = {'type': tile_type}\n            if tile_type == 'unseen':\n                unseen_tiles.append((x, y))\n            if tile_elem.find('Object') is not None:\n                map_objects_impassable.add((x,y))\n    \n    all_impassable = map_objects_impassable.union(extra_impassable)\n\n    shortest_path = None\n\n    # Find all valid paths to unseen tiles\n    all_paths = []\n    for unseen_x, unseen_y in unseen_tiles:\n        # Find path to an adjacent, traversable tile\n        for move_x, move_y in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            target_x, target_y = unseen_x + move_x, unseen_y + move_y\n            if grid.get((target_x, target_y), {}).get('type') not in ['unseen', 'WALL', 'VOID']:\n                path = find_path_bfs(grid, (start_x, start_y), (target_x, target_y), all_impassable)\n                if path:\n                    all_paths.append(path)\n\n    # Find the shortest path among all valid paths\n    if all_paths:\n        shortest_path = min(all_paths, key=len)\n\n    if shortest_path:\n        path_coords = [[p[0], p[1]] for p in shortest_path]\n        print(json.dumps({'path': path_coords, 'error': None}))\n    else:\n        print(json.dumps({'path': [], 'error': 'No reachable unseen tiles found.'}))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'path': [], 'error': f'An exception occurred: {str(e)}\\n{traceback.format_exc()}'}))"
  },
  "object_finder": {
    "description": "Finds a specific map object by its ID and returns its coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "object_id": {
          "type": "string"
        }
      },
      "required": [
        "object_id"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntarget_id = input_data['object_id']\nroot = ET.fromstring(map_xml_string)\nfound = False\nfor row in root.findall('Row'):\n    y = row.get('id')\n    for tile in row.findall('Tile'):\n        x = tile.get('id')\n        for obj in tile.findall('Object'):\n            if obj.get('id') == target_id:\n                print(json.dumps({'x': x, 'y': y}))\n                found = True\n                break\n        if found:\n            break\n    if found:\n        break\n\nif not found:\n    print(json.dumps({'error': 'Object not found on screen.'}))"
  },
  "path_master_v24": {
    "description": "A robust pathfinding tool using Breadth-First Search (BFS). This version correctly treats all map objects, including defeated trainers, as impassable.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "extra_impassable_coordinates": {
          "type": "string",
          "description": "A JSON string of a list of additional [x, y] coordinates to treat as impassable."
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef find_path_bfs(grid, start, end, all_impassable):\n    impassable_base = {\n        'WALL', 'VOID', 'WATER', 'CUT_TREE', 'COUNTER', 'BUOY', 'HEADBUTT_TREE', 'unseen',\n        'MART_SHELF', 'BOOKSHELF', 'TV', 'RADIO', 'PC', 'TOWN_MAP', 'WINDOW', 'PAINTING', 'STATUE', 'PILLAR',\n        'BED', 'TABLE', 'CHAIR'\n    }\n\n    if start not in grid or end not in grid:\n        return [], 'Start or end position not in grid.'\n\n    if grid.get(start, {}).get('type') in impassable_base or start in all_impassable:\n        return [], 'Start position is impassable.'\n\n    queue = deque([(start, [start])])\n    visited = {start}\n\n    while queue:\n        (current_pos, path) = queue.popleft()\n\n        if current_pos == end:\n            return path, None\n\n        current_type = grid.get(current_pos, {}).get('type')\n\n        for move_x, move_y, move_name in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            next_pos = (current_pos[0] + move_x, current_pos[1] + move_y)\n\n            if next_pos in visited or next_pos not in grid:\n                continue\n\n            next_type = grid.get(next_pos, {}).get('type')\n\n            if next_type in impassable_base:\n                continue\n            if next_pos in all_impassable and next_pos != end:\n                continue\n            \n            if current_type == 'LEDGE_HOP_DOWN' and move_name != 'Down': continue\n            if current_type == 'LEDGE_HOP_LEFT' and move_name != 'Left': continue\n            if current_type == 'LEDGE_HOP_RIGHT' and move_name != 'Right': continue\n            if next_type == 'LEDGE_HOP_DOWN' and move_name == 'Up': continue\n            if next_type == 'LEDGE_HOP_LEFT' and move_name == 'Right': continue\n            if next_type == 'LEDGE_HOP_RIGHT' and move_name == 'Left': continue\n            if current_type == 'FLOOR_UP_WALL' and move_name in ['Up', 'Down']: continue\n            if next_type == 'FLOOR_UP_WALL' and move_name != 'Up': continue\n\n            visited.add(next_pos)\n            new_path = list(path)\n            new_path.append(next_pos)\n            queue.append((next_pos, new_path))\n\n    return [], 'No path found to destination.'\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    \n    extra_impassable_str = input_data.get('extra_impassable_coordinates')\n    loaded_extra = json.loads(extra_impassable_str) if extra_impassable_str else []\n    extra_impassable = {tuple(map(int, coord)) for coord in loaded_extra} if loaded_extra else set()\n\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    map_objects_impassable = set()\n\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            grid[(x, y)] = {'type': tile.get('type')}\n            if tile.find('Object') is not None:\n                map_objects_impassable.add((x,y))\n\n    all_impassable = map_objects_impassable.union(extra_impassable)\n\n    path, error = find_path_bfs(grid, (start_x, start_y), (end_x, end_y), all_impassable)\n    path_coords = [[p[0], p[1]] for p in path]\n    \n    print(json.dumps({'path': path_coords, 'error': error}))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'path': [], 'error': f'An exception occurred: {str(e)}\\n{traceback.format_exc()}'}))"
  },
  "path_master_v27": {
    "description": "A robust pathfinding tool using Breadth-First Search (BFS). This version correctly treats all map objects, including defeated trainers, as impassable and includes debugging prints.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "extra_impassable_coordinates": {
          "type": "string",
          "description": "A JSON string of a list of additional [x, y] coordinates to treat as impassable."
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef find_path_bfs(grid, start, end, all_impassable):\n    impassable_base = {\n        'WALL', 'VOID', 'WATER', 'CUT_TREE', 'COUNTER', 'BUOY', 'HEADBUTT_TREE', 'unseen',\n        'MART_SHELF', 'BOOKSHELF', 'TV', 'RADIO', 'PC', 'TOWN_MAP', 'WINDOW', 'PAINTING', 'STATUE', 'PILLAR',\n        'BED', 'TABLE', 'CHAIR', 'PIPE_HORIZONTAL', 'PIPE_VERTICAL'\n    }\n\n    if start not in grid or end not in grid:\n        return [], f'Start {start} or end {end} position not in grid.'\n\n    if grid.get(start, {}).get('type') in impassable_base or start in all_impassable:\n        return [], f'Start position {start} is impassable.'\n\n    queue = deque([(start, [start])])\n    visited = {start}\n\n    while queue:\n        (current_pos, path) = queue.popleft()\n\n        if current_pos == end:\n            return path, None\n\n        current_type = grid.get(current_pos, {}).get('type')\n\n        for move_x, move_y, move_name in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            next_pos = (current_pos[0] + move_x, current_pos[1] + move_y)\n\n            if next_pos in visited or next_pos not in grid:\n                continue\n\n            next_type = grid.get(next_pos, {}).get('type')\n\n            if next_type in impassable_base:\n                continue\n            if next_pos in all_impassable and next_pos != end:\n                continue\n            \n            if current_type == 'LEDGE_HOP_DOWN' and move_name != 'Down': continue\n            if current_type == 'LEDGE_HOP_LEFT' and move_name != 'Left': continue\n            if current_type == 'LEDGE_HOP_RIGHT' and move_name != 'Right': continue\n            if next_type == 'LEDGE_HOP_DOWN' and move_name == 'Up': continue\n            if next_type == 'LEDGE_HOP_LEFT' and move_name == 'Right': continue\n            if next_type == 'LEDGE_HOP_RIGHT' and move_name == 'Left': continue\n            if current_type == 'FLOOR_UP_WALL' and move_name in ['Up', 'Down']: continue\n            if next_type == 'FLOOR_UP_WALL' and move_name != 'Up': continue\n\n            visited.add(next_pos)\n            new_path = list(path)\n            new_path.append(next_pos)\n            queue.append((next_pos, new_path))\n\n    return [], 'No path found to destination.'\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    \n    extra_impassable_str = input_data.get('extra_impassable_coordinates')\n    loaded_extra = json.loads(extra_impassable_str) if extra_impassable_str else []\n    extra_impassable = {tuple(map(int, coord)) for coord in loaded_extra} if loaded_extra else set()\n\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    map_objects_impassable = set()\n\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            grid[(x, y)] = {'type': tile.get('type')}\n            if tile.find('Object') is not None:\n                map_objects_impassable.add((x,y))\n\n    all_impassable = map_objects_impassable.union(extra_impassable)\n\n    path, error = find_path_bfs(grid, (start_x, start_y), (end_x, end_y), all_impassable)\n    path_coords = [[p[0], p[1]] for p in path]\n    \n    print(json.dumps({'path': path_coords, 'error': error}))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'path': [], 'error': f'An exception occurred: {str(e)}\\n{traceback.format_exc()}'}))"
  }
}