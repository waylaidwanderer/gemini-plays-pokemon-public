{
  "find_path_bfs": {
    "description": "Finds a path from the player's current position to a target coordinate using Breadth-First Search (BFS). It correctly handles one-way ledges and other obstacles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef parse_map(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    tiles = {}\n    player_pos = None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tiles[(x, y)] = tile\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n    return tiles, player_pos, width, height\n\ndef is_obstacle(tile):\n    if tile is None: return True\n    tile_type = tile.attrib['type']\n    return tile_type in ['WALL', 'HEADBUTT_TREE', 'VOID', 'CUT_TREE', 'COUNTER'] or tile.find('Object') is not None\n\ndef bfs_search(tiles, start, goal, width, height):\n    neighbors = [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]\n\n    if is_obstacle(tiles.get(goal)):\n        potential_goals = []\n        for dx, dy, move in neighbors:\n            adj_tile_coord = (goal[0] + dx, goal[1] + dy)\n            if not is_obstacle(tiles.get(adj_tile_coord)):\n                potential_goals.append(adj_tile_coord)\n        if not potential_goals:\n            return None\n        goal = potential_goals[0]\n\n    queue = deque([[start]])\n    visited = {start}\n\n    while queue:\n        path = queue.popleft()\n        node = path[-1]\n\n        if node == goal:\n            return path\n\n        for i, j, move_dir in neighbors:\n            neighbor_coord = (node[0] + i, node[1] + j)\n            \n            if not (1 <= neighbor_coord[0] <= width and 1 <= neighbor_coord[1] <= height):\n                continue\n\n            if neighbor_coord in visited:\n                continue\n            \n            neighbor_tile = tiles.get(neighbor_coord)\n\n            if is_obstacle(neighbor_tile):\n                continue\n            \n            neighbor_tile_type = neighbor_tile.attrib.get('type')\n\n            if neighbor_tile_type == 'LEDGE_HOP_DOWN' and move_dir != 'Down':\n                continue\n            if neighbor_tile_type == 'LEDGE_HOP_RIGHT' and move_dir != 'Right':\n                continue\n            if neighbor_tile_type == 'LEDGE_HOP_LEFT' and move_dir != 'Left':\n                continue\n\n            new_path = list(path)\n            new_path.append(neighbor_coord)\n            queue.append(new_path)\n            visited.add(neighbor_coord)\n            \n    return None\n\ntry:\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    tiles, player_pos, map_width, map_height = parse_map(map_xml_string)\n    if player_pos:\n        path = bfs_search(tiles, player_pos, (target_x, target_y), map_width, map_height)\n        if path:\n            path_coords = [{'x': p[0], 'y': p[1]} for p in path]\n            print(json.dumps(path_coords))\n        else:\n            print(json.dumps([]))\n    else:\n        print(json.dumps([]))\nexcept Exception as e:\n    import traceback\n    print(f'An error occurred: {e}\\n{traceback.format_exc()}')"
  },
  "find_reachable_unseen_tiles": {
    "description": "Parses the map to find all unseen tiles that are adjacent to walkable tiles and then uses BFS to determine which of them are reachable from the player's current position.",
    "input_schema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef parse_map(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    tiles = {}\n    player_pos = None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tiles[(x, y)] = tile\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n    return tiles, player_pos, width, height\n\ndef is_obstacle(tile):\n    if tile is None: return True\n    tile_type = tile.attrib['type']\n    return tile_type in ['WALL', 'HEADBUTT_TREE', 'VOID', 'CUT_TREE'] or tile.find('Object') is not None\n\ndef bfs_find_all_reachable(tiles, start, width, height):\n    queue = deque([start])\n    visited = {start}\n    reachable = set()\n    neighbors = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    while queue:\n        node = queue.popleft()\n        reachable.add(node)\n\n        for dx, dy in neighbors:\n            neighbor_coord = (node[0] + dx, node[1] + dy)\n            if not (1 <= neighbor_coord[0] <= width and 1 <= neighbor_coord[1] <= height):\n                continue\n            if neighbor_coord in visited:\n                continue\n            \n            neighbor_tile = tiles.get(neighbor_coord)\n            if is_obstacle(neighbor_tile):\n                continue\n\n            # Ledge logic\n            move_dir = ''\n            if dy == 1: move_dir = 'Down'\n            elif dy == -1: move_dir = 'Up'\n            elif dx == 1: move_dir = 'Right'\n            elif dx == -1: move_dir = 'Left'\n\n            current_tile_type = tiles.get(node).attrib.get('type')\n            neighbor_tile_type = neighbor_tile.attrib.get('type')\n\n            if move_dir == 'Up' and neighbor_tile_type == 'LEDGE_HOP_DOWN': continue\n            if move_dir == 'Right' and neighbor_tile_type == 'LEDGE_HOP_LEFT': continue\n            if move_dir == 'Left' and neighbor_tile_type == 'LEDGE_HOP_RIGHT': continue\n\n            visited.add(neighbor_coord)\n            queue.append(neighbor_coord)\n    return reachable\n\ntry:\n    tiles, player_pos, map_width, map_height = parse_map(map_xml_string)\n    if player_pos:\n        reachable_tiles = bfs_find_all_reachable(tiles, player_pos, map_width, map_height)\n        unseen_adjacent = []\n        for y in range(1, map_height + 1):\n            for x in range(1, map_width + 1):\n                tile = tiles.get((x, y))\n                if tile is not None and tile.attrib['seen'] == 'false':\n                    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        adj_coord = (x + dx, y + dy)\n                        adj_tile = tiles.get(adj_coord)\n                        if adj_tile is not None and adj_tile.attrib['type'] not in ['WALL', 'unseen']:\n                            if adj_coord in reachable_tiles:\n                                unseen_adjacent.append({'x': x, 'y': y})\n                                break\n        print(json.dumps(unseen_adjacent))\n    else:\n        print(json.dumps([]))\nexcept Exception as e:\n    import traceback\n    print(f'An error occurred: {e}\\n{traceback.format_exc()}')"
  }
}