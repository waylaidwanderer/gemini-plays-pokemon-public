{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "boulder_push_planner": {
    "description": "Analyzes the map to find a sequence of moves for the player to push a specific boulder to a specific hole. It considers impassable terrain and other objects.",
    "input_schema": {
      "type": "object",
      "properties": {
        "boulder_start_x": {
          "type": "string"
        },
        "boulder_start_y": {
          "type": "string"
        },
        "hole_x": {
          "type": "string"
        },
        "hole_y": {
          "type": "string"
        },
        "player_x": {
          "type": "string"
        },
        "player_y": {
          "type": "string"
        }
      },
      "required": [
        "boulder_start_x",
        "boulder_start_y",
        "hole_x",
        "hole_y",
        "player_x",
        "player_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\ngrid = [['' for _ in range(width)] for _ in range(height)]\nimpassable_tiles = set()\n\nfor r_idx, row_elem in enumerate(root.findall('Row')):\n    y = int(row_elem.get('id')) - 1\n    for c_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n        x = int(tile_elem.get('id')) - 1\n        tile_type = tile_elem.get('type')\n        grid[y][x] = tile_type\n        if tile_type in ['impassable', 'boulder_barrier', 'closed_gate'] or tile_elem.find('Object') is not None:\n            impassable_tiles.add((x, y))\n\nboulder_start_x, boulder_start_y = int(input_data['boulder_start_x']) - 1, int(input_data['boulder_start_y']) - 1\nhole_x, hole_y = int(input_data['hole_x']) - 1, int(input_data['hole_y']) - 1\nplayer_x, player_y = int(input_data['player_x']) - 1, int(input_data['player_y']) - 1\n\ndef bfs_path(start, end, obstacles):\n    queue = deque([(start, [])])\n    visited = {start}\n    while queue:\n        (cx, cy), path = queue.popleft()\n        if (cx, cy) == end:\n            return path\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            if (0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited and (nx, ny) not in obstacles):\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [(nx, ny)]))\n    return None\n\ndef find_boulder_path():\n    initial_state = (player_x, player_y, boulder_start_x, boulder_start_y)\n    queue = deque([(initial_state, [])])\n    visited_states = {initial_state}\n    \n    while queue:\n        (px, py, bx, by), plan = queue.popleft()\n\n        if (bx, by) == (hole_x, hole_y):\n            return plan\n\n        for move_dir in [('Up', 0, -1), ('Down', 0, 1), ('Left', -1, 0), ('Right', 1, 0)]:\n            move_name, dx, dy = move_dir\n            player_push_pos = (bx - dx, by - dy)\n            \n            if not (0 <= player_push_pos[0] < width and 0 <= player_push_pos[1] < height):\n                continue\n\n            path_to_push_pos = bfs_path((px, py), player_push_pos, impassable_tiles | {(bx, by)})\n\n            if path_to_push_pos is not None:\n                new_bx, new_by = bx + dx, by + dy\n\n                if not (0 <= new_bx < width and 0 <= new_by < height) or (new_bx, new_by) in impassable_tiles:\n                    continue\n\n                new_state = (bx, by, new_bx, new_by)\n                if new_state not in visited_states:\n                    visited_states.add(new_state)\n                    new_plan = plan + [{'path_to_push': [{'x': x+1, 'y': y+1} for x, y in path_to_push_pos], 'push_direction': move_name}]\n                    queue.append((new_state, new_plan))\n\n    return None\n\npath_result = find_boulder_path()\nif path_result:\n    print(json.dumps({'plan': path_result, 'reasoning': 'Found a valid plan to push the boulder.'}))\nelse:\n    print(json.dumps({'plan': [], 'reasoning': 'Could not find a valid plan to push the boulder.'}))"
  },
  "find_path": {
    "description": "A robust pathfinding tool. Finds a path to specified X, Y coordinates, considering the current movement state (walking or surfing). It can now avoid a specified list of coordinates. If no end coordinates are provided, it finds a path to the nearest reachable unseen tile. It automatically paths to an adjacent tile if the target is impassable. It can handle elevation changes via steps. This version includes fixes for tile traversal logic and input validation.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string",
          "nullable": true
        },
        "end_y": {
          "type": "string",
          "nullable": true
        },
        "movement_mode": {
          "type": "string",
          "enum": [
            "walking",
            "surfing"
          ]
        },
        "avoid_coords": {
          "type": "string",
          "nullable": true,
          "description": "A JSON string representing a list of coordinate objects, e.g., '[{\"x\":\"10\",\"y\":\"12\"}]'"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "movement_mode"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef find_path(start_x, start_y, end_x, end_y, movement_mode, avoid_coords_str, map_xml):\n    root = ET.fromstring(map_xml)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    all_tiles = {}\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            all_tiles[(x, y)] = tile\n\n    avoid_coords = set()\n    if avoid_coords_str:\n        try:\n            avoid_list = json.loads(avoid_coords_str)\n            for coord in avoid_list:\n                avoid_coords.add((int(coord['x']), int(coord['y'])))\n        except (json.JSONDecodeError, KeyError, TypeError):\n            pass\n\n    walkable_types = {'ground', 'grass', 'steps', 'elevated_ground', 'cleared_boulder_barrier', 'open_gate', 'boulder_switch', 'teleport', 'hole', 'spinner_stop', 'ladder_up', 'ladder_down', 'ledge'}\n    if movement_mode == 'surfing':\n        walkable_types.add('water')\n\n    def is_walkable(x, y):\n        if not (1 <= x <= width and 1 <= y <= height):\n            return False\n        if (x, y) in avoid_coords:\n            return False\n        tile = all_tiles.get((x, y))\n        if not tile or tile.get('type') not in walkable_types:\n            return False\n        obj = tile.find('Object')\n        if obj is not None and obj.get('id-name') != 'Pikachu':\n            return False\n        return True\n\n    def get_neighbors(x, y):\n        neighbors = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            current_tile_node = all_tiles.get((x,y))\n            if not current_tile_node: continue\n            current_tile_type = current_tile_node.get('type')\n            neighbor_tile_node = all_tiles.get((nx, ny))\n            if not neighbor_tile_node: continue\n            neighbor_tile_type = neighbor_tile_node.get('type')\n\n            if not is_walkable(nx, ny):\n                continue\n\n            if current_tile_type == 'ledge' and dy != 1:\n                continue\n            if neighbor_tile_type == 'ledge' and dy == -1:\n                continue\n\n            is_step_move = (current_tile_type == 'steps' and neighbor_tile_type in {'ground', 'elevated_ground'} and dx == 0) or \\\n                           (neighbor_tile_type == 'steps' and current_tile_type in {'ground', 'elevated_ground'} and dx == 0)\n            \n            if is_walkable(nx, ny) or is_step_move:\n                 neighbors.append((nx, ny))\n        return neighbors\n\n    start_node = (start_x, start_y)\n    \n    if end_x is not None and end_y is not None:\n        end_node = (end_x, end_y)\n        if not is_walkable(end_x, end_y):\n            found_alt = False\n            for nx, ny in get_neighbors(end_x, end_y):\n                if is_walkable(nx, ny):\n                    end_node = (nx, ny)\n                    found_alt = True\n                    break\n            if not found_alt:\n                print(json.dumps({'error': 'Target and its adjacent tiles are unreachable.'}))\n                return\n\n        q = [(0, start_node)]\n        came_from = {start_node: None}\n        cost_so_far = {start_node: 0}\n\n        while q:\n            _, current = heapq.heappop(q)\n            if current == end_node:\n                break\n            for next_node in get_neighbors(current[0], current[1]):\n                new_cost = cost_so_far[current] + 1\n                if next_node not in cost_so_far or new_cost < cost_so_far[next_node]:\n                    cost_so_far[next_node] = new_cost\n                    priority = new_cost + abs(next_node[0] - end_node[0]) + abs(next_node[1] - end_node[1])\n                    heapq.heappush(q, (priority, next_node))\n                    came_from[next_node] = current\n        else:\n            print(json.dumps({'error': 'No path found.'}))\n            return\n        \n        path = []\n        current = end_node\n        while current is not None:\n            path.append({'x': str(current[0]), 'y': str(current[1])})\n            current = came_from[current]\n        print(json.dumps(path[::-1]))\n\n    else:\n        q = [(start_node, [{'x': str(start_x), 'y': str(start_y)}])]\n        visited = {start_node}\n        while q:\n            (cx, cy), path = q.pop(0)\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = cx + dx, cy + dy\n                if (1 <= nx <= width and 1 <= ny <= height):\n                    tile = all_tiles.get((nx, ny))\n                    if tile and tile.get('seen') == 'false':\n                        print(json.dumps(path))\n                        return\n            for neighbor in get_neighbors(cx, cy):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    new_path = path + [{'x': str(neighbor[0]), 'y': str(neighbor[1])}]\n                    q.append((neighbor, new_path))\n        print(json.dumps({'error': 'No reachable unseen tiles found.'}))\n\ntry:\n    start_x_str = input_data.get('start_x')\n    start_y_str = input_data.get('start_y')\n    end_x_str = input_data.get('end_x')\n    end_y_str = input_data.get('end_y')\n    movement_mode = input_data.get('movement_mode', 'walking')\n    avoid_coords_str = input_data.get('avoid_coords')\n    \n    if not start_x_str or not start_y_str:\n        raise ValueError('start_x and start_y are required.')\n        \n    start_x = int(start_x_str)\n    start_y = int(start_y_str)\n    end_x = int(end_x_str) if end_x_str else None\n    end_y = int(end_y_str) if end_y_str else None\n\n    find_path(start_x, start_y, end_x, end_y, movement_mode, avoid_coords_str, map_xml_string)\n\nexcept Exception as e:\n    print(json.dumps({'error': f'An error occurred: {e}'}))"
  },
  "get_impassable_tiles": {
    "description": "Extracts and returns a JSON list of all impassable tile coordinates from the current map XML.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET; import json; root = ET.fromstring(map_xml_string); impassable_tiles = []; for row_elem in root.findall('Row'): y = int(row_elem.get('id')); for tile_elem in row_elem.findall('Tile'): x = int(tile_elem.get('id')); if tile_elem.get('type') == 'impassable' or tile_elem.find('Object') is not None: impassable_tiles.append({'x': x, 'y': y}); print(json.dumps(impassable_tiles))"
  },
  "shop_automation_planner": {
    "description": "A placeholder tool to acknowledge the need for shop automation. The player's repeated errors in the shop menu indicate a need for a more streamlined process. This tool serves as a commitment to either developing a viable automation solution in the future or improving manual execution to prevent such errors. Direct UI control is not possible with current tool capabilities, so the immediate focus will be on careful, deliberate manual input.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "python_script": "print(\"Automation acknowledged. The critique regarding error-prone manual item purchasing is valid. While direct UI control tools cannot be built, I will proceed with methodical, single-input-per-turn actions to eliminate errors.\")"
  }
}