{
  "give_item_v1_refined": {
    "description": "Gives an item from the PACK to a Pokémon. Assumes overworld. Parameters: item_index (0-indexed position in the current pocket), pokemon_index (1-indexed position in the party), current_menu_index (0-indexed position of the menu cursor, POKEDEX=0, EXIT=7).",
    "input_schema": {
      "type": "object",
      "properties": {
        "item_index": {
          "type": "integer",
          "description": "0-indexed position of the item in the current pocket"
        },
        "pokemon_index": {
          "type": "integer",
          "description": "1-indexed position of the Pokémon in the party"
        },
        "current_menu_index": {
          "type": "integer",
          "description": "0-indexed position of the current menu cursor (POKEDEX=0, EXIT=7)"
        }
      },
      "required": [
        "item_index",
        "pokemon_index",
        "current_menu_index"
      ]
    },
    "python_script": "\nimport json\n\ndef main():\n    item_index = int(input_data['item_index'])\n    pokemon_index = int(input_data['pokemon_index'])\n    current_menu_index = int(input_data['current_menu_index'])\n    \n    buttons = [\"Start\", \"sleep 500\"]\n    \n    # Navigate to Pack (index 2)\n    diff = 2 - current_menu_index\n    if diff > 0:\n        for _ in range(diff):\n            buttons.append(\"Down\")\n    elif diff < 0:\n        for _ in range(abs(diff)):\n            buttons.append(\"Up\")\n            \n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # Navigate to Item\n    for _ in range(item_index):\n        buttons.append(\"Down\")\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # Select GIVE (2nd option)\n    buttons.append(\"Down\")\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # Select Pokemon\n    for _ in range(pokemon_index - 1):\n        buttons.append(\"Down\")\n    buttons.append(\"A\")\n    buttons.append(\"sleep 1000\")\n    \n    # Clear text\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    buttons.append(\"A\")\n    \n    print(json.dumps(buttons))\n\nif __name__ == \"__main__\":\n    main()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-19T10:55:52.584Z",
        "action_counter": 3933
      }
    ]
  },
  "press_sequence": {
    "description": "Executes a specific sequence of button presses, allowing for mixed directional and action inputs. Useful for complex menu navigation.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nprint(json.dumps(input_data['buttons']))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T06:11:16.135Z",
        "action_counter": 948
      }
    ]
  },
  "find_path": {
    "description": "Finds the shortest path to a target coordinate, correctly handling all collision types, one-way ledges, and treating 'unseen' tiles as traversable. Returns a list of coordinate objects (e.g., [{\"x\": 5, \"y\": 9}, {\"x\": 4, \"y\": 9}]). Treats tiles with is-warp=\"true\" or markers as impassable unless they are the target.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        return\n\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    player_x, player_y = -1, -1\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            if tile.find('Player') is not None:\n                player_x = int(tile.attrib['id'])\n                player_y = y\n                break\n        if player_x != -1:\n            break\n            \n    if player_x == -1:\n        return\n\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n\n    impassable_types = {\"WALL\", \"WATER\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"BOOKSHELF\", \"PC\", \"TOWN_MAP\", \"WINDOW\"}\n\n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            has_obj = tile.attrib.get('has-object') == 'true'\n            is_warp = tile.attrib.get('is-warp') == 'true'\n            grid[(x, y)] = (t_type, has_obj, is_warp)\n\n    queue = deque([(player_x, player_y, [{\"x\": player_x, \"y\": player_y}])])\n    visited = {(player_x, player_y)}\n    \n    while queue:\n        x, y, path = queue.popleft()\n        \n        if x == target_x and y == target_y:\n            print(json.dumps(path))\n            return\n            \n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:\n                t_info = grid.get((nx, ny))\n                if not t_info: continue\n                t_type, has_obj, is_warp = t_info\n                \n                is_target = (nx == target_x and ny == target_y)\n                # Objects are obstacles. Warps are obstacles unless target.\n                is_obstacle = (has_obj and not is_target) or (is_warp and not is_target)\n\n                is_passable = (t_type not in impassable_types and not is_obstacle) or t_type == \"unseen\"\n                \n                is_blocked = False\n                curr_type, _, _ = grid[(x, y)]\n                if \"LEDGE_HOP_DOWN\" in curr_type and dy != 1: is_blocked = True\n                if \"LEDGE_HOP_UP\" in curr_type and dy != -1: is_blocked = True\n                if \"LEDGE_HOP_LEFT\" in curr_type and dx != -1: is_blocked = True\n                if \"LEDGE_HOP_RIGHT\" in curr_type and dx != 1: is_blocked = True\n                \n                if \"LEDGE_HOP_DOWN\" in t_type and dy == -1: is_blocked = True\n                if \"LEDGE_HOP_UP\" in t_type and dy == 1: is_blocked = True\n                if \"LEDGE_HOP_LEFT\" in t_type and dx == 1: is_blocked = True\n                if \"LEDGE_HOP_RIGHT\" in t_type and dx == -1: is_blocked = True\n\n                if not is_blocked and is_passable:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [{\"x\": nx, \"y\": ny}]))\n\n    return\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-20T01:20:05.033Z",
        "action_counter": 4861
      },
      {
        "commit_message": "Treat tiles with is-warp=\"true\" as impassable to avoid falling into holes.",
        "timestamp": "2025-12-20T01:47:21.967Z",
        "action_counter": 4928
      },
      {
        "commit_message": "Treat tiles with markers as impassable unless they are the target tile. This prevents walking through NPCs or into known holes.",
        "timestamp": "2025-12-20T01:48:12.765Z",
        "action_counter": 4929
      },
      {
        "commit_message": "Updated find_path to return button strings for autopress_buttons compatibility. Added logic to convert coordinate path to directional inputs.",
        "timestamp": "2025-12-20T02:52:02.354Z",
        "action_counter": 5051
      },
      {
        "commit_message": "Updated find_path to return coordinate objects for use with navigate tool, complying with movement tool best practices.",
        "timestamp": "2025-12-20T03:15:31.607Z",
        "action_counter": 5086
      }
    ]
  },
  "get_reachable_unseen_tiles_v1": {
    "description": "Finds all reachable unseen tiles on the current map using the Mental Map XML. Returns a list of coordinates. Re-evaluates reachability by treating warps as obstacles.",
    "input_schema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef find_reachable_unseen():\n    root = ET.fromstring(map_xml_string)\n    \n    # Map layout and player position\n    grid = {}\n    player_pos = None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tile_type = tile.attrib['type']\n            seen = tile.attrib['seen'] == 'true'\n            is_warp = tile.attrib.get('is-warp') == 'true'\n            has_object = tile.attrib.get('has-object') == 'true'\n            \n            grid[(x, y)] = {\n                'type': tile_type,\n                'seen': seen,\n                'is_warp': is_warp,\n                'has_object': has_object\n            }\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n\n    if not player_pos:\n        return []\n\n    # BFS to find reachable tiles\n    reachable_unseen = set()\n    visited = set()\n    queue = deque([player_pos])\n    visited.add(player_pos)\n    \n    while queue:\n        cx, cy = queue.popleft()\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            \n            if (nx, ny) not in grid:\n                continue\n            \n            tile = grid[(nx, ny)]\n            \n            if not tile['seen']:\n                reachable_unseen.add((nx, ny))\n                continue\n                \n            if (nx, ny) not in visited:\n                # Warps are impassable for through-traffic in Crystal\n                # Objects and non-FLOOR tiles are impassable\n                if tile['type'] == 'FLOOR' and not tile['has_object'] and not tile['is_warp']:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n                    \n    return sorted(list(reachable_unseen))\n\nreachable = find_reachable_unseen()\nprint(json.dumps(reachable))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-20T02:20:21.962Z",
        "action_counter": 4983
      },
      {
        "commit_message": "Fixed KeyError by using .get() for is-warp and has-object attributes. Added better traversal logic.",
        "timestamp": "2025-12-20T02:20:53.109Z",
        "action_counter": 4985
      },
      {
        "commit_message": "Refined reachability logic to treat warps as obstacles (since they trigger immediately) and ensure it only returns tiles that can be reached without leaving the map.",
        "timestamp": "2025-12-20T02:25:07.479Z",
        "action_counter": 4997
      }
    ]
  },
  "find_path_v2": {
    "description": "Finds the shortest path to a target coordinate, correctly handling all collision types, one-way ledges, and treating 'PIT' tiles and warps as impassable unless they are the target or in an override list. Returns a list of coordinate objects.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "type": "boolean"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ],
      "type": "object"
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n    except Exception:\n        print(\"[]\")\n        return\n\n    map_id = root.attrib.get('id')\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    player_x, player_y = -1, -1\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            if tile.find('Player') is not None:\n                player_x = int(tile.attrib['id'])\n                player_y = y\n                break\n        if player_x != -1:\n            break\n            \n    if player_x == -1:\n        print(\"[]\")\n        return\n\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n\n    impassable_types = {\"WALL\", \"WATER\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"BOOKSHELF\", \"PC\", \"TOWN_MAP\", \"WINDOW\", \"PIT\"}\n    # Known safe warps that are incorrectly labeled in XML\n    safe_overrides = {(\"4_7\", 6, 7)} \n\n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            has_obj = tile.attrib.get('has-object') == 'true'\n            is_warp = tile.attrib.get('is-warp') == 'true'\n            grid[(x, y)] = (t_type, has_obj, is_warp)\n\n    queue = deque([(player_x, player_y, [{\"x\": player_x, \"y\": player_y}])])\n    visited = {(player_x, player_y)}\n    \n    while queue:\n        x, y, path = queue.popleft()\n        \n        if x == target_x and y == target_y:\n            if input_data.get('autopress_buttons'):\n                buttons = []\n                for i in range(len(path) - 1):\n                    dx = path[i+1]['x'] - path[i]['x']\n                    dy = path[i+1]['y'] - path[i]['y']\n                    if dx == 1: buttons.append(\"Right\")\n                    elif dx == -1: buttons.append(\"Left\")\n                    elif dy == 1: buttons.append(\"Down\")\n                    elif dy == -1: buttons.append(\"Up\")\n                print(json.dumps(buttons))\n            else:\n                print(json.dumps(path))\n            return\n            \n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:\n                t_info = grid.get((nx, ny))\n                if not t_info: continue\n                t_type, has_obj, is_warp = t_info\n                \n                is_target = (nx == target_x and ny == target_y)\n                \n                # Check for safe overrides\n                is_safe_override = (map_id, nx, ny) in safe_overrides\n                \n                # Objects are obstacles. Warps and PITs are obstacles unless target or overridden.\n                is_obstacle = (has_obj and not is_target) or (is_warp and not is_target and not is_safe_override) or (t_type == \"PIT\" and not is_target)\n\n                is_passable = (t_type not in impassable_types and not is_obstacle) or t_type == \"unseen\" or is_target\n                \n                is_blocked = False\n                curr_type, _, _ = grid[(x, y)]\n                \n                # Ledge logic\n                if \"LEDGE_HOP\" in curr_type:\n                    if \"DOWN\" in curr_type and dy != 1: is_blocked = True\n                    elif \"UP\" in curr_type and dy != -1: is_blocked = True\n                    elif \"LEFT\" in curr_type and dx != -1: is_blocked = True\n                    elif \"RIGHT\" in curr_type and dx != 1: is_blocked = True\n                \n                if \"LEDGE_HOP\" in t_type:\n                    if \"DOWN\" in t_type and dy == -1: is_blocked = True\n                    elif \"UP\" in t_type and dy == 1: is_blocked = True\n                    elif \"LEFT\" in t_type and dx == 1: is_blocked = True\n                    elif \"RIGHT\" in t_type and dx == -1: is_blocked = True\n\n                if not is_blocked and is_passable:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [{\"x\": nx, \"y\": ny}]))\n\n    print(\"[]\")\n    return\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-20T04:07:19.465Z",
        "action_counter": 5144
      },
      {
        "commit_message": "Enhanced ledge hop collision logic and added safe_overrides for Ecruteak Gym (6,7).",
        "timestamp": "2025-12-20T04:59:36.981Z",
        "action_counter": 5223
      },
      {
        "commit_message": "Refined ledge logic and added safe_overrides for Ecruteak Gym. Added empty list fallback to prevent JSON errors.",
        "timestamp": "2025-12-20T05:05:07.338Z",
        "action_counter": 5237
      },
      {
        "commit_message": "Refined ledge logic and added safe_overrides for Ecruteak Gym. Added empty list fallback to prevent JSON errors.",
        "timestamp": "2025-12-20T05:07:22.098Z",
        "action_counter": 5240
      }
    ]
  }
}