{
  "advanced_pathfinder": {
    "description": "An advanced pathfinder that ignores most tile types to find hidden passages, but respects truly impassable tiles, objects, and closed gates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\ngrid = [['' for _ in range(width)] for _ in range(height)]\nimpassable_coords = set()\n\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.get('id')) - 1\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.get('id')) - 1\n        grid[y][x] = tile_elem.get('type')\n        obj = tile_elem.find('Object')\n        if obj is not None and obj.get('id-name') != 'Pikachu':\n            impassable_coords.add((x, y))\n\nstart_x = int(input_data['start_x']) - 1\nstart_y = int(input_data['start_y']) - 1\nend_x = int(input_data['end_x']) - 1\nend_y = int(input_data['end_y']) - 1\n\nstart_node = (start_x, start_y)\nend_node = (end_x, end_y)\n\nqueue = deque([(start_node, [start_node])])\nvisited = {start_node}\n\npath_found = False\nwhile queue:\n    (current_x, current_y), path = queue.popleft()\n\n    if (current_x, current_y) == end_node:\n        path_plan = [{'x': x + 1, 'y': y + 1} for x, y in path]\n        print(json.dumps(path_plan))\n        path_found = True\n        break\n\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        next_x, next_y = current_x + dx, current_y + dy\n\n        if 0 <= next_x < width and 0 <= next_y < height:\n            neighbor = (next_x, next_y)\n            if neighbor not in visited:\n                tile_type = grid[next_y][next_x]\n                if tile_type not in ['impassable', 'closed_gate'] and neighbor not in impassable_coords:\n                    visited.add(neighbor)\n                    new_path = path + [neighbor]\n                    queue.append((neighbor, new_path))\n\nif not path_found:\n    print(json.dumps([]))"
  },
  "find_next_exploration_target": {
    "description": "Analyzes unseen tiles and reachable barriers to suggest the most logical next exploration target. Prioritizes the closest unseen tile. If none exist, it finds the closest reachable barrier based on Manhattan distance from the player's current coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "unseen_tiles_json": {
          "type": "string"
        },
        "reachable_barriers_json": {
          "type": "string"
        },
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "unseen_tiles_json",
        "reachable_barriers_json",
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import json\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nunseen_tiles = json.loads(input_data['unseen_tiles_json'])\nreachable_barriers = json.loads(input_data['reachable_barriers_json'])\n\nstart_pos = (start_x, start_y)\nnext_target = None\nmin_dist = float('inf')\nreasoning = ''\n\nif unseen_tiles:\n    for tile in unseen_tiles:\n        dist = heuristic(start_pos, (tile['x'], tile['y']))\n        if dist < min_dist:\n            min_dist = dist\n            next_target = tile\n    if next_target:\n        reasoning = f'The closest unseen tile is at ({next_target[\"x\"]}, {next_target[\"y\"]}) with a distance of {min_dist}.'\n    else:\n        reasoning = 'No unseen tiles found.'\nelif reachable_barriers:\n    for barrier in reachable_barriers:\n        dist = heuristic(start_pos, (barrier['x'], barrier['y']))\n        if dist < min_dist:\n            min_dist = dist\n            next_target = barrier\n    if next_target:\n        reasoning = f'No unseen tiles. The closest reachable barrier is at ({next_target[\"x\"]}, {next_target[\"y\"]}) with a distance of {min_dist}.'\n    else:\n        reasoning = 'No reachable barriers found.'\nelse:\n    reasoning = 'No unseen tiles or reachable barriers to suggest.'\n\nif next_target:\n    print(json.dumps({'next_target_x': next_target['x'], 'next_target_y': next_target['y'], 'reasoning': reasoning}))\nelse:\n    print(json.dumps({'next_target_x': None, 'next_target_y': None, 'reasoning': reasoning}))"
  },
  "find_path": {
    "description": "A consolidated pathfinding tool. Finds a path to specified X, Y coordinates. If no coordinates are provided, it finds a path to the nearest reachable unseen tile. It automatically paths to an adjacent tile if the target is impassable.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "traversal_type": {
          "type": "string",
          "enum": [
            "walk",
            "surf"
          ]
        },
        "end_x": {
          "type": "string",
          "nullable": true
        },
        "end_y": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "start_x",
        "start_y",
        "traversal_type"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\ngrid = [['' for _ in range(width)] for _ in range(height)]\nimpassable_coords = set()\nunseen_tiles = []\n\nwalk_types = ['ground', 'grass', 'open_gate', 'cleared_boulder_barrier', 'boulder_switch', 'teleport', 'hole', 'spinner_stop', 'ladder_up', 'ladder_down', 'steps', 'ledge', 'cuttable']\nsurf_types = ['water']\n\nfor r_idx, row_elem in enumerate(root.findall('Row')):\n    y = int(row_elem.get('id')) - 1\n    for c_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n        x = int(tile_elem.get('id')) - 1\n        tile_type = tile_elem.get('type')\n        grid[y][x] = tile_type\n        if tile_elem.get('seen') == 'false':\n            unseen_tiles.append((x, y))\n        if tile_elem.find('Object') is not None and (tile_elem.find('Object').get('id-name') != 'Pikachu'):\n            impassable_coords.add((x, y))\n\nstart_x, start_y = int(input_data['start_x']) - 1, int(input_data['start_y']) - 1\ntraversal_type = input_data['traversal_type']\nend_x = int(input_data['end_x']) - 1 if 'end_x' in input_data and input_data['end_x'] is not None else None\nend_y = int(input_data['end_y']) - 1 if 'end_y' in input_data and input_data['end_y'] is not None else None\n\ntraversable_tiles = set(surf_types) if traversal_type == 'surf' else set(walk_types)\n\ntarget_nodes = set()\n\nif end_x is not None and end_y is not None:\n    # Path to specific coordinates\n    destination_tile_type = grid[end_y][end_x]\n    destination_is_traversable = destination_tile_type in traversable_tiles and (end_x, end_y) not in impassable_coords\n    if destination_is_traversable:\n        target_nodes.add((end_x, end_y))\n    else:\n        # Find adjacent traversable tiles\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_x, adj_y = end_x + dx, end_y + dy\n            if 0 <= adj_x < width and 0 <= adj_y < height and grid[adj_y][adj_x] in traversable_tiles and (adj_x, adj_y) not in impassable_coords:\n                target_nodes.add((adj_x, adj_y))\nelse:\n    # Path to nearest unseen tile (exploration mode)\n    for ux, uy in unseen_tiles:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_x, adj_y = ux + dx, uy + dy\n            if 0 <= adj_x < width and 0 <= adj_y < height and grid[adj_y][adj_x] in traversable_tiles and (adj_x, adj_y) not in impassable_coords:\n                target_nodes.add((adj_x, adj_y))\n\nif not target_nodes:\n    print(json.dumps({'path': [], 'reasoning': 'No reachable targets found.'}))\nelse:\n    queue = deque([((start_x, start_y), [(start_x, start_y)])])\n    visited = {(start_x, start_y)}\n    path_found = False\n\n    while queue:\n        (current_x, current_y), path = queue.popleft()\n\n        if (current_x, current_y) in target_nodes:\n            path_plan = [{'x': x + 1, 'y': y + 1} for x, y in path]\n            target_x, target_y = path_plan[-1]['x'], path_plan[-1]['y']\n            reasoning = f'Path found to target at ({target_x}, {target_y}).'\n            print(json.dumps({'path': path_plan, 'reasoning': reasoning}))\n            path_found = True\n            break\n\n        for move_info in [((0, 1), 'Down'), ((0, -1), 'Up'), ((1, 0), 'Right'), ((-1, 0), 'Left')]:\n            (dx, dy), direction = move_info\n            next_x, next_y = current_x + dx, current_y + dy\n            \n            if 0 <= next_x < width and 0 <= next_y < height and (next_x, next_y) not in visited:\n                next_tile_type = grid[next_y][next_x]\n                is_ledge_move = (next_tile_type == 'ledge')\n                can_traverse_ledge = (is_ledge_move and direction == 'Down')\n                \n                if (next_tile_type in traversable_tiles and not is_ledge_move) or can_traverse_ledge:\n                    if (next_x, next_y) not in impassable_coords:\n                        visited.add((next_x, next_y))\n                        new_path = path + [(next_x, next_y)]\n                        if can_traverse_ledge and next_y + 1 < height:\n                            new_path.append((next_x, next_y + 1))\n                        queue.append(((new_path[-1][0], new_path[-1][1]), new_path))\n    \n    if not path_found:\n        print(json.dumps({'path': [], 'reasoning': 'Could not find a path to any reachable targets.'}))"
  }
}