{
  "find_adjacent_traversable_tiles": {
    "description": "Takes a target coordinate and finds all adjacent (non-diagonal) tiles that are traversable, returning them as a list of coordinates. This is useful for finding valid spots to stand when trying to interact with an object or NPC.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntry:\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n\n    root = ET.fromstring(map_xml_string)\n    \n    impassable_types = {\n        'WALL', 'VOID', 'WATER', 'BOOKSHELF', 'COUNTER', 'CUT_TREE',\n        'HEADBUTT_TREE', 'MART_SHELF', 'PC', 'PILLAR', 'RADIO', 'TOWN_MAP',\n        'TV', 'WINDOW'\n    }\n\n    grid = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            has_object = tile_elem.find('Object') is not None\n            \n            is_impassable = (tile_type in impassable_types) or has_object\n            grid[(x, y)] = not is_impassable\n\n    adjacent_traversable = []\n    for dx, dy, direction in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n        nx, ny = target_x + dx, target_y + dy\n        neighbor_coord = (nx, ny)\n\n        if grid.get(neighbor_coord, False):\n            adjacent_traversable.append({'x': nx, 'y': ny, 'direction_from_target': direction})\n            \n    print(json.dumps(adjacent_traversable))\n\nexcept Exception as e:\n    print(json.dumps({\"error\": str(e)}))",
    "history": [
      {
        "commit_message": "feat: Create tool to find valid interaction spots. This tool, `find_adjacent_traversable_tiles`, replaces the functionality of the deleted `hypothesis_generator` agent. It deterministically parses the map XML to find all valid, traversable tiles adjacent to a target coordinate. This provides a reliable method for generating testable puzzle hypotheses and directly addresses the system critique regarding the faulty agent.",
        "timestamp": "2025-10-31T11:18:33.232Z",
        "action_counter": 10203
      }
    ]
  },
  "deterministic_battle_strategist": {
    "description": "A deterministic, non-LLM tool that analyzes battle state and recommends the next action (FIGHT/RUN) and move. A reliable backup for the simple_battle_strategist agent.",
    "input_schema": {
      "type": "object",
      "properties": {
        "my_pokemon_level": {
          "type": "integer"
        },
        "my_pokemon_hp_current": {
          "type": "integer"
        },
        "my_pokemon_hp_max": {
          "type": "integer"
        },
        "opponent_pokemon_name": {
          "type": "string"
        },
        "opponent_pokemon_level": {
          "type": "integer",
          "nullable": true
        },
        "move_1_name": {
          "type": "string"
        },
        "move_1_pp_current": {
          "type": "integer"
        },
        "move_2_name": {
          "type": "string",
          "nullable": true
        },
        "move_2_pp_current": {
          "type": "integer",
          "nullable": true
        },
        "move_3_name": {
          "type": "string",
          "nullable": true
        },
        "move_3_pp_current": {
          "type": "integer",
          "nullable": true
        },
        "move_4_name": {
          "type": "string",
          "nullable": true
        },
        "move_4_pp_current": {
          "type": "integer",
          "nullable": true
        },
        "current_objective": {
          "type": "string",
          "enum": [
            "TRAINING",
            "TRAVELING"
          ]
        },
        "battle_type": {
          "type": "string",
          "enum": [
            "WILD",
            "TRAINER"
          ]
        }
      },
      "required": [
        "my_pokemon_level",
        "my_pokemon_hp_current",
        "my_pokemon_hp_max",
        "opponent_pokemon_name",
        "move_1_name",
        "move_1_pp_current",
        "current_objective",
        "battle_type"
      ]
    },
    "python_script": "import json\n\n# --- Knowledge Base ---\nKNOWN_POKEMON_TYPES = {\n    'BEEDRILL': ['Bug', 'Poison'], 'BELLSPROUT': ['Grass', 'Poison'], 'CATERPIE': ['Bug'],\n    'CROCONAW': ['Water'], 'DUNSPARCE': ['Normal'], 'EKANS': ['Poison'], 'GASTLY': ['Ghost', 'Poison'],\n    'GEODUDE': ['Rock', 'Ground'], 'HOOTHOOT': ['Normal', 'Flying'], 'HOPPIP': ['Grass', 'Flying'],\n    'KAKUNA': ['Bug', 'Poison'], 'LEDYBA': ['Bug', 'Flying'], 'METAPOD': ['Bug'], 'ODDISH': ['Grass', 'Poison'],\n    'ONIX': ['Rock', 'Ground'], 'PARAS': ['Bug', 'Grass'], 'PIDGEY': ['Normal', 'Flying'], 'POLIWAG': ['Water'],\n    'PSYDUCK': ['Water'], 'RATTATA': ['Normal'], 'SANDSHREW': ['Ground'], 'SCYTHER': ['Bug', 'Flying'],\n    'SLOWPOKE': ['Water', 'Psychic'], 'SPEAROW': ['Normal', 'Flying'], 'SPINARAK': ['Bug', 'Poison'],\n    'VENONAT': ['Bug', 'Poison'], 'VULPIX': ['Fire'], 'WEEDLE': ['Bug', 'Poison'], 'WOOPER': ['Water', 'Ground'],\n    'ZUBAT': ['Poison', 'Flying']\n}\n\nKNOWN_MOVE_TYPES = {\n    'TACKLE': 'Normal', 'QUICK ATTACK': 'Normal', 'EMBER': 'Fire', 'FLAME WHEEL': 'Fire',\n    'HIDDEN POWER': 'Psychic', 'LEER': 'Normal', 'GROWL': 'Normal', 'CHARM': 'Normal'\n}\n\nSTATUS_MOVES = {'LEER', 'GROWL', 'CHARM'}\n\nTYPE_CHART = {\n    'Fire': {'super_effective': ['Bug', 'Grass'], 'not_very_effective': ['Water', 'Fire', 'Rock', 'Ground'], 'no_effect': []},\n    'Ground': {'super_effective': ['Fire'], 'not_very_effective': [], 'no_effect': []},\n    'Normal': {'super_effective': [], 'not_very_effective': ['Rock', 'Ground'], 'no_effect': ['Ghost']},\n    'Psychic': {'super_effective': [], 'not_very_effective': ['Bug'], 'no_effect': []}\n}\n\n# --- Input Parsing ---\nmy_level = int(input_data['my_pokemon_level'])\nopponent_name = input_data['opponent_pokemon_name']\nopponent_level_str = input_data.get('opponent_pokemon_level')\nopponent_level = int(opponent_level_str) if opponent_level_str and opponent_level_str != 'null' else None\nobjective = input_data['current_objective']\nbattle_type = input_data['battle_type']\nmy_hp_current = int(input_data['my_pokemon_hp_current'])\nmy_hp_max = int(input_data['my_pokemon_hp_max'])\n\nmoves_input = [\n    (input_data.get('move_1_name'), input_data.get('move_1_pp_current')),\n    (input_data.get('move_2_name'), input_data.get('move_2_pp_current')),\n    (input_data.get('move_3_name'), input_data.get('move_3_pp_current')),\n    (input_data.get('move_4_name'), input_data.get('move_4_pp_current'))\n]\n\nmoves = [(name, int(pp)) for name, pp in moves_input if name and pp is not None]\n\n# --- Logic ---\nif battle_type == 'TRAINER':\n    pass\nelif objective == 'TRAINING':\n    if (my_hp_current / my_hp_max) < 0.25:\n        print(json.dumps({'action': 'RUN', 'move_to_use': None}))\n        exit()\nelse: # Traveling\n    if opponent_level is not None and my_level >= opponent_level + 20:\n        pass # Fall through to fight\n    elif opponent_level is None:\n        pass # Level unknown, fall through to effectiveness check\n    else:\n        print(json.dumps({'action': 'RUN', 'move_to_use': None}))\n        exit()\n\n# --- Move Selection ---\nopponent_types = KNOWN_POKEMON_TYPES.get(opponent_name, [])\n\nscored_moves = []\nfor name, pp in moves:\n    if pp == 0 or name in STATUS_MOVES:\n        continue\n\n    move_type = KNOWN_MOVE_TYPES.get(name)\n    if not move_type or not opponent_types:\n        effectiveness = 1.0\n    else:\n        effectiveness = 1.0\n        chart = TYPE_CHART.get(move_type, {})\n        for opp_type in opponent_types:\n            if opp_type in chart.get('super_effective', []): effectiveness *= 2.0\n            if opp_type in chart.get('not_very_effective', []): effectiveness *= 0.5\n            if opp_type in chart.get('no_effect', []): effectiveness *= 0.0\n    \n    scored_moves.append({'name': name, 'pp': pp, 'effectiveness': effectiveness})\n\nif not scored_moves:\n    print(json.dumps({'action': 'RUN', 'move_to_use': None}))\n    exit()\n\nbest_move = sorted(scored_moves, key=lambda x: (x['effectiveness'], x['pp']), reverse=True)[0]\n\nif objective == 'TRAVELING' and best_move['effectiveness'] <= 0.5:\n    print(json.dumps({'action': 'RUN', 'move_to_use': None}))\n    exit()\n\nprint(json.dumps({'action': 'FIGHT', 'move_to_use': best_move['name']}))\n",
    "history": [
      {
        "commit_message": "feat: Create deterministic battle strategist. This tool replaces the unreliable simple_battle_strategist agent, which has been failing due to server errors. It uses a hardcoded type chart and logic to provide a stable and consistent source of battle advice, directly addressing a critical system critique.",
        "timestamp": "2025-11-03T18:25:45.289Z",
        "action_counter": 17503
      },
      {
        "commit_message": "fix: Correctly filter status moves. The previous version had a flawed check that failed to exclude status moves like LEER, causing it to give incorrect battle advice. This commit introduces a dedicated `STATUS_MOVES` set and adds a clear check (`if name in STATUS_MOVES`) to the move evaluation loop, ensuring that only damaging moves are considered. This resolves the critical logic bug.",
        "timestamp": "2025-11-03T18:29:57.269Z",
        "action_counter": 17510
      },
      {
        "commit_message": "fix: Handle null opponent level in wild battles. The script was crashing with a ValueError when `opponent_pokemon_level` was the string 'null'. This commit adds an explicit check for 'null' before attempting integer conversion, preventing the crash and allowing the tool to function correctly in wild encounters where the opponent's level is not displayed.",
        "timestamp": "2025-11-03T19:50:14.395Z",
        "action_counter": 17599
      },
      {
        "commit_message": "feat: Add Sandshrew type and improve run logic. The tool previously recommended fighting a Sandshrew with a Fire-type because it lacked type information and its run logic was too simple. This commit adds 'SANDSHREW' to the `KNOWN_POKEMON_TYPES` dictionary and introduces a new check to automatically run from wild battles when traveling if the best available move is not very effective. This improves strategic decision-making and prevents wasting resources on unfavorable encounters.",
        "timestamp": "2025-11-03T20:58:14.951Z",
        "action_counter": 17685
      },
      {
        "commit_message": "fix: Prevent automatic run when opponent level is unknown. The previous logic would default to 'RUN' during wild encounters where the opponent's level is not displayed, bypassing the more nuanced type-effectiveness check. This commit adds a specific condition to handle `opponent_level` being `None`, allowing the script to fall through to the effectiveness logic and make a more intelligent decision. This resolves the critical failure where the tool recommended running from a battle with a clear type advantage.",
        "timestamp": "2025-11-03T21:39:18.957Z",
        "action_counter": 17743
      }
    ]
  },
  "find_reachable_unseen_tiles": {
    "description": "Parses the map XML and current player position to return a list of unseen tiles that are confirmed to be reachable, filtering out those blocked by walls or other obstacles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\nimport json\nimport sys\n\nstart_x_str = input_data['start_x']\nstart_y_str = input_data['start_y']\nstart_x, start_y = int(start_x_str), int(start_y_str)\n\nroot = ET.fromstring(map_xml_string)\nmap_id = root.get('id')\nimpassable_types = {'WALL', 'WATER', 'COUNTER', 'MART_SHELF', 'PC', 'TV', 'BOOKSHELF', 'RADIO', 'TOWN_MAP', 'WINDOW', 'CUT_TREE', 'HEADBUTT_TREE'}\n\ntile_data = {}\nunseen_tiles = []\nfor tile_elem in root.findall('.//Tile'):\n    coord_str = tile_elem.get('coordinate')\n    x_str, y_str = coord_str.strip('()').split(',')\n    x, y = int(x_str.strip()), int(y_str.strip())\n    tile_type = tile_elem.get('type')\n    is_warp = tile_elem.get('is-warp') == 'true'\n    tile_data[(x, y)] = {'type': tile_type, 'is_warp': is_warp}\n    if tile_elem.get('seen') == 'false':\n        unseen_tiles.append((x, y))\n\nstart_node = (start_x, start_y)\nqueue = collections.deque([start_node])\nvisited = {start_node}\nreachable_unseen = []\n\nwhile queue:\n    x, y = queue.popleft()\n\n    if (x, y) in unseen_tiles and (x, y) not in reachable_unseen:\n        reachable_unseen.append({'x': x, 'y': y})\n\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n        nx, ny = x + dx, y + dy\n        neighbor_node = (nx, ny)\n\n        if neighbor_node in visited or neighbor_node not in tile_data:\n            continue\n\n        current_tile_data = tile_data.get((x,y))\n        neighbor_tile_data = tile_data.get(neighbor_node)\n        current_tile_type = current_tile_data['type']\n        neighbor_tile_type = neighbor_tile_data['type']\n\n        if neighbor_tile_type in impassable_types:\n            continue\n        \n        if neighbor_tile_data['is_warp']:\n            continue\n\n        if current_tile_type == 'LEDGE_HOP_DOWN' and dy == -1: continue\n        if current_tile_type == 'LEDGE_HOP_LEFT' and dx == 1: continue\n        if current_tile_type == 'LEDGE_HOP_RIGHT' and dx == -1: continue\n        if neighbor_tile_type == 'LEDGE_HOP_DOWN' and dy == -1: continue\n        if neighbor_tile_type == 'LEDGE_HOP_LEFT' and dx == 1: continue\n        if neighbor_tile_type == 'LEDGE_HOP_RIGHT' and dx == -1: continue\n        if neighbor_tile_type == 'FLOOR_UP_WALL' and dy == 1 and map_id in ['10_9', '10_1', '3_37', '3_38', '3_78']: continue\n        \n        visited.add(neighbor_node)\n        queue.append(neighbor_node)\n\nprint(json.dumps(reachable_unseen))",
    "history": [
      {
        "commit_message": "feat: Create tool to find reachable unseen tiles. This tool automates the process of checking for explorable areas by performing a BFS from the player's position and returning a list of all unseen tiles that are confirmed to be reachable. This addresses a recurring strategic need for efficient exploration.",
        "timestamp": "2025-11-04T01:31:43.456Z",
        "action_counter": 18091
      }
    ]
  },
  "path_and_execute": {
    "description": "Generates a path to a target coordinate and returns a sequence of button presses intended for use with `autopress_buttons`. Automatically attempts to run from wild battles if interrupted.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nimport collections\n\ndef pathfind(start_x, start_y, end_x, end_y, map_xml_string):\n    object_locations = {}\n    root = ET.fromstring(map_xml_string)\n    try:\n        for tile_elem in root.findall('.//Object/..'):\n            obj_elem = tile_elem.find('Object')\n            obj_id = obj_elem.get('id')\n            if obj_id == '0': continue\n            coord_str = tile_elem.get('coordinate')\n            if coord_str:\n                x_str, y_str = coord_str.strip('()').split(',')\n                x, y = int(x_str.strip()), int(y_str.strip())\n                object_locations[obj_id] = [x, y]\n        for tile_elem in root.findall('.//Marker[@object_id]/..'):\n            marker_elem = tile_elem.find('Marker[@object_id]')\n            obj_id = marker_elem.get('object_id')\n            if obj_id not in object_locations:\n                coord_str = tile_elem.get('coordinate')\n                if coord_str:\n                    x_str, y_str = coord_str.strip('()').split(',')\n                    x, y = int(x_str.strip()), int(y_str.strip())\n                    object_locations[obj_id] = [x, y]\n    except ET.ParseError:\n        pass\n    \n    impassable_types = {'WALL', 'WATER', 'COUNTER', 'MART_SHELF', 'PC', 'TV', 'BOOKSHELF', 'RADIO', 'TOWN_MAP', 'WINDOW', 'CUT_TREE', 'HEADBUTT_TREE'}\n    tile_data = {}\n    for tile_elem in root.findall('.//Tile'):\n        coord_str = tile_elem.get('coordinate')\n        x_str, y_str = coord_str.strip('()').split(',')\n        x, y = int(x_str.strip()), int(y_str.strip())\n        tile_data[(x, y)] = {'type': tile_elem.get('type'), 'is_warp': tile_elem.get('is-warp') == 'true'}\n\n    obstacle_coords = set(tuple(coords) for coords in object_locations.values())\n    start_node = (start_x, start_y)\n    target_node = (end_x, end_y)\n\n    if target_node in obstacle_coords or tile_data.get(target_node, {}).get('type') in impassable_types:\n        potential_targets = []\n        for dx, dy in [(0, 1), (0, -1), (-1, 0), (1, 0)]:\n            adj_node = (end_x + dx, end_y + dy)\n            if adj_node not in tile_data: continue\n            if adj_node in obstacle_coords: continue\n            adj_tile_data = tile_data.get(adj_node)\n            if not adj_tile_data: continue\n            if adj_tile_data['type'] in impassable_types: continue\n            if adj_tile_data['is_warp']: continue\n            potential_targets.append(adj_node)\n        if not potential_targets: return None\n        potential_targets.sort(key=lambda p: abs(p[0] - start_x) + abs(p[1] - start_y))\n        target_node = potential_targets[0]\n\n    if start_node == target_node: return []\n\n    queue = collections.deque([[start_node]])\n    visited = {start_node}\n\n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n        if (x, y) == target_node: return path\n\n        current_tile_data = tile_data.get((x, y))\n        if not current_tile_data: continue\n\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = x + dx, y + dy\n            neighbor_node = (nx, ny)\n            if neighbor_node in visited or neighbor_node not in tile_data: continue\n            if neighbor_node in obstacle_coords: continue\n            neighbor_tile_data = tile_data.get(neighbor_node)\n            if not neighbor_tile_data: continue\n            \n            if dy == -1 and neighbor_tile_data['type'] in {'LEDGE_HOP_DOWN', 'FLOOR_UP_WALL'}:\n                continue\n            if dx == 1 and neighbor_tile_data['type'] == 'LEDGE_HOP_LEFT':\n                continue\n            if dx == -1 and neighbor_tile_data['type'] == 'LEDGE_HOP_RIGHT':\n                continue\n            if dy == 1 and neighbor_tile_data['type'] == 'FLOOR_UP_WALL':\n                continue\n\n            if neighbor_tile_data['type'] in impassable_types: continue\n            if neighbor_tile_data['is_warp'] and neighbor_node != target_node: continue\n            visited.add(neighbor_node)\n            new_path = list(path)\n            new_path.append(neighbor_node)\n            queue.append(new_path)\n    return None\n\n\ntarget_x = int(input_data['target_x'])\ntarget_y = int(input_data['target_y'])\nroot = ET.fromstring(map_xml_string)\nplayer_tile = root.find('.//Player/..')\nif player_tile is None:\n    print(json.dumps(['Down', 'Down', 'A']))\nelse:\n    coord_str = player_tile.get('coordinate')\n    x_str, y_str = coord_str.strip('()').split(',')\n    player_x, player_y = int(x_str.strip()), int(y_str.strip())\n    path = pathfind(player_x, player_y, target_x, target_y, map_xml_string)\n    if path is not None:\n        buttons = []\n        for i in range(len(path) - 1):\n            curr_x, curr_y = path[i]\n            next_x, next_y = path[i+1]\n            if next_y < curr_y: buttons.append('Up')\n            elif next_y > curr_y: buttons.append('Down')\n            elif next_x < curr_x: buttons.append('Left')\n            elif next_x > curr_x: buttons.append('Right')\n        print(json.dumps(buttons))\n    else:\n        print(json.dumps([]))",
    "history": [
      {
        "commit_message": "feat: Create unified pathing and execution tool. This new tool, `path_and_execute`, combines the pathfinding logic of `automated_navigation_tool` with the button conversion logic of `manual_path_executor`. This addresses the critical, recurring failure of the built-in `path` command by generating a reliable button sequence for `autopress_buttons` in a single tool call, streamlining the navigation process.",
        "timestamp": "2025-11-04T14:17:31.770Z",
        "action_counter": 19229
      },
      {
        "commit_message": "feat: Create unified pathing and execution tool. This new tool, `path_and_execute`, combines the pathfinding logic of `automated_navigation_tool` with the button conversion logic of `manual_path_executor`. This addresses the critical, recurring failure of the built-in `path` command by generating a reliable button sequence for `autopress_buttons` in a single tool call, streamlining the navigation process.",
        "timestamp": "2025-11-04T14:21:07.531Z",
        "action_counter": 19236
      },
      {
        "commit_message": "fix: Improve pathfinding logic to avoid obstacles. This commit addresses a recurring failure where the tool would generate paths directly into static NPCs. The pathfinding algorithm has been enhanced with a more comprehensive list of impassable tile types sourced from the notepad and more robust logic for handling one-way tiles. This directly responds to the system critique regarding the tool's faulty obstacle avoidance.",
        "timestamp": "2025-11-04T14:58:16.123Z",
        "action_counter": 19291
      },
      {
        "commit_message": "fix: Implement specific one-way tile logic. The previous general logic failed to prevent an invalid downward move onto a `FLOOR_UP_WALL` tile on Route 32. This commit replaces the broad checks with specific, directional rules for each one-way tile type, directly addressing the recurring pathing failure.",
        "timestamp": "2025-11-04T15:08:30.743Z",
        "action_counter": 19303
      },
      {
        "commit_message": "fix: Add off-screen obstacle detection and correct one-way logic. The tool now parses map markers to identify and avoid off-screen objects, preventing pathing failures on long routes. It also implements a more accurate, directional rule set for one-way tiles like ledges and FLOOR_UP_WALL, resolving a recurring invalid move error.",
        "timestamp": "2025-11-04T15:14:07.530Z",
        "action_counter": 19308
      },
      {
        "commit_message": "fix: Correct one-way tile pathing logic. The previous version incorrectly checked both the current and neighbor tiles, blocking valid moves away from ledges. This commit refines the logic to only check the destination (neighbor) tile, which correctly enforces one-way traversal and resolves the recurring pathing failure.",
        "timestamp": "2025-11-04T15:22:33.501Z",
        "action_counter": 19316
      },
      {
        "commit_message": "fix: Add rule to prevent downward movement onto FLOOR_UP_WALL tiles. The previous version lacked this check, causing the pathfinder to generate invalid paths, such as moving from (16, 3) to (16, 4) in Union Cave. This commit adds the specific rule to resolve the recurring pathing failure.",
        "timestamp": "2025-11-04T15:27:29.315Z",
        "action_counter": 19323
      }
    ]
  }
}