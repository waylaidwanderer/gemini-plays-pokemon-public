{
  "overworld_navigator": {
    "description": "Calculates a multi-map path between a start and end location using the World Knowledge Graph. This tool is designed for complex navigation that requires traversing between different map_ids via warps or map edges. It returns a sequence of actions, including local pathfinding on each map segment and the necessary warp/transition actions.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_map_id": {
          "type": "string"
        },
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_map_id": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_map_id",
        "start_x",
        "start_y",
        "end_map_id",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import json\nimport heapq\n\ndef heuristic(a, b):\n    return abs(a['x'] - b['x']) + abs(a['y'] - b['y'])\n\ndef a_star_search(graph, start_node_id, end_node_id):\n    nodes_by_id = {n['id']: n for n in graph['nodes']}\n    start_node = nodes_by_id.get(start_node_id)\n    end_node = nodes_by_id.get(end_node_id)\n    if not start_node or not end_node:\n        return None\n\n    open_set = [(0, start_node_id)]\n    came_from = {}\n    g_score = {node_id: float('inf') for node_id in nodes_by_id}\n    g_score[start_node_id] = 0\n    f_score = {node_id: float('inf') for node_id in nodes_by_id}\n    f_score[start_node_id] = heuristic(start_node['coordinates'], end_node['coordinates'])\n    open_set_hash = {start_node_id}\n\n    while open_set:\n        _, current_id = heapq.heappop(open_set)\n        open_set_hash.remove(current_id)\n\n        if current_id == end_node_id:\n            path = []\n            temp = current_id\n            while temp in came_from:\n                path.append(temp)\n                temp = came_from[temp]\n            path.append(start_node_id)\n            return path[::-1]\n\n        for edge in graph['edges']:\n            neighbor_id = None\n            if edge['source_node_id'] == current_id:\n                neighbor_id = edge['destination_node_id']\n            elif edge['destination_node_id'] == current_id and not edge.get('is_one_way', False):\n                neighbor_id = edge['source_node_id']\n\n            if neighbor_id:\n                tentative_g_score = g_score[current_id] + 1\n                if tentative_g_score < g_score[neighbor_id]:\n                    came_from[neighbor_id] = current_id\n                    g_score[neighbor_id] = tentative_g_score\n                    neighbor_node = nodes_by_id.get(neighbor_id)\n                    if neighbor_node:\n                        f_score[neighbor_id] = g_score[neighbor_id] + heuristic(neighbor_node['coordinates'], end_node['coordinates'])\n                        if neighbor_id not in open_set_hash:\n                            heapq.heappush(open_set, (f_score[neighbor_id], neighbor_id))\n                            open_set_hash.add(neighbor_id)\n    return None\n\ntry:\n    world_graph = json.loads(world_knowledge_graph_json_string)\n    start_map_id = input_data['start_map_id']\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_map_id = input_data['end_map_id']\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n\n    start_nodes_on_map = [n for n in world_graph.get('nodes', []) if n.get('map_id') == start_map_id]\n    end_nodes_on_map = [n for n in world_graph.get('nodes', []) if n.get('map_id') == end_map_id]\n\n    if not start_nodes_on_map or not end_nodes_on_map:\n        print(json.dumps({'path_found': False, 'path': [], 'error': 'Start or end map not found in World Knowledge Graph.'}))\n    else:\n        start_node = min(start_nodes_on_map, key=lambda n: heuristic(n['coordinates'], {'x': start_x, 'y': start_y}))\n        end_node = min(end_nodes_on_map, key=lambda n: heuristic(n['coordinates'], {'x': end_x, 'y': end_y}))\n        path_node_ids = a_star_search(world_graph, start_node['id'], end_node['id'])\n\n        if path_node_ids:\n            path_details = []\n            for node_id in path_node_ids:\n                node = next((n for n in world_graph['nodes'] if n['id'] == node_id), None)\n                if node:\n                    path_details.append({'map_id': node['map_id'], 'name': node['name'], 'x': node['coordinates']['x'], 'y': node['coordinates']['y']})\n            print(json.dumps({'path_found': True, 'path': path_details}))\n        else:\n            print(json.dumps({'path_found': False, 'path': [], 'error': 'No path found between nodes in World Knowledge Graph.'}))\nexcept Exception as e:\n    print(json.dumps({'path_found': False, 'path': [], 'error': str(e)}))\n"
  },
  "overworld_navigator_tool": {
    "description": "DEPRECATED - DO NOT USE. This tool is currently bugged and produces unreliable paths.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "print('{\"error\": \"This tool is deprecated and buggy. Do not use. Use the standard pathfinder instead.\"}')"
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map using the Breadth-First Search (BFS) algorithm, avoiding impassable tiles and objects. It correctly handles one-way ledge traversal and water tiles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\n\ngrid = {}\nfor r in root.findall('Row'):\n    y = int(r.get('id'))\n    for t in r.findall('Tile'):\n        x = int(t.get('id'))\n        has_impassable_object = False\n        obj_node = t.find('Object')\n        if obj_node is not None and obj_node.get('id-name') != 'Pikachu':\n            has_impassable_object = True\n        grid[(x, y)] = {\n            'type': t.get('type'),\n            'has_object': has_impassable_object\n        }\n\nimpassable_types = ['impassable', 'unknown', 'closed_gate', 'cuttable', 'water']\n\nqueue = deque([((start_x, start_y), [])])\nvisited = {(start_x, start_y)}\n\nwhile queue:\n    (cx, cy), path = queue.popleft()\n\n    if (cx, cy) == (end_x, end_y):\n        final_path = path + [(cx, cy)]\n        json_path = [{'x': p[0], 'y': p[1]} for p in final_path]\n        print(json.dumps({'path_found': True, 'path': json_path}))\n        exit()\n\n    # Explore neighbors\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n        nx, ny = cx + dx, cy + dy\n\n        if not (1 <= nx <= width and 1 <= ny <= height) or (nx, ny) in visited:\n            continue\n\n        current_tile = grid.get((cx, cy))\n        neighbor_tile = grid.get((nx, ny))\n        if not neighbor_tile:\n            continue\n\n        if neighbor_tile['type'] in impassable_types or neighbor_tile['has_object']:\n            continue\n\n        # Ledge logic: you can't move up onto a ledge\n        if neighbor_tile['type'] == 'ledge' and dy == -1:\n            continue\n\n        visited.add((nx, ny))\n        new_path = path + [(cx, cy)]\n        queue.append(((nx, ny), new_path))\n\nprint(json.dumps({'path_found': False, 'path': []}))"
  },
  "select_battle_option": {
    "description": "Calculates and executes the button presses needed to select a specific option from the main battle menu (FIGHT, PKMN, ITEM, RUN).",
    "input_schema": {
      "type": "object",
      "properties": {
        "option_to_select": {
          "type": "string",
          "enum": [
            "FIGHT",
            "PKMN",
            "ITEM",
            "RUN"
          ]
        }
      },
      "required": [
        "option_to_select"
      ]
    },
    "python_script": "option = input_data['option_to_select']\noptions = [\"FIGHT\", \"PKMN\", \"ITEM\", \"RUN\"]\ncurrent_pos = 0 # Assume cursor starts on FIGHT\npresses = []\ntarget_pos = options.index(option)\n# Simplified logic: Assume cursor moves right and down\nif target_pos == 1: # PKMN\n    presses.append('Right')\nelif target_pos == 2: # ITEM\n    presses.append('Down')\nelif target_pos == 3: # RUN\n    presses.append('Right')\n    presses.append('Down')\npresses.append('A')\nimport json\nprint(json.dumps(presses))"
  },
  "map_segment_analyzer": {
    "description": "Analyzes the current map segment to find all reachable tiles, warps, and objects from the player's current position.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\nimport traceback\n\ndef get_tile(root, x, y):\n    # Helper to get a tile, returns None if not found\n    for row in root.findall('Row'):\n        if row.get('id') == str(y):\n            for tile in row.findall('Tile'):\n                if tile.get('id') == str(x):\n                    return tile\n    return None\n\ndef is_traversable(tile, has_surf=False):\n    if tile is None:\n        return False\n    tile_type = tile.get('type')\n    if tile.find('Object') is not None:\n        obj = tile.find('Object')\n        if obj.get('id-name') == 'Pikachu':\n            return True # Pikachu is traversable\n        return False # Other objects are not\n    \n    traversable_types = ['ground', 'grass', 'cleared_boulder_barrier', 'open_gate', 'teleport', 'hole', 'ladder_up', 'ladder_down', 'steps']\n    if has_surf:\n        traversable_types.append('water')\n    \n    traversable_types.extend(['spinner_up', 'spinner_down', 'spinner_left', 'spinner_right', 'spinner_stop'])\n    \n    return tile_type in traversable_types\n\ndef analyze_segment(map_xml_string, start_x, start_y):\n    try:\n        root = ET.fromstring(map_xml_string)\n        start_x = int(start_x)\n        start_y = int(start_y)\n        \n        start_node = None\n        for row in root.findall('Row'):\n            if row.get('id') == str(start_y):\n                for tile in row.findall('Tile'):\n                    if tile.get('id') == str(start_x):\n                        start_node = tile\n                        break\n            if start_node is not None:\n                break\n\n        if start_node is None:\n            return json.dumps({\"error\": f\"Start tile ({start_x},{start_y}) not found.\"})\n\n        queue = deque([(start_x, start_y)])\n        visited = set([(start_x, start_y)])\n        \n        reachable_tiles = []\n        reachable_warps = []\n        reachable_objects = []\n\n        while queue:\n            current_x, current_y = queue.popleft()\n            \n            reachable_tiles.append({'x': current_x, 'y': current_y})\n            \n            current_tile_node = get_tile(root, current_x, current_y)\n            if current_tile_node is None:\n                continue\n\n            if current_tile_node.get('is-warp') == 'true':\n                warp_info = {'x': current_x, 'y': current_y}\n                if warp_info not in reachable_warps:\n                    reachable_warps.append(warp_info)\n\n            obj_node = current_tile_node.find('Object')\n            if obj_node is not None:\n                obj_info = {\n                    'id': obj_node.get('id'),\n                    'id-name': obj_node.get('id-name'),\n                    'name': obj_node.get('name'),\n                    'x': current_x,\n                    'y': current_y\n                }\n                if obj_info not in reachable_objects:\n                    reachable_objects.append(obj_info)\n            \n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                next_x, next_y = current_x + dx, current_y + dy\n                \n                if (next_x, next_y) not in visited:\n                    visited.add((next_x, next_y))\n                    neighbor_tile = get_tile(root, next_x, next_y)\n                    \n                    current_tile_type = current_tile_node.get('type')\n                    neighbor_tile_type = neighbor_tile.get('type') if neighbor_tile is not None else None\n                    \n                    is_ledge_jump = (dy == 1 and current_tile_type == 'ledge')\n                    is_moving_into_ledge_from_side = (dx != 0 and neighbor_tile_type == 'ledge')\n                    is_moving_into_ledge_from_below = (dy == -1 and neighbor_tile_type == 'ledge')\n\n                    if is_moving_into_ledge_from_side or is_moving_into_ledge_from_below:\n                        continue\n\n                    if is_ledge_jump:\n                        landing_x, landing_y = next_x, next_y + 1\n                        if (landing_x, landing_y) not in visited:\n                             landing_tile = get_tile(root, landing_x, landing_y)\n                             if is_traversable(landing_tile):\n                                 visited.add((landing_x, landing_y))\n                                 queue.append((landing_x, landing_y))\n                        continue\n\n                    if is_traversable(neighbor_tile):\n                        queue.append((next_x, next_y))\n\n        result = {\n            \"reachable_tiles_count\": len(reachable_tiles),\n            \"reachable_warps\": reachable_warps,\n            \"reachable_objects\": reachable_objects,\n            \"segment_size\": len(visited)\n        }\n        \n        return json.dumps(result, indent=2)\n\n    except Exception as e:\n        return json.dumps({\"error\": str(e), \"traceback\": traceback.format_exc()})\n\nprint(analyze_segment(map_xml_string, input_data['start_x'], input_data['start_y']))"
  }
}