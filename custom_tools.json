{
  "find_reachable_unseen_tiles": {
    "description": "Analyzes the current map to find all unseen tiles that are adjacent to seen, traversable tiles and determines which of them are actually reachable from the player's current position. Outputs a JSON list of coordinate dictionaries for reachable unseen tiles.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef find_reachable_unseen_tiles():\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.get('width'))\n    map_height = int(root.get('height'))\n    \n    grid = {}\n    all_tiles = []\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tile_type = tile.get('type')\n            seen = tile.get('seen') == 'true'\n            is_impassable = tile_type in ['WALL', 'WATER', 'COUNTER', 'HEADBUTT_TREE', 'CUT_TREE'] or tile.find('Object') is not None\n            grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable, 'seen': seen}\n            all_tiles.append((x, y))\n    \n    player_tile = root.find('.//Player/..')\n    if player_tile is None:\n        print(json.dumps([]))\n        return\n    start_x = int(player_tile.get('id'))\n    start_y = int(player_tile.get('coordinate').split(',')[1].strip(')'))\n\n    unseen_adj_tiles = set()\n    for x, y in all_tiles:\n        if not grid[(x,y)]['seen']:\n            for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                adj_x, adj_y = x + dx, y + dy\n                if grid.get((adj_x, adj_y)) and grid[(adj_x, adj_y)]['seen'] and not grid[(adj_x, adj_y)]['impassable']:\n                    unseen_adj_tiles.add((x, y))\n                    break\n\n    reachable_unseen = []\n    for tx, ty in unseen_adj_tiles:\n        queue = deque([((start_x, start_y), [])])\n        visited = {(start_x, start_y)}\n        path_found = False\n        \n        targets = []\n        target_tile_info = grid.get((tx, ty))\n        if target_tile_info and not target_tile_info['impassable']:\n            targets.append((tx, ty))\n        else:\n            for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                adj_x, adj_y = tx + dx, ty + dy\n                if grid.get((adj_x, adj_y)) and not grid[(adj_x, adj_y)]['impassable']:\n                    targets.append((adj_x, adj_y))\n        \n        if not targets:\n            continue\n\n        while queue:\n            (current_x, current_y), path = queue.popleft()\n            if (current_x, current_y) in targets:\n                reachable_unseen.append({'x': tx, 'y': ty})\n                path_found = True\n                break\n            \n            if path_found:\n                break\n\n            for move, dx, dy in [('Up', 0, -1), ('Down', 0, 1), ('Left', -1, 0), ('Right', 1, 0)]:\n                next_x, next_y = current_x + dx, current_y + dy\n                if not (1 <= next_x <= map_width and 1 <= next_y <= map_height) or (next_x, next_y) in visited:\n                    continue\n                next_tile_info = grid.get((next_x, next_y))\n                if not next_tile_info or next_tile_info['impassable']:\n                    continue\n                next_tile_type = next_tile_info.get('type')\n                if (next_tile_type == 'LEDGE_HOP_DOWN' and move == 'Up') or \\\n                   (next_tile_type == 'LEDGE_HOP_LEFT' and move == 'Right') or \\\n                   (next_tile_type == 'LEDGE_HOP_RIGHT' and move == 'Left'):\n                    continue\n                visited.add((next_x, next_y))\n                new_path = path + [(next_x, next_y)]\n                queue.append(((next_x, next_y), new_path))\n\n    print(json.dumps(reachable_unseen))\n\nfind_reachable_unseen_tiles()",
    "history": [
      {
        "commit_message": "feat: Create tool to find reachable unseen tiles. This tool performs a BFS from the player's position to every unseen tile that is adjacent to a seen, traversable tile. This will automate exploration and ensure no paths are missed.",
        "timestamp": "2025-07-23T08:08:37.279Z",
        "action_counter": 1217
      }
    ]
  },
  "find_path_to_target": {
    "description": "Finds the shortest path from the player's current position to a specified target coordinate using a Breadth-First Search algorithm. It correctly handles one-way ledges and will find a path to a tile adjacent to the target if the target itself is impassable.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef find_path_to_target():\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.get('width'))\n    map_height = int(root.get('height'))\n\n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tile_type = tile.get('type')\n            is_impassable = tile_type in ['WALL', 'WATER', 'COUNTER', 'HEADBUTT_TREE', 'CUT_TREE'] or tile.find('Object') is not None\n            grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n\n    player_tile = root.find('.//Player/..')\n    if not player_tile:\n        print(json.dumps([]))\n        return\n    start_x = int(player_tile.get('id'))\n    start_y = int(player_tile.get('coordinate').split(',')[1].strip(')'))\n    \n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n\n    queue = deque([[(start_x, start_y)]])\n    visited = {(start_x, start_y)}\n\n    while queue:\n        path = queue.popleft()\n        current_x, current_y = path[-1]\n\n        if current_x == target_x and current_y == target_y:\n            print(json.dumps([{'x': p[0], 'y': p[1]} for p in path]))\n            return\n        \n        is_target_impassable = grid.get((target_x, target_y), {'impassable': True})['impassable']\n        if is_target_impassable:\n            if abs(current_x - target_x) + abs(current_y - target_y) == 1:\n                 print(json.dumps([{'x': p[0], 'y': p[1]} for p in path]))\n                 return\n\n        for move, dx, dy in [('Up', 0, -1), ('Down', 0, 1), ('Left', -1, 0), ('Right', 1, 0)]:\n            next_x, next_y = current_x + dx, current_y + dy\n\n            if (next_x, next_y) in visited:\n                continue\n\n            next_tile_info = grid.get((next_x, next_y))\n            if not next_tile_info or next_tile_info['impassable']:\n                continue\n            \n            next_tile_type = next_tile_info.get('type')\n            if (next_tile_type == 'LEDGE_HOP_DOWN' and move == 'Up') or \\\n               (next_tile_type == 'LEDGE_HOP_LEFT' and move == 'Right') or \\\n               (next_tile_type == 'LEDGE_HOP_RIGHT' and move == 'Left'):\n                continue\n\n            new_path = list(path)\n            new_path.append((next_x, next_y))\n            visited.add((next_x, next_y))\n            queue.append(new_path)\n\n    print(json.dumps([]))\n\nfind_path_to_target()",
    "history": [
      {
        "commit_message": "feat: Create new pathfinding tool. This tool, `find_path_to_target`, replaces the old, buggy `find_path` tool. It uses a standard Breadth-First Search (BFS) algorithm to find the shortest path, properly handles one-way ledges, and can path to a tile adjacent to the target if the destination itself is blocked. This provides a more robust and reliable foundation for navigation.",
        "timestamp": "2025-07-23T08:07:27.131Z",
        "action_counter": 1215
      },
      {
        "commit_message": "refactor: Replace buggy pathfinder with a new, standard BFS implementation. The previous versions had a persistent, unidentified bug that caused pathing failures even on valid routes. This complete rewrite uses a textbook BFS algorithm to ensure reliability and correctness for future navigation.",
        "timestamp": "2025-07-23T08:10:32.846Z",
        "action_counter": 1220
      }
    ]
  }
}