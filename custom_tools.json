{
  "landmass_analyzer": {
    "description": "Analyzes the map to identify all disconnected, traversable landmasses. Helps diagnose navigation puzzles and prevent getting stuck in isolated areas.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ndef get_neighbors(x, y, width, height):\n    neighbors = []\n    if x > 1: neighbors.append((x - 1, y))\n    if x < width: neighbors.append((x + 1, y))\n    if y > 1: neighbors.append((x, y - 1))\n    if y < height: neighbors.append((x, y + 1))\n    return neighbors\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\n\ntile_data = {}\nfor row in root.findall('Row'):\n    y = int(row.get('id'))\n    for tile in row.findall('Tile'):\n        x = int(tile.get('id'))\n        tile_data[(x, y)] = tile\n\nplayer_pos = None\nfor (x, y), tile in tile_data.items():\n    if tile.find('Player') is not None:\n        player_pos = (x, y)\n        break\n\ntraversable_types = {'ground', 'grass', 'elevated_ground', 'steps', 'cleared_boulder_barrier', 'boulder_switch', 'ladder_up', 'ladder_down'}\ntraversable_nodes = set()\nfor (x, y), tile in tile_data.items():\n    if tile.get('type') in traversable_types and tile.find('Object[@id!=\\\"15\\\"]') is None and tile.find('Boulder') is None:\n        traversable_nodes.add((x, y))\n\nlandmasses = []\nvisited = set()\n\nfor node in traversable_nodes:\n    if node not in visited:\n        current_landmass = set()\n        q = [node]\n        visited.add(node)\n        while q:\n            curr_x, curr_y = q.pop(0)\n            current_landmass.add((curr_x, curr_y))\n            for nx, ny in get_neighbors(curr_x, curr_y, width, height):\n                if (nx, ny) in traversable_nodes and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    q.append((nx, ny))\n        landmasses.append(sorted(list(current_landmass)))\n\nplayer_landmass_id = -1\nif player_pos:\n    for i, mass in enumerate(landmasses):\n        if player_pos in mass:\n            player_landmass_id = i\n            break\n\nresult = {\n    'player_landmass_id': player_landmass_id,\n    'total_landmasses': len(landmasses),\n    'landmasses': landmasses\n}\n\nprint(json.dumps(result))",
    "history": [
      {
        "commit_message": "feat: Create landmass_analyzer tool. This tool identifies disconnected traversable areas on a map, which will prevent getting stuck in navigational loops like the one experienced on Victory Road 2F. This directly addresses an Overwatch critique and improves long-term strategic navigation.",
        "timestamp": "2025-08-06T05:09:44.480Z",
        "action_counter": 123572
      }
    ]
  },
  "puzzle_input_generator": {
    "description": "Parses the current map's XML to generate the correct JSON input for the puzzle_strategist_agent, targeting a specific switch.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntarget_x = int(input_data['target_x'])\ntarget_y = int(input_data['target_y'])\n\nroot = ET.fromstring(map_xml_string)\n\nplayer_pos = None\nboulders = []\nswitches = []\nbarriers = []\nimpassable_tiles = []\n\nfor row in root.findall('Row'):\n    y = int(row.get('id'))\n    for tile in row.findall('Tile'):\n        x = int(tile.get('id'))\n        coord = {'x': x, 'y': y}\n\n        if tile.find('Player') is not None:\n            player_pos = coord\n        if tile.find('Boulder') is not None:\n            boulders.append(coord)\n        if tile.get('type') == 'boulder_switch':\n            switches.append(coord)\n        if tile.get('type') == 'boulder_barrier':\n            barriers.append(coord)\n        if tile.get('type') == 'impassable':\n            impassable_tiles.append(coord)\n\nagent_call = {\n    'tool_name': 'puzzle_strategist_agent',\n    'tool_args': [\n        {'name': 'player_pos', 'value': json.dumps(player_pos)},\n        {'name': 'boulders', 'value': json.dumps(boulders)},\n        {'name': 'switches', 'value': json.dumps(switches)},\n        {'name': 'barriers', 'value': json.dumps(barriers)},\n        {'name': 'impassable_tiles', 'value': json.dumps(impassable_tiles)},\n        {'name': 'target_switch', 'value': json.dumps({'x': target_x, 'y': target_y})},\n        {'name': 'solved_switches', 'value': '[]'},\n        {'name': 'system_directive', 'value': json.dumps('You are on a map with a boulder puzzle. Your progress is likely blocked by a boulder barrier elsewhere. To proceed, you MUST attempt to solve the puzzle.')},\n        {'name': 'notepad_content', 'value': json.dumps(\"\")} # Placeholder, user should provide this\n    ]\n}\n\nprint(json.dumps(agent_call, indent=2))",
    "history": [
      {
        "commit_message": "feat: Create puzzle_input_generator tool. This tool automates the repetitive task of parsing the map XML to gather all necessary data (player position, boulders, switches, etc.) and formats it into the correct JSON structure required to call the `puzzle_strategist_agent`. This was identified as a key process improvement during self-reflection, as it streamlines puzzle-solving and reduces the chance of manual error.",
        "timestamp": "2025-08-06T07:21:26.855Z",
        "action_counter": 123715
      },
      {
        "commit_message": "fix: Correct a syntax error in the agent_call dictionary. The `notepad_content` value was an unterminated string, causing a Python `SyntaxError`. This has been corrected to use `json.dumps(\"\")` for a valid empty string placeholder.",
        "timestamp": "2025-08-06T07:23:13.766Z",
        "action_counter": 123717
      }
    ]
  }
}