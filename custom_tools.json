{
  "find_path": {
    "description": "Finds a path from the player's current position to a target coordinate on the current map using BFS. Returns a list of coordinate dictionaries, or a list of button strings if autopress_buttons is true. If the target is impassable, it finds a path to an adjacent traversable tile. Handles 'unseen' tiles as potentially walkable for exploration. Correctly handles one-way ledge mechanics.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "description": "If true and the tool returns a list of buttons, they will be pressed automatically.",
          "type": "boolean"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y",
        "autopress_buttons"
      ],
      "type": "object"
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\nimport json\n\ndef solve():\n    try:\n        if not map_xml_string:\n            print(\"Error: map_xml_string is empty.\")\n            return\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        print(f\"Error parsing XML: {e}\")\n        return\n\n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n        autopress = input_data.get('autopress_buttons', False)\n    except (KeyError, ValueError) as e:\n        print(f\"Error in input data: {e}\")\n        return\n    \n    tiles = {}\n    start_x, start_y = None, None\n    for row in root.findall('Row'):\n        row_id_attr = row.attrib.get('id')\n        if row_id_attr is None: continue\n        y = int(row_id_attr)\n        for tile in row.findall('Tile'):\n            tile_id_attr = tile.attrib.get('id')\n            if tile_id_attr is None: continue\n            x = int(tile_id_attr)\n            tiles[(x, y)] = tile\n            if tile.find('Player') is not None:\n                start_x, start_y = x, y\n    \n    if start_x is None:\n        print(\"Error: Player position not found in XML.\")\n        return\n    \n    queue = collections.deque([(start_x, start_y, [{\"x\": start_x, \"y\": start_y}])])\n    visited = set([(start_x, start_y)])\n    reachable = {}\n    \n    impassable_types = [\"WALL\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"WATER\", \"BOOKSHELF\", \"WINDOW\", \"TRASHCAN\", \"PC\", \"BOOKSHELVES\", \"VOID\"]\n    \n    while queue:\n        x, y, path = queue.popleft()\n        reachable[(x, y)] = path\n        if x == target_x and y == target_y:\n            break\n            \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) in visited: continue\n            \n            tile = tiles.get((nx, ny))\n            if tile is None: continue\n            \n            tile_type = tile.attrib.get('type', 'unseen')\n            \n            # Ledge check: Ledges are impassable barriers UNLESS jumped in the correct direction.\n            if \"LEDGE\" in tile_type:\n                can_jump = False\n                if tile_type == \"LEDGE_HOP_DOWN\" and dy == 1: can_jump = True\n                elif tile_type == \"LEDGE_HOP_UP\" and dy == -1: can_jump = True\n                elif tile_type == \"LEDGE_HOP_LEFT\" and dx == -1: can_jump = True\n                elif tile_type == \"LEDGE_HOP_RIGHT\" and dx == 1: can_jump = True\n                \n                if can_jump:\n                    # Jumping takes you to the tile AFTER the ledge\n                    lx, ly = nx + dx, ny + dy\n                    landing_tile = tiles.get((lx, ly))\n                    if landing_tile is not None:\n                        landing_type = landing_tile.attrib.get('type', 'unseen')\n                        if landing_type not in impassable_types and landing_tile.attrib.get('has-object') != 'true' and (lx, ly) not in visited:\n                            visited.add((nx, ny))\n                            visited.add((lx, ly))\n                            new_path = path + [{\"x\": nx, \"y\": ny}, {\"x\": lx, \"y\": ly}]\n                            queue.append((lx, ly, new_path))\n                continue\n\n            # Standard collision check\n            if tile_type in impassable_types or tile.attrib.get('has-object') == 'true':\n                continue\n\n            visited.add((nx, ny))\n            queue.append((nx, ny, path + [{\"x\": nx, \"y\": ny}]))\n            \n    final_path = reachable.get((target_x, target_y))\n    \n    if final_path is None:\n        best_dist = float('inf')\n        for (rx, ry), rpath in reachable.items():\n            dist = abs(rx - target_x) + abs(ry - target_y)\n            if dist < best_dist:\n                best_dist = dist\n                final_path = rpath\n                \n    if final_path is None:\n        print(\"Error: No reachable tiles found.\")\n        return\n\n    if autopress:\n        buttons = []\n        for i in range(len(final_path) - 1):\n            curr = final_path[i]\n            next_t = final_path[i+1]\n            if next_t['x'] > curr['x']: buttons.append(\"Right\")\n            elif next_t['x'] < curr['x']: buttons.append(\"Left\")\n            elif next_t['y'] > curr['y']: buttons.append(\"Down\")\n            elif next_t['y'] < curr['y']: buttons.append(\"Up\")\n        print(json.dumps(buttons))\n    else:\n        print(json.dumps(final_path))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-17T22:12:33.740Z",
        "action_counter": 34
      },
      {
        "commit_message": "Refined find_path to handle impassable targets by finding a path to an adjacent tile, and improved collision detection.",
        "timestamp": "2025-12-17T22:15:22.920Z",
        "action_counter": 41
      },
      {
        "commit_message": "Refined find_path to correctly handle impassable targets and improved error reporting.",
        "timestamp": "2025-12-17T22:54:25.130Z",
        "action_counter": 116
      },
      {
        "commit_message": "Updated find_path to support autopress_buttons by returning a JSON array of button strings.",
        "timestamp": "2025-12-17T22:56:11.542Z",
        "action_counter": 121
      },
      {
        "commit_message": "Fixing script to use injected input_data and handle impassable targets by searching for the nearest reachable tile.",
        "timestamp": "2025-12-17T23:01:40.135Z",
        "action_counter": 132
      },
      {
        "commit_message": "Refining find_path to avoid using the '..' selector, which may not be supported, and improving overall robustness.",
        "timestamp": "2025-12-17T23:03:24.005Z",
        "action_counter": 134
      },
      {
        "commit_message": "Further refining find_path for robustness and better error handling. Added more debug prints.",
        "timestamp": "2025-12-17T23:07:19.867Z",
        "action_counter": 143
      },
      {
        "commit_message": "Refining find_path to treat 'unseen' tiles as potentially walkable to better support exploration.",
        "timestamp": "2025-12-17T23:19:28.275Z",
        "action_counter": 151
      },
      {
        "commit_message": "Refining find_path to include 'CUT_TREE' as impassable and ensuring 'unseen' is NOT in the impassable list to support exploration.",
        "timestamp": "2025-12-17T23:21:37.089Z",
        "action_counter": 153
      },
      {
        "commit_message": "Refining find_path to correctly handle LEDGE tiles. Ledges are impassable unless jumped from the specific direction allowed by their type. Added logic to detect the player's approach direction and allow traversal only for valid ledge jumps.",
        "timestamp": "2025-12-17T23:24:36.242Z",
        "action_counter": 157
      },
      {
        "commit_message": "Refining find_path to properly distinguish between entering a ledge tile and jumping over it. Ledge tiles are now strictly impassable from any direction EXCEPT the valid approach direction, in which case they trigger a two-tile jump.",
        "timestamp": "2025-12-17T23:26:39.479Z",
        "action_counter": 159
      }
    ]
  }
}