{
  "interact_with_tile_v1": {
    "description": "Navigates to a specific tile on the current map and interacts with it using the A button. Useful for cutting trees, talking to NPCs behind counters, or interacting with objects. Uses BFS for pathfinding.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import json\nfrom collections import deque\nimport xml.etree.ElementTree as ET\n\ndef solve():\n    try:\n        data = input_data\n        target_x = int(data['target_x'])\n        target_y = int(data['target_y'])\n        \n        root = ET.fromstring(map_xml_string)\n        width = int(root.attrib['width'])\n        height = int(root.attrib['height'])\n        \n        grid = [[False for _ in range(width)] for _ in range(height)]\n        player_pos = None\n        \n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                t_type = tile.attrib['type']\n                \n                if tile.find('Player') is not None:\n                    player_pos = (x, y)\n                \n                # Check traversability\n                walkable_types = ['FLOOR', 'TALL_GRASS', 'GATEHOUSE_FLOOR', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'WARP_CARPET_UP', 'WARP_CARPET_DOWN']\n                is_walkable = t_type in walkable_types\n                \n                # Objects and warps act as walls for pathfinding to interaction points\n                if tile.find('Object') is not None or tile.attrib.get('is-warp') == 'true':\n                    is_walkable = False\n                \n                # The target tile itself might be an object (like a tree), but we need to stand ADJACENT to it.\n                # So we treat the target as non-walkable.\n                if x == target_x and y == target_y:\n                    is_walkable = False\n                    \n                grid[y][x] = is_walkable\n\n        if not player_pos:\n            print(json.dumps([]))\n            return\n\n        queue = deque([(player_pos, [])])\n        visited = {player_pos}\n        \n        while queue:\n            (curr_x, curr_y), path = queue.popleft()\n            \n            # Check if adjacent to target\n            if abs(curr_x - target_x) + abs(curr_y - target_y) == 1:\n                final_btn = \"\"\n                if target_x > curr_x: final_btn = \"Right\"\n                elif target_x < curr_x: final_btn = \"Left\"\n                elif target_y > curr_y: final_btn = \"Down\"\n                elif target_y < curr_y: final_btn = \"Up\"\n                \n                print(json.dumps(path + [final_btn, \"A\"]))\n                return\n            \n            for dx, dy, btn in [(0, -1, \"Up\"), (0, 1, \"Down\"), (-1, 0, \"Left\"), (1, 0, \"Right\")]:\n                nx, ny = curr_x + dx, curr_y + dy\n                if 0 <= nx < width and 0 <= ny < height and grid[ny][nx] and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append(((nx, ny), path + [btn]))\n\n        print(json.dumps([]))\n    except Exception as e:\n        print(json.dumps([f\"Error: {str(e)}\"]))\n\nsolve()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-27T19:51:30.216Z",
        "action_counter": 26672
      }
    ]
  },
  "find_path_v10": {
    "description": "Improved pathfinding that treats HEADBUTT_TREE and CUT_TREE as impassable and handles surfing transitions. Returns a JSON array of button strings.",
    "input_schema": {
      "properties": {
        "can_cut": {
          "default": true,
          "type": "boolean"
        },
        "can_surf": {
          "default": true,
          "type": "boolean"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        }
      },
      "required": [
        "end_x",
        "end_y"
      ],
      "type": "object"
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\n# input_data is provided by the harness\ntarget_x = int(input_data['end_x'])\ntarget_y = int(input_data['end_y'])\ncan_surf = input_data.get('can_surf', True)\n\nroot = ET.fromstring(map_xml_string)\ngrid = {}\nstart_pos = None\nfor row in root.findall('Row'):\n    y = int(row.get('id'))\n    for tile in row.findall('Tile'):\n        x = int(tile.get('id'))\n        t_type = tile.get('type')\n        seen = tile.get('seen') == 'true'\n        is_warp = tile.get('is-warp') == 'true'\n        has_obj = tile.get('has-object') == 'true'\n        if tile.find('Player') is not None:\n            start_pos = (x, y)\n        grid[(x, y)] = {'has_obj': has_obj, 'is_warp': is_warp, 'seen': seen, 'type': t_type}\n\nif not start_pos:\n    print('[]')\nelse:\n    impassable = {'WALL', 'HEADBUTT_TREE', 'CUT_TREE', 'BUOY', 'LEDGE_HOP_DOWN'}\n\n    # Detect initial surfing state based on player's current tile\n    initial_surfing = grid[start_pos]['type'] == 'WATER'\n\n    queue = deque([(start_pos[0], start_pos[1], [], initial_surfing)])\n    visited = set()\n\n    found = False\n    while queue:\n        x, y, path, surfing = queue.popleft()\n        if (x, y, surfing) in visited: continue\n        visited.add((x, y, surfing))\n\n        if x == target_x and y == target_y:\n            print(json.dumps(path))\n            found = True\n            break\n\n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) not in grid: continue\n            tile = grid[(nx, ny)]\n\n            if not tile['seen']: continue\n            \n            # Allow target tile to have object or warp\n            if (tile['has_obj'] or tile['is_warp']) and (nx != target_x or ny != target_y):\n                continue\n\n            if surfing:\n                if tile['type'] == 'WATER':\n                    queue.append((nx, ny, path + [btn], True))\n                elif tile['type'] in {'FLOOR', 'TALL_GRASS'}:\n                    queue.append((nx, ny, path + [btn], False))\n            else:\n                if tile['type'] == 'WATER' and can_surf:\n                    queue.append((nx, ny, path + [btn, 'A', 'A', btn], True))\n                elif tile['type'] not in impassable:\n                    queue.append((nx, ny, path + [btn], False))\n    if not found:\n        print('[]')",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T03:21:24.968Z",
        "action_counter": 27584
      },
      {
        "commit_message": "Fixing JSON output and logic for start position and target tile.",
        "timestamp": "2025-12-28T03:22:47.944Z",
        "action_counter": 27587
      },
      {
        "commit_message": "Refining pathfinding to correctly detect initial surfing state based on the player's starting tile type.",
        "timestamp": "2025-12-28T03:24:10.152Z",
        "action_counter": 27589
      },
      {
        "commit_message": "Treating CUT_TREE and HEADBUTT_TREE as impassable for navigation.",
        "timestamp": "2025-12-28T03:26:29.057Z",
        "action_counter": 27592
      }
    ]
  },
  "find_path_v11": {
    "description": "Advanced pathfinding tool that handles land-water transitions and avoids obstacles. Uses global map_xml_string.",
    "input_schema": {
      "properties": {
        "can_cut": {
          "default": true,
          "type": "boolean"
        },
        "can_surf": {
          "default": true,
          "type": "boolean"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        }
      },
      "required": [
        "end_x",
        "end_y"
      ],
      "type": "object"
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\nimport json\nimport sys\n\ndef solve():\n    global map_xml_string\n    if 'map_xml_string' not in globals() or not map_xml_string:\n        print(json.dumps([]))\n        return\n\n    input_data = {}\n    try:\n        raw_input = sys.stdin.read()\n        if raw_input:\n            input_data = json.loads(raw_input)\n    except:\n        pass\n        \n    root = ET.fromstring(map_xml_string)\n    if 'end_x' not in input_data or 'end_y' not in input_data:\n        print(json.dumps([]))\n        return\n        \n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    can_cut = input_data.get('can_cut', True)\n    can_surf = input_data.get('can_surf', True)\n    \n    grid = {}\n    player_pos = None\n    \n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            t_type = tile.get('type')\n            has_player = tile.find('Player') is not None\n            has_object = tile.find('Object') is not None\n            \n            if has_player:\n                player_pos = (x, y)\n            \n            grid[(x, y)] = {\n                'type': t_type,\n                'has_object': has_object\n            }\n\n    if player_pos is None:\n        print(json.dumps([]))\n        return\n\n    def get_buttons(path):\n        buttons = []\n        for i in range(len(path) - 1):\n            curr = path[i]\n            nxt = path[i+1]\n            if nxt[0] > curr[0]: buttons.append(\"Right\")\n            elif nxt[0] < curr[0]: buttons.append(\"Left\")\n            elif nxt[1] > curr[1]: buttons.append(\"Down\")\n            elif nxt[1] < curr[1]: buttons.append(\"Up\")\n        return buttons\n\n    queue = collections.deque([(player_pos, [])])\n    visited = {player_pos}\n    \n    impassable_types = {'WALL', 'BUOY', 'COUNTER', 'HEADBUTT_TREE'}\n    \n    while queue:\n        (curr_x, curr_y), path = queue.popleft()\n        \n        if curr_x == end_x and curr_y == end_y:\n            print(json.dumps(get_buttons(path + [(curr_x, curr_y)])))\n            return\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = curr_x + dx, curr_y + dy\n            if (nx, ny) in grid and (nx, ny) not in visited:\n                tile = grid[(nx, ny)]\n                \n                is_blocked = False\n                if tile['type'] in impassable_types: is_blocked = True\n                if tile['type'] == 'CUT_TREE' and not can_cut: is_blocked = True\n                if tile['type'] == 'WATER' and not can_surf: is_blocked = True\n                if tile['has_object'] and (nx != end_x or ny != end_y): is_blocked = True\n                \n                if not is_blocked:\n                    visited.add((nx, ny))\n                    queue.append(((nx, ny), path + [(curr_x, curr_y)]))\n    \n    print(json.dumps([]))\n\nif __name__ == \"__main__\":\n    solve()",
    "history": [
      {
        "commit_message": "Initial version of refined pathfinding tool for land/water transitions.",
        "timestamp": "2025-12-28T06:02:21.601Z",
        "action_counter": 27924
      }
    ]
  },
  "interact_with_tile_v2": {
    "description": "Navigates to and interacts with a target tile. Uses global map_xml_string.",
    "input_schema": {
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ],
      "type": "object"
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\nimport json\nimport sys\n\ndef solve():\n    global map_xml_string\n    if 'map_xml_string' not in globals() or not map_xml_string:\n        print(json.dumps([]))\n        return\n\n    input_data = {}\n    try:\n        raw_input = sys.stdin.read()\n        if raw_input:\n            input_data = json.loads(raw_input)\n    except:\n        pass\n        \n    root = ET.fromstring(map_xml_string)\n    if 'target_x' not in input_data or 'target_y' not in input_data:\n        print(json.dumps([]))\n        return\n        \n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    \n    grid = {}\n    player_pos = None\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            if tile.find('Player') is not None: player_pos = (x, y)\n            grid[(x, y)] = {\n                'type': tile.get('type'),\n                'has_object': tile.find('Object') is not None\n            }\n\n    if player_pos is None:\n        print(json.dumps([]))\n        return\n\n    def get_buttons(path):\n        buttons = []\n        for i in range(len(path) - 1):\n            curr = path[i]\n            nxt = path[i+1]\n            if nxt[0] > curr[0]: buttons.append(\"Right\")\n            elif nxt[0] < curr[0]: buttons.append(\"Left\")\n            elif nxt[1] > curr[1]: buttons.append(\"Down\")\n            elif nxt[1] < curr[1]: buttons.append(\"Up\")\n        return buttons\n\n    queue = collections.deque([(player_pos, [])])\n    visited = {player_pos}\n    impassable = {'WALL', 'BUOY', 'COUNTER', 'HEADBUTT_TREE'}\n    \n    best_path = None\n    best_adj = None\n    \n    while queue:\n        (curr_x, curr_y), path = queue.popleft()\n        \n        if abs(curr_x - target_x) + abs(curr_y - target_y) == 1:\n            best_path = path + [(curr_x, curr_y)]\n            best_adj = (curr_x, curr_y)\n            break\n            \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = curr_x + dx, curr_y + dy\n            if (nx, ny) in grid and (nx, ny) not in visited:\n                tile = grid[(nx, ny)]\n                if tile['type'] in impassable or tile['has_object']: continue\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [(curr_x, curr_y)]))\n                \n    if best_path:\n        buttons = get_buttons(best_path)\n        if target_x > best_adj[0]: buttons.append(\"Right\")\n        elif target_x < best_adj[0]: buttons.append(\"Left\")\n        elif target_y > best_adj[1]: buttons.append(\"Down\")\n        elif target_y < best_adj[1]: buttons.append(\"Up\")\n        buttons.append(\"A\")\n        print(json.dumps(buttons))\n    else:\n        print(json.dumps([]))\n\nif __name__ == \"__main__\":\n    solve()",
    "history": [
      {
        "commit_message": "Initial version of refined interaction tool.",
        "timestamp": "2025-12-28T06:02:21.601Z",
        "action_counter": 27924
      }
    ]
  },
  "get_reachable_unseen_tiles": {
    "description": "Finds all unseen tiles that are directly adjacent to reachable, passable tiles on the current map. Returns a JSON array of coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\n# map_xml_string and input_data are provided by the harness\n\nroot = ET.fromstring(map_xml_string)\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\n\ngrid = {}\nfor row in root.findall('Row'):\n    y = int(row.attrib['id'])\n    for tile in row.findall('Tile'):\n        x = int(tile.attrib['id'])\n        tile_type = tile.attrib['type']\n        seen = tile.attrib['seen'] == 'true'\n        grid[(x, y)] = {'type': tile_type, 'seen': seen}\n        \nreachable = set()\nqueue = deque([(start_x, start_y)])\nvisited = set([(start_x, start_y)])\n\n# Passable types\npassable_types = ['FLOOR', 'TALL_GRASS', 'LONG_GRASS', 'WARP_CARPET', 'WATER', 'ICE', 'WARP_CARPET_DOWN', 'WARP_CARPET_UP', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT']\n\nwhile queue:\n    cx, cy = queue.popleft()\n    reachable.add((cx, cy))\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nx, ny = cx + dx, cy + dy\n        if (nx, ny) in grid and (nx, ny) not in visited:\n            if grid[(nx, ny)]['seen'] and grid[(nx, ny)]['type'] in passable_types:\n                visited.add((nx, ny))\n                queue.append((nx, ny))\n\nunseen_reachable = set()\nfor rx, ry in reachable:\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nx, ny = rx + dx, ry + dy\n        if (nx, ny) in grid and not grid[(nx, ny)]['seen']:\n            unseen_reachable.add((nx, ny))\n\nprint(json.dumps(sorted(list(unseen_reachable))))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T06:20:54.963Z",
        "action_counter": 27975
      },
      {
        "commit_message": "Fixed the tool to execute the logic and print the result properly. Removed function wrapping to ensure execution in the harness environment.",
        "timestamp": "2025-12-28T06:21:58.588Z",
        "action_counter": 27977
      },
      {
        "commit_message": "Added 'ICE' and 'WARP_CARPET_DOWN' to passable types for better exploration.",
        "timestamp": "2025-12-28T07:02:21.682Z",
        "action_counter": 28055
      }
    ]
  }
}