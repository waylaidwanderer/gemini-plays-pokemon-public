{
  "object_finder": {
    "description": "Finds a specific map object by its ID and returns its coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "object_id": {
          "type": "string"
        }
      },
      "required": [
        "object_id"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntarget_id = input_data['object_id']\nroot = ET.fromstring(map_xml_string)\nfound = False\nfor row in root.findall('Row'):\n    y = row.get('id')\n    for tile in row.findall('Tile'):\n        x = tile.get('id')\n        for obj in tile.findall('Object'):\n            if obj.get('id') == target_id:\n                print(json.dumps({'x': x, 'y': y}))\n                found = True\n                break\n        if found:\n            break\n    if found:\n        break\n\nif not found:\n    print(json.dumps({'error': 'Object not found on screen.'}))"
  },
  "pathfinder": {
    "description": "A* pathfinding tool that finds the shortest path between two points on the current map. It takes start and end coordinates, a list of traversable tile types, and returns a sequence of button presses to follow the path. It has improved logic to handle one-way ledges and find paths to tiles adjacent to impassable destinations.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "traversable_tiles": {
          "type": "string",
          "description": "A comma-separated string of tile types that are considered traversable."
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "traversable_tiles"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef to_buttons(path):\n    buttons = []\n    for i in range(len(path) - 1):\n        current_pos = path[i]\n        next_pos = path[i+1]\n        if next_pos[0] > current_pos[0]:\n            buttons.append(\"Right\")\n        elif next_pos[0] < current_pos[0]:\n            buttons.append(\"Left\")\n        elif next_pos[1] > current_pos[1]:\n            buttons.append(\"Down\")\n        elif next_pos[1] < current_pos[1]:\n            buttons.append(\"Up\")\n    return buttons\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    traversable_tiles_str = input_data.get('traversable_tiles', '')\n    traversable_tiles = {tile.strip() for tile in traversable_tiles_str.split(',')}\n\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    tile_data = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id'])\n            tile_type = tile_elem.attrib['type']\n            has_object = tile_elem.attrib.get('has-object') == 'true'\n            tile_data[(x, y)] = {'type': tile_type, 'has_object': has_object}\n\n    start_node = (start_x, start_y)\n    target_node = (end_x, end_y)\n    \n    actual_end_node = None\n    end_node_info = tile_data.get(target_node)\n    \n    if end_node_info and end_node_info['type'] in traversable_tiles and not end_node_info['has_object']:\n        actual_end_node = target_node\n    else:\n        potential_ends = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_node = (target_node[0] + dx, target_node[1] + dy)\n            adj_info = tile_data.get(adj_node)\n            if adj_info and adj_info['type'] in traversable_tiles and not adj_info['has_object']:\n                dist = abs(adj_node[0] - start_node[0]) + abs(adj_node[1] - start_node[1])\n                heapq.heappush(potential_ends, (dist, adj_node))\n        \n        if potential_ends:\n            _, actual_end_node = heapq.heappop(potential_ends)\n\n    if actual_end_node is None:\n        print(json.dumps({\"error\": \"No path found. Destination and all adjacent tiles are unreachable.\"}))\n        exit()\n\n    open_set = []\n    heapq.heappush(open_set, (0, start_node))\n    came_from = {}\n    g_score = {start_node: 0}\n    f_score = {start_node: abs(start_node[0] - actual_end_node[0]) + abs(start_node[1] - actual_end_node[1])}\n\n    path_found = False\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == actual_end_node:\n            path = []\n            temp = current\n            while temp in came_from:\n                path.append(temp)\n                temp = came_from[temp]\n            path.append(start_node)\n            path.reverse()\n            buttons = to_buttons(path)\n            print(json.dumps({\"path\": buttons}))\n            path_found = True\n            break\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n\n            if not (1 <= neighbor[0] <= width and 1 <= neighbor[1] <= height):\n                continue\n\n            neighbor_info = tile_data.get(neighbor)\n            current_info = tile_data.get(current)\n            \n            if not neighbor_info or neighbor_info['has_object'] or neighbor_info['type'] not in traversable_tiles:\n                continue\n\n            # Standard Ledge Logic\n            if neighbor_info['type'] == 'LEDGE_HOP_DOWN' and dy != 1: continue\n            if neighbor_info['type'] == 'LEDGE_HOP_LEFT' and dx != -1: continue\n            if neighbor_info['type'] == 'LEDGE_HOP_RIGHT' and dx != 1: continue\n            if current_info and current_info['type'] == 'LEDGE_HOP_DOWN' and dy == -1: continue\n            if current_info and current_info['type'] == 'LEDGE_HOP_LEFT' and dx == 1: continue\n            if current_info and current_info['type'] == 'LEDGE_HOP_RIGHT' and dx == -1: continue\n            \n            # FLOOR_UP_WALL Logic\n            is_current_fuw = current_info and current_info['type'] == 'FLOOR_UP_WALL'\n            is_neighbor_fuw = neighbor_info['type'] == 'FLOOR_UP_WALL'\n            # Moving TO a FLOOR_UP_WALL from a different tile type\n            if is_neighbor_fuw and not is_current_fuw:\n                if dy != -1: # Can only move UP onto it\n                    continue\n            # Moving FROM a FLOOR_UP_WALL to a different tile type\n            elif is_current_fuw and not is_neighbor_fuw:\n                if dy != 1: # Can only move DOWN off of it\n                    continue\n            # Moving BETWEEN FLOOR_UP_WALL tiles\n            elif is_current_fuw and is_neighbor_fuw:\n                if dy != 0: # Can only move horizontally\n                    continue\n\n            tentative_g_score = g_score.get(current, float('inf')) + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + abs(neighbor[0] - actual_end_node[0]) + abs(neighbor[1] - actual_end_node[1])\n                if neighbor not in [i[1] for i in open_set]:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    \n    if not path_found:\n        print(json.dumps({\"error\": \"No path found.\"}))\nexcept Exception as e:\n    print(json.dumps({\"error\": f\"An error occurred: {e}\"}))"
  },
  "warp_scanner": {
    "description": "Scans the current map XML and returns the coordinates of all warp tiles that do not have a map marker.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    unmarked_warps = []\n    for row_elem in root.findall('Row'):\n        for tile_elem in row_elem.findall('Tile'):\n            is_warp = tile_elem.find('Warp') is not None\n            has_marker = tile_elem.find('Marker') is not None\n            \n            if is_warp and not has_marker:\n                x = int(tile_elem.get('id'))\n                y = int(row_elem.get('id'))\n                unmarked_warps.append([x, y])\n                \n    print(json.dumps({\"unmarked_warps\": unmarked_warps, \"error\": None}))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({\"unmarked_warps\": [], \"error\": f\"An exception occurred: {str(e)}\\n{traceback.format_exc()}\"}))"
  },
  "puzzle_solver_step": {
    "description": "Calculates the next single button press to solve the Ruins of Alph tile puzzle. It takes the current puzzle grid, target grid, cursor position, and whether a piece is being held, and returns the next single D-pad or 'A' button press.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_grid": {
          "type": "string"
        },
        "target_grid": {
          "type": "string"
        },
        "cursor_x": {
          "type": "string"
        },
        "cursor_y": {
          "type": "string"
        },
        "holding_piece": {
          "type": "string"
        },
        "held_piece_id": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "start_grid",
        "target_grid",
        "cursor_x",
        "cursor_y",
        "holding_piece"
      ]
    },
    "python_script": "import json\n\nstart_grid = json.loads(input_data['start_grid'])\ntarget_grid = json.loads(input_data['target_grid'])\ncursor_x = int(input_data['cursor_x'])\ncursor_y = int(input_data['cursor_y'])\nholding_piece = input_data.get('holding_piece', 'false').lower() == 'true'\nheld_piece_id_str = input_data.get('held_piece_id')\nheld_piece_id = int(held_piece_id_str) if held_piece_id_str and held_piece_id_str.isdigit() else None\n\nWIDTH, HEIGHT = 6, 6\ncursor_pos = (cursor_y, cursor_x)\n\ndef find_piece(grid, piece_id):\n    for r, row in enumerate(grid):\n        for c, piece in enumerate(row):\n            if piece == piece_id:\n                return (r, c)\n    return None\n\ndef find_empty_border_slot(grid):\n    for r in range(HEIGHT):\n        if grid[r][0] is None: return (r, 0)\n        if grid[r][WIDTH-1] is None: return (r, WIDTH-1)\n    for c in range(1, WIDTH - 1):\n        if grid[0][c] is None: return (0, c)\n        if grid[HEIGHT-1][c] is None: return (HEIGHT-1, c)\n    return None\n\ncurrent_grid = [row[:] for row in start_grid]\n\nif holding_piece:\n    piece_to_place = held_piece_id\n    target_pos = find_piece(target_grid, piece_to_place)\n    piece_at_target = current_grid[target_pos[0]][target_pos[1]]\n    \n    if cursor_pos == target_pos and piece_at_target is None:\n        print(json.dumps({'next_button': 'A'}))\n    elif cursor_pos == target_pos and piece_at_target is not None:\n        temp_pos = find_empty_border_slot(current_grid)\n        if cursor_pos == temp_pos:\n            print(json.dumps({'next_button': 'A'}))\n        else:\n            dr, dc = temp_pos[0] - cursor_pos[0], temp_pos[1] - cursor_pos[1]\n            if dr > 0: print(json.dumps({'next_button': 'Down'}))\n            elif dr < 0: print(json.dumps({'next_button': 'Up'}))\n            elif dc > 0: print(json.dumps({'next_button': 'Right'}))\n            else: print(json.dumps({'next_button': 'Left'}))\n    else:\n        dr, dc = target_pos[0] - cursor_pos[0], target_pos[1] - cursor_pos[1]\n        if dr > 0: print(json.dumps({'next_button': 'Down'}))\n        elif dr < 0: print(json.dumps({'next_button': 'Up'}))\n        elif dc > 0: print(json.dumps({'next_button': 'Right'}))\n        else: print(json.dumps({'next_button': 'Left'}))\nelse:\n    next_piece_to_move = None\n    for i in range(1, 17):\n        current_pos = find_piece(current_grid, i)\n        target_pos = find_piece(target_grid, i)\n        if current_pos != target_pos:\n            next_piece_to_move = i\n            break\n\n    if next_piece_to_move is None:\n        print(json.dumps({'next_button': 'Start'}))\n    else:\n        piece_pos = find_piece(current_grid, next_piece_to_move)\n        if cursor_pos == piece_pos:\n            print(json.dumps({'next_button': 'A'}))\n        else:\n            dr, dc = piece_pos[0] - cursor_pos[0], piece_pos[1] - cursor_pos[1]\n            if dr > 0: print(json.dumps({'next_button': 'Down'}))\n            elif dr < 0: print(json.dumps({'next_button': 'Up'}))\n            elif dc > 0: print(json.dumps({'next_button': 'Right'}))\n            else: print(json.dumps({'next_button': 'Left'}))"
  }
}