{
  "find_path": {
    "description": "Calculates the shortest path from the player's current position to a target coordinate (x, y) on the current map using a Breadth-First Search algorithm. It avoids impassable tiles like WALLs, WATER, and objects. It also correctly handles one-way ledges.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef find_path_logic():\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.get('width'))\n    map_height = int(root.get('height'))\n    player_tile = root.find('.//Player/..')\n    if player_tile is None:\n        print(\"Error: Player not found on map.\")\n        return\n    start_x = int(player_tile.get('id'))\n    start_y = int(player_tile.get('coordinate').split(',')[1].strip(')'))\n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n    except (KeyError, ValueError):\n        print(\"Error: Invalid or missing target_x/target_y.\")\n        return\n\n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tile_type = tile.get('type')\n            is_impassable = tile_type in ['WALL', 'WATER', 'COUNTER', 'HEADBUTT_TREE', 'CUT_TREE'] or tile.find('Object') is not None\n            grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n\n    queue = deque([((start_x, start_y), [])])\n    visited = {(start_x, start_y)}\n\n    while queue:\n        (current_x, current_y), path = queue.popleft()\n        if (current_x, current_y) == (target_x, target_y):\n            buttons = []\n            last_x, last_y = start_x, start_y\n            for step_x, step_y in path:\n                if step_y < last_y: buttons.append('Up')\n                elif step_y > last_y: buttons.append('Down')\n                elif step_x < last_x: buttons.append('Left')\n                elif step_x > last_x: buttons.append('Right')\n                last_x, last_y = step_x, step_y\n            print(buttons)\n            return\n\n        for move, dx, dy in [('Up', 0, -1), ('Down', 0, 1), ('Left', -1, 0), ('Right', 1, 0)]:\n            next_x, next_y = current_x + dx, current_y + dy\n            if not (1 <= next_x <= map_width and 1 <= next_y <= map_height) or (next_x, next_y) in visited:\n                continue\n\n            next_tile_info = grid.get((next_x, next_y))\n            current_tile_info = grid.get((current_x, current_y))\n            if not next_tile_info or next_tile_info['impassable']:\n                continue\n\n            # Ledge logic\n            if (current_tile_info.get('type') == 'LEDGE_HOP_DOWN' and move != 'Down') or \\\n               (current_tile_info.get('type') == 'LEDGE_HOP_LEFT' and move != 'Left') or \\\n               (current_tile_info.get('type') == 'LEDGE_HOP_RIGHT' and move != 'Right'):\n                continue\n\n            visited.add((next_x, next_y))\n            new_path = path + [(next_x, next_y)]\n            queue.append(((next_x, next_y), new_path))\n\n    print([])\n\nfind_path_logic()"
  }
}