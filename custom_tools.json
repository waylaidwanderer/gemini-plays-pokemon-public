{
  "sequence_press": {
    "description": "Executes a sequence of button presses to navigate menus or perform actions. Allows mixing directional and action buttons.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\ntry:\n    buttons = input_data['buttons']\n    print(json.dumps(buttons))\nexcept KeyError:\n    print(\"Error: 'buttons' key not found in input_data\")\n    print(f\"input_data keys: {input_data.keys()}\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T08:10:06.907Z",
        "action_counter": 33328
      },
      {
        "commit_message": "Initial definition of sequence_press tool",
        "timestamp": "2026-01-11T10:39:20.952Z",
        "action_counter": 33514
      },
      {
        "commit_message": "Debugging tool to find variable injection method",
        "timestamp": "2026-01-11T10:41:14.927Z",
        "action_counter": 33517
      },
      {
        "commit_message": "Fix variable access by using input_data dictionary",
        "timestamp": "2026-01-11T10:43:22.032Z",
        "action_counter": 33520
      }
    ]
  },
  "pathfind": {
    "description": "Finds a path from the player's current position to a target coordinate using BFS. Returns a list of buttons.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\n# Retrieve arguments safely from input_data\ntry:\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    autopress_buttons = bool(input_data.get('autopress_buttons', False))\nexcept (NameError, KeyError, ValueError) as e:\n    print(json.dumps({\"error\": f\"Invalid arguments: {e}\"}))\n    exit()\n\ndef pathfind(target_x, target_y, autopress_buttons=False):\n    # Parse the map XML\n    try:\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        print(json.dumps({\"error\": f\"Error parsing XML: {e}\"}))\n        return []\n\n    # Get map dimensions\n    try:\n        width = int(root.attrib.get('width'))\n        height = int(root.attrib.get('height'))\n    except:\n        return []\n    \n    # Get player position\n    player_pos = None\n    \n    # Build the grid and find player\n    grid = {}\n    \n    for row in root.findall('Row'):\n        try:\n            y = int(row.attrib['id'])\n        except:\n            continue\n            \n        for tile in row.findall('Tile'):\n            try:\n                x = int(tile.attrib['id'])\n            except:\n                continue\n                \n            t_type = tile.attrib.get('type', 'unseen')\n            \n            # Check for player\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n            elif tile.attrib.get('has-player') == 'true':\n                 player_pos = (x, y)\n\n            # Determine walkability\n            walkable = True\n            # Basic blocking types\n            if t_type in ['WALL', 'HEADBUTT_TREE', 'unseen', 'WATER']: \n                walkable = False\n            # Ledges are complicated, treat as obstacles for simple pathfinding unless we want to handle one-way logic\n            if 'LEDGE' in t_type:\n                walkable = False\n                \n            # Check for objects (which act as walls)\n            # Note: We do NOT filter out the target tile if it has an object/warp, \n            # because sometimes we want to path TO an object to interact.\n            # But we can't stand ON it.\n            # For this 'movement' tool, we assume we want to stand on the target.\n            # If target has object, we effectively can't go there.\n            \n            has_object = False\n            if tile.find('Object') is not None:\n                has_object = True\n            if tile.attrib.get('has-object') == 'true':\n                has_object = True\n            \n            if has_object:\n                walkable = False\n\n            grid[(x, y)] = walkable\n\n    if player_pos is None:\n        print(json.dumps({\"error\": \"Player position not found in XML.\"}))\n        return []\n\n    start = player_pos\n    goal = (target_x, target_y)\n\n    if start == goal:\n        return []\n        \n    # Check if goal is walkable according to our strict grid\n    if not grid.get(goal, False):\n        # Optional: Print why it failed for debugging, but return empty list to not break schema\n        # print(f\"Target {goal} is not walkable.\")\n        return []\n\n    # BFS\n    queue = deque([(start, [])])\n    visited = {start}\n    \n    while queue:\n        (cx, cy), path = queue.popleft()\n        \n        if (cx, cy) == goal:\n            return path\n        \n        moves = [\n            (0, -1, 'Up'),\n            (0, 1, 'Down'),\n            (-1, 0, 'Left'),\n            (1, 0, 'Right')\n        ]\n        \n        for dx, dy, direction in moves:\n            nx, ny = cx + dx, cy + dy\n            \n            if 0 <= nx < width and 0 <= ny < height:\n                if grid.get((nx, ny), False):\n                    if (nx, ny) not in visited:\n                        visited.add((nx, ny))\n                        queue.append(((nx, ny), path + [direction]))\n                        \n    # No path found\n    return []\n\nprint(json.dumps(pathfind(target_x, target_y, autopress_buttons)))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T09:01:19.563Z",
        "action_counter": 33384
      },
      {
        "commit_message": "Fixed NameError by using globals().get() to safely retrieve injected arguments. Added autopress_buttons support.",
        "timestamp": "2026-01-11T16:48:12.265Z",
        "action_counter": 34015
      },
      {
        "commit_message": "Refined JSON output compliance using json.dumps to avoid parsing errors.",
        "timestamp": "2026-01-11T16:49:46.390Z",
        "action_counter": 34017
      },
      {
        "commit_message": "Added debug logic to inspect available variables if arguments are missing.",
        "timestamp": "2026-01-11T16:50:53.134Z",
        "action_counter": 34018
      },
      {
        "commit_message": "Updated to retrieve arguments from `input_data` global dictionary.",
        "timestamp": "2026-01-11T16:51:34.865Z",
        "action_counter": 34019
      },
      {
        "commit_message": "Fixed XML parsing logic to correctly iterate Rows and Tiles instead of using unsupported '..' XPath.",
        "timestamp": "2026-01-11T16:52:03.375Z",
        "action_counter": 34020
      },
      {
        "commit_message": "Added WARP_CARPET_* and DOOR types to traversable list.",
        "timestamp": "2026-01-11T17:10:57.545Z",
        "action_counter": 34044
      },
      {
        "commit_message": "Fixing pathfind tool to return valid JSON array on failure instead of an object, preventing schema validation errors.",
        "timestamp": "2026-01-12T04:10:40.878Z",
        "action_counter": 34986
      },
      {
        "commit_message": "Fixed 'pathfind' tool by explicitly accessing 'target_x' and 'target_y' from the 'input_data' dictionary, resolving the NameError.",
        "timestamp": "2026-01-12T04:13:03.377Z",
        "action_counter": 34988
      },
      {
        "commit_message": "Fixed XML parsing, added proper grid construction checking for walls, objects, and ledges, and implemented BFS for shortest path.",
        "timestamp": "2026-01-12T09:14:34.850Z",
        "action_counter": 35403
      },
      {
        "commit_message": "Fixed NameError by explicitly retrieving arguments from the `input_data` dictionary.",
        "timestamp": "2026-01-12T09:15:49.641Z",
        "action_counter": 35405
      }
    ]
  },
  "open_map": {
    "description": "Opens the Pokegear and navigates to the Map card. Assumes the main menu cursor is already on 'POKEGEAR' (last used) and the Pokegear starts at the default 'BACK' position.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "python_script": "print('[\"Start\", \"A\", \"Right\", \"A\"]')",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-12T18:35:50.856Z",
        "action_counter": 36061
      }
    ]
  },
  "route42_gate_shuffle": {
    "description": "Executes the Roamer Shuffle loop on Route 42: Closes Pokegear, enters/exits the Ecruteak Gate, and re-opens the Pokegear directly to the Map view.",
    "input_schema": {
      "type": "object",
      "properties": {
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "autopress_buttons"
      ]
    },
    "python_script": "import json\nprint(json.dumps([\"B\", \"sleep 500\", \"B\", \"sleep 500\", \"Left\", \"sleep 5000\", \"Right\", \"sleep 5000\", \"Start\", \"sleep 500\", \"A\", \"sleep 500\", \"Right\", \"sleep 500\", \"A\"]))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-12T20:22:49.714Z",
        "action_counter": 36226
      },
      {
        "commit_message": "Fixed commit message error. Increased sleep times to 3000ms to ensure reliable warping and added B presses to clear menus.",
        "timestamp": "2026-01-12T20:26:03.884Z",
        "action_counter": 36228
      },
      {
        "commit_message": "Added an extra 'A' press at the end to automatically enter the Map view after opening the Pokegear.",
        "timestamp": "2026-01-12T20:26:39.668Z",
        "action_counter": 36229
      },
      {
        "commit_message": "Increased sleep times to 5000ms to ensure reliable warping, as 3000ms was insufficient.",
        "timestamp": "2026-01-12T20:29:59.154Z",
        "action_counter": 36234
      },
      {
        "commit_message": "Updated to use 'Start, A, Right, A' sequence for opening the Map, correcting the previous 'Start, A, A' which failed to navigate past the 'BACK' option. Maintains 5000ms sleep for warps.",
        "timestamp": "2026-01-12T20:31:24.222Z",
        "action_counter": 36236
      }
    ]
  }
}