{
  "unseen_tile_checker": {
    "description": "Analyzes the list of unseen tiles from a system alert and uses pathfinding logic to determine which are actually reachable from the player's current position.",
    "input_schema": {
      "type": "object",
      "properties": {
        "coordinates": {
          "type": "string",
          "description": "A stringified JSON array of coordinate objects, e.g., '[{\"x\":1,\"y\":2}]'"
        }
      },
      "required": [
        "coordinates"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef parse_map_xml(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    grid = [['unseen' for _ in range(width)] for _ in range(height)]\n    player_pos = None\n    tile_data = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_data[(x, y)] = tile_elem\n    for y_idx in range(height):\n        for x_idx in range(width):\n            x, y = x_idx + 1, y_idx + 1\n            if (x, y) in tile_data:\n                tile_elem = tile_data[(x, y)]\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.find('Object') is not None\n                if has_object:\n                    grid[y_idx][x_idx] = 'WALL'\n                else:\n                    grid[y_idx][x_idx] = tile_type\n                if tile_elem.find('Player') is not None:\n                    player_pos = (x_idx, y_idx)\n    return grid, width, height, player_pos\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(grid, start, goal, width, height, traversable_tiles, one_way_tiles):\n    neighbors = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    close_set = set()\n    came_from = {}\n    gscore = {start: 0}\n    fscore = {start: heuristic(start, goal)}\n    oheap = []\n    heapq.heappush(oheap, (fscore[start], start))\n    while oheap:\n        current = heapq.heappop(oheap)[1]\n        if current == goal:\n            return True\n        close_set.add(current)\n        for i, j in neighbors:\n            neighbor = current[0] + i, current[1] + j\n            if 0 <= neighbor[0] < width and 0 <= neighbor[1] < height:\n                current_tile_type = grid[current[1]][current[0]]\n                neighbor_tile_type = grid[neighbor[1]][neighbor[0]]\n                if current_tile_type in one_way_tiles:\n                    if (i, j) not in one_way_tiles[current_tile_type]: continue\n                is_invalid_move = False\n                for tile, moves in one_way_tiles.items():\n                    if neighbor_tile_type == tile and (-i, -j) not in moves:\n                        is_invalid_move = True\n                        break\n                if is_invalid_move: continue\n                if neighbor_tile_type not in traversable_tiles.union(one_way_tiles.keys()):\n                    continue\n                tentative_g_score = gscore[current] + 1\n                if neighbor in close_set and tentative_g_score >= gscore.get(neighbor, float('inf')):\n                    continue\n                if tentative_g_score < gscore.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    gscore[neighbor] = tentative_g_score\n                    fscore[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                    heapq.heappush(oheap, (fscore[neighbor], neighbor))\n    return False\n\ntraversable = {'FLOOR', 'TALL_GRASS', 'LONG_GRASS', 'DOOR', 'WARP_CARPET_DOWN', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'LADDER'}\none_way = {'LEDGE_HOP_DOWN': [(0, 1)], 'LEDGE_HOP_LEFT': [(-1, 0)], 'LEDGE_HOP_RIGHT': [(1, 0)]}\ngrid, width, height, player_pos = parse_map_xml(map_xml_string)\nif player_pos is None:\n    print(json.dumps({'error': 'Player position not found on the map.'}))\nelse:\n    start_pos = player_pos\n    target_unseen_coords = json.loads(input_data['coordinates'])\n    reachable_unseen_tiles = []\n    for coord in target_unseen_coords:\n        unseen_x, unseen_y = coord['x'], coord['y']\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_x, adj_y = unseen_x + dx, unseen_y + dy\n            adj_grid_x, adj_grid_y = adj_x - 1, adj_y - 1\n            if 0 <= adj_grid_x < width and 0 <= adj_grid_y < height:\n                tile_type = grid[adj_grid_y][adj_grid_x]\n                if tile_type in traversable.union(one_way.keys()):\n                    if a_star_search(grid, start_pos, (adj_grid_x, adj_grid_y), width, height, traversable, one_way):\n                        reachable_unseen_tiles.append(coord)\n                        break\n    print(json.dumps({'reachable_unseen_tiles': reachable_unseen_tiles}))",
    "history": [
      {
        "commit_message": "feat: Create unseen_tile_checker tool. This tool automates the process of checking which unseen tiles from a system alert are actually reachable, streamlining exploration and preventing wasted turns trying to path to disconnected areas.",
        "timestamp": "2025-07-29T03:31:55.070Z",
        "action_counter": 15144
      },
      {
        "commit_message": "feat: Create unseen_tile_checker tool. This tool automates the process of checking which unseen tiles from a system alert are actually reachable, streamlining exploration and preventing wasted turns trying to path to disconnected areas.",
        "timestamp": "2025-07-29T06:52:53.467Z",
        "action_counter": 15273
      },
      {
        "commit_message": "fix: Corrected invalid JSON in input_schema and refined the pathfinding logic to be more robust. The previous attempt failed due to a simple syntax error. This version ensures the tool is defined correctly so that strategic exploration can resume.",
        "timestamp": "2025-07-29T09:53:35.885Z",
        "action_counter": 15436
      }
    ]
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map using the A* algorithm, avoiding obstacles and impassable terrain.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\n\ndef find_path_from_xml(map_xml_string, start_x, start_y, end_x, end_y):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = [['' for _ in range(width + 1)] for _ in range(height + 1)]\n    occupied_tiles = set()\n\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            grid[y][x] = tile.get('type')\n            if tile.find('Object') is not None:\n                occupied_tiles.add((x, y))\n\n    traversable = {'FLOOR', 'TALL_GRASS', 'LONG_GRASS', 'DOOR', 'WARP_CARPET_DOWN', 'LADDER', 'CAVE'}\n    one_way_down = {'LEDGE_HOP_DOWN'}\n    one_way_right = {'LEDGE_HOP_RIGHT'}\n    one_way_left = {'LEDGE_HOP_LEFT'}\n\n    start = (int(start_x), int(start_y))\n    end = (int(end_x), int(end_y))\n\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    open_list = []\n    heapq.heappush(open_list, (0, start))\n    came_from = {}\n    g_score = {start: 0}\n    f_score = {start: heuristic(start, end)}\n\n    while open_list:\n        _, current = heapq.heappop(open_list)\n\n        if current == end:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            return path[::-1]\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            nx, ny = neighbor\n\n            if not (1 <= nx <= width and 1 <= ny <= height):\n                continue\n\n            if neighbor in occupied_tiles:\n                continue\n\n            tile_type = grid[ny][nx]\n            \n            is_valid_move = False\n            if tile_type in traversable:\n                is_valid_move = True\n            elif tile_type in one_way_down and dy == 1:\n                is_valid_move = True\n            elif tile_type in one_way_right and dx == 1:\n                is_valid_move = True\n            elif tile_type in one_way_left and dx == -1:\n                is_valid_move = True\n\n            if not is_valid_move:\n                continue\n\n            tentative_g_score = g_score.get(current, float('inf')) + 1\n\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + heuristic(neighbor, end)\n                heapq.heappush(open_list, (f_score[neighbor], neighbor))\n\n    return None\n\npath = find_path_from_xml(map_xml_string, input_data['start_x'], input_data['start_y'], input_data['end_x'], input_data['end_y'])\n\nif path:\n    path_str = ' -> '.join(map(str, path))\n    print(f\"Path found: {path_str}\")\nelse:\n    print(\"No path found.\")",
    "history": [
      {
        "commit_message": "feat: Create robust pathfinder tool using A* algorithm. This tool is a direct response to repeated navigation failures and system critiques. It correctly handles known traversable and one-way tiles, and will serve as the foundation for all future movement, eliminating inefficient and error-prone manual pathing. This is a critical infrastructure upgrade.",
        "timestamp": "2025-07-29T09:27:18.707Z",
        "action_counter": 15399
      },
      {
        "commit_message": "Re-defining the pathfinder tool. The previous attempts to use it failed due to a sandbox error. Re-defining it is an attempt to resolve this external issue. The code itself remains unchanged.",
        "timestamp": "2025-07-29T09:40:23.317Z",
        "action_counter": 15419
      },
      {
        "commit_message": "fix: Update pathfinder to treat tiles with objects as impassable. The previous version failed to account for NPCs and other objects, leading to invalid paths. This fix correctly identifies and avoids these obstacles.",
        "timestamp": "2025-07-29T09:42:58.171Z",
        "action_counter": 15421
      }
    ]
  }
}