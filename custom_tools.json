{
  "find_closest_unseen_tile": {
    "description": "Finds the closest reachable unseen tile and a reachable adjacent tile to pathfind to. This version correctly handles player movement state (walking/surfing) and various tile types.",
    "input_schema": {
      "type": "object",
      "properties": {
        "party_data": {
          "type": "string"
        },
        "movement_state": {
          "type": "string"
        }
      },
      "required": [
        "party_data",
        "movement_state"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport collections\nimport heapq\n\ndef parse_party_data(party_data_str):\n    try:\n        party_data = json.loads(party_data_str)\n        hms_known = set()\n        for pokemon in party_data:\n            for move in pokemon.get('moves', []):\n                if isinstance(move, dict):\n                    move_name = move.get('name', '').upper()\n                    if move_name == 'CUT':\n                        hms_known.add('cut')\n                    elif move_name == 'SURF':\n                        hms_known.add('surf')\n        return hms_known\n    except (json.JSONDecodeError, TypeError):\n        return set()\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(start, goal, grid, map_width, map_height, hms_known, movement_state):\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {start: 0}\n    f_score = {start: heuristic(start, goal)}\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == goal:\n            return True\n\n        current_tile_info = grid.get(current, {})\n        is_on_ledge = current_tile_info.get('type') == 'ledge'\n        \n        if is_on_ledge:\n            neighbors = [(current[0], current[1] + 1)]\n        else:\n            neighbors = [(current[0] + dx, current[1] + dy) for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]]\n\n        for neighbor in neighbors:\n            if not (1 <= neighbor[0] <= map_width and 1 <= neighbor[1] <= map_height):\n                continue\n\n            neighbor_info = grid.get(neighbor, {})\n            neighbor_type = neighbor_info.get('type')\n            is_neighbor_impassable = neighbor_info.get('impassable', True)\n            \n            if is_neighbor_impassable:\n                continue\n            \n            if neighbor_type == 'ledge' and current[1] != neighbor[1] - 1:\n                continue\n\n            is_neighbor_water = neighbor_type == 'water'\n            is_neighbor_cuttable = neighbor_type == 'cuttable'\n\n            can_move = False\n            if movement_state == 'surfing':\n                if is_neighbor_water or not is_neighbor_impassable:\n                    can_move = True\n            else: # walking\n                if is_neighbor_water:\n                    if 'surf' in hms_known:\n                        can_move = True\n                elif is_neighbor_cuttable:\n                    if 'cut' in hms_known:\n                        can_move = True\n                else:\n                    can_move = True\n            \n            if not can_move:\n                continue\n\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    return False\n\ntry:\n    party_data_str = input_data['party_data']\n    movement_state = input_data['movement_state']\n    hms = parse_party_data(party_data_str)\n    \n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.attrib['width'])\n    map_height = int(root.attrib['height'])\n\n    player_pos = None\n    unseen_tiles = []\n    grid = {}\n\n    for tile in root.findall('.//Tile'):\n        x, y = int(tile.get('id')), int(tile.get('coordinate').split(',')[1].strip(')'))\n        tile_type = tile.get('type')\n        obj = tile.find('Object')\n        is_impassable_obj = obj is not None and obj.get('id-name') != 'Pikachu'\n        is_impassable_tile = tile_type in ['impassable', 'boulder_barrier', 'closed_gate', 'unknown']\n        \n        grid[(x, y)] = {\n            'type': tile_type,\n            'impassable': is_impassable_tile or is_impassable_obj\n        }\n\n        if tile.get('seen') != 'true':\n            unseen_tiles.append((x, y))\n        if tile.find('Player') is not None:\n            player_pos = (x, y)\n\n    if not player_pos:\n        print(json.dumps({'error': 'Player not found.'}))\n    else:\n        reachable_unseen = []\n        for ux, uy in unseen_tiles:\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adj_tile = (ux + dx, uy + dy)\n                if not (1 <= adj_tile[0] <= map_width and 1 <= adj_tile[1] <= map_height):\n                    continue\n                \n                adj_info = grid.get(adj_tile, {})\n                if adj_info.get('impassable') or adj_info.get('type') == 'unknown':\n                    continue\n                \n                if a_star_search(player_pos, adj_tile, grid, map_width, map_height, hms, movement_state):\n                    dist = heuristic(player_pos, adj_tile)\n                    reachable_unseen.append({'unseen': (ux, uy), 'adj': adj_tile, 'dist': dist})\n                    break\n\n        if not reachable_unseen:\n            print(json.dumps({'message': 'No reachable unseen tiles found.'}))\n        else:\n            closest = min(reachable_unseen, key=lambda x: x['dist'])\n            print(json.dumps({\n                'closest_reachable_unseen_tile': {'x': closest['unseen'][0], 'y': closest['unseen'][1]},\n                'adjacent_tile': {'x': closest['adj'][0], 'y': closest['adj'][1]}\n            }))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))"
  },
  "reachable_shoreline_finder": {
    "description": "Analyzes the map_xml_string to identify all reachable water-adjacent ground tiles from the player's current position. This version correctly handles elevation changes via 'steps' tiles.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\n\nroot = ET.fromstring(map_xml_string)\nmap_width = int(root.attrib['width'])\nmap_height = int(root.attrib['height'])\n\ngrid = {}\nplayer_start = None\n\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.attrib['id'])\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.attrib['id'])\n        tile_type = tile_elem.attrib['type']\n        has_object = tile_elem.find('Object') is not None\n        \n        is_impassable = tile_type in ['impassable', 'boulder_barrier', 'closed_gate', 'unknown'] or has_object\n        if has_object and tile_elem.find('Object').attrib.get('id-name') == 'Pikachu':\n            is_impassable = False\n\n        grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n        if tile_elem.find('Player') is not None:\n            player_start = (x, y)\n\nif not player_start:\n    print(\"Error: Player position not found.\")\nelse:\n    queue = collections.deque([player_start])\n    visited = {player_start}\n    \n    # Walkable tiles for BFS. This is the key fix.\n    walkable_types = ['ground', 'elevated_ground', 'steps', 'grass', 'cleared_boulder_barrier', 'boulder_switch', 'open_gate', 'gate_offscreen']\n\n    while queue:\n        cx, cy = queue.popleft()\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            neighbor_coord = (nx, ny)\n            \n            if 1 <= nx <= map_width and 1 <= ny <= map_height and neighbor_coord not in visited:\n                neighbor_tile = grid.get(neighbor_coord, {})\n                if not neighbor_tile.get('impassable') and neighbor_tile.get('type') in walkable_types:\n                    visited.add(neighbor_coord)\n                    queue.append(neighbor_coord)\n\n    shoreline_tiles = []\n    land_types_for_surfing = ['ground', 'elevated_ground', 'steps', 'grass'] # Tiles you can stand on to initiate Surf\n\n    for x, y in sorted(list(visited)):\n        current_tile = grid.get((x,y), {})\n        if current_tile.get('type') in land_types_for_surfing:\n            is_shore = False\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 1 <= nx <= map_width and 1 <= ny <= map_height:\n                    if grid.get((nx, ny), {}).get('type') == 'water':\n                        is_shore = True\n                        break\n            if is_shore:\n                shoreline_tiles.append((x, y))\n\n    if shoreline_tiles:\n        print(f\"Reachable shoreline tiles found: {shoreline_tiles}\")\n    else:\n        print(\"No reachable shoreline tiles found from the current position.\")"
  },
  "robust_pathfinder": {
    "description": "A more robust A* pathfinding tool that can handle mixed movement states (walking/surfing) and avoid specific 'hazard' coordinates. This version includes corrected ledge traversal logic and prevents invalid water entry from elevated ground.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "party_data": {
          "type": "string"
        },
        "hazard_coords": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "target_x",
        "target_y",
        "party_data"
      ]
    },
    "python_script": "\nimport heapq\nimport xml.etree.ElementTree as ET\nimport json\n\ndef parse_party_data(party_data_str):\n    try:\n        party_data = json.loads(party_data_str)\n        hms_known = set()\n        for pokemon in party_data:\n            if not isinstance(pokemon, dict): continue\n            for move in pokemon.get('moves', []):\n                if isinstance(move, dict):\n                    move_name = move.get('name', '').upper()\n                    if move_name == 'CUT': hms_known.add('cut')\n                    elif move_name == 'SURF': hms_known.add('surf')\n                    elif move_name == 'STRENGTH': hms_known.add('strength')\n        return hms_known\n    except (json.JSONDecodeError, TypeError):\n        return set()\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(start, goal, grid, map_width, map_height, hms_known, ledges, movement_state):\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {start: 0}\n    f_score = {start: heuristic(start, goal)}\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            return path[::-1]\n\n        if current in ledges:\n            neighbors = [(current[0], current[1] + 1)]\n        else:\n            neighbors = [(current[0] + dx, current[1] + dy) for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]]\n\n        for neighbor in neighbors:\n            if not (1 <= neighbor[0] <= map_width and 1 <= neighbor[1] <= map_height):\n                continue\n\n            if neighbor in ledges and current[1] != neighbor[1] - 1:\n                continue\n\n            tentative_g_score = g_score[current] + 1\n\n            if tentative_g_score >= g_score.get(neighbor, float('inf')):\n                continue\n\n            current_tile_info = grid.get(current, {})\n            neighbor_tile_info = grid.get(neighbor, {})\n\n            if not neighbor_tile_info or neighbor_tile_info.get('impassable', True):\n                continue\n\n            current_type = current_tile_info.get('type')\n            neighbor_type = neighbor_tile_info.get('type')\n\n            # FIX: Prevent walking into water\n            if movement_state == 'walking' and neighbor_type == 'water':\n                continue\n\n            if neighbor_type == 'water' and current_type not in ['water', 'steps', 'ground']:\n                continue\n\n            is_invalid_elevation_change = False\n            if (current_type == 'elevated_ground' and neighbor_type == 'ground') or \\\n               (current_type == 'ground' and neighbor_type == 'elevated_ground'):\n                if neighbor_type != 'steps' and current_type != 'steps':\n                    is_invalid_elevation_change = True\n            \n            if is_invalid_elevation_change:\n                continue\n\n            came_from[neighbor] = current\n            g_score[neighbor] = tentative_g_score\n            f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n            heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    return None\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.get('width'))\n    map_height = int(root.get('height'))\n    \n    player_pos = None\n    movement_state = 'walking' # Default to walking\n    grid = {}\n    ledges = set()\n\n    for tile in root.findall('.//Tile'):\n        x, y = int(tile.get('id')), int(tile.get('coordinate').split(',')[1].strip(')'))\n        tile_type = tile.get('type')\n        obj = tile.find('Object')\n        is_impassable_obj = obj is not None and obj.get('id-name') != 'Pikachu'\n        impassable = tile_type in ['impassable', 'boulder_barrier', 'closed_gate', 'unknown'] or is_impassable_obj\n        grid[(x, y)] = {'type': tile_type, 'impassable': impassable}\n        if tile.find('Player') is not None:\n            player_pos = (x, y)\n            # Infer movement state from player's tile type\n            if grid[player_pos]['type'] == 'water':\n                movement_state = 'surfing'\n\n        if tile_type == 'ledge': ledges.add((x, y))\n\n    if 'hazard_coords' in input_data and input_data['hazard_coords']:\n        try:\n            hazards = json.loads(input_data['hazard_coords'])\n            for hx, hy in hazards:\n                if (int(hx), int(hy)) in grid:\n                    grid[(int(hx), int(hy))]['impassable'] = True\n        except (json.JSONDecodeError, ValueError, TypeError): pass\n\n    start_pos = player_pos\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    goal_pos = (target_x, target_y)\n    \n    party_data_str = input_data.get('party_data', '[]')\n    hms = parse_party_data(party_data_str)\n\n    if not start_pos:\n        print(json.dumps({'error': 'Player position not found.'}))\n    else:\n        if grid.get(goal_pos, {}).get('impassable', True):\n            adjacent_goals = []\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adj_pos = (goal_pos[0] + dx, goal_pos[1] + dy)\n                if 1 <= adj_pos[0] <= map_width and 1 <= adj_pos[1] <= map_height and not grid.get(adj_pos, {}).get('impassable', True):\n                    heapq.heappush(adjacent_goals, (heuristic(start_pos, adj_pos), adj_pos))\n            \n            path = None\n            while adjacent_goals and not path:\n                _, new_goal = heapq.heappop(adjacent_goals)\n                path = a_star_search(start_pos, new_goal, grid, map_width, map_height, hms, ledges, movement_state)\n        else:\n            path = a_star_search(start_pos, goal_pos, grid, map_width, map_height, hms, ledges, movement_state)\n\n        if path:\n            final_path = []\n            i = 0\n            while i < len(path):\n                current_tile = path[i]\n                final_path.append(current_tile)\n                if current_tile in ledges and i > 0:\n                    if i + 1 < len(path):\n                        next_tile_on_path = path[i+1]\n                        if next_tile_on_path[0] == current_tile[0] and next_tile_on_path[1] == current_tile[1] + 1:\n                             i += 1\n                i += 1\n            print(json.dumps([{'x': x, 'y': y} for x, y in final_path]))\n        else:\n            print(json.dumps({'error': 'No path found.'}))\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))\n",
    "history": [
      {
        "commit_message": "fix: Prevent invalid water entry from elevated ground. The pathfinder was incorrectly allowing movement from 'elevated_ground' tiles directly to 'water' tiles. This commit adds a check to the A* algorithm to explicitly disallow entering water from any tile type other than 'water', 'steps', or 'ground', which are the only valid entry points for Surf. This will prevent the tool from generating invalid paths and causing movement loops.",
        "timestamp": "2025-07-23T02:45:55.283Z",
        "action_counter": 94248
      },
      {
        "commit_message": "fix: Prevent pathfinding over water when walking. The tool was incorrectly generating paths that included water tiles even when the player was not surfing. This commit adds a check to the A* algorithm to treat water tiles as impassable if the player's current movement state is 'walking'. It also infers the movement state based on the player's current tile type from the map XML.",
        "timestamp": "2025-07-23T04:34:15.655Z",
        "action_counter": 94472
      }
    ]
  },
  "spinner_maze_pathfinder": {
    "description": "A pathfinding tool specifically designed to solve spinner mazes by treating spinner tiles as forced-movement warps to their specified end-coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\nimport json\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef solve_maze(start, goal, grid, map_width, map_height):\n    open_set = []\n    heapq.heappush(open_set, (heuristic(start, goal), 0, start))\n    came_from = {start: None}\n    g_score = {start: 0}\n\n    while open_set:\n        _, current_g, current = heapq.heappop(open_set)\n\n        if current == goal:\n            path = []\n            while current:\n                path.append(current)\n                current = came_from[current]\n            return path[::-1]\n\n        neighbors = []\n        current_tile_info = grid.get(current, {})\n        \n        if current_tile_info.get('spinner_end'):\n            neighbors.append(current_tile_info['spinner_end'])\n        else:\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                neighbor = (current[0] + dx, current[1] + dy)\n                if 1 <= neighbor[0] <= map_width and 1 <= neighbor[1] <= map_height:\n                    neighbor_tile_info = grid.get(neighbor, {})\n                    if not neighbor_tile_info.get('impassable', True):\n                        neighbors.append(neighbor)\n\n        for neighbor in neighbors:\n            new_g = current_g + 1\n            if neighbor not in g_score or new_g < g_score[neighbor]:\n                g_score[neighbor] = new_g\n                f_score = new_g + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_score, new_g, neighbor))\n                came_from[neighbor] = current\n                \n    return None\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.get('width'))\n    map_height = int(root.get('height'))\n    \n    player_pos = None\n    grid = {}\n\n    for tile in root.findall('.//Tile'):\n        coords_raw = tile.get('coordinate')\n        coords_clean = coords_raw.replace('(', '').replace(')', '')\n        coords_parts = coords_clean.split(',')\n        x, y = int(coords_parts[0]), int(coords_parts[1])\n        tile_type = tile.get('type')\n        obj = tile.find('Object')\n        is_impassable_obj = obj is not None and obj.get('id-name') != 'Pikachu'\n        impassable = tile_type in ['impassable', 'boulder_barrier', 'closed_gate', 'unknown'] or is_impassable_obj\n        \n        spinner_end = None\n        spinner_tag = tile.find('Spinner')\n        if spinner_tag is not None and spinner_tag.get('end-coordinate'):\n            end_coords_raw = spinner_tag.get('end-coordinate')\n            end_coords_clean = end_coords_raw.replace('(', '').replace(')', '')\n            end_coords_parts = end_coords_clean.split(',')\n            spinner_end = (int(end_coords_parts[0]), int(end_coords_parts[1]))\n\n        grid[(x, y)] = {'type': tile_type, 'impassable': impassable, 'spinner_end': spinner_end}\n        \n        if tile.find('Player') is not None:\n            player_pos = (x, y)\n\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    goal_pos = (target_x, target_y)\n\n    if not player_pos:\n        print(json.dumps({'error': 'Player position not found.'}))\n    else:\n        if grid.get(goal_pos, {}).get('impassable', True):\n            adjacent_goals = []\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adj_pos = (goal_pos[0] + dx, goal_pos[1] + dy)\n                if 1 <= adj_pos[0] <= map_width and 1 <= adj_pos[1] <= map_height and not grid.get(adj_pos, {}).get('impassable', True):\n                    heapq.heappush(adjacent_goals, (heuristic(player_pos, adj_pos), adj_pos))\n            \n            path = None\n            while adjacent_goals and not path:\n                _, new_goal = heapq.heappop(adjacent_goals)\n                path = solve_maze(player_pos, new_goal, grid, map_width, map_height)\n        else:\n            path = solve_maze(player_pos, goal_pos, grid, map_width, map_height)\n\n        if path:\n            print(json.dumps([{'x': x, 'y': y} for x, y in path]))\n        else:\n            print(json.dumps({'error': 'No path found.'}))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))",
    "history": [
      {
        "commit_message": "feat: Create spinner_maze_pathfinder. This new tool is specifically designed to handle spinner mazes by correctly interpreting spinner tiles as forced-movement warps. The existing `robust_pathfinder` fails in these scenarios, causing movement loops. This tool will provide accurate paths through spinner-heavy areas like the Viridian Gym.",
        "timestamp": "2025-07-23T05:15:29.896Z",
        "action_counter": 94565
      },
      {
        "commit_message": "fix: Correct coordinate parsing. The tool was crashing due to a `ValueError` when converting the coordinate string to an integer. This was caused by incorrect string manipulation that failed to remove parentheses. The parsing logic has been fixed to correctly strip characters before conversion.",
        "timestamp": "2025-07-23T05:16:22.794Z",
        "action_counter": 94567
      },
      {
        "commit_message": "fix: Correct coordinate parsing. The tool was crashing due to a `ValueError` when converting the coordinate string to an integer. This was caused by incorrect string manipulation that failed to remove parentheses. The parsing logic has been fixed to correctly strip characters before conversion.",
        "timestamp": "2025-07-23T05:16:54.687Z",
        "action_counter": 94568
      },
      {
        "commit_message": "fix: Implement robust coordinate parsing. The tool was repeatedly crashing due to a `ValueError` when converting coordinate strings to integers. The previous `.strip()` method was unreliable. This commit replaces it with a more robust `.replace()` method to definitively remove parentheses before parsing, which should prevent any further crashes from this issue.",
        "timestamp": "2025-07-23T05:18:43.652Z",
        "action_counter": 94571
      },
      {
        "commit_message": "fix: Correct spinner end-coordinate parsing. The tool was crashing due to a `ValueError` because the coordinate string for spinner destinations was not being properly cleaned. The fix applies the same robust `.replace()` logic to the `end-coordinate` attribute, which should finally resolve the issue and allow for correct pathfinding in spinner mazes.",
        "timestamp": "2025-07-23T05:20:06.270Z",
        "action_counter": 94573
      },
      {
        "commit_message": "fix: Correct spinner end-coordinate parsing. The tool was crashing due to a `ValueError` because the coordinate string for spinner destinations was not being properly cleaned. The fix applies the same robust `.replace()` logic to the `end-coordinate` attribute, which should finally resolve the issue and allow for correct pathfinding in spinner mazes.",
        "timestamp": "2025-07-23T05:20:40.802Z",
        "action_counter": 94574
      }
    ]
  }
}