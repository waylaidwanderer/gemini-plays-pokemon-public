{
  "find_path_v2": {
    "description": "Finds the shortest path between two coordinates on the current map using BFS, considering walls, objects, and hazardous tiles (pits/ladders) as obstacles. Returns a JSON array of buttons.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "description": "If true and the tool returns a list of buttons, they will be pressed automatically.",
          "type": "boolean"
        },
        "avoid_warps": {
          "default": true,
          "description": "If true, treats CAVE and WARP tiles as obstacles unless they are the destination.",
          "type": "boolean"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "autopress_buttons"
      ],
      "type": "object"
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef solve():\n    root = ET.fromstring(map_xml_string)\n    \n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    avoid_warps = input_data.get('avoid_warps', True)\n    \n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            grid[(x, y)] = {\n                'type': tile.attrib['type'],\n                'has_object': tile.attrib.get('has-object') == 'true'\n            }\n            \n    # 'unseen' is NOT impassable to allow exploration.\n    impassable_base = {'WALL', 'FLOOR_UP_WALL', 'WATER', 'PIT', 'VOID'}\n    if avoid_warps:\n        impassable_base.add('CAVE')\n        impassable_base.add('WARP')\n    \n    queue = deque([(start_x, start_y, [])])\n    visited = {(start_x, start_y)}\n    \n    while queue:\n        x, y, path = queue.popleft()\n        \n        if x == end_x and y == end_y:\n            print(json.dumps(path))\n            return\n\n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = x + dx, y + dy\n            \n            if (nx, ny) in grid and (nx, ny) not in visited:\n                tile_info = grid[(nx, ny)]\n                tile_type = tile_info['type']\n                has_object = tile_info['has_object']\n                \n                can_pass = True\n                if nx == end_x and ny == end_y:\n                    can_pass = True\n                elif tile_type in impassable_base or has_object:\n                    can_pass = False\n                \n                # Ledge Logic: A ledge tile can only be entered from the direction it hops from.\n                if tile_type == 'LEDGE_HOP_DOWN' and dy != 1:\n                    can_pass = False\n                if tile_type == 'LEDGE_HOP_UP' and dy != -1:\n                    can_pass = False\n                if tile_type == 'LEDGE_HOP_LEFT' and dx != -1:\n                    can_pass = False\n                if tile_type == 'LEDGE_HOP_RIGHT' and dx != 1:\n                    can_pass = False\n                \n                if can_pass:\n                    if tile_type.startswith('LEDGE_HOP_'):\n                        nnx, nny = nx + dx, ny + dy\n                        if (nnx, nny) in grid and (nnx, nny) not in visited:\n                            nn_info = grid[(nnx, nny)]\n                            nn_type = nn_info['type']\n                            nn_has_obj = nn_info['has_object']\n                            if (nn_type not in impassable_base and not nn_has_obj) or (nnx == end_x and nny == end_y):\n                                visited.add((nnx, nny))\n                                queue.append((nnx, nny, path + [btn]))\n                    else:\n                        visited.add((nx, ny))\n                        queue.append((nx, ny, path + [btn]))\n\n    print(json.dumps([]))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T20:27:16.465Z",
        "action_counter": 29425
      },
      {
        "commit_message": "Refined to correctly identify objects using 'has-object' attribute and added logic for boulder bridges in pits.",
        "timestamp": "2025-12-28T20:30:14.390Z",
        "action_counter": 29431
      },
      {
        "commit_message": "Refined to correctly handle autopress_buttons by outputting button strings and fixed pathfinding logic for boulder bridges.",
        "timestamp": "2025-12-28T20:30:50.776Z",
        "action_counter": 29432
      },
      {
        "commit_message": "Refined to handle boulder bridges in Blackthorn Gym 1F and improved object detection.",
        "timestamp": "2025-12-28T20:47:40.334Z",
        "action_counter": 29458
      },
      {
        "commit_message": "Fixing missing commit message and improving tile passability logic.",
        "timestamp": "2025-12-28T22:59:48.479Z",
        "action_counter": 29673
      },
      {
        "commit_message": "Fix find_path_v2 by providing a commit message and using input_data correctly.",
        "timestamp": "2025-12-29T03:29:03.821Z",
        "action_counter": 30041
      },
      {
        "commit_message": "Refine find_path_v2 to treat PIT and LADDER tiles as obstacles by default to prevent accidental warps, unless they are the intended destination.",
        "timestamp": "2025-12-29T04:09:14.393Z",
        "action_counter": 30092
      },
      {
        "commit_message": "Refine find_path_v2 to treat all warp tiles (PIT, LADDER) as obstacles unless they are the specific destination, and correctly identify objects using 'has-object'.",
        "timestamp": "2025-12-29T04:10:34.909Z",
        "action_counter": 30094
      },
      {
        "commit_message": "Initial definition with ledge handling.",
        "timestamp": "2026-01-06T20:56:57.721Z",
        "action_counter": 30778
      },
      {
        "commit_message": "Added commit message to update tool.",
        "timestamp": "2026-01-06T21:16:09.438Z",
        "action_counter": 30812
      },
      {
        "commit_message": "Refined ledge handling: ledges are now impassable from all directions except the jump direction. Added more impassable tile types.",
        "timestamp": "2026-01-06T21:17:48.184Z",
        "action_counter": 30816
      },
      {
        "commit_message": "Added CAVE and WARP to impassable tiles to prevent accidental map transitions.",
        "timestamp": "2026-01-06T21:27:34.747Z",
        "action_counter": 30833
      },
      {
        "commit_message": "Added avoid_warps parameter and object detection logic. Refined ledge and warp handling.",
        "timestamp": "2026-01-06T21:37:49.308Z",
        "action_counter": 30841
      },
      {
        "commit_message": "Removed 'unseen' from impassable_base to allow exploration pathing.",
        "timestamp": "2026-01-06T21:53:26.245Z",
        "action_counter": 30871
      },
      {
        "commit_message": "Removed 'unseen' from impassable tiles to allow exploration pathing. Added avoid_warps parameter. Refined ledge and object handling.",
        "timestamp": "2026-01-06T21:58:47.153Z",
        "action_counter": 30880
      }
    ]
  },
  "press_menu_buttons": {
    "description": "Presses a sequence of buttons to navigate menus, bypassing the directional/action mixing restriction. Use for menu navigation ONLY. Returns the sequence of buttons as a JSON array.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nprint(json.dumps(input_data['buttons']))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-29T01:56:30.654Z",
        "action_counter": 29934
      }
    ]
  },
  "use_item_on_pokemon_v2": {
    "description": "Uses an item from the bag on a Pokemon. Automatically finds the item index in the Items pocket and resets the menu state.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "pokemon_index": {
          "type": "integer"
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "target_item",
        "pokemon_index",
        "inventory"
      ]
    },
    "python_script": "import json\ninventory = input_data.get('inventory', [])\ntarget = input_data.get('target_item', '')\npkmn_idx = int(input_data.get('pokemon_index', 1))\nidx = -1\nfor i, item in enumerate(inventory):\n    if target.upper() in item.upper():\n        idx = i + 1\n        break\nif idx == -1: print(json.dumps([]))\nelse:\n    seq = ['B', 'B', 'B', 'Start', 'Up', 'Up', 'Up', 'Up', 'Up', 'Up', 'Up', 'Down', 'Down', 'A']\n    for _ in range(20): seq.append('Up')\n    for _ in range(idx - 1): seq.append('Down')\n    seq.extend(['A', 'A'])\n    for _ in range(6): seq.append('Up')\n    for _ in range(pkmn_idx - 1): seq.append('Down')\n    seq.extend(['A', 'A', 'B', 'B', 'B'])\n    print(json.dumps(seq))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-07T06:34:04.271Z",
        "action_counter": 31833
      },
      {
        "commit_message": "Fixed Python append error and refined menu navigation logic.",
        "timestamp": "2026-01-07T06:34:55.322Z",
        "action_counter": 31834
      },
      {
        "commit_message": "Fixed main menu navigation logic (Up x7, Down x2 for PACK) and added confirmation A press.",
        "timestamp": "2026-01-07T06:37:30.704Z",
        "action_counter": 31835
      }
    ]
  },
  "swap_pokemon_v2": {
    "description": "Swaps the positions of two Pokemon in the party.",
    "input_schema": {
      "type": "object",
      "properties": {
        "p1_index": {
          "type": "integer"
        },
        "p2_index": {
          "type": "integer"
        }
      },
      "required": [
        "p1_index",
        "p2_index"
      ]
    },
    "python_script": "import json\np1 = int(input_data.get('p1_index', 1))\np2 = int(input_data.get('p2_index', 2))\nseq = ['B', 'B', 'B', 'Start', 'Up', 'Up', 'Up', 'Up', 'Up', 'Up', 'Up', 'Up', 'Up', 'Up', 'Down', 'A']\nseq.extend(['Up']*7 + ['Down']*(p1-1) + ['A', 'Down', 'A'])\nseq.extend(['Up']*7 + ['Down']*(p2-1) + ['A', 'B', 'B', 'B'])\nprint(json.dumps(seq))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-07T06:44:21.222Z",
        "action_counter": 31838
      }
    ]
  },
  "fly_to_city_v4": {
    "description": "Uses Fly to travel to a city. Assumes Icarus is in slot 2 and Fly is the first field move. Uses a robust 'Reset to New Bark' strategy.",
    "input_schema": {
      "type": "object",
      "properties": {
        "city_name": {
          "type": "string"
        }
      },
      "required": [
        "city_name"
      ]
    },
    "python_script": "import json\n\n# input_data is injected by the harness\ncity = input_data.get(\"city_name\", \"Blackthorn City\")\n\nbuttons = [\"B\", \"B\", \"B\", \"B\", \"B\", \"Start\", \"sleep 500\", \"Up\", \"Up\", \"Up\", \"Up\", \"Up\", \"Up\", \"Up\", \"Up\", \"Down\", \"Down\", \"A\", \"sleep 1000\", \"Down\", \"A\", \"sleep 500\", \"A\", \"sleep 500\", \"A\", \"sleep 3000\", \"Down\", \"Down\", \"Down\", \"Down\", \"Down\", \"Down\", \"Down\", \"Down\", \"Right\", \"Right\", \"Right\", \"Right\", \"Right\", \"Right\", \"Right\", \"Right\"]\n\nif city == \"Blackthorn City\":\n    buttons.append(\"Up\")\nelif city == \"Goldenrod City\":\n    buttons.append(\"Left\")\n    buttons.append(\"Left\")\nelif city == \"Ecruteak City\":\n    buttons.append(\"Left\")\n    buttons.append(\"Left\")\n    buttons.append(\"Up\")\nelif city == \"Olivine City\":\n    buttons.append(\"Left\")\n    buttons.append(\"Left\")\n    buttons.append(\"Left\")\nelif city == \"Cianwood City\":\n    buttons.append(\"Left\")\n    buttons.append(\"Left\")\n    buttons.append(\"Left\")\n    buttons.append(\"Left\")\nelif city == \"Violet City\":\n    buttons.append(\"Left\")\n    buttons.append(\"Up\")\nelif city == \"Mahogany Town\":\n    buttons.append(\"Left\")\n    buttons.append(\"Up\")\n    buttons.append(\"Up\")\nelif city == \"Cherrygrove City\":\n    buttons.append(\"Left\")\n\nbuttons.append(\"A\")\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Fixed Fly tool with robust menu navigation (sleeps and top-reset) and corrected city paths.",
        "timestamp": "2026-01-07T07:27:04.749Z",
        "action_counter": 31885
      },
      {
        "commit_message": "Fixed JSON output and added robust navigation logic.",
        "timestamp": "2026-01-07T07:38:10.740Z",
        "action_counter": 31894
      }
    ]
  }
}