{
  "give_item_v1_refined": {
    "description": "Gives an item from the PACK to a Pokémon. Assumes overworld. Parameters: item_index (0-indexed position in the current pocket), pokemon_index (1-indexed position in the party), current_menu_index (0-indexed position of the menu cursor, POKEDEX=0, EXIT=7).",
    "input_schema": {
      "type": "object",
      "properties": {
        "item_index": {
          "type": "integer",
          "description": "0-indexed position of the item in the current pocket"
        },
        "pokemon_index": {
          "type": "integer",
          "description": "1-indexed position of the Pokémon in the party"
        },
        "current_menu_index": {
          "type": "integer",
          "description": "0-indexed position of the current menu cursor (POKEDEX=0, EXIT=7)"
        }
      },
      "required": [
        "item_index",
        "pokemon_index",
        "current_menu_index"
      ]
    },
    "python_script": "\nimport json\n\ndef main():\n    item_index = int(input_data['item_index'])\n    pokemon_index = int(input_data['pokemon_index'])\n    current_menu_index = int(input_data['current_menu_index'])\n    \n    buttons = [\"Start\", \"sleep 500\"]\n    \n    # Navigate to Pack (index 2)\n    diff = 2 - current_menu_index\n    if diff > 0:\n        for _ in range(diff):\n            buttons.append(\"Down\")\n    elif diff < 0:\n        for _ in range(abs(diff)):\n            buttons.append(\"Up\")\n            \n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # Navigate to Item\n    for _ in range(item_index):\n        buttons.append(\"Down\")\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # Select GIVE (2nd option)\n    buttons.append(\"Down\")\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # Select Pokemon\n    for _ in range(pokemon_index - 1):\n        buttons.append(\"Down\")\n    buttons.append(\"A\")\n    buttons.append(\"sleep 1000\")\n    \n    # Clear text\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    buttons.append(\"A\")\n    \n    print(json.dumps(buttons))\n\nif __name__ == \"__main__\":\n    main()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-19T10:55:52.584Z",
        "action_counter": 3933
      }
    ]
  },
  "press_sequence": {
    "description": "Executes a specific sequence of button presses, allowing for mixed directional and action inputs. Useful for complex menu navigation.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nprint(json.dumps(input_data['buttons']))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T06:11:16.135Z",
        "action_counter": 948
      }
    ]
  },
  "find_path": {
    "description": "Finds the shortest path to a target coordinate, correctly handling all collision types, one-way ledges, and treating 'unseen' tiles as traversable. Returns a list of coordinate objects.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        print(f\"Error parsing map_xml_string: {e}\")\n        return\n\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    player_x, player_y = -1, -1\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            if tile.find('Player') is not None:\n                player_x = int(tile.attrib['id'])\n                player_y = y\n                break\n        if player_x != -1:\n            break\n            \n    if player_x == -1:\n        print(\"Player position not found.\")\n        return\n\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n\n    impassable_types = {\"WALL\", \"WATER\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"BOOKSHELF\", \"PC\", \"TOWN_MAP\", \"WINDOW\"}\n\n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            has_obj = tile.attrib.get('has-object') == 'true'\n            grid[(x, y)] = (t_type, has_obj)\n\n    queue = deque([(player_x, player_y, [{\"x\": player_x, \"y\": player_y}])])\n    visited = {(player_x, player_y)}\n    \n    while queue:\n        x, y, path = queue.popleft()\n        \n        if x == target_x and y == target_y:\n            print(json.dumps(path))\n            return\n            \n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:\n                t_info = grid.get((nx, ny))\n                if not t_info: continue\n                t_type, has_obj = t_info\n                \n                is_passable = (t_type not in impassable_types and not has_obj) or t_type == \"unseen\"\n                \n                is_blocked = False\n                curr_type, _ = grid[(x, y)]\n                if \"LEDGE_HOP_DOWN\" in curr_type and dy != 1: is_blocked = True\n                if \"LEDGE_HOP_UP\" in curr_type and dy != -1: is_blocked = True\n                if \"LEDGE_HOP_LEFT\" in curr_type and dx != -1: is_blocked = True\n                if \"LEDGE_HOP_RIGHT\" in curr_type and dx != 1: is_blocked = True\n                \n                if \"LEDGE_HOP_DOWN\" in t_type and dy == -1: is_blocked = True\n                if \"LEDGE_HOP_UP\" in t_type and dy == 1: is_blocked = True\n                if \"LEDGE_HOP_LEFT\" in t_type and dx == 1: is_blocked = True\n                if \"LEDGE_HOP_RIGHT\" in t_type and dx == -1: is_blocked = True\n\n                if not is_blocked:\n                    if is_passable or (nx == target_x and ny == target_y):\n                        visited.add((nx, ny))\n                        queue.append((nx, ny, path + [{\"x\": nx, \"y\": ny}]))\n\n    print(\"No path found.\")\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-20T01:20:05.033Z",
        "action_counter": 4861
      }
    ]
  }
}