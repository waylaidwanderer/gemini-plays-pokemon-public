{
  "master_navigator": {
    "description": "A consolidated navigation tool that handles pathfinding. It can find a path to a specific coordinate. It now considers map markers for obstacles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "mode": {
          "type": "string",
          "enum": [
            "pathfind"
          ]
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer",
          "nullable": true
        },
        "end_y": {
          "type": "integer",
          "nullable": true
        },
        "traversable_tiles": {
          "type": "string"
        }
      },
      "required": [
        "mode",
        "start_x",
        "start_y",
        "traversable_tiles"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef find_path(map_xml_string, start_x, start_y, end_x, end_y, traversable_tiles_str):\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        traversable_tiles = traversable_tiles_str.split(',')\n\n        grid = [[True for _ in range(width + 1)] for _ in range(height + 1)]\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                \n                is_traversable = tile_type in traversable_tiles and not has_object\n                \n                for marker in tile_elem.findall('Marker'):\n                    if marker.get('emoji') == 'ðŸš«':\n                        is_traversable = False\n                        break\n                \n                grid[y][x] = is_traversable\n\n        def heuristic(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n        start = (start_x, start_y)\n        goal = (end_x, end_y)\n        \n        open_set = [(0, start)]\n        came_from = {}\n        g_score = { (x,y): float('inf') for y in range(height+1) for x in range(width+1) }\n        g_score[start] = 0\n        f_score = { (x,y): float('inf') for y in range(height+1) for x in range(width+1) }\n        f_score[start] = heuristic(start, goal)\n\n        while open_set:\n            _, current = heapq.heappop(open_set)\n\n            if current == goal:\n                path = []\n                while current in came_from:\n                    path.append({'x': current[0], 'y': current[1]})\n                    current = came_from[current]\n                path.append({'x': start[0], 'y': start[1]})\n                return list(reversed(path))\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                neighbor = (current[0] + dx, current[1] + dy)\n                nx, ny = neighbor\n\n                if not (1 <= nx <= width and 1 <= ny <= height):\n                    continue\n                \n                if not grid[ny][nx]:\n                    continue\n\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, goal)\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n        \n        return None\n\n    except Exception as e:\n        return {\"error\": str(e)}\n\ntry:\n    mode = input_data['mode']\n    if mode == 'pathfind':\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        end_x = int(input_data['end_x'])\n        end_y = int(input_data['end_y'])\n        traversable_tiles_str = input_data['traversable_tiles']\n\n        path = find_path(map_xml_string, start_x, start_y, end_x, end_y, traversable_tiles_str)\n\n        if isinstance(path, dict) and \"error\" in path:\n            print(json.dumps(path))\n        elif path:\n            print(json.dumps({\"path\": path}))\n        else:\n            print(json.dumps({\"error\": \"No path found.\"}))\n    else:\n        print(json.dumps({\"error\": f\"Invalid mode: {mode}\"}))\n\nexcept Exception as e:\n    print(json.dumps({\"error\": f\"Tool execution failed: {str(e)}\"}))"
  },
  "maze_navigator": {
    "description": "Suggests the next move in a maze using a wall-following algorithm (right-hand rule).",
    "input_schema": {
      "type": "object",
      "properties": {
        "facing_direction": {
          "type": "string",
          "enum": [
            "up",
            "down",
            "left",
            "right"
          ]
        },
        "adjacent_tiles": {
          "type": "string",
          "description": "A JSON string representing adjacent tiles, e.g., '{\"up\":\"WALL\",\"down\":\"FLOOR\",...}'"
        }
      },
      "required": [
        "facing_direction",
        "adjacent_tiles"
      ]
    },
    "python_script": "import json\n\nfacing_direction = input_data['facing_direction']\nadjacent_tiles = json.loads(input_data['adjacent_tiles'])\n\nturn_order = {\n    'up': ['right', 'up', 'left', 'down'],\n    'down': ['left', 'down', 'right', 'up'],\n    'left': ['up', 'left', 'down', 'right'],\n    'right': ['down', 'right', 'up', 'left']\n}\n\nmove_map = {\n    'up': 'Up',\n    'down': 'Down',\n    'left': 'Left',\n    'right': 'Right'\n}\n\nrecommended_move = None\njustification = \"\"\nfor move_dir in turn_order[facing_direction]:\n    # Use .get() with a default of 'WALL' to handle cases where a direction might not be in the input\n    if adjacent_tiles.get(move_dir, 'WALL').upper() == 'FLOOR':\n        recommended_move = move_map[move_dir]\n        if move_dir == turn_order[facing_direction][0]:\n            justification = f\"Following the right-hand rule, the priority is to turn right ({recommended_move}), which is a clear path.\"\n        elif move_dir == turn_order[facing_direction][1]:\n            justification = f\"Cannot turn right. The next priority is to go straight ({recommended_move}), which is a clear path.\"\n        elif move_dir == turn_order[facing_direction][2]:\n            justification = f\"Cannot turn right or go straight. The next priority is to turn left ({recommended_move}), which is a clear path.\"\n        else:\n            justification = f\"All other paths are blocked. The only option is to turn around ({recommended_move}).\"\n        break\n\nif recommended_move:\n    result = {\"action\": recommended_move, \"justification\": justification}\nelse:\n    result = {\"action\": \"None\", \"justification\": \"No valid moves found. Trapped.\"}\n\nprint(json.dumps(result))"
  }
}