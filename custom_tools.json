{
  "bfs_check_path": {
    "description": "Checks if a path exists between two points using BFS on the Mental Map. Returns True/False and the path length.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef check_path(start_x, start_y, target_x, target_y):\n    try:\n        # map_xml_string is injected into the environment\n        if 'map_xml_string' not in globals():\n            print(\"Error: map_xml_string not found in globals.\")\n            return\n\n        root = ET.fromstring(map_xml_string)\n        \n        # Parse map dimensions\n        width = int(root.attrib['width'])\n        height = int(root.attrib['height'])\n        \n        # Build grid of walkable tiles\n        walkable = set()\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                t_type = tile.attrib.get('type', 'unseen')\n                \n                # Define walkable types\n                # Excluding known walls/obstacles\n                # TYPE_2889: Tree/Wall\n                # TYPE_80fc: Wall/Roof?\n                # TYPE_5519: Cut Tree\n                # TYPE_fed7: Ledge (Usually one way, treating as obstacle for general BFS unless logic added)\n                # TYPE_c453: Ledge\n                if t_type not in ['TYPE_2889', 'TYPE_80fc', 'TYPE_5519', 'TYPE_fed7', 'TYPE_c453']: \n                    walkable.add((x, y))\n                    \n        start = (start_x, start_y)\n        target = (target_x, target_y)\n        \n        if start not in walkable:\n            print(f\"Start {start} is not walkable or is an obstacle.\")\n            # return # Attempt to path anyway if start is 'obstacle' (e.g. current pos on ledge)\n            \n        if target not in walkable:\n            print(f\"Target {target} is not walkable or is an obstacle.\")\n            return\n\n        queue = deque([(start, 0)])\n        visited = {start}\n        \n        while queue:\n            (curr_x, curr_y), dist = queue.popleft()\n            \n            if (curr_x, curr_y) == target:\n                print(f\"Path found! Distance: {dist}\")\n                return\n            \n            # Check neighbors (Up, Down, Left, Right)\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = curr_x + dx, curr_y + dy\n                \n                if (nx, ny) in walkable and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append(((nx, ny), dist + 1))\n                    \n        print(\"No path found.\")\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n\ncheck_path(start_x, start_y, target_x, target_y)",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T13:46:49.913Z",
        "action_counter": 1128
      },
      {
        "commit_message": "Initial definition of BFS pathfinding tool to check connectivity on the Mental Map.",
        "timestamp": "2026-01-17T18:35:27.285Z",
        "action_counter": 1502
      },
      {
        "commit_message": "Initial definition of BFS path checking tool to replace the broken connectivity tool.",
        "timestamp": "2026-01-17T21:09:57.634Z",
        "action_counter": 1713
      }
    ]
  },
  "check_path_connectivity": {
    "description": "Checks if a path exists between two coordinates using BFS on the Mental Map XML. Returns path length and steps if found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\n\nstart_x = input_data['start_x']\nstart_y = input_data['start_y']\ntarget_x = input_data['target_x']\ntarget_y = input_data['target_y']\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get(\"width\"))\n    height = int(root.get(\"height\"))\n    grid = {}\n    \n    for row in root.findall(\"Row\"):\n        y = int(row.get(\"id\"))\n        for tile in row.findall(\"Tile\"):\n            x = int(tile.get(\"id\"))\n            t_type = tile.get(\"type\")\n            grid[(x, y)] = t_type\n\n    start = (start_x, start_y)\n    target = (target_x, target_y)\n    \n    if start not in grid or target not in grid:\n        print(f\"Error: Coordinates out of bounds or not in map data.\")\n        exit()\n\n    queue = collections.deque([[start]])\n    visited = set([start])\n    \n    found = False\n    final_path = []\n    \n    # Simple passable check - assume anything not explicitly a known wall is passable for now\n    # This can be refined\n    WALL_TYPES = [\"TYPE_2889\", \"TYPE_80fc\", \"TYPE_5519\", \"TYPE_a336\", \"TYPE_fed7\"] \n    # Note: TYPE_c453 is ledge, handled as one-way usually, but for simple connectivity checks might treat as passable or blocked depending on direction. \n    # For this simple BFS, let's treat it as passable but risky, or just block it if we want strictness.\n    # Let's verify specific blocked types from notepad.\n    \n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n        \n        if (x, y) == target:\n            found = True\n            final_path = path\n            break\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < width and 0 <= ny < height:\n                if (nx, ny) not in visited:\n                    tile_type = grid.get((nx, ny), \"unseen\")\n                    if tile_type not in WALL_TYPES:\n                        visited.add((nx, ny))\n                        new_path = list(path)\n                        new_path.append((nx, ny))\n                        queue.append(new_path)\n\n    if found:\n        print(f\"Path found! Length: {len(final_path)}. Path: {final_path}\")\n    else:\n        print(\"No path found.\")\n\nexcept Exception as e:\n    print(f\"Error parsing map or finding path: {e}\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T04:38:25.635Z",
        "action_counter": 310
      },
      {
        "commit_message": "Fixed autopress_buttons support by returning JSON list of buttons.",
        "timestamp": "2026-01-17T05:14:56.870Z",
        "action_counter": 363
      },
      {
        "commit_message": "Initial definition of check_path_connectivity tool to help verify navigation paths.",
        "timestamp": "2026-01-17T19:59:31.235Z",
        "action_counter": 1608
      },
      {
        "commit_message": "Initial definition of check_path_connectivity tool for verifying paths on the mental map.",
        "timestamp": "2026-01-18T00:52:36.653Z",
        "action_counter": 2016
      }
    ]
  },
  "find_nearest_unseen": {
    "description": "Finds the nearest 'unseen' tile in the Mental Map to the current player position. Useful for systematically clearing fog of war.",
    "input_schema": {
      "type": "object",
      "properties": {
        "player_x": {
          "type": "integer"
        },
        "player_y": {
          "type": "integer"
        }
      },
      "required": [
        "player_x",
        "player_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport math\n\nmap_xml = map_xml_string\npx = input_data['player_x']\npy = input_data['player_y']\n\nroot = ET.fromstring(map_xml)\nunseen_tiles = []\n\nfor row in root.findall('Row'):\n    y = int(row.get('id'))\n    for tile in row.findall('Tile'):\n        t_type = tile.get('type')\n        if t_type == 'unseen':\n            x = int(tile.get('id'))\n            dist = math.sqrt((x - px)**2 + (y - py)**2)\n            unseen_tiles.append({'x': x, 'y': y, 'dist': dist})\n\nif not unseen_tiles:\n    print(\"No unseen tiles found.\")\nelse:\n    # Sort by distance\n    unseen_tiles.sort(key=lambda t: t['dist'])\n    nearest = unseen_tiles[0]\n    print(f\"Nearest unseen tile is at ({nearest['x']}, {nearest['y']}) with distance {nearest['dist']:.2f}\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T05:16:24.634Z",
        "action_counter": 364
      }
    ]
  },
  "navigate_to": {
    "description": "Navigates to a target coordinate using BFS on the Mental Map. Returns a list of buttons.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "avoid_coords": {
          "type": "array",
          "items": {
            "type": "array",
            "items": {
              "type": "integer"
            }
          },
          "nullable": true
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\n\n# Parse XML\nroot = ET.fromstring(map_xml_string)\nmap_width = int(root.attrib['width'])\nmap_height = int(root.attrib['height'])\n\ngrid = {}\nplayer_pos = None\n\nfor row in root.findall('Row'):\n    y_coord = int(row.attrib['id'])\n    for tile in row.findall('Tile'):\n        x_coord = int(tile.attrib['id'])\n        t_type = tile.attrib.get('type')\n        grid[(x_coord, y_coord)] = t_type\n        if tile.find('Player') is not None:\n            player_pos = (x_coord, y_coord)\n\nif player_pos is None:\n    print(\"[]\")\n    exit()\n\ntarget = (target_x, target_y)\navoid = set()\n\n# Handle avoid_coords being possibly None or list\nif 'avoid_coords' in globals() and avoid_coords:\n    for c in avoid_coords:\n        avoid.add(tuple(c))\n\ndef bfs(start, tgt, grid_map, w, h, avoid_set):\n    queue = collections.deque([(start, [])])\n    visited = set([start])\n    \n    while queue:\n        (cx, cy), path = queue.popleft()\n        if (cx, cy) == tgt:\n            return path\n        \n        # Try 4 directions: Left, Right, Up, Down\n        for dx, dy, move in [(-1, 0, 'Left'), (1, 0, 'Right'), (0, -1, 'Up'), (0, 1, 'Down')]:\n            nx, ny = cx + dx, cy + dy\n            \n            # Check bounds\n            if 0 <= nx < w and 0 <= ny < h:\n                if (nx, ny) not in visited and (nx, ny) not in avoid_set:\n                    tile_type = grid_map.get((nx, ny), 'unseen')\n                    \n                    # Walkability Rule:\n                    # 1. TYPE_3fe2 is definitely floor.\n                    # 2. Allow moving ONTO the target regardless of type (allows bumping/interaction).\n                    # 3. Disallow trees (TYPE_2889) unless it is the target.\n                    # 4. Allow TYPE_80fc (Cut tree) as target\n                    \n                    is_walkable = (tile_type == 'TYPE_3fe2')\n                    is_target = ((nx, ny) == tgt)\n                    \n                    if is_walkable or is_target:\n                        visited.add((nx, ny))\n                        queue.append(((nx, ny), path + [move]))\n    return None\n\npath_moves = bfs(player_pos, target, grid, map_width, map_height, avoid)\n\nif path_moves is not None:\n    # Print as JSON array string\n    print(str(path_moves).replace(\"'\", '\"'))\nelse:\n    print(\"[]\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-18T06:37:45.170Z",
        "action_counter": 2522
      },
      {
        "commit_message": "Implemented BFS navigation logic to parse map_xml_string and return a path to target coordinates, avoiding obstacles.",
        "timestamp": "2026-01-19T01:21:39.683Z",
        "action_counter": 3936
      },
      {
        "commit_message": "Fixing tool by adding required commit message and ensuring robustness.",
        "timestamp": "2026-01-19T03:58:58.882Z",
        "action_counter": 4142
      }
    ]
  },
  "patrol_grass": {
    "description": "Moves the player Left and Right to search for wild Pokemon, and presses A to handle battle introductions.",
    "input_schema": {},
    "python_script": "import json\ncmds = [\"Left\", \"Right\", \"Left\", \"Right\", \"A\", \"A\", \"A\", \"A\"]\nprint(json.dumps(cmds))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T02:06:33.549Z",
        "action_counter": 93
      }
    ]
  },
  "scan_surroundings": {
    "description": "Scans the Mental Map around the player and returns the type and coordinates of nearby tiles. Useful for identifying walls, ledges, and navigable paths without walking into them.",
    "input_schema": {
      "type": "object",
      "properties": {
        "radius": {
          "type": "integer",
          "description": "The radius of tiles to scan around the player. Defaults to 2."
        }
      },
      "required": [
        "radius"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    player_pos = None\n    \n    # Find player position\n    for row in root.findall(\"Row\"):\n        for tile in row.findall(\"Tile\"):\n            if tile.find(\"Player\") is not None:\n                player_pos = (int(tile.get(\"id\")), int(row.get(\"id\")))\n                break\n        if player_pos: break\n\n    if not player_pos:\n        print(\"Error: Player not found in Mental Map.\")\n    else:\n        px, py = player_pos\n        radius = input_data.get('radius', 2)\n        map_id = root.get('id')\n        print(f\"Scanning radius {radius} around {player_pos} on map {map_id}:\")\n        \n        for y in range(py - radius, py + radius + 1):\n            row = root.find(f\"./Row[@id='{y}']\")\n            if row is not None:\n                row_str = \"\"\n                for x in range(px - radius, px + radius + 1):\n                    tile = row.find(f\"./Tile[@id='{x}']\")\n                    if tile is not None:\n                        t_type = tile.get(\"type\")\n                        row_str += f\"[{x},{y}: {t_type}] \"\n                    else:\n                        row_str += f\"[{x},{y}: N/A] \"\n                print(row_str)\n            else:\n                print(f\"Row {y} not found.\")\n\nexcept Exception as e:\n    print(f\"Error executing scan_surroundings: {e}\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T03:27:06.196Z",
        "action_counter": 213
      }
    ]
  }
}