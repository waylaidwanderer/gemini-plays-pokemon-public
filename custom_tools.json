{
  "automated_explorer": {
    "description": "Finds the nearest reachable unseen tile and generates a path to an adjacent traversable tile. Now correctly handles water traversal by checking for SURF capability and planning paths across water even when not currently surfing. Accepts a 'can_surf' parameter.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "can_surf": {
          "type": "string",
          "enum": [
            "true",
            "false"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "can_surf"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\nimport json\n\ndef find_all_reachable_and_paths(start, grid, width, height, can_surf):\n    queue = collections.deque([(start, grid.get(start, {}).get('type') == 'water')])\n    came_from = {start: None}\n    \n    while queue:\n        (current, is_surfing_state) = queue.popleft()\n        \n        for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = current[0] + move_x, current[1] + move_y\n            next_pos = (next_x, next_y)\n            \n            if not (1 <= next_x <= width and 1 <= next_y <= height):\n                continue\n            \n            if next_pos in came_from:\n                continue\n                \n            current_tile_info = grid.get(current, {})\n            next_tile_info = grid.get(next_pos, {})\n            next_tile_type = next_tile_info.get('type')\n            \n            if move_y == 1 and current_tile_info.get('type') != 'ledge' and next_tile_type == 'ledge':\n                ledge_jump_pos = (next_x, next_y + 1)\n                if ledge_jump_pos in came_from: continue\n                if grid.get(ledge_jump_pos, {}).get('type') not in ['impassable', 'unknown']:\n                    came_from[next_pos] = current\n                    came_from[ledge_jump_pos] = next_pos\n                    queue.append((ledge_jump_pos, is_surfing_state))\n                continue\n\n            impassable_types = ['impassable', 'unknown', 'closed_gate']\n            if next_tile_type == 'ledge':\n                 if current_tile_info.get('type') != 'water' and move_y != 1:\n                    continue\n            \n            if next_tile_type in impassable_types:\n                continue\n\n            if next_tile_type == 'water' and not (is_surfing_state or can_surf):\n                continue\n            \n            if next_tile_info.get('has_object') and next_tile_info.get('object_name') != 'Pikachu':\n                continue\n\n            current_elevation = 'elevated' if current_tile_info.get('type') == 'elevated_ground' else 'ground'\n            next_elevation = 'elevated' if next_tile_type == 'elevated_ground' else 'ground'\n            if current_elevation != next_elevation and current_tile_info.get('type') not in ['steps', 'ladder_up', 'ladder_down'] and next_tile_type not in ['steps', 'ladder_up', 'ladder_down']:\n                continue\n            \n            came_from[next_pos] = current\n            queue.append((next_pos, next_tile_type == 'water'))\n            \n    return came_from\n\ndef reconstruct_path(came_from, end):\n    if end not in came_from:\n        return None\n    path = []\n    current = end\n    while current is not None:\n        path.append(list(current))\n        current = came_from.get(current)\n    return path[::-1]\n\ndef main():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        start_node = (start_x, start_y)\n        can_surf = input_data['can_surf'] == 'true'\n\n        grid = {}\n        unseen_tiles = []\n\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                grid[(x, y)] = {\n                    'type': tile_elem.get('type'),\n                    'has_object': tile_elem.get('has-object') == 'true',\n                    'object_name': tile_elem.find('Object').get('id-name') if tile_elem.find('Object') is not None else None\n                }\n                if tile_elem.get('seen') == 'false':\n                    unseen_tiles.append((x, y))\n\n        if not unseen_tiles:\n            print(json.dumps({'status': 'success', 'message': 'No unseen tiles found.'}))\n            return\n\n        came_from = find_all_reachable_and_paths(start_node, grid, width, height, can_surf)\n        reachable_nodes = set(came_from.keys())\n        \n        targetable_unseen_tiles = [tile for tile in unseen_tiles if any((tile[0] + dx, tile[1] + dy) in reachable_nodes for dx, dy in [(0,1),(0,-1),(1,0),(-1,0)])]\n\n        if not targetable_unseen_tiles:\n            print(json.dumps({'status': 'error', 'message': 'No unseen tiles are adjacent to reachable areas.', 'reachable_nodes_count': len(reachable_nodes)}))\n            return\n\n        shortest_path = None\n        target_unseen = None\n        \n        sorted_targets = sorted(targetable_unseen_tiles, key=lambda t: (abs(t[0] - start_x) + abs(t[1] - start_y)))\n\n        for tile in sorted_targets:\n            best_adj_path = None\n            for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adj_x, adj_y = tile[0] + move_x, tile[1] + move_y\n                adj_pos = (adj_x, adj_y)\n                if adj_pos in reachable_nodes:\n                    path = reconstruct_path(came_from, adj_pos)\n                    if path and (best_adj_path is None or len(path) < len(best_adj_path)):\n                        best_adj_path = path\n            \n            if best_adj_path:\n                shortest_path = best_adj_path\n                target_unseen = tile\n                break\n        \n        if shortest_path:\n            print(json.dumps({'status': 'success', 'path': shortest_path, 'target_unseen_tile': target_unseen}))\n        else:\n            print(json.dumps({'status': 'error', 'message': 'Could not find a path to any adjacent tile of any reachable unseen tiles.'}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'status': 'error', 'message': f'An exception occurred: {traceback.format_exc()}'}))\n\nmain()"
  },
  "find_wkg_node_by_coords": {
    "description": "Finds a World Knowledge Graph node ID by map ID and coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "map_id": {
          "type": "string"
        },
        "x": {
          "type": "string"
        },
        "y": {
          "type": "string"
        }
      },
      "required": [
        "map_id",
        "x",
        "y"
      ]
    },
    "python_script": "import json\n\ndef find_node():\n    try:\n        wkg = json.loads(world_knowledge_graph_json_string)\n        target_map_id = input_data['map_id']\n        target_x = int(input_data['x'])\n        target_y = int(input_data['y'])\n\n        for node in wkg['nodes']:\n            if str(node['map_id']) == str(target_map_id) and node['coordinates']['x'] == target_x and node['coordinates']['y'] == target_y:\n                print(json.dumps({'status': 'success', 'node_id': node['id']}))\n                return\n        \n        print(json.dumps({'status': 'error', 'message': f'Node not found on map {target_map_id} at ({target_x}, {target_y}).'}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'status': 'error', 'message': f'An exception occurred: {traceback.format_exc()}'}))\n\nfind_node()"
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map. It now correctly handles impassable tiles, dynamic transitions between walking and surfing, and navigates ledges. It outputs a JSON list of coordinate dictionaries. **REFINED:** Now treats teleporter tiles as impassable unless they are the target destination.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "is_surfing": {
          "type": "string",
          "enum": [
            "true",
            "false"
          ]
        },
        "can_surf": {
          "type": "string",
          "enum": [
            "true",
            "false"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "is_surfing",
        "can_surf"
      ]
    },
    "python_script": "import json\nimport heapq\nfrom xml.etree import ElementTree as ET\n\ndef pathfinder():\n    try:\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        end_x = int(input_data['end_x'])\n        end_y = int(input_data['end_y'])\n        is_surfing = input_data['is_surfing'].lower() == 'true'\n        can_surf = input_data['can_surf'].lower() == 'true'\n\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        grid = [['' for _ in range(width + 1)] for _ in range(height + 1)]\n\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                if has_object:\n                    object_elem = tile_elem.find('Object')\n                    if object_elem is not None and object_elem.get('id-name') == 'Pikachu':\n                        has_object = False\n                is_teleporter = tile_type == 'teleport'\n                is_target_teleporter = is_teleporter and x == end_x and y == end_y\n\n                if tile_type in ['impassable', 'boulder_barrier', 'closed_gate'] or has_object or (is_teleporter and not is_target_teleporter):\n                    grid[y][x] = 'wall'\n                else:\n                    grid[y][x] = tile_type\n\n        def get_neighbors(x, y, current_is_surfing):\n            neighbors = []\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if not (1 <= nx <= width and 1 <= ny <= height):\n                    continue\n\n                neighbor_tile = grid[ny][nx]\n                if neighbor_tile == 'wall':\n                    continue\n\n                if neighbor_tile == 'ledge' and dy == -1:\n                    continue\n\n                is_water = neighbor_tile == 'water'\n                if is_water and not can_surf:\n                    continue\n\n                if neighbor_tile == 'ledge' and dy == 1:\n                    nny = ny + 1\n                    if 1 <= nny <= height and grid[nny][nx] != 'wall':\n                        neighbors.append((nx, nny))\n                else:\n                    neighbors.append((nx, ny))\n            return neighbors\n\n        start_node = (start_x, start_y)\n        end_node = (end_x, end_y)\n        open_set = [(0, start_node)]\n        came_from = {}\n        g_score = {start_node: 0}\n\n        while open_set:\n            current_g, current_node = heapq.heappop(open_set)\n\n            if current_node == end_node:\n                path = []\n                while current_node in came_from:\n                    path.append({'x': current_node[0], 'y': current_node[1]})\n                    current_node = came_from[current_node]\n                path.append({'x': start_node[0], 'y': start_node[1]})\n                print(json.dumps(path[::-1]))\n                return\n\n            cx, cy = current_node\n            current_is_surfing = grid[cy][cx] == 'water'\n\n            for neighbor in get_neighbors(cx, cy, current_is_surfing):\n                nx, ny = neighbor\n                new_g = g_score[current_node] + 1\n                if neighbor not in g_score or new_g < g_score[neighbor]:\n                    g_score[neighbor] = new_g\n                    f_score = new_g + abs(nx - end_x) + abs(ny - end_y)\n                    heapq.heappush(open_set, (f_score, neighbor))\n                    came_from[neighbor] = current_node\n\n        print(json.dumps([]))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))\n\npathfinder()\n"
  },
  "wkg_pathfinder": {
    "description": "Finds the shortest path between two nodes in the World Knowledge Graph using BFS. Outputs a list of node IDs representing the path.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_node_id": {
          "type": "string"
        },
        "end_node_id": {
          "type": "string"
        }
      },
      "required": [
        "start_node_id",
        "end_node_id"
      ]
    },
    "python_script": "import json\nimport collections\n\ndef wkg_pathfinder(start_node_id, end_node_id):\n    try:\n        wkg = json.loads(world_knowledge_graph_json_string)\n        nodes = {node['id']: node for node in wkg.get('nodes', [])}\n        edges = wkg.get('edges', [])\n        \n        nodes_in_wkg = set(nodes.keys())\n        missing = []\n        if start_node_id not in nodes_in_wkg:\n            missing.append(\"Start node '{}'\".format(start_node_id))\n        if end_node_id not in nodes_in_wkg:\n            missing.append(\"End node '{}'\".format(end_node_id))\n        if missing:\n            print(json.dumps({'status': 'error', 'message': \"Node(s) not found in World Knowledge Graph: {}.\".format(', '.join(missing))}))\n            return\n\n        adj = collections.defaultdict(list)\n        for edge in edges:\n            source = edge['source_node_id']\n            dest = edge['destination_node_id']\n            adj[source].append(dest)\n            if not edge.get('is_one_way', False):\n                adj[dest].append(source)\n\n        queue = collections.deque([(start_node_id, [start_node_id])])\n        visited = {start_node_id}\n        \n        while queue:\n            current_node_id, path = queue.popleft()\n            \n            if current_node_id == end_node_id:\n                print(json.dumps({'status': 'success', 'path': path}))\n                return\n            \n            for neighbor_id in adj.get(current_node_id, []):\n                if neighbor_id not in visited:\n                    visited.add(neighbor_id)\n                    new_path = list(path)\n                    new_path.append(neighbor_id)\n                    queue.append((neighbor_id, new_path))\n        \n        print(json.dumps({'status': 'no_path_found', 'message': \"No path found from {} to {}.\".format(start_node_id, end_node_id)}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'status': 'error', 'message': 'An exception occurred: {}'.format(traceback.format_exc())}))\n\nwkg_pathfinder(input_data['start_node_id'], input_data['end_node_id'])"
  },
  "find_edge_by_nodes": {
    "description": "Finds the ID of an edge in the World Knowledge Graph that connects two specified nodes.",
    "input_schema": {
      "type": "object",
      "properties": {
        "node1_id": {
          "type": "string"
        },
        "node2_id": {
          "type": "string"
        }
      },
      "required": [
        "node1_id",
        "node2_id"
      ]
    },
    "python_script": "import json\ndef find_edge_by_nodes():\n    try:\n        node1_id = input_data['node1_id']\n        node2_id = input_data['node2_id']\n        graph = json.loads(world_knowledge_graph_json_string)\n        for edge in graph.get('edges', []):\n            source_id = edge.get('source_node_id')\n            dest_id = edge.get('destination_node_id')\n            if (source_id == node1_id and dest_id == node2_id) or (source_id == node2_id and dest_id == node1_id):\n                print(json.dumps({'edge_id': edge.get('id')}))\n                return\n        print(json.dumps({'edge_id': None, 'error': 'Edge not found between the given nodes.'}))\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))\nfind_edge_by_nodes()"
  }
}