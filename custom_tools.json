{
  "master_navigator": {
    "description": "A consolidated navigation tool that handles pathfinding, exploration targeting, and maze navigation. It can find a path to a specific coordinate, identify the best exploration target, or navigate a known maze.",
    "input_schema": {
      "type": "object",
      "properties": {
        "mode": {
          "type": "string",
          "enum": [
            "pathfind",
            "explore"
          ]
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer",
          "nullable": true
        },
        "end_y": {
          "type": "integer",
          "nullable": true
        },
        "traversable_tiles": {
          "type": "string"
        }
      },
      "required": [
        "mode",
        "start_x",
        "start_y",
        "traversable_tiles"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef parse_map_xml(xml_string):\n    root = ET.fromstring(xml_string)\n    map_data = {\n        'width': int(root.attrib['width']),\n        'height': int(root.attrib['height']),\n        'tiles': {},\n    }\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id'])\n            tile_type = tile_elem.attrib.get('type', 'VOID')\n            has_object = tile_elem.attrib.get('has-object') == 'true'\n            map_data['tiles'][(x, y)] = {'type': tile_type, 'has_object': has_object}\n    return map_data\n\ndef is_traversable(tile_coord, map_data, traversable_types):\n    if tile_coord not in map_data['tiles']:\n        return False\n    tile_info = map_data['tiles'][tile_coord]\n    return tile_info['type'] in traversable_types and not tile_info['has_object']\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(map_data, start, end, traversable_types):\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {start: 0}\n    f_score = {start: heuristic(start, end)}\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == end:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            return path[::-1]\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not is_traversable(neighbor, map_data, traversable_types):\n                continue\n\n            tentative_g_score = g_score[current] + 1\n            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + heuristic(neighbor, end)\n                heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    return None\n\ntry:\n    mode = input_data['mode']\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    start_node = (start_x, start_y)\n    traversable_list = json.loads(input_data['traversable_tiles'])\n    map_info = parse_map_xml(map_xml_string)\n\n    if mode == 'pathfind':\n        end_x = int(input_data.get('end_x', -1))\n        end_y = int(input_data.get('end_y', -1))\n        end_node = (end_x, end_y)\n\n        target_nodes = []\n        if is_traversable(end_node, map_info, traversable_list):\n            target_nodes.append(end_node)\n        else:\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                neighbor = (end_node[0] + dx, end_node[1] + dy)\n                if is_traversable(neighbor, map_info, traversable_list):\n                    target_nodes.append(neighbor)\n        \n        if not target_nodes:\n            print(json.dumps([]))\n        else:\n            all_paths = []\n            for target in target_nodes:\n                path = a_star_search(map_info, start_node, target, traversable_list)\n                if path:\n                    all_paths.append(path)\n            \n            if all_paths:\n                shortest_path = min(all_paths, key=len)\n                print(json.dumps([{'x': p[0], 'y': p[1]} for p in shortest_path]))\n            else:\n                print(json.dumps([]))\n\nexcept Exception as e:\n    import sys\n    print(f\"Error in master_navigator: {e}\", file=sys.stderr)\n    print(json.dumps([]))"
  },
  "maze_navigator": {
    "description": "Suggests the next move in a maze using a wall-following algorithm (right-hand rule).",
    "input_schema": {
      "type": "object",
      "properties": {
        "facing_direction": {
          "type": "string",
          "enum": [
            "up",
            "down",
            "left",
            "right"
          ]
        },
        "adjacent_tiles": {
          "type": "string",
          "description": "A JSON string representing adjacent tiles, e.g., '{\"up\":\"WALL\",\"down\":\"FLOOR\",...}'"
        }
      },
      "required": [
        "facing_direction",
        "adjacent_tiles"
      ]
    },
    "python_script": "import json\n\nfacing_direction = input_data['facing_direction']\nadjacent_tiles = json.loads(input_data['adjacent_tiles'])\n\nturn_order = {\n    'up': ['right', 'up', 'left', 'down'],\n    'down': ['left', 'down', 'right', 'up'],\n    'left': ['up', 'left', 'down', 'right'],\n    'right': ['down', 'right', 'up', 'left']\n}\n\nmove_map = {\n    'up': 'Up',\n    'down': 'Down',\n    'left': 'Left',\n    'right': 'Right'\n}\n\nrecommended_move = None\njustification = \"\"\nfor move_dir in turn_order[facing_direction]:\n    # Use .get() with a default of 'WALL' to handle cases where a direction might not be in the input\n    if adjacent_tiles.get(move_dir, 'WALL').upper() == 'FLOOR':\n        recommended_move = move_map[move_dir]\n        if move_dir == turn_order[facing_direction][0]:\n            justification = f\"Following the right-hand rule, the priority is to turn right ({recommended_move}), which is a clear path.\"\n        elif move_dir == turn_order[facing_direction][1]:\n            justification = f\"Cannot turn right. The next priority is to go straight ({recommended_move}), which is a clear path.\"\n        elif move_dir == turn_order[facing_direction][2]:\n            justification = f\"Cannot turn right or go straight. The next priority is to turn left ({recommended_move}), which is a clear path.\"\n        else:\n            justification = f\"All other paths are blocked. The only option is to turn around ({recommended_move}).\"\n        break\n\nif recommended_move:\n    result = {\"action\": recommended_move, \"justification\": justification}\nelse:\n    result = {\"action\": \"None\", \"justification\": \"No valid moves found. Trapped.\"}\n\nprint(json.dumps(result))"
  }
}