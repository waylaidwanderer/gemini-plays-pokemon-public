{
  "find_path_v2": {
    "description": "Calculates a path between two coordinates on the current map using BFS, accounting for walls, objects, and one-way tiles (ledges, floor-up-walls). Returns a list of coordinate objects or button strings if autopress_buttons is true.",
    "input_schema": {
      "properties": {
        "can_surf": {
          "type": "boolean"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "nullable": true,
          "type": "integer"
        },
        "start_y": {
          "nullable": true,
          "type": "integer"
        }
      },
      "required": [
        "end_x",
        "end_y"
      ],
      "type": "object"
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ntry:\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    can_surf = input_data.get('can_surf', False)\n    autopress_buttons = input_data.get('autopress_buttons', False)\n    \n    root = ET.fromstring(map_xml_string)\n    \n    start_x = input_data.get('start_x')\n    start_y = input_data.get('start_y')\n    \n    if start_x is None or start_y is None:\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                if tile.find('Player') is not None:\n                    start_x = int(tile.attrib['id'])\n                    start_y = y\n                    break\n            if start_x is not None: break\n\n    if start_x is None:\n        print(json.dumps([\"Error: Player position not found\"]))\n    else:\n        queue = deque([(start_x, start_y, [])])\n        visited = set([(start_x, start_y)])\n        \n        tiles = {}\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                t_type = tile.attrib['type']\n                has_obj = tile.attrib.get('has-object') == 'true'\n                is_warp = tile.attrib.get('is-warp') == 'true'\n                tiles[(x, y)] = {'type': t_type, 'obj': has_obj, 'warp': is_warp}\n\n        path_found = None\n        while queue:\n            curr_x, curr_y, path = queue.popleft()\n            if curr_x == end_x and curr_y == end_y:\n                path_found = path + [(curr_x, curr_y)]\n                break\n            \n            for dx, dy, btn in [(0, -1, \"Up\"), (0, 1, \"Down\"), (-1, 0, \"Left\"), (1, 0, \"Right\")]:\n                nx, ny = curr_x + dx, curr_y + dy\n                if (nx, ny) in tiles and (nx, ny) not in visited:\n                    target = tiles[(nx, ny)]\n                    traversable = False\n                    \n                    if target['type'] in [\"FLOOR\", \"TALL_GRASS\", \"DIRT\", \"SAND\", \"WARP_CARPET_LEFT\", \"WARP_CARPET_RIGHT\", \"WARP_CARPET_UP\", \"WARP_CARPET_DOWN\"]:\n                        traversable = True\n                    elif target['type'] == \"WATER\" and can_surf:\n                        traversable = True\n                    elif target['type'] == \"CAVE\" or target['warp']:\n                        traversable = True\n                    elif target['type'] == \"FLOOR_UP_WALL\":\n                        if dy == -1: traversable = True\n                    elif target['type'] == \"LEDGE\":\n                        if dy == 1: traversable = True\n                    \n                    if target['obj'] and not (nx == end_x and ny == end_y):\n                        traversable = False\n                    \n                    if traversable:\n                        visited.add((nx, ny))\n                        queue.append((nx, ny, path + [(curr_x, curr_y)]))\n        \n        if path_found:\n            if autopress_buttons:\n                btns = []\n                for i in range(len(path_found) - 1):\n                    x1, y1 = path_found[i]\n                    x2, y2 = path_found[i+1]\n                    if x2 > x1: btns.append(\"Right\")\n                    elif x2 < x1: btns.append(\"Left\")\n                    elif y2 > y1: btns.append(\"Down\")\n                    elif y2 < y1: btns.append(\"Up\")\n                print(json.dumps(btns))\n            else:\n                print(json.dumps([{\"x\": p[0], \"y\": p[1]} for p in path_found]))\n        else:\n            print(json.dumps([\"Error: No path found\"]))\nexcept Exception as e:\n    print(json.dumps([f\"Error: {str(e)}\"]))\n",
    "history": [
      {
        "commit_message": "Refined find_path to use the globally available map_xml_string and removed it from input_schema. Fixed one-way logic and impassable types.",
        "timestamp": "2025-12-23T14:36:16.850Z",
        "action_counter": 14568
      },
      {
        "commit_message": "Updated find_path_v2 to automatically detect player position from map_xml_string if start_x/y are not provided. Added start_x/y to input_schema as optional properties.",
        "timestamp": "2025-12-23T14:37:43.655Z",
        "action_counter": 14570
      },
      {
        "commit_message": "Fixed a bug in find_path_v2 where the path reconstruction loop would never terminate if the start position was found, leading to a KeyError: (None, None). Also fixed start_x/y handling to properly detect player position from XML if not provided as arguments.",
        "timestamp": "2025-12-23T14:38:20.004Z",
        "action_counter": 14571
      },
      {
        "commit_message": "Corrected output format of find_path_v2 to return a flat list of coordinates, matching the expected input for the navigate tool.",
        "timestamp": "2025-12-23T14:41:01.719Z",
        "action_counter": 14573
      },
      {
        "commit_message": "Fixed a bug in path reconstruction where (None, None) was not correctly identified as the termination condition, causing a KeyError. Also improved player position detection.",
        "timestamp": "2025-12-23T14:54:49.565Z",
        "action_counter": 14596
      },
      {
        "commit_message": "Refined find_path_v2 to handle pathfinding more robustly, correctly detecting the player's position from the XML if not provided, and returning a list of coordinate objects suitable for the navigate tool's path_plan. Added checks for impassable tiles including HEADBUTT_TREE and WATER.",
        "timestamp": "2025-12-23T14:56:11.952Z",
        "action_counter": 14599
      },
      {
        "commit_message": "Fixing find_path_v2 to correctly return a JSON array of button strings when autopress_buttons is true, and ensuring it handles the end tile correctly even if it's marked as impassable (like an NPC).",
        "timestamp": "2025-12-23T17:23:41.688Z",
        "action_counter": 14852
      },
      {
        "commit_message": "Updating find_path_v2 to support an optional 'can_surf' parameter. When true, WATER tiles are treated as traversable. This allows for pathfinding across ponds and oceans when the player has a Pokemon with Surf.",
        "timestamp": "2025-12-23T18:04:50.520Z",
        "action_counter": 14936
      },
      {
        "commit_message": "Refined passable types and added better error handling for unreachable destinations.",
        "timestamp": "2025-12-23T20:52:10.769Z",
        "action_counter": 15273
      },
      {
        "commit_message": "Refined passable types, added better error handling, and fixed button output for overworld/menu navigation.",
        "timestamp": "2025-12-23T20:52:38.251Z",
        "action_counter": 15274
      },
      {
        "commit_message": "Reverted to returning coordinates for 'navigate' tool and added specific logic for FLOOR_UP_WALL one-way tiles.",
        "timestamp": "2025-12-23T20:54:14.377Z",
        "action_counter": 15278
      },
      {
        "commit_message": "Fix find_path_v2 to handle autopress_buttons correctly by returning a JSON array of button strings when enabled, and account for one-way tiles like LEDGE and FLOOR_UP_WALL.",
        "timestamp": "2025-12-23T21:48:39.009Z",
        "action_counter": 15375
      },
      {
        "commit_message": "Fix find_path_v2 to handle autopress_buttons correctly and add one-way tile logic for LEDGE and FLOOR_UP_WALL.",
        "timestamp": "2025-12-23T21:49:12.615Z",
        "action_counter": 15376
      },
      {
        "commit_message": "Fix find_path_v2 by removing the function wrapper and ensuring it prints the result directly to stdout, and refine traversable types to include CAVE and warps.",
        "timestamp": "2025-12-23T21:51:09.492Z",
        "action_counter": 15382
      }
    ]
  },
  "get_reachable_unseen_tiles_v2": {
    "description": "Analyzes the current map XML to identify unseen tiles that are directly adjacent to tiles reachable from the player's current position. Handles ledges and one-way tiles. Returns a list of coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef run(input_data):\n    if not map_xml_string or \"<Map\" not in map_xml_string:\n        return {\"error\": \"Mental Map unavailable.\"}\n    \n    root = ET.fromstring(map_xml_string)\n    \n    start_x, start_y = None, None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            if tile.find('Player') is not None:\n                start_x, start_y = int(tile.attrib['id']), y\n                break\n        if start_x is not None: break\n            \n    if start_x is None: return {\"reachable_unseen\": []}\n\n    grid = {}\n    impassable_types = {'WALL', 'HEADBUTT_TREE', 'WATER', 'unseen'}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            grid[(x, y)] = t_type\n            if tile.find('Object') is not None: grid[(x, y)] = 'WALL'\n\n    queue = deque([(start_x, start_y)])\n    visited = {(start_x, start_y)}\n    reachable_tiles = {(start_x, start_y)}\n    \n    while queue:\n        curr_x, curr_y = queue.popleft()\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = curr_x + dx, curr_y + dy\n            if (nx, ny) in grid:\n                t_type = grid[(nx, ny)]\n                \n                # Relational movement logic (one-way tiles)\n                if dy == 1: # South\n                    if grid.get((curr_x, curr_y)) == 'FLOOR_UP_WALL' or t_type == 'FLOOR_UP_WALL': continue\n                    if t_type == 'LEDGE_HOP_DOWN':\n                        ny += 1\n                        if (nx, ny) in grid: t_type = grid[(nx, ny)]\n                        else: continue\n                elif dy == -1: # North\n                    if t_type == 'LEDGE_HOP_DOWN': continue\n                elif dx == 1: # East\n                    if t_type == 'LEDGE_HOP_RIGHT':\n                        nx += 1\n                        if (nx, ny) in grid: t_type = grid[(nx, ny)]\n                        else: continue\n                elif dx == -1: # West\n                    if t_type == 'LEDGE_HOP_RIGHT': continue\n                \n                if t_type not in impassable_types:\n                    if (nx, ny) not in visited:\n                        visited.add((nx, ny))\n                        reachable_tiles.add((nx, ny))\n                        queue.append((nx, ny))\n\n    reachable_unseen = set()\n    for rx, ry in reachable_tiles:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ux, uy = rx + dx, ry + dy\n            if (ux, uy) in grid and grid[(ux, uy)] == 'unseen':\n                reachable_unseen.add((ux, uy))\n                \n    return {\"reachable_unseen\": sorted(list(reachable_unseen))}\n\nprint(json.dumps(run(input_data)))",
    "history": [
      {
        "commit_message": "Refined get_reachable_unseen_tiles to use the BFS logic from find_path_v2, correctly handling ledges and one-way movement. Added Mental Map availability check.",
        "timestamp": "2025-12-23T15:43:54.280Z",
        "action_counter": 14678
      }
    ]
  },
  "wild_encounter_looper": {
    "description": "Generates a sequence of button presses to pace back and forth between two adjacent coordinates to trigger wild encounters. Outputs a JSON array of button strings.",
    "input_schema": {
      "type": "object",
      "properties": {
        "coord1_x": {
          "type": "integer"
        },
        "coord1_y": {
          "type": "integer"
        },
        "coord2_x": {
          "type": "integer"
        },
        "coord2_y": {
          "type": "integer"
        },
        "iterations": {
          "type": "integer"
        }
      },
      "required": [
        "coord1_x",
        "coord1_y",
        "coord2_x",
        "coord2_y",
        "iterations"
      ]
    },
    "python_script": "import json\n\n# Arguments are available in the 'input_data' dictionary\ntry:\n    x1 = int(input_data.get('coord1_x'))\n    y1 = int(input_data.get('coord1_y'))\n    x2 = int(input_data.get('coord2_x'))\n    y2 = int(input_data.get('coord2_y'))\n    iters = int(input_data.get('iterations', 5))\nexcept (TypeError, ValueError):\n    # Fallback or silent exit if input is bad\n    print(json.dumps([]))\n    exit()\n\ndef get_button(start_x, start_y, end_x, end_y):\n    if end_x > start_x: return \"Right\"\n    if end_x < start_x: return \"Left\"\n    if end_y > start_y: return \"Down\"\n    if end_y < start_y: return \"Up\"\n    return None\n\nbuttons = []\nfor _ in range(iters):\n    b1 = get_button(x1, y1, x2, y2)\n    b2 = get_button(x2, y2, x1, y1)\n    if b1: buttons.append(b1)\n    if b2: buttons.append(b2)\n\nprint(json.dumps(buttons))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-23T18:38:32.658Z",
        "action_counter": 15001
      },
      {
        "commit_message": "Fixed argument handling by using the global 'input_data' dictionary instead of 'sys.argv'. Added basic error handling.",
        "timestamp": "2025-12-23T18:39:58.588Z",
        "action_counter": 15005
      }
    ]
  },
  "roamer_encounter_looper": {
    "description": "Generates a sequence of button presses to pace back and forth between two adjacent coordinates to trigger wild encounters while a Repel is active. Specifically designed for roamer hunting. Outputs a JSON array of button strings.",
    "input_schema": {
      "type": "object",
      "properties": {
        "coord1_x": {
          "type": "integer"
        },
        "coord1_y": {
          "type": "integer"
        },
        "coord2_x": {
          "type": "integer"
        },
        "coord2_y": {
          "type": "integer"
        },
        "iterations": {
          "type": "integer"
        }
      },
      "required": [
        "coord1_x",
        "coord1_y",
        "coord2_x",
        "coord2_y",
        "iterations"
      ]
    },
    "python_script": "import json\n\ndef generate_pacing_buttons(c1_x, c1_y, c2_x, c2_y, iters):\n    buttons = []\n    # Determine the direction between the two points\n    if c1_x < c2_x:\n        dir1, dir2 = \"Right\", \"Left\"\n    elif c1_x > c2_x:\n        dir1, dir2 = \"Left\", \"Right\"\n    elif c1_y < c2_y:\n        dir1, dir2 = \"Down\", \"Up\"\n    else:\n        dir1, dir2 = \"Up\", \"Down\"\n    \n    for _ in range(iters):\n        buttons.append(dir1)\n        buttons.append(dir2)\n    return buttons\n\ninput_data = locals().get('input_data', {})\nc1x = int(input_data.get('coord1_x', 51))\nc1y = int(input_data.get('coord1_y', 12))\nc2x = int(input_data.get('coord2_x', 52))\nc2y = int(input_data.get('coord2_y', 12))\niters = int(input_data.get('iterations', 10))\n\nprint(json.dumps(generate_pacing_buttons(c1x, c1y, c2x, c2y, iters)))",
    "history": [
      {
        "commit_message": "Refined roamer_encounter_looper to prioritize efficiency and state verification.",
        "timestamp": "2025-12-23T20:28:20.548Z",
        "action_counter": 15218
      }
    ]
  }
}