{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "get_impassable_tiles": {
    "description": "Extracts and returns a JSON list of all impassable tile coordinates from the current map XML.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET; import json; root = ET.fromstring(map_xml_string); impassable_tiles = []; for row_elem in root.findall('Row'): y = int(row_elem.get('id')); for tile_elem in row_elem.findall('Tile'): x = int(tile_elem.get('id')); if tile_elem.get('type') == 'impassable' or tile_elem.find('Object') is not None: impassable_tiles.append({'x': x, 'y': y}); print(json.dumps(impassable_tiles))"
  },
  "inventory_navigator_tool": {
    "description": "Calculates the optimal number of button presses (Up/Down) to navigate from a current selection to a target item in a list-based menu. This version correctly handles non-wrapping menus and provides a warning for long scrolls.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory_list": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "current_selection": {
          "type": "string"
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "inventory_list",
        "current_selection",
        "target_item"
      ]
    },
    "python_script": "import json\ntry:\n    inventory = json.loads(input_data['inventory_list'])\n    current_item = input_data['current_selection']\n    target_item = input_data['target_item']\n\n    if current_item not in inventory or target_item not in inventory:\n        print(json.dumps({'error': 'Item not found in inventory list.'}))\n    else:\n        current_idx = inventory.index(current_item)\n        target_idx = inventory.index(target_item)\n        \n        response = {}\n        if current_idx == target_idx:\n            response = {'direction': 'NONE', 'presses': 0}\n        elif target_idx > current_idx:\n            presses = target_idx - current_idx\n            response = {'direction': 'DOWN', 'presses': presses}\n        else: # target_idx < current_idx\n            presses = current_idx - target_idx\n            response = {'direction': 'UP', 'presses': presses}\n\n        if response.get('presses', 0) > 4:\n            response['note'] = 'Warning: This is a long scroll. Press Down in increments of 4 to navigate pages more effectively.'\n        \n        print(json.dumps(response))\nexcept Exception as e:\n    print(json.dumps({'error': str(e), 'type': type(e).__name__}))"
  },
  "find_path": {
    "description": "A consolidated and robust pathfinding tool. Finds a path from a start to an end coordinate using A* algorithm, correctly handling all known tile types including ledges, open gates, and offscreen gates. If the destination is impassable, it finds a path to an adjacent walkable tile. This version now correctly handles disconnected map sections by first verifying connectivity and allows ignoring specific NPCs.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "movement_mode": {
          "type": "string",
          "enum": [
            "walking",
            "surfing"
          ]
        },
        "ignore_npc_ids": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "movement_mode"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\nimport json\n\ndef find_path(input_data):\n    map_xml_string = globals().get('map_xml_string', '')\n    if not map_xml_string:\n        print(json.dumps({'error': 'map_xml_string not found'}))\n        return\n\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    movement_mode = input_data['movement_mode']\n    ignore_npc_ids_str = input_data.get('ignore_npc_ids', '')\n    ignore_npc_ids = [int(id) for id in ignore_npc_ids_str.split(',') if id] if ignore_npc_ids_str else []\n\n    try:\n        root = ET.fromstring(map_xml_string)\n    except ET.ParseError as e:\n        print(json.dumps({'error': f'XML Parse Error: {e}'}))\n        return\n\n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            grid[(x, y)] = tile\n\n    def is_walkable(x, y):\n        tile = grid.get((x, y))\n        if not tile or tile.get('seen') == 'false':\n            return False\n        \n        tile_type = tile.get('type')\n        if tile_type in ['impassable', 'boulder_barrier', 'closed_gate']:\n            return False\n\n        if tile.find('Object') is not None:\n            obj = tile.find('Object')\n            obj_id_str = obj.get('id')\n            if obj_id_str and obj_id_str.isdigit():\n                obj_id = int(obj_id_str)\n                if obj_id in ignore_npc_ids:\n                    return True \n                if obj.get('id-name') != 'PIKACHU':\n                    return False\n            elif obj.get('name') and not obj.get('id-name'): # Background object\n                return False\n\n        if movement_mode == 'walking':\n            return tile_type not in ['water']\n        elif movement_mode == 'surfing':\n            return tile_type in ['water', 'ground', 'grass', 'steps', 'elevated_ground', 'cleared_boulder_barrier', 'open_gate', 'gate_offscreen']\n        return False\n\n    def get_neighbors(x, y):\n        neighbors = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            current_tile = grid.get((x, y))\n            neighbor_tile = grid.get((nx, ny))\n\n            if not neighbor_tile:\n                continue\n\n            # Ledge logic\n            if current_tile.get('type') == 'ledge' and dy == 1: # Jumping down a ledge\n                if is_walkable(nx, ny + 1):\n                    neighbors.append((nx, ny + 1))\n                continue\n            if neighbor_tile.get('type') == 'ledge' and dy == -1: # Trying to go up a ledge\n                continue\n            \n            if is_walkable(nx, ny):\n                neighbors.append((nx, ny))\n        return neighbors\n\n    def is_connected(start_node, end_node):\n        if not is_walkable(start_node[0], start_node[1]) or not is_walkable(end_node[0], end_node[1]):\n             # Find adjacent walkable tile if target is not walkable\n            target_walkable = False\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                if is_walkable(end_node[0] + dx, end_node[1] + dy):\n                    target_walkable = True\n                    break\n            if not target_walkable:\n                return False\n\n        q = [start_node]\n        visited = {start_node}\n        while q:\n            current = q.pop(0)\n            if current == end_node:\n                return True\n            for neighbor in get_neighbors(current[0], current[1]):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    q.append(neighbor)\n        return False\n\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n\n    # If end node is not walkable, find a walkable neighbor\n    if not is_walkable(end_x, end_y):\n        found_new_target = False\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = end_x + dx, end_y + dy\n            if is_walkable(nx, ny):\n                end_node = (nx, ny)\n                found_new_target = True\n                break\n        if not found_new_target:\n            print(json.dumps({'path': [], 'message': 'Destination and its neighbors are unwalkable.'}))\n            return\n\n    if not is_connected(start_node, end_node):\n        print(json.dumps({'path': [], 'message': 'Destination is in a disconnected area of the map.'}))\n        return\n\n    # A* algorithm\n    open_set = [(0, start_node)]\n    came_from = {}\n    g_score = {node: float('inf') for node in grid}\n    g_score[start_node] = 0\n    f_score = {node: float('inf') for node in grid}\n    f_score[start_node] = abs(start_x - end_node[0]) + abs(start_y - end_node[1])\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == end_node:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start_node)\n            print(json.dumps({'path': path[::-1]}))\n            return\n\n        for neighbor in get_neighbors(current[0], current[1]):\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = g_score[neighbor] + abs(neighbor[0] - end_node[0]) + abs(neighbor[1] - end_node[1])\n                if neighbor not in [i[1] for i in open_set]:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    print(json.dumps({'path': [], 'message': 'No path found.'}))\n\nfind_path(input_data)"
  },
  "mansion_puzzle_solver": {
    "description": "Analyzes the Pokemon Mansion's gate and switch puzzles. It takes the map XML and identifies switches, gates, and positional triggers to calculate the optimal sequence of actions to explore the entire floor. (v2)",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef parse_map_xml(xml_string):\n    root = ET.fromstring(xml_string)\n    grid, width, height = {}, int(root.get('width')), int(root.get('height'))\n    switches, gates, warps = {}, {}, []\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tile_type = tile.get('type')\n            is_warp = tile.get('is-warp') == 'true'\n            grid[(x, y)] = {'type': tile_type, 'is_warp': is_warp}\n            if is_warp: warps.append((x,y))\n            obj = tile.find('Object')\n            if obj is not None and obj.get('name') and 'Switch' in obj.get('name'):\n                switches[(x, y)] = 'toggle'\n            if 'gate' in tile_type:\n                gates[(x, y)] = tile_type\n    return grid, width, height, switches, gates, warps\n\ndef get_neighbors(pos, width, height):\n    x, y = pos\n    neighbors = []\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nx, ny = x + dx, y + dy\n        if 1 <= nx <= width and 1 <= ny <= height: neighbors.append((nx, ny))\n    return neighbors\n\ndef solve_mansion_2f(grid, width, height, start_pos, target_pos):\n    # Hardcoded logic for Pokemon Mansion 2F (map_id 214)\n    switch_pos = (3, 12)\n    trigger_1_pos = (11, 10)\n    trigger_2_pos = (21, 13)\n    west_gates = [(10, 5), (10, 6)]\n    east_gates = [(19, 9), (20, 9)]\n    south_gates = [(8, 23), (8, 24)] # Hypothetical based on map layout\n\n    # State: (player_pos, west_open, east_open, south_open)\n    q = deque([(start_pos, False, True, False, [])]) # Initial state based on current observation\n    visited = set([(start_pos, False, True, False)])\n\n    while q:\n        pos, w_open, e_open, s_open, path = q.popleft()\n        if pos == target_pos: return path\n        if len(path) > 75: continue\n\n        # Movement\n        for neighbor in get_neighbors(pos, width, height):\n            tile_type = grid[neighbor]['type']\n            is_passable = tile_type in ['ground', 'open_gate']\n            if (neighbor in west_gates and w_open) or (neighbor in east_gates and e_open) or (neighbor in south_gates and s_open):\n                is_passable = True\n            if grid[neighbor].get('is_warp'): is_passable = True\n\n            if is_passable:\n                next_path = path + [neighbor]\n                nw_open, ne_open, ns_open = w_open, e_open, s_open\n                if neighbor == trigger_1_pos:\n                    nw_open, ne_open = False, True\n                if neighbor == trigger_2_pos:\n                    ne_open = True\n                \n                state = (neighbor, nw_open, ne_open, ns_open)\n                if state not in visited:\n                    visited.add(state)\n                    q.append((neighbor, nw_open, ne_open, ns_open, next_path))\n\n        # Switch Interaction (must be adjacent to (3,12) and facing it)\n        if abs(pos[0] - switch_pos[0]) + abs(pos[1] - switch_pos[1]) == 1:\n            next_path = path + [f'PRESS_SWITCH_{switch_pos}']\n            # Rule: Switch toggles the southern gates\n            ns_open_toggled = not s_open\n            state = (pos, w_open, e_open, ns_open_toggled)\n            if state not in visited:\n                visited.add(state)\n                q.append((pos, w_open, e_open, ns_open_toggled, next_path))\n\n    return ['No solution found by v2 solver.']\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    grid, width, height, _, _, _ = parse_map_xml(map_xml_string)\n    solution = solve_mansion_2f(grid, width, height, (start_x, start_y), (target_x, target_y))\n    print(json.dumps(solution))\nexcept Exception as e:\n    import traceback\n    print(json.dumps([f'Error: {str(e)}', traceback.format_exc()]))"
  }
}