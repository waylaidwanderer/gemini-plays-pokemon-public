{
  "auto_attacker": {
    "description": "Calculates the directional button presses needed to select a specific move from the 2x2 battle move menu. Does not press 'A'.",
    "input_schema": {
      "type": "object",
      "properties": {
        "move_to_select": {
          "type": "string"
        },
        "pokemon_move_list": {
          "type": "string"
        },
        "current_selected_move": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "move_to_select",
        "pokemon_move_list"
      ]
    },
    "python_script": "import json\n\ndef auto_attacker(move_to_select, pokemon_move_list_str, current_selected_move_str=None):\n    move_list = json.loads(pokemon_move_list_str)\n    \n    try:\n        target_index = move_list.index(move_to_select)\n    except ValueError:\n        print(json.dumps({'status': 'failure', 'reason': f'Target move \\\"{move_to_select}\\\" not found in move list.'}))\n        return\n\n    start_index = 0\n    if current_selected_move_str:\n        try:\n            start_index = move_list.index(current_selected_move_str)\n        except ValueError:\n            start_index = 0\n\n    presses = []\n    diff = target_index - start_index\n\n    if diff > 0:\n        for _ in range(diff):\n            presses.append('Down')\n    elif diff < 0:\n        for _ in range(abs(diff)):\n            presses.append('Up')\n\n    print(json.dumps({'status': 'success', 'presses': presses}))\n\nauto_attacker(input_data['move_to_select'], input_data['pokemon_move_list'], input_data.get('current_selected_move'))",
    "history": [
      {
        "commit_message": "feat: Create auto_attacker tool to streamline battle actions. In response to my 50-turn reflection identifying an inefficiency, this tool combines the logic of selecting a move and pressing 'A' to use it into a single, automated command. This is a critical step to improve my turn-by-turn efficiency in combat.",
        "timestamp": "2025-08-20T00:25:17.302Z",
        "action_counter": 155553
      },
      {
        "commit_message": "refactor: Add 'FIGHT' selection to automate full attack sequence. In response to a direct Overwatch critique, this commit refactors the tool to handle the entire attack process, from selecting 'FIGHT' on the main menu to executing the chosen move. This eliminates the previous multi-turn manual process, improving battle efficiency and preventing user error. This is a critical fix to adhere to the immediate action mandate.",
        "timestamp": "2025-08-20T01:45:41.444Z",
        "action_counter": 155731
      },
      {
        "commit_message": "refactor: Remove all 'A' presses to comply with system input rules. The tool now only calculates and outputs the directional presses required to highlight a move in the menu, preventing mixed-input errors. The user must manually press 'A' in subsequent turns.",
        "timestamp": "2025-08-20T02:07:25.147Z",
        "action_counter": 155779
      },
      {
        "commit_message": "feat: Create auto_attacker tool to streamline battle actions. In response to my 50-turn reflection identifying an inefficiency, this tool combines the logic of selecting a move and pressing 'A' to use it into a single, automated command. This is a critical step to improve my turn-by-turn efficiency in combat.",
        "timestamp": "2025-08-20T04:21:47.836Z",
        "action_counter": 156070
      },
      {
        "commit_message": "fix: Implement vertical list logic for move selection. The previous version incorrectly assumed a 2x2 grid for the move menu, leading to incorrect directional outputs. This commit replaces the faulty grid logic with a simple index comparison for a linear, vertical menu, ensuring correct navigation. This is a critical fix to restore the tool's core functionality.",
        "timestamp": "2025-08-20T04:23:23.452Z",
        "action_counter": 156074
      },
      {
        "commit_message": "fix: Implement 2x2 grid logic for move selection. The previous version incorrectly assumed a vertical list, causing incorrect navigation and move selection. This commit replaces the faulty logic with a coordinate-based system that correctly calculates Up/Down and Left/Right presses for a 2x2 grid. This is a critical fix to restore the tool's core functionality and prevent future battle errors, as mandated by an Overwatch critique.",
        "timestamp": "2025-08-20T06:14:21.880Z",
        "action_counter": 156301
      },
      {
        "commit_message": "fix: Revert to vertical list logic for move selection. My previous fix incorrectly assumed a 2x2 grid, but in-game observation confirms the move menu is a simple vertical list. This commit reverts the logic to correctly calculate only Up/Down presses. This is a critical fix to restore the tool's core functionality based on direct evidence from the game screen.",
        "timestamp": "2025-08-20T06:15:54.921Z",
        "action_counter": 156304
      }
    ]
  },
  "auto_switcher": {
    "description": "Automates the entire process of switching Pokémon in battle. Takes a target Pokémon's name and party info, then returns the full sequence of button presses ('Right' for PKMN, directional inputs, 'A', 'A').",
    "input_schema": {
      "type": "object",
      "properties": {
        "pokemon_to_select": {
          "type": "string"
        },
        "party_pokemon_list": {
          "type": "string"
        },
        "lead_pokemon_name": {
          "type": "string"
        }
      },
      "required": [
        "pokemon_to_select",
        "party_pokemon_list",
        "lead_pokemon_name"
      ]
    },
    "python_script": "import json\n\ndef auto_switcher(pokemon_to_select, party_pokemon_list_str, lead_pokemon_name):\n    presses = ['Right', 'A']\n    party_list = json.loads(party_pokemon_list_str)\n    print(f\"DEBUG: auto_switcher - Party List: {party_list}\")\n    print(f\"DEBUG: auto_switcher - Lead: {lead_pokemon_name}, Target: {pokemon_to_select}\")\n    \n    try:\n        start_index = party_list.index(lead_pokemon_name)\n    except ValueError:\n        print(json.dumps({'status': 'failure', 'reason': f'Lead Pokémon \"{lead_pokemon_name}\" not found in party list.'}))\n        return\n\n    try:\n        target_index = party_list.index(pokemon_to_select)\n    except ValueError:\n        print(json.dumps({'status': 'failure', 'reason': f'Target Pokémon \"{pokemon_to_select}\" not found in party list.'}))\n        return\n\n    print(f\"DEBUG: auto_switcher - Start Index: {start_index}, Target Index: {target_index}\")\n    diff = target_index - start_index\n    print(f\"DEBUG: auto_switcher - Calculated Diff: {diff}\")\n\n    if diff > 0:\n        for _ in range(diff):\n            presses.append('Down')\n    elif diff < 0:\n        for _ in range(abs(diff)):\n            presses.append('Up')\n\n    presses.append('A')\n    presses.append('A')\n    print(json.dumps({'status': 'success', 'presses': presses}))\n\nauto_switcher(input_data['pokemon_to_select'], input_data['party_pokemon_list'], input_data['lead_pokemon_name'])",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-08-19T22:46:58.889Z",
        "action_counter": 155341
      },
      {
        "commit_message": "fix: Correct SyntaxError by wrapping logic in a function. The tool was failing with a `SyntaxError: 'return' outside function` because the script logic was not properly encapsulated. This commit wraps the entire process within a single function, ensuring all `return` statements are correctly scoped. It also refines the logic to correctly generate the full sequence of button presses for a switch, from selecting 'PKMN' on the main menu to confirming the final choice.",
        "timestamp": "2025-08-19T22:58:40.462Z",
        "action_counter": 155360
      },
      {
        "commit_message": "fix: Correct battle menu navigation logic. The tool was using 'Down' to select the PKMN option, which is incorrect for the 2x2 battle menu layout. This commit changes the initial button press to 'Right', ensuring the tool correctly navigates to the Pokémon selection screen. This is a critical fix to restore the tool's intended functionality.",
        "timestamp": "2025-08-19T22:59:34.999Z",
        "action_counter": 155362
      },
      {
        "commit_message": "refactor: Change input from index to name for robustness. The tool was previously failing because it relied on a numeric index for the current cursor position, which was based on an incorrect assumption. This commit refactors the tool to accept the *name* of the currently selected Pokémon, making the logic independent of unpredictable cursor starting positions. This is a critical fix to improve reliability, as identified during my 50-turn reflection and by an Overwatch critique.",
        "timestamp": "2025-08-20T02:47:46.482Z",
        "action_counter": 155863
      },
      {
        "commit_message": "fix: Add 'Down' press to correctly select 'SWITCH' option. The previous version incorrectly assumed the party sub-menu defaulted to 'SWITCH', causing it to open the 'STATS' screen instead. This commit adds a 'Down' press to navigate from the default 'STATS' option to 'SWITCH', ensuring the tool performs the intended action. This is a critical fix for battle automation.",
        "timestamp": "2025-08-20T05:06:30.462Z",
        "action_counter": 156174
      },
      {
        "commit_message": "fix: Remove incorrect 'Down' press from switch sequence. In-game observation confirms the party sub-menu defaults to 'SWITCH', not 'STATS' as previously assumed. The extra 'Down' press was causing the tool to select 'STATS' instead of confirming the switch. This commit removes the erroneous press, restoring the tool's core functionality.",
        "timestamp": "2025-08-20T10:15:40.014Z",
        "action_counter": 156551
      },
      {
        "commit_message": "fix: Correct cursor logic to start from active Pokémon. The tool was incorrectly assuming the party menu cursor starts on the lead Pokémon. This commit refactors the logic to take the `active_pokemon_name` as the starting point, ensuring correct path calculation during in-battle switches. This is a critical fix to restore the tool's core functionality, as mandated by an Overwatch critique.",
        "timestamp": "2025-08-20T13:50:20.672Z",
        "action_counter": 156661
      },
      {
        "commit_message": "fix: Add diagnostic logging to debug repeated failures. The tool has failed multiple times, causing incorrect switches and faints. This commit adds print statements to log the input party list, active/target Pokémon names, and calculated indices to identify the root cause of the incorrect button sequence generation, as mandated by a critical Overwatch review.",
        "timestamp": "2025-08-20T16:15:19.648Z",
        "action_counter": 156811
      },
      {
        "commit_message": "fix: Correct cursor logic to start from lead Pokémon. The tool was incorrectly assuming the party menu cursor starts on the active Pokémon, causing catastrophic switch failures. In-game observation confirmed the cursor defaults to the lead Pokémon. This commit refactors the logic and input schema to use `lead_pokemon_name` as the starting point, which is a critical fix to restore the tool's core functionality.",
        "timestamp": "2025-08-20T16:43:36.302Z",
        "action_counter": 156849
      }
    ]
  },
  "battle_data_extractor": {
    "description": "Parses battle data by taking separate JSON strings for player party and enemy pokemon, making it more robust against parsing errors.",
    "input_schema": {
      "type": "object",
      "properties": {
        "player_party_json": {
          "type": "string"
        },
        "enemy_pokemon_json": {
          "type": "string"
        },
        "active_pokemon_name": {
          "type": "string"
        },
        "opponent_known_moves": {
          "type": "string",
          "nullable": true
        },
        "type_map_json": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "player_party_json",
        "enemy_pokemon_json",
        "active_pokemon_name"
      ]
    },
    "python_script": "import json\n\ndef extract_battle_data(player_party_json, enemy_pokemon_json, active_pokemon_name, opponent_known_moves_str, type_map_json=None):\n    try:\n        player_party_dict = json.loads(player_party_json)\n        enemy_pokemon_list = json.loads(enemy_pokemon_json)\n\n        if type_map_json:\n            type_map = json.loads(type_map_json)\n        else:\n            type_map = {}\n\n        def get_types(species_name):\n            if not species_name:\n                return \"Unknown\", None\n            types = type_map.get(species_name, [\"Unknown\"])\n            type1 = types[0]\n            type2 = types[1] if len(types) > 1 else None\n            return type1, type2\n\n        active_pokemon_data = player_party_dict.get(active_pokemon_name)\n        \n        if not active_pokemon_data:\n             print(json.dumps({\"error\": f\"Active pokemon '{active_pokemon_name}' not found in party.\"}))\n             return\n\n        active_type1, active_type2 = get_types(active_pokemon_data.get('species'))\n        player_active_pokemon = {\n            \"name\": active_pokemon_data.get('name'),\n            \"level\": active_pokemon_data.get('level'),\n            \"hp_current\": active_pokemon_data.get('hp_current'),\n            \"hp_max\": active_pokemon_data.get('hp_max'),\n            \"type1\": active_type1, \"type2\": active_type2, \"status\": active_pokemon_data.get('status'),\n            \"moves\": active_pokemon_data.get('moves')\n        }\n\n        player_party_formatted = []\n        for pkm in player_party_dict.values():\n            type1, type2 = get_types(pkm.get('species'))\n            player_party_formatted.append({\n                \"name\": pkm.get('name'),\n                \"level\": pkm.get('level'),\n                \"hp_current\": pkm.get('hp_current'),\n                \"hp_max\": pkm.get('hp_max'),\n                \"status\": pkm.get('status'),\n                \"type1\": type1, \"type2\": type2\n            })\n\n        if not enemy_pokemon_list:\n            print(json.dumps({\"error\": \"The 'enemy_pokemon' list is empty.\"}))\n            return\n\n        opponent_data = enemy_pokemon_list[0]\n        opponent_species_name = opponent_data.get('name')\n        opponent_type1, opponent_type2 = get_types(opponent_species_name)\n        opponent_active_pokemon = {\n            \"name\": opponent_species_name, \n            \"level\": opponent_data.get('level'),\n            \"type1\": opponent_type1, \"type2\": opponent_type2, \"status\": opponent_data.get('status'),\n            \"is_opponent_invulnerable\": False,\n            \"known_moves\": json.loads(opponent_known_moves_str) if opponent_known_moves_str and opponent_known_moves_str != 'null' else []\n        }\n\n        output = {\n            \"player_active_pokemon\": player_active_pokemon,\n            \"player_party\": player_party_formatted,\n            \"opponent_active_pokemon\": opponent_active_pokemon\n        }\n        print(json.dumps(output))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({\"error\": str(e), \"traceback\": traceback.format_exc()}))\n\nplayer_party_json = input_data['player_party_json']\nenemy_pokemon_json = input_data['enemy_pokemon_json']\nactive_pokemon_name = input_data['active_pokemon_name']\nopponent_known_moves_str = input_data.get('opponent_known_moves', '')\ntype_map_json_str = input_data.get('type_map_json')\n\nextract_battle_data(player_party_json, enemy_pokemon_json, active_pokemon_name, opponent_known_moves_str, type_map_json_str)",
    "history": [
      {
        "commit_message": "feat: Create battle_data_extractor tool. In response to my 50-turn reflection identifying a slow, manual, and error-prone process, this tool automates the extraction and formatting of all necessary battle data from the game state. It will significantly improve the speed and reliability of calling the `battle_strategist_agent`, making my in-battle decision-making more efficient.",
        "timestamp": "2025-08-18T14:31:39.397Z",
        "action_counter": 152542
      },
      {
        "commit_message": "fix: Correct JSON parsing logic. The tool was crashing with a KeyError because it was looking for a non-existent 'battle_info' key. This commit updates the script to correctly parse the 'party' and 'enemy_pokemon' keys from the root of the game_state JSON. It also adds a hardcoded type map as a temporary solution to the missing type data, allowing the tool to function until a more robust Pokedex lookup can be implemented.",
        "timestamp": "2025-08-18T14:39:23.279Z",
        "action_counter": 152549
      },
      {
        "commit_message": "fix: Correct opponent data parsing. The tool was crashing with an AttributeError because it was treating the `enemy_pokemon` list as a dictionary and using the incorrect key 'name' instead of 'species'. This commit updates the script to correctly access the first element of the list and use the 'species' key, restoring functionality.",
        "timestamp": "2025-08-18T15:15:44.827Z",
        "action_counter": 152593
      },
      {
        "commit_message": "fix: Add Gengar to type map. The tool was failing to identify Gengar's type, which is critical for the battle_strategist_agent. This commit adds its Ghost/Poison typing to the hardcoded map.",
        "timestamp": "2025-08-18T15:37:47.069Z",
        "action_counter": 152624
      },
      {
        "commit_message": "refactor: Add type_map_json parameter to improve robustness. In response to an Overwatch critique, this commit refactors the tool to accept an optional `type_map_json` parameter. This removes the dependency on a hardcoded internal dictionary, preventing future crashes when encountering new Pokémon species and making the tool more flexible and reliable.",
        "timestamp": "2025-08-18T16:56:26.938Z",
        "action_counter": 152732
      },
      {
        "commit_message": "fix: Add `active_pokemon_name` parameter and correct HP keys. The tool was crashing with an `IndexError` because it incorrectly assumed the active Pokémon was always at index 0 of the party list. It also used the wrong keys ('hp_current') for HP values from the party data. This commit adds a required `active_pokemon_name` parameter to correctly identify the active Pokémon and updates the script to use the correct 'hp' and 'max_hp' keys, preventing future crashes and ensuring data accuracy.",
        "timestamp": "2025-08-18T17:09:17.534Z",
        "action_counter": 152753
      },
      {
        "commit_message": "fix: Add debug print to diagnose IndexError. The tool is failing with a `list index out of range` error when parsing opponent data. This commit adds a print statement to inspect the `enemy_pokemon` list from the game state, which will help determine if the list is unexpectedly empty or malformed.",
        "timestamp": "2025-08-18T18:31:57.837Z",
        "action_counter": 152906
      },
      {
        "commit_message": "fix: Add explicit check for empty opponent list. The tool was crashing with an IndexError without providing clear diagnostics. This commit adds a check to verify if the `enemy_pokemon` list is empty and returns a specific error message if it is. This is a critical debugging step to isolate whether the game state is being passed incorrectly or if there's another issue.",
        "timestamp": "2025-08-18T18:32:50.406Z",
        "action_counter": 152908
      },
      {
        "commit_message": "fix: Add detailed type/value logging to diagnose IndexError. The tool continues to fail with an IndexError despite a check for an empty list. This commit adds explicit print statements for the type and value of the 'enemy_pokemon' list immediately before the check. This is a critical diagnostic step, taken in immediate response to an Overwatch critique, to uncover the root cause of why the empty-list check is not preventing the crash.",
        "timestamp": "2025-08-18T19:16:52.205Z",
        "action_counter": 153001
      },
      {
        "commit_message": "refactor: Replace single game_state_json with separate party/enemy inputs. The previous implementation was highly brittle, frequently failing due to JSON parsing errors on the massive, hard-to-validate game state string. This commit refactors the tool to accept smaller, discrete JSON strings for the player party and enemy Pokémon. This is a critical fix to improve reliability and prevent future crashes during battle analysis.",
        "timestamp": "2025-08-18T19:52:10.932Z",
        "action_counter": 153070
      },
      {
        "commit_message": "fix: Add detailed type/value logging to diagnose IndexError. The tool continues to fail with an IndexError despite a check for an empty list. This commit adds explicit print statements for the type and value of the 'enemy_pokemon' list immediately before the check. This is a critical diagnostic step to uncover the root cause of why the empty-list check is not preventing the crash.",
        "timestamp": "2025-08-18T19:53:51.035Z",
        "action_counter": 153073
      },
      {
        "commit_message": "fix: Add robust type handling to prevent IndexError. The tool was crashing because the provided `type_map_json` used single-element lists for single-type Pokémon, causing an `IndexError` when the code tried to access a non-existent second type. This commit refactors the type-lookup logic to correctly handle lists of any length, ensuring that single-type Pokémon are assigned `None` for their second type. This is a critical fix to prevent future crashes and ensure data integrity.",
        "timestamp": "2025-08-18T19:54:55.301Z",
        "action_counter": 153075
      },
      {
        "commit_message": "fix: Correct key from 'nickname' to 'name'. The tool was crashing because the party data from the game state uses the 'name' key for Pokémon names, not 'nickname'. This commit updates all instances to use the correct key, preventing future crashes during data extraction.",
        "timestamp": "2025-08-19T03:44:50.580Z",
        "action_counter": 154021
      },
      {
        "commit_message": "fix: Correct key access for species name. The tool was failing to extract types because it was not correctly accessing the 'species' key from the party and enemy data structures. This commit updates the script to use `pkm.get('species')` for all type lookups, ensuring that the tool can now correctly identify and assign types to all Pokémon in the battle.",
        "timestamp": "2025-08-19T03:47:44.875Z",
        "action_counter": 154024
      },
      {
        "commit_message": "fix: Correct key access for HP and parse known_moves. The tool was failing because it was using incorrect keys ('hp', 'max_hp') to access health data from the party JSON. This commit updates the script to use the correct keys ('hp_current', 'hp_max'). Additionally, the opponent's known moves were being treated as a raw string instead of a JSON list; this is now fixed with `json.loads` to ensure proper parsing. This is a critical fix to restore the tool's core functionality for battle analysis.",
        "timestamp": "2025-08-19T04:19:50.881Z",
        "action_counter": 154077
      },
      {
        "commit_message": "fix: Correct key access from 'species' to 'name' for opponent data. The tool was crashing because the enemy data from the game state uses the 'name' key for the Pokémon's species, not 'species'. This commit updates the script to use the correct key, preventing future crashes during data extraction.",
        "timestamp": "2025-08-20T02:38:19.024Z",
        "action_counter": 155841
      },
      {
        "commit_message": "fix: Correct iteration over player party data. The tool was failing because it was iterating over the keys of the player party dictionary (a string) instead of the dictionary values (objects). This commit changes the loop to `for pkm in player_party_dict.values():` and adjusts the active pokemon lookup to use `.get()` on the dictionary, which is more direct and robust.",
        "timestamp": "2025-08-20T10:09:44.371Z",
        "action_counter": 156538
      }
    ]
  },
  "type_map_generator": {
    "description": "Generates a JSON string mapping Pokémon species names to their types based on a hardcoded dictionary. Takes player party and enemy Pokémon JSON as input.",
    "input_schema": {
      "type": "object",
      "properties": {
        "player_party_json": {
          "type": "string"
        },
        "enemy_pokemon_json": {
          "type": "string"
        }
      },
      "required": [
        "player_party_json",
        "enemy_pokemon_json"
      ]
    },
    "python_script": "import json\n\ndef generate_type_map(player_party_json, enemy_pokemon_json):\n    KNOWN_TYPES = {\n        'MAROWAK': ['Ground'], 'KANGASKHAN': ['Normal'], 'LAPRAS': ['Water', 'Ice'],\n        'GOLEM': ['Rock', 'Ground'], 'PIKACHU': ['Electric'], 'GOLBAT': ['Poison', 'Flying'],\n        'DRAGONITE': ['Dragon', 'Flying'], 'GYARADOS': ['Water', 'Flying'], 'CHARIZARD': ['Fire', 'Flying'],\n        'AERODACTYL': ['Rock', 'Flying'], 'DEWGONG': ['Water', 'Ice'], 'JYNX': ['Ice', 'Psychic'],\n        'SLOWBRO': ['Water', 'Psychic'], 'CLOISTER': ['Water', 'Ice'], 'HITMONCHAN': ['Fighting'],\n        'POLIWRATH': ['Water', 'Fighting'], 'HITMONLEE': ['Fighting'], 'ONIX': ['Rock', 'Ground'],\n        'MACHAMP': ['Fighting'], 'GENGAR': ['Ghost', 'Poison'], 'ARBOK': ['Poison']\n    }\n    type_map = {}\n    try:\n        player_party = json.loads(player_party_json)\n        for pkm in player_party.values():\n            species = pkm.get('species')\n            if species and species in KNOWN_TYPES:\n                type_map[species] = KNOWN_TYPES[species]\n        enemy_pokemon = json.loads(enemy_pokemon_json)\n        for pkm in enemy_pokemon:\n            species = pkm.get('name')\n            if species and species in KNOWN_TYPES:\n                type_map[species] = KNOWN_TYPES[species]\n        print(json.dumps({'status': 'success', 'type_map_json': json.dumps(type_map)}))\n    except Exception as e:\n        print(json.dumps({'status': 'failure', 'reason': str(e)}))\n\ngenerate_type_map(input_data['player_party_json'], input_data['enemy_pokemon_json'])",
    "history": [
      {
        "commit_message": "feat: Create type_map_generator tool. This tool automates the creation of the type map JSON required by other battle tools. This eliminates a repetitive, error-prone manual step identified during my 50-turn reflection, improving overall reliability and efficiency.",
        "timestamp": "2025-08-20T06:30:22.987Z",
        "action_counter": 156329
      },
      {
        "commit_message": "fix: Correct iteration over player party data. The tool was failing because it was iterating over the keys of the player party dictionary (strings) instead of the dictionary values (objects). This commit changes the loop to `for pkm in player_party.values():` to correctly access the Pokémon data. This is a critical fix to restore the tool's functionality.",
        "timestamp": "2025-08-20T10:07:49.034Z",
        "action_counter": 156534
      }
    ]
  },
  "find_path": {
    "description": "Finds the shortest path between two points on the current map using the A* algorithm. Can find a path to an adjacent tile if the destination is impassable. Returns a list of coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef find_path(start_x_str, start_y_str, end_x_str, end_y_str):\n    start_x, start_y = int(start_x_str), int(start_y_str)\n    end_x, end_y = int(end_x_str), int(end_y_str)\n    \n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.get('width'))\n    map_height = int(root.get('height'))\n    \n    grid = [['' for _ in range(map_width + 1)] for _ in range(map_height + 1)]\n    traversable_types = ['ground', 'grass', 'steps', 'elevated_ground', 'cleared_boulder_barrier', 'ladder_up', 'ladder_down']\n    \n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tile_type = tile.get('type')\n            \n            has_impassable_object = False\n            if tile.find('Object') is not None:\n                obj = tile.find('Object')\n                if 'id-name' in obj.attrib and obj.attrib['id-name'] != 'Pikachu':\n                    has_impassable_object = True\n\n            if tile_type in traversable_types and not has_impassable_object:\n                grid[y][x] = 'traversable'\n            else:\n                grid[y][x] = 'impassable'\n\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n\n    if grid[end_y][end_x] == 'impassable':\n        possible_goals = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = end_x + dx, end_y + dy\n            if 1 <= nx <= map_width and 1 <= ny <= map_height and grid[ny][nx] == 'traversable':\n                possible_goals.append((nx, ny))\n        \n        if not possible_goals:\n            print(json.dumps({'status': 'failure', 'reason': 'Destination and all adjacent tiles are impassable.'}))\n            return\n        \n        possible_goals.sort(key=lambda pos: abs(pos[0] - start_x) + abs(pos[1] - start_y))\n        end_node = possible_goals[0]\n        end_x, end_y = end_node\n\n    open_set = [(0, start_node)]\n    came_from = {}\n    g_score = { (x,y): float('inf') for x in range(map_width + 1) for y in range(map_height + 1) }\n    g_score[start_node] = 0\n    f_score = { (x,y): float('inf') for x in range(map_width + 1) for y in range(map_height + 1) }\n    f_score[start_node] = abs(start_x - end_x) + abs(start_y - end_y)\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == end_node:\n            path = []\n            while current in came_from:\n                path.append({'x': current[0], 'y': current[1]})\n                current = came_from[current]\n            path.append({'x': start_node[0], 'y': start_node[1]})\n            path.reverse()\n            print(json.dumps({'status': 'success', 'path': path}))\n            return\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            nx, ny = neighbor\n\n            if not (1 <= nx <= map_width and 1 <= ny <= map_height):\n                continue\n            \n            if grid[ny][nx] == 'impassable':\n                continue\n\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                h_score = abs(nx - end_x) + abs(ny - end_y)\n                f_score[neighbor] = tentative_g_score + h_score\n                if neighbor not in [item[1] for item in open_set]:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    print(json.dumps({'status': 'failure', 'reason': 'No path found.'}))\n\nfind_path(input_data['start_x'], input_data['start_y'], input_data['end_x'], input_data['end_y'])",
    "history": [
      {
        "commit_message": "feat: Create find_path tool to automate navigation. In response to a critical overwatch review identifying over 100 wasted turns due to manual navigation failure, this tool implements an A* pathfinding algorithm. It parses the map XML, handles impassable destinations by targeting adjacent tiles, and will prevent future catastrophic navigation loops. This replaces the previous, unused pathfinding tool.",
        "timestamp": "2025-08-20T09:43:44.097Z",
        "action_counter": 156512
      }
    ]
  }
}