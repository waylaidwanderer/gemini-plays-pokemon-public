{
  "find_reachable_unseen_tiles": {
    "description": "Identifies all unseen tiles on the current map that are adjacent to reachable walkable tiles. If autopress_buttons is true, returns a path to the nearest one.",
    "input_schema": {
      "type": "object",
      "properties": {
        "current_x": {
          "type": "integer"
        },
        "current_y": {
          "type": "integer"
        },
        "autopress_buttons": {
          "type": "boolean"
        }
      },
      "required": [
        "current_x",
        "current_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport collections\n\n# Use global map_xml_string and input_data\nroot = ET.fromstring(map_xml_string)\nautopress = input_data.get('autopress_buttons', False)\ncurrent_x = input_data.get('current_x')\ncurrent_y = input_data.get('current_y')\n\ngrid = {}\nfor row in root.findall('Row'):\n    y = int(row.attrib['id'])\n    for tile in row.findall('Tile'):\n        x = int(tile.attrib['id'])\n        grid[(x, y)] = tile\n\nif current_x is None or current_y is None:\n    player_pos = None\n    for (x, y), tile in grid.items():\n        if tile.find('Player') is not None:\n            player_pos = (x, y)\n            break\nelse:\n    player_pos = (int(current_x), int(current_y))\n        \nif not player_pos:\n    if autopress:\n        print(json.dumps([]))\n    else:\n        print(json.dumps({\"unseen_tiles\": [], \"buttons\": []}))\nelse:\n    is_surfing = grid[player_pos].attrib['type'] == 'WATER'\n\n    def can_move(from_pos, to_pos, direction):\n        if to_pos not in grid: return False\n        f_tile = grid[from_pos]\n        t_tile = grid[to_pos]\n        f_type = f_tile.attrib['type']\n        t_type = t_tile.attrib['type']\n        \n        if t_tile.attrib['seen'] == 'false': return False\n        if t_type == 'WALL': return False\n        if t_tile.find('Object') is not None: return False\n        if t_type == 'WATER' and not is_surfing: return False\n        if t_type == 'WATERFALL' and not is_surfing: return False\n        \n        # Directional collisions\n        if direction == 'Down':\n            if f_type == 'WALL_DOWN_FLOOR': return False\n            if t_type == 'FLOOR_UP_WALL': return False\n        elif direction == 'Up':\n            if f_type == 'WALL_UP_FLOOR': return False\n            if t_type == 'FLOOR_DOWN_WALL': return False\n        elif direction == 'Right':\n            if f_type == 'WALL_RIGHT_FLOOR': return False\n            if t_type == 'FLOOR_LEFT_WALL': return False\n        elif direction == 'Left':\n            if f_type == 'WALL_LEFT_FLOOR': return False\n            if t_type == 'FLOOR_RIGHT_WALL': return False\n            \n        # Ledges\n        if t_type == 'LEDGE_DOWN': return direction == 'Down'\n        if t_type == 'LEDGE_LEFT': return direction == 'Left'\n        if t_type == 'LEDGE_RIGHT': return direction == 'Right'\n        \n        return True\n\n    queue = collections.deque([player_pos])\n    visited = {player_pos}\n    reachable_walkable = set()\n    while queue:\n        cx, cy = queue.popleft()\n        reachable_walkable.add((cx, cy))\n        for dx, dy, btn in [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) in grid:\n                if can_move((cx, cy), (nx, ny), btn) and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n\n    reachable_unseen = []\n    for (cx, cy) in reachable_walkable:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) in grid and grid[(nx, ny)].attrib['seen'] == 'false':\n                if [nx, ny] not in reachable_unseen:\n                    reachable_unseen.append([nx, ny])\n\n    path_found = []\n    if reachable_unseen:\n        queue = collections.deque([(player_pos, [])])\n        visited_path = {player_pos}\n        while queue:\n            (cx, cy), path = queue.popleft()\n            for dx, dy, btn in [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n                nx, ny = cx + dx, cy + dy\n                if (nx, ny) in grid:\n                    if grid[(nx, ny)].attrib['seen'] == 'false':\n                        # Check if we can stand next to it\n                        path_found = path + [btn]\n                        break\n                    if can_move((cx, cy), (nx, ny), btn) and (nx, ny) not in visited_path:\n                        visited_path.add((nx, ny))\n                        queue.append(((nx, ny), path + [btn]))\n                if path_found: break\n            if path_found: break\n\n    if autopress:\n        print(json.dumps(path_found))\n    else:\n        print(json.dumps({\"unseen_tiles\": reachable_unseen, \"buttons\": path_found}))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T18:35:24.812Z",
        "action_counter": 41414
      },
      {
        "commit_message": "Refined logic to correctly identify unseen tiles adjacent to reachable walkable tiles. Removed 'unseen' from walkable types to ensure search only passes through confirmed traversable areas.",
        "timestamp": "2026-01-11T22:25:41.646Z",
        "action_counter": 41821
      },
      {
        "commit_message": "Fix find_reachable_unseen_tiles to return button strings when autopress_buttons is true.",
        "timestamp": "2026-01-12T01:57:28.881Z",
        "action_counter": 42305
      },
      {
        "commit_message": "Initial implementation of find_reachable_unseen_tiles. Fixed collision check to include BOOKSHELF.",
        "timestamp": "2026-01-12T04:26:41.177Z",
        "action_counter": 42572
      },
      {
        "commit_message": "Refined collision logic to include PC and WINDOW. Ensured exploration tool accounts for indoor obstacles.",
        "timestamp": "2026-01-12T04:49:49.116Z",
        "action_counter": 42622
      },
      {
        "commit_message": "Initial implementation of reachable unseen tiles finder.",
        "timestamp": "2026-01-12T06:33:54.023Z",
        "action_counter": 42797
      },
      {
        "commit_message": "Initial implementation with basic collision check and reachability analysis.",
        "timestamp": "2026-01-12T10:23:29.129Z",
        "action_counter": 43173
      },
      {
        "commit_message": "Refined to return a path of buttons to the nearest unseen tile when called with autopress_buttons.",
        "timestamp": "2026-01-12T10:27:10.775Z",
        "action_counter": 43180
      },
      {
        "commit_message": "Refined collision logic to handle ledges (Down, Left, Right) and one-way walls (FLOOR_UP_WALL, WALL_UP_FLOOR). Removed WATER from default walkable list.",
        "timestamp": "2026-01-12T10:56:58.943Z",
        "action_counter": 43237
      },
      {
        "commit_message": "Adding wall and ledge collision logic to find_reachable_unseen_tiles.",
        "timestamp": "2026-01-12T14:00:58.389Z",
        "action_counter": 43503
      },
      {
        "commit_message": "Refining collision logic for all wall types and ledges in the exploration tool.",
        "timestamp": "2026-01-12T14:16:45.409Z",
        "action_counter": 43531
      },
      {
        "commit_message": "Explicitly add autopress_buttons to schema to ensure it's passed to input_data.",
        "timestamp": "2026-01-12T14:30:40.926Z",
        "action_counter": 43547
      },
      {
        "commit_message": "Incorporate directional collision logic (FLOOR_UP_WALL, etc.) and ledge jumping into find_reachable_unseen_tiles.",
        "timestamp": "2026-01-12T14:47:36.458Z",
        "action_counter": 43574
      }
    ]
  },
  "menu_navigator": {
    "description": "Executes a sequence of button presses to navigate menus. Returns a JSON array of buttons. Use this to bypass the restriction on mixing directional and action inputs. Automatically handles autopress_buttons.",
    "input_schema": {
      "properties": {
        "sequence": {
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "sequence"
      ],
      "type": "object"
    },
    "python_script": "import json\n# input_data is a dictionary containing the tool's input arguments.\n# This script simply returns the sequence of buttons provided in the input.\nsequence = input_data.get('sequence', [])\nprint(json.dumps(sequence))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-12T07:58:07.386Z",
        "action_counter": 42950
      },
      {
        "commit_message": "Fixing menu_navigator to correctly use input_data dictionary instead of sys.stdin.",
        "timestamp": "2026-01-12T07:59:05.011Z",
        "action_counter": 42952
      },
      {
        "commit_message": "Fixing menu_navigator to correctly use the injected input_data dictionary and avoid sys.stdin.",
        "timestamp": "2026-01-12T07:59:59.685Z",
        "action_counter": 42953
      }
    ]
  },
  "find_path_v7_robust": {
    "description": "Finds a path between two coordinates on the current map, accounting for complex collision types (ledges, one-way walls), treating 'unseen' tiles as walkable FLOOR, and supporting surfing/land modes.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "is_surfing": {
          "type": "boolean"
        },
        "autopress_buttons": {
          "type": "boolean"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport collections\n\nroot = ET.fromstring(map_xml_string)\nautopress = input_data.get('autopress_buttons', False)\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\nis_surfing = input_data.get('is_surfing', False)\n\ngrid = {}\nfor row in root.findall('Row'):\n    y = int(row.attrib['id'])\n    for tile in row.findall('Tile'):\n        x = int(tile.attrib['id'])\n        grid[(x, y)] = tile\n\ndef can_move(from_pos, to_pos, direction):\n    if to_pos not in grid: return False\n    f_tile = grid[from_pos]\n    t_tile = grid[to_pos]\n    f_type = f_tile.attrib['type']\n    t_type = t_tile.attrib['type']\n    if t_tile.attrib['seen'] == 'false': return True\n    if t_type == 'WALL': return False\n    if t_tile.find('Object') is not None: return False\n    if is_surfing:\n        if t_type not in ['WATER', 'WATERFALL', 'FLOOR', 'WALL_DOWN_FLOOR', 'WALL_UP_FLOOR', 'WALL_RIGHT_FLOOR', 'WALL_LEFT_FLOOR', 'FLOOR_UP_WALL', 'FLOOR_DOWN_WALL', 'FLOOR_LEFT_WALL', 'FLOOR_RIGHT_WALL', 'CAVE', 'WARP_CARPET_DOWN']: return False\n    else:\n        if t_type in ['WATER', 'WATERFALL']: return False\n    if direction == 'Down':\n        if f_type == 'WALL_DOWN_FLOOR' or t_type == 'FLOOR_UP_WALL': return False\n    elif direction == 'Up':\n        if f_type == 'WALL_UP_FLOOR' or t_type == 'FLOOR_DOWN_WALL': return False\n    elif direction == 'Right':\n        if f_type == 'WALL_RIGHT_FLOOR' or t_type == 'FLOOR_LEFT_WALL': return False\n    elif direction == 'Left':\n        if f_type == 'WALL_LEFT_FLOOR' or t_type == 'FLOOR_RIGHT_WALL': return False\n    if t_type == 'LEDGE_DOWN' and direction != 'Down': return False\n    if t_type == 'LEDGE_LEFT' and direction != 'Left': return False\n    if t_type == 'LEDGE_RIGHT' and direction != 'Right': return False\n    return True\n\nqueue = collections.deque([((start_x, start_y), [])])\nvisited = {(start_x, start_y)}\nfound_path = None\nwhile queue:\n    (cx, cy), path = queue.popleft()\n    if (cx, cy) == (end_x, end_y):\n        found_path = path\n        break\n    for dx, dy, btn in [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n        nx, ny = cx + dx, cy + dy\n        if (nx, ny) in grid and (nx, ny) not in visited:\n            if can_move((cx, cy), (nx, ny), btn):\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [btn]))\n\nif found_path is not None:\n    if autopress: print(json.dumps(found_path))\n    else: print(json.dumps({\"path\": found_path}))\nelse:\n    if autopress: print(json.dumps([]))\n    else: print(json.dumps({\"path\": []}))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-12T12:21:09.333Z",
        "action_counter": 43372
      },
      {
        "commit_message": "Update FLOOR_UP_WALL collision logic to check both 'from' and 'to' tiles.",
        "timestamp": "2026-01-12T12:24:45.250Z",
        "action_counter": 43376
      },
      {
        "commit_message": "Refine FLOOR_UP_WALL collision to block all North/South entry and exit.",
        "timestamp": "2026-01-12T12:44:31.097Z",
        "action_counter": 43404
      },
      {
        "commit_message": "Update find_path_v7_robust to handle WATER, WATERFALL, and Objects. Added coordinate-based output option.",
        "timestamp": "2026-01-12T13:01:25.227Z",
        "action_counter": 43420
      },
      {
        "commit_message": "Fixing pathfinding logic to include all wall types and ledges and adding button output.",
        "timestamp": "2026-01-12T14:00:23.450Z",
        "action_counter": 43502
      },
      {
        "commit_message": "Refining collision logic for all wall types and ledges. Added consistent entry/exit blocking for one-way tiles.",
        "timestamp": "2026-01-12T14:16:45.408Z",
        "action_counter": 43531
      },
      {
        "commit_message": "Add support for surfing mode and refined collision logic (directional walls, ledges).",
        "timestamp": "2026-01-12T15:02:01.294Z",
        "action_counter": 43591
      }
    ]
  }
}