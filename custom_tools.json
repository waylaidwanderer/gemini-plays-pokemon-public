{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "find_nearest_unsolved_puzzle": {
    "description": "Takes player coordinates and a list of unsolved puzzle coordinates. Uses an A* pathfinding algorithm to find the puzzle with the shortest actual travel path and returns its coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "player_x": {
          "type": "integer"
        },
        "player_y": {
          "type": "integer"
        },
        "unsolved_puzzles": {
          "type": "string"
        }
      },
      "required": [
        "player_x",
        "player_y",
        "unsolved_puzzles"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef find_shortest_path_a_star(start, end, grid, map_width, map_height):\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = { (c,r): float('inf') for r in range(map_height + 2) for c in range(map_width + 2) }\n    g_score[start] = 0\n    f_score = { (c,r): float('inf') for r in range(map_height + 2) for c in range(map_width + 2) }\n    f_score[start] = abs(start[0] - end[0]) + abs(start[1] - end[1])\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n        if current == end:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            return len(path)\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (1 <= neighbor[0] <= map_width and 1 <= neighbor[1] <= map_height):\n                continue\n            if grid[neighbor[1]][neighbor[0]] == 1:\n                continue\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + (abs(neighbor[0] - end[0]) + abs(neighbor[1] - end[1]))\n                heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    return float('inf')\n\nroot = ET.fromstring(map_xml_string)\nmap_width = int(root.get('width'))\nmap_height = int(root.get('height'))\nplayer_x = int(input_data['player_x'])\nplayer_y = int(input_data['player_y'])\nunsolved_puzzles_str = input_data['unsolved_puzzles']\nunsolved_puzzles = json.loads(unsolved_puzzles_str)\n\ngrid = [[0 for _ in range(map_width + 1)] for _ in range(map_height + 1)]\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.get('id'))\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.get('id'))\n        tile_type = tile_elem.get('type')\n        is_pikachu = tile_elem.find(\"./Object[@id-name='Pikachu']\") is not None\n        has_object = tile_elem.find('Object') is not None\n        is_impassable = False\n        impassable_types = ['impassable', 'boulder_barrier', 'closed_gate', 'unknown', 'gate_offscreen']\n        if tile_type in impassable_types or (has_object and not is_pikachu):\n            is_impassable = True\n        if is_impassable:\n            grid[y][x] = 1\n\nshortest_path = float('inf')\nbest_target = None\n\nfor puzzle in unsolved_puzzles:\n    target_x = puzzle['x']\n    target_y = puzzle['y']\n    \n    interaction_x, interaction_y = target_x, target_y + 1\n\n    if not (1 <= interaction_x <= map_width and 1 <= interaction_y <= map_height) or grid[interaction_y][interaction_x] == 1:\n        continue\n\n    path_length = find_shortest_path_a_star((player_x, player_y), (interaction_x, interaction_y), grid, map_width, map_height)\n    if path_length < shortest_path:\n        shortest_path = path_length\n        best_target = {'x': target_x, 'y': target_y}\n\nif best_target:\n    print(json.dumps(best_target))\nelse:\n    print(json.dumps({'error': 'No reachable unsolved puzzles found.'}))"
  },
  "inventory_scanner": {
    "description": "Scans the player's inventory list for a target item and returns whether it was found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory_list": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "inventory_list",
        "target_item"
      ]
    },
    "python_script": "import json\n\ntry:\n    inventory_list = json.loads(input_data['inventory_list'])\n    target_item = input_data['target_item']\n    found = False\n    for item in inventory_list:\n        if target_item.lower() in item.lower():\n            found = True\n            break\n    print(f'Item found: {found}')\nexcept Exception as e:\n    print(f'An error occurred: {e}')"
  },
  "pathfinder": {
    "description": "Calculates the shortest path from the player's current position to a target coordinate on the current map using the A* algorithm. It parses the map_xml_string to build a grid, avoiding impassable tiles and objects (including NPCs), and correctly handles Pikachu as a traversable object. It avoids non-destination warp tiles and handles 'unknown' tiles as impassable. Now correctly treats 'gate_offscreen' as traversable.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\ndef pathfinder_func(map_xml_string, input_data):\n    print(\"Pathfinder v5.4 starting...\")\n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n    except (ValueError, KeyError) as e:\n        print(f\"Pathfinder v5.4 Error: Invalid input data. {e}\")\n        return\n\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.get('width'))\n    map_height = int(root.get('height'))\n    player_pos = None\n    player_tile_type = None\n\n    for row_elem in root.findall('Row'):\n        for tile_elem in row_elem.findall('Tile'):\n            if tile_elem.get('has-player') == 'true':\n                player_pos = (int(tile_elem.get('id')), int(row_elem.get('id')))\n                player_tile_type = tile_elem.get('type')\n                break\n        if player_pos:\n            break\n\n    if not player_pos:\n        print('Pathfinder v5.4 Error: Player position not found in map data.')\n        return\n    \n    print(f\"Player at {player_pos}, Target at ({target_x}, {target_y})\")\n\n    is_surfing = player_tile_type == 'water'\n\n    grid = [[0 for _ in range(map_width + 1)] for _ in range(map_height + 1)]\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            is_pikachu = tile_elem.find(\"./Object[@id-name='Pikachu']\") is not None\n            has_object = tile_elem.find('Object') is not None\n            is_warp = tile_elem.get('is-warp') == 'true'\n            is_impassable = False\n            \n            impassable_types = ['impassable', 'boulder_barrier', 'closed_gate', 'unknown']\n            \n            if tile_type in impassable_types:\n                is_impassable = True\n            elif has_object and not is_pikachu:\n                is_impassable = True\n            elif is_surfing and tile_type != 'water':\n                is_impassable = True\n            elif not is_surfing and tile_type == 'water':\n                is_impassable = True\n            elif is_warp and (x, y) != (target_x, target_y):\n                is_impassable = True\n\n            if is_impassable:\n                grid[y][x] = 1\n            elif tile_type == 'ledge':\n                grid[y][x] = 2\n            else:\n                grid[y][x] = 0\n\n    start = player_pos\n    end = (target_x, target_y)\n\n    if not (1 <= end[0] <= map_width and 1 <= end[1] <= map_height):\n        print(f\"Pathfinder v5.4 Error: Target {end} is out of map bounds.\")\n        return\n\n    if grid[end[1]][end[0]] == 1:\n        original_end = end\n        found_new_target = False\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_x, adj_y = original_end[0] + dx, original_end[1] + dy\n            if 1 <= adj_x <= map_width and 1 <= adj_y <= map_height and grid[adj_y][adj_x] == 0:\n                end = (adj_x, adj_y)\n                found_new_target = True\n                break\n        if not found_new_target:\n            print('Pathfinder v5.4 Error: Path not found. Target is impassable and has no traversable adjacent tiles.')\n            return\n\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = { (c,r): float('inf') for r in range(map_height + 2) for c in range(map_width + 2) }\n    g_score[start] = 0\n    f_score = { (c,r): float('inf') for r in range(map_height + 2) for c in range(map_width + 2) }\n    f_score[start] = heuristic(start, end)\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == end:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            final_path_str = ','.join([f'({p[0]},{p[1]})' for p in path[::-1]])\n            print(f'Path: [{final_path_str}]')\n            print(\"Pathfinder v5.4 finished.\")\n            return\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n\n            if not (1 <= neighbor[0] <= map_width and 1 <= neighbor[1] <= map_height):\n                continue\n\n            if grid[neighbor[1]][neighbor[0]] == 2:\n                if dy == 1 and current[1] == neighbor[1] - 1:\n                    actual_neighbor = (neighbor[0], neighbor[1] + 1)\n                    if 1 <= actual_neighbor[1] <= map_height and grid[actual_neighbor[1]][actual_neighbor[0]] != 1:\n                        tentative_g_score = g_score[current] + 1\n                        if tentative_g_score < g_score.get(actual_neighbor, float('inf')):\n                            came_from[actual_neighbor] = current\n                            g_score[actual_neighbor] = tentative_g_score\n                            f_score[actual_neighbor] = tentative_g_score + heuristic(actual_neighbor, end)\n                            heapq.heappush(open_set, (f_score[actual_neighbor], actual_neighbor))\n                continue\n\n            if grid[neighbor[1]][neighbor[0]] == 1:\n                continue\n\n            tentative_g_score = g_score[current] + 1\n\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + heuristic(neighbor, end)\n                heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    print('Pathfinder v5.4 Error: Path not found.')\n    print(\"Pathfinder v5.4 finished.\")\n\npathfinder_func(map_xml_string, input_data)"
  },
  "spinner_maze_solver": {
    "description": "Finds the shortest path in a spinner maze. It parses the map_xml_string, builds a graph including spinner traversals, and uses A* to find the path from the player's position to a target coordinate. If the target tile is impassable, it will find a path to an adjacent traversable tile. This version includes debugging print statements.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "\nimport xml.etree.ElementTree as ET\nimport heapq\n\ntarget_x = int(input_data['target_x'])\ntarget_y = int(input_data['target_y'])\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\n\ngrid = [['' for _ in range(width + 1)] for _ in range(height + 1)]\nplayer_pos = None\nspinners = {}\nimpassable_types = ['impassable', 'unknown', 'cuttable', 'boulder_barrier', 'closed_gate']\n\nprint(f\"Map dimensions: {width}x{height}\")\n\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.get('id'))\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.get('id'))\n        tile_type = tile_elem.get('type')\n        grid[y][x] = tile_type\n\n        if tile_elem.find('Player') is not None:\n            player_pos = (x, y)\n        \n        spinner_elem = tile_elem.find('Spinner')\n        if spinner_elem is not None:\n            end_coord_str = spinner_elem.get('end-coordinate')\n            if end_coord_str:\n                end_x, end_y = map(int, end_coord_str.split(','))\n                spinners[(x, y)] = (end_x, end_y)\n                print(f\"Found spinner at ({x}, {y}) -> ({end_x}, {end_y})\")\n\nif not player_pos:\n    print(\"Error: Player position not found in map XML.\")\nelse:\n    print(f\"Player position: {player_pos}\")\n    start_node = player_pos\n    \n    if grid[target_y][target_x] in impassable_types:\n        print(f\"Target ({target_x}, {target_y}) is impassable. Finding adjacent traversable tile.\")\n        found_new_target = False\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = target_x + dx, target_y + dy\n            if 1 <= nx <= width and 1 <= ny <= height and grid[ny][nx] not in impassable_types:\n                target_x, target_y = nx, ny\n                print(f\"New target set to ({target_x}, {target_y}).\")\n                found_new_target = True\n                break\n        if not found_new_target:\n            print(\"Error: No traversable tile adjacent to the impassable target.\")\n            start_node = None # Prevent A* from running\n            \n    if start_node:\n        goal_node = (target_x, target_y)\n\n        def heuristic(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n        open_set = [(0, start_node)]\n        came_from = {}\n        g_score = {start_node: 0}\n\n        print(f\"Starting A* from {start_node} to {goal_node}\")\n        \n        path_found = False\n        while open_set:\n            _, current = heapq.heappop(open_set)\n\n            if current == goal_node:\n                path = []\n                temp_current = current\n                while temp_current in came_from:\n                    prev = came_from[temp_current]\n                    if prev[0] == temp_current[0] + 1:\n                        path.append('Left')\n                    elif prev[0] == temp_current[0] - 1:\n                        path.append('Right')\n                    elif prev[1] == temp_current[1] + 1:\n                        path.append('Up')\n                    elif prev[1] == temp_current[1] - 1:\n                        path.append('Down')\n                    temp_current = prev\n                print(list(reversed(path)))\n                path_found = True\n                break\n\n            # Process spinner first\n            if current in spinners:\n                neighbor = spinners[current]\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score = tentative_g_score + heuristic(neighbor, goal_node)\n                    heapq.heappush(open_set, (f_score, neighbor))\n                continue\n\n            # Then process normal moves\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                neighbor = (current[0] + dx, current[1] + dy)\n                nx, ny = neighbor\n\n                if not (1 <= nx <= width and 1 <= ny <= height):\n                    continue\n\n                if grid[ny][nx] in impassable_types:\n                    continue\n                \n                if grid[ny][nx] == 'ledge' and dy == -1:\n                    continue\n\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score = tentative_g_score + heuristic(neighbor, goal_node)\n                    heapq.heappush(open_set, (f_score, neighbor))\n        \n        if not path_found:\n            print(\"No path found\")\n"
  }
}