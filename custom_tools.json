{
  "get_reachable_unseen_tiles": {
    "description": "Finds all unseen tiles that are directly adjacent to reachable, passable tiles on the current map. Returns a JSON array of coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef run():\n    try:\n        root = ET.fromstring(map_xml_string)\n        player_pos = None\n        grid = {}\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                if tile.find('Player') is not None:\n                    player_pos = (x, y)\n                grid[(x, y)] = {\n                    'type': tile.attrib['type'],\n                    'seen': tile.attrib['seen'] == 'true',\n                    'has_object': tile.attrib.get('has-object') == 'true',\n                    'is_warp': tile.attrib.get('is-warp') == 'true'\n                }\n        \n        if not player_pos:\n            print(\"Error: Player pos not found.\")\n            return\n\n        passable_types = ['FLOOR', 'TALL_GRASS', 'LONG_GRASS', 'WARP_CARPET', 'WATER', 'ICE', 'LADDER', 'PIT']\n        \n        reachable = set()\n        queue = deque([player_pos])\n        visited = {player_pos}\n\n        while queue:\n            cx, cy = queue.popleft()\n            reachable.add((cx, cy))\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = cx + dx, cy + dy\n                if (nx, ny) in grid and (nx, ny) not in visited:\n                    tile = grid[(nx, ny)]\n                    if tile['seen'] and tile['type'] in passable_types and not tile['has_object'] and not tile['is_warp']:\n                        visited.add((nx, ny))\n                        queue.append((nx, ny))\n\n        unseen_reachable = set()\n        for rx, ry in reachable:\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = rx + dx, ry + dy\n                if (nx, ny) in grid and not grid[(nx, ny)]['seen']:\n                    unseen_reachable.add((nx, ny))\n\n        print(json.dumps(sorted(list(unseen_reachable))))\n    except Exception as e:\n        print(f\"Error: {str(e)}\")\n\nrun()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T06:20:54.963Z",
        "action_counter": 27975
      },
      {
        "commit_message": "Fixed the tool to execute the logic and print the result properly. Removed function wrapping to ensure execution in the harness environment.",
        "timestamp": "2025-12-28T06:21:58.588Z",
        "action_counter": 27977
      },
      {
        "commit_message": "Added 'ICE' and 'WARP_CARPET_DOWN' to passable types for better exploration.",
        "timestamp": "2025-12-28T07:02:21.682Z",
        "action_counter": 28055
      },
      {
        "commit_message": "Updating exploration tool to find reachable unseen tiles.",
        "timestamp": "2025-12-28T09:40:39.023Z",
        "action_counter": 28377
      },
      {
        "commit_message": "Refining exploration tool to accurately identify reachable unseen tiles from the current player position.",
        "timestamp": "2025-12-28T09:41:08.853Z",
        "action_counter": 28378
      }
    ]
  },
  "find_map_objects": {
    "description": "Finds all instances of a specific object type in the Mental Map and returns their coordinates and IDs.",
    "input_schema": {
      "type": "object",
      "properties": {
        "object_name": {
          "type": "string",
          "description": "The name or part of the name of the object to find (e.g., 'BOULDER', 'ITEM', 'NPC')"
        }
      },
      "required": [
        "object_name"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ndef run():\n    try:\n        root = ET.fromstring(map_xml_string)\n        target = input_data.get('object_name', 'BOULDER').upper()\n        found = []\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                obj = tile.find('Object')\n                if obj is not None:\n                    name = obj.attrib.get('id-name', '').upper()\n                    if target in name:\n                        found.append({\n                            'x': x, \n                            'y': y, \n                            'id': int(obj.attrib.get('id', 0)), \n                            'name': name\n                        })\n        print(json.dumps(found))\n    except Exception as e:\n        print(json.dumps({\"error\": str(e)}))\n\nrun()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T15:59:50.178Z",
        "action_counter": 28951
      }
    ]
  },
  "analyze_gym_map_v2": {
    "description": "Analyzes the Mental Map for boulders, pits, and warps.",
    "input_schema": {
      "type": "object",
      "properties": {
        "map_id": {
          "type": "string",
          "description": "The ID of the map to analyze."
        }
      },
      "required": [
        "map_id"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ndef run():\n    try:\n        root = ET.fromstring(map_xml_string)\n        map_id = input_data.get('map_id')\n        target_map = root if root.get('id') == map_id else root.find(f\".//Map[@id='{map_id}']\")\n        \n        if target_map is None:\n            print(json.dumps({\"error\": f\"Map {map_id} not found.\"}))\n            return\n\n        boulders = []\n        pits = []\n        warps = []\n        \n        for row in target_map.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                x = int(tile.get('id'))\n                t_type = tile.get('type')\n                \n                if t_type == 'PIT':\n                    pits.append({'x': x, 'y': y})\n                \n                if tile.get('is-warp') == 'true':\n                    warp_elem = tile.find('Warp')\n                    warps.append({\n                        'x': x, 'y': y,\n                        'entry_point': warp_elem.get('entry_point') if warp_elem is not None else None\n                    })\n                \n                for obj in tile.findall('Object'):\n                    name = obj.get('id-name', '').upper()\n                    if 'BOULDER' in name:\n                        boulders.append({\n                            'x': x, 'y': y,\n                            'id': int(obj.get('id', 0)),\n                            'name': name\n                        })\n                        \n        print(json.dumps({\n            \"map_id\": map_id,\n            \"boulders\": boulders,\n            \"pits\": pits,\n            \"warps\": warps\n        }, indent=2))\n    except Exception as e:\n        print(json.dumps({\"error\": str(e)}))\n\nrun()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T19:40:03.529Z",
        "action_counter": 29341
      }
    ]
  },
  "find_path_v2": {
    "description": "Finds the shortest path between two coordinates on the current map using BFS, considering walls and objects as obstacles. Returns a JSON array of coordinates or buttons.",
    "input_schema": {
      "properties": {
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ],
      "type": "object"
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef run():\n    root = ET.fromstring(map_xml_string)\n    map_id = root.attrib.get('id')\n    start = (int(input_data['start_x']), int(input_data['start_y']))\n    end = (int(input_data['end_x']), int(input_data['end_y']))\n    autopress = input_data.get('autopress_buttons', False)\n    \n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib.get('type')\n            is_passable = t_type in ['FLOOR', 'LADDER', 'WARP_CARPET_DOWN', 'WARP_CARPET_UP', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'PIT']\n            \n            obj = tile.find('Object')\n            has_obj = tile.attrib.get('has-object') == 'true' or obj is not None\n            \n            if has_obj:\n                is_passable = False\n                # Blackthorn Gym Bridge Exception: Boulders on 1F are passable\n                if map_id == '5_1':\n                    if obj is not None and 'BOULDER' in obj.attrib.get('id-name', '').upper():\n                        is_passable = True\n                    elif obj is None and tile.attrib.get('has-object') == 'true':\n                        is_passable = True\n                # General Pit/Warp Exception (for 2F navigation)\n                if t_type == 'PIT' or tile.attrib.get('is-warp') == 'true':\n                    if obj is not None and 'BOULDER' in obj.attrib.get('id-name', '').upper():\n                        is_passable = True\n            \n            if (x, y) == end:\n                is_passable = True\n            grid[(x, y)] = is_passable\n\n    queue = deque([(start, [])])\n    visited = {start}\n    \n    while queue:\n        (x, y), path = queue.popleft()\n        if (x, y) == end:\n            if autopress:\n                print(json.dumps(path))\n            else:\n                coord_path = [{\"x\": start[0], \"y\": start[1]}]\n                cx, cy = start\n                for btn in path:\n                    if btn == \"Up\": cy -= 1\n                    elif btn == \"Down\": cy += 1\n                    elif btn == \"Left\": cx -= 1\n                    elif btn == \"Right\": cx += 1\n                    coord_path.append({\"x\": cx, \"y\": cy})\n                print(json.dumps(coord_path))\n            return\n        \n        for dx, dy, btn in [(0, 1, \"Down\"), (0, -1, \"Up\"), (1, 0, \"Right\"), (-1, 0, \"Left\")]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) in grid and grid[(nx, ny)] and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [btn]))\n    print(json.dumps([]))\n\nrun()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T20:27:16.465Z",
        "action_counter": 29425
      },
      {
        "commit_message": "Refined to correctly identify objects using 'has-object' attribute and added logic for boulder bridges in pits.",
        "timestamp": "2025-12-28T20:30:14.390Z",
        "action_counter": 29431
      },
      {
        "commit_message": "Refined to correctly handle autopress_buttons by outputting button strings and fixed pathfinding logic for boulder bridges.",
        "timestamp": "2025-12-28T20:30:50.776Z",
        "action_counter": 29432
      },
      {
        "commit_message": "Refined to handle boulder bridges in Blackthorn Gym 1F and improved object detection.",
        "timestamp": "2025-12-28T20:47:40.334Z",
        "action_counter": 29458
      }
    ]
  },
  "solve_gym_puzzle": {
    "description": "Calculates the sequence of button presses to solve the Blackthorn Gym boulder puzzle using persistent Mental Map data. Returns a list of buttons.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import collections\nimport json\nimport xml.etree.ElementTree as ET\n\ndef run():\n    try:\n        root = ET.fromstring(map_xml_string)\n        map_elem = root if root.attrib.get('id') == '5_2' else root.find(\".//Map[@id='5_2']\")\n        \n        passable = set()\n        pits = set()\n        boulders = {}\n        walls = set()\n        \n        for row in map_elem.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                t = tile.attrib['type']\n                if t in ('FLOOR', 'LADDER'): passable.add((x, y))\n                if t == 'PIT': pits.add((x, y))\n                if t == 'WALL': walls.add((x, y))\n                \n                obj = tile.find('Object')\n                if obj is not None:\n                    n = obj.attrib.get('id-name', '').upper()\n                    oid = int(obj.attrib.get('id', 0))\n                    if 'BOULDER' in n: boulders[oid] = (x, y)\n                    elif 'COOLTRAINER' in n or 'NPC' in n: walls.add((x, y))\n                \n                for marker in tile.findall('Marker'):\n                    l = marker.text.upper()\n                    if 'BOULDER' in l:\n                        oid = int(marker.attrib.get('object_id', 99))\n                        if oid not in boulders: boulders[oid] = (x, y)\n                    elif 'DEFEATED' in l: walls.add((x, y))\n\n        start_p = (int(input_data['start_x']), int(input_data['start_y']))\n        start_b = tuple(sorted(boulders.values()))\n        start_pits = tuple(sorted(pits))\n        \n        # state: (player_pos, boulder_positions, remaining_pits)\n        queue = collections.deque([(start_p, start_b, start_pits, [])])\n        visited = { (start_p, start_b, start_pits) }\n        \n        count = 0\n        while queue:\n            cp, cb_t, cpits_t, path = queue.popleft()\n            if len(cpits_t) == 0:\n                print(json.dumps(path))\n                return\n            \n            if len(path) > 350: continue\n            count += 1\n            if count > 150000: break\n\n            cb_l = list(cb_t)\n            cpits_s = set(cpits_t)\n            for dx, dy, btn in [(0,-1,'Up'), (0,1,'Down'), (-1,0,'Left'), (1,0,'Right')]:\n                nx, ny = cp[0]+dx, cp[1]+dy\n                if (nx, ny) in cb_l:\n                    bx, by = nx+dx, ny+dy\n                    if (bx, by) in (passable | cpits_s) and (bx, by) not in cb_l and (bx, by) not in walls:\n                        nb = [b for b in cb_l if b != (nx, ny)]\n                        npits = set(cpits_s)\n                        if (bx, by) in cpits_s:\n                            npits.remove((bx, by))\n                        else:\n                            nb.append((bx, by))\n                        \n                        nt_b = tuple(sorted(nb))\n                        nt_p = tuple(sorted(npits))\n                        if (nx, ny, nt_b, nt_p) not in v if 'v' in locals() else (nx, ny, nt_b, nt_p) not in visited:\n                            visited.add((nx, ny, nt_b, nt_p))\n                            queue.append(((nx, ny), nt_b, nt_p, path + [btn]))\n                elif (nx, ny) in passable and (nx, ny) not in walls:\n                    if (nx, ny, cb_t, cpits_t) not in visited:\n                        visited.add((nx, ny, cb_t, cpits_t))\n                        queue.append(((nx, ny), cb_t, cpits_t, path + [btn]))\n        print(json.dumps({\"error\": \"No solution found\"}))\n    except Exception as e:\n        print(json.dumps({\"error\": str(e)}))\n\nrun()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T22:28:24.749Z",
        "action_counter": 29623
      },
      {
        "commit_message": "Increase search depth and ensure filled pits are treated as floor.",
        "timestamp": "2025-12-28T22:30:10.927Z",
        "action_counter": 29626
      },
      {
        "commit_message": "Refine BFS logic: handle filled pits correctly, include marker-based objects, and increase search depth.",
        "timestamp": "2025-12-28T22:30:37.058Z",
        "action_counter": 29627
      },
      {
        "commit_message": "Refine BFS logic to solve the Blackthorn Gym boulder puzzle from a reset state, correctly identifying all three target pits and boulders.",
        "timestamp": "2025-12-28T22:38:49.016Z",
        "action_counter": 29642
      },
      {
        "commit_message": "Refine logic to solve for all 3 boulders and 3 pits from the reset state.",
        "timestamp": "2025-12-28T22:46:55.372Z",
        "action_counter": 29657
      },
      {
        "commit_message": "Fix success condition (len(cb_t) == 0) and increase search depth for 3-boulder solution.",
        "timestamp": "2025-12-28T22:47:29.978Z",
        "action_counter": 29659
      },
      {
        "commit_message": "Implement robust BFS for 3-boulder puzzle with dynamic map parsing and state tracking for pits.",
        "timestamp": "2025-12-28T22:49:00.589Z",
        "action_counter": 29660
      }
    ]
  }
}