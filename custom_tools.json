{
  "attempt_surf": {
    "description": "Initiates surfing by executing a robust sequence of button presses: Face Direction -> Wait -> Interact (A) -> Wait -> Confirm (A) -> Wait -> Clear Text (B). Use 'autopress_buttons: true'.",
    "input_schema": {
      "type": "object",
      "properties": {
        "direction": {
          "type": "string",
          "enum": [
            "Up",
            "Down",
            "Left",
            "Right"
          ],
          "description": "The direction to face (towards the water)."
        }
      },
      "required": [
        "direction"
      ]
    },
    "python_script": "import json\nd = input_data['direction']\n# Sequence: Direction, Wait, Interact(A), Wait, Confirm(A), Wait, Clear(B)\ncmds = [d, \"sleep 500\", \"A\", \"sleep 1000\", \"A\", \"sleep 1000\", \"B\"]\nprint(json.dumps(cmds))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-11-30T14:29:22.466Z",
        "action_counter": 15036
      },
      {
        "commit_message": "feat: Define attempt_surf tool to standardize surfing interactions and prevent manual button sequence errors.",
        "timestamp": "2025-11-30T14:33:24.442Z",
        "action_counter": 15042
      },
      {
        "commit_message": "feat: Define attempt_surf tool to standardize surfing interactions and prevent manual button sequence errors.",
        "timestamp": "2025-11-30T14:44:58.504Z",
        "action_counter": 15055
      }
    ]
  },
  "find_path": {
    "description": "Calculates a path using A*. Strictly handles Surfing state and Directional Ledges. Treats WALL, CUT_TREE, BUOY, WHIRLPOOL, WINDOW, CAVE_WALL, and FLOOR_UP_WALL as obstacles. Handles blocked targets by pathing to nearest adjacent walkable tile.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "\nimport xml.etree.ElementTree as ET\nimport heapq\nimport math\nimport json\n\n# Parse Map\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.attrib['width'])\nheight = int(root.attrib['height'])\ngrid = {}\nplayer_pos = None\n\nfor row in root.findall('Row'):\n    y = int(row.attrib['id'])\n    for tile in row.findall('Tile'):\n        x = int(tile.attrib['id'])\n        t_type = tile.attrib['type'].strip().upper()\n        has_object = tile.attrib.get('has-object') == 'true'\n        is_warp = tile.attrib.get('is-warp') == 'true'\n        \n        # Check for player\n        if tile.find('Player') is not None:\n            player_pos = (x, y)\n        \n        # Check for objects in children (more robust)\n        if not has_object:\n            if tile.find('Object') is not None:\n                has_object = True\n                \n        grid[(x, y)] = {\n            'type': t_type,\n            'blocked': has_object, # Objects are walls unless target\n            'is_warp': is_warp # Warps are walls unless target\n        }\n\nif not player_pos:\n    print(\"Error: Player not found\")\n    exit()\n\ntarget_x = int(input_data['target_x'])\ntarget_y = int(input_data['target_y'])\ntarget = (target_x, target_y)\n\n# Determine Surfing State\nplayer_tile = grid.get(player_pos)\nis_surfing = player_tile['type'] == 'WATER'\n\n# Define Cost Function\ndef get_cost(curr, next_node):\n    c_tile = grid.get(curr)\n    n_tile = grid.get(next_node)\n    \n    if not n_tile: return float('inf')\n    \n    # Basic Terrain Blocking\n    # Added FLOOR_UP_WALL back to impassable types\n    if n_tile['type'] in ['WALL', 'CUT_TREE', 'BUOY', 'WHIRLPOOL', 'WINDOW', 'CAVE_WALL', 'FLOOR_UP_WALL']:\n        return float('inf')\n    \n    # Ledge Logic - Strict Directional Entry\n    # Ledges are strictly one-way. You can only enter them from the direction of the hop.\n    dx = next_node[0] - curr[0]\n    dy = next_node[1] - curr[1]\n    \n    if n_tile['type'] == 'LEDGE_HOP_DOWN' and dy != 1: return float('inf')\n    if n_tile['type'] == 'LEDGE_HOP_UP' and dy != -1: return float('inf')\n    if n_tile['type'] == 'LEDGE_HOP_LEFT' and dx != -1: return float('inf')\n    if n_tile['type'] == 'LEDGE_HOP_RIGHT' and dx != 1: return float('inf')\n    \n    # Object Blocking (unless target)\n    if n_tile['blocked'] and next_node != target: return float('inf')\n    \n    # Warp Blocking (unless target)\n    if n_tile['is_warp'] and next_node != target: return float('inf')\n\n    # Water/Land Transitions\n    c_type = c_tile['type']\n    n_type = n_tile['type']\n    \n    if is_surfing:\n        # Penalize dismounting unless it's the target\n        if c_type == 'WATER' and n_type != 'WATER':\n            if next_node == target: return 1\n            return 10000\n    else:\n        # Penalize entering water (require manual surf tool)\n        if c_type != 'WATER' and n_type == 'WATER':\n            return float('inf') \n            \n    return 1\n\n# A* Algorithm\ndef solve_path(start, end):\n    queue = [(0, start)]\n    came_from = {start: None}\n    cost_so_far = {start: 0}\n    \n    while queue:\n        _, current = heapq.heappop(queue)\n        \n        if current == end:\n            break\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_node = (current[0] + dx, current[1] + dy)\n            if next_node not in grid: continue\n            \n            new_cost = cost_so_far[current] + get_cost(current, next_node)\n            \n            if new_cost < float('inf'):\n                if next_node not in cost_so_far or new_cost < cost_so_far[next_node]:\n                    cost_so_far[next_node] = new_cost\n                    priority = new_cost + abs(end[0] - next_node[0]) + abs(end[1] - next_node[1])\n                    heapq.heappush(queue, (priority, next_node))\n                    came_from[next_node] = current\n                    \n    return came_from, cost_so_far\n\n# Handle Blocked Target (e.g. clicking on an NPC)\n# If target is blocked or unreachable, try neighbors\nfinal_target = target\ncame_from, cost_so_far = solve_path(player_pos, target)\n\nif target not in came_from:\n    # Target unreachable. Is it because it's blocked?\n    # Try adjacent tiles\n    neighbors = []\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        n = (target[0] + dx, target[1] + dy)\n        if n in grid and not grid[n]['blocked'] and grid[n]['type'] != 'WALL':\n             neighbors.append(n)\n    \n    # Sort neighbors by distance to player\n    neighbors.sort(key=lambda n: abs(player_pos[0]-n[0]) + abs(player_pos[1]-n[1]))\n    \n    path_found = False\n    for n in neighbors:\n        came_from, cost_so_far = solve_path(player_pos, n)\n        if n in came_from:\n            final_target = n\n            path_found = True\n            break\n            \n    if not path_found:\n        print(\"[]\")\n        exit()\n\n# Reconstruct Path\npath = []\ncurr = final_target\nwhile curr != player_pos:\n    path.append(curr)\n    curr = came_from[curr]\npath.reverse()\n\n# Output\noutput = [{'x': p[0], 'y': p[1]} for p in path]\nprint(json.dumps(output))\n",
    "history": [
      {
        "commit_message": "feat: Add find_path tool. Calculates shortest path using BFS, handling walls, objects, and one-way ledges.",
        "timestamp": "2025-11-20T08:35:46.882Z",
        "action_counter": 924
      },
      {
        "commit_message": "fix: Add LADDER to traversable basic_types in find_path. Previously, the tool considered LADDER tiles as walls, preventing pathfinding to or from them.",
        "timestamp": "2025-11-20T10:46:07.670Z",
        "action_counter": 1068
      },
      {
        "commit_message": "fix: Add FLOOR_UP_WALL to traversable tiles when moving down. This tile type appears on Route 32 and visually resembles a ledge, so it is assumed to be jumpable from the north.",
        "timestamp": "2025-11-20T21:10:28.299Z",
        "action_counter": 1479
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. In-game testing proved this tile type blocks movement from the north, contrary to the initial hypothesis that it was a jumpable ledge.",
        "timestamp": "2025-11-20T21:14:51.875Z",
        "action_counter": 1484
      },
      {
        "commit_message": "fix: Reinforce object collision check in find_path and add debug prints for player's neighbors to diagnose issues where objects are ignored.",
        "timestamp": "2025-11-20T23:31:27.320Z",
        "action_counter": 1632
      },
      {
        "commit_message": "fix: Add CAVE to traversable basic_types. This tile type represents cave entrances (warps) and must be traversable to enter dungeons like Union Cave. Also removed debug prints.",
        "timestamp": "2025-11-20T23:38:16.306Z",
        "action_counter": 1641
      },
      {
        "commit_message": "fix: Enable FLOOR_UP_WALL as a traversable ledge when moving down. This is necessary to test if the western ledge at (12, 18) is jumpable, as the eastern path is blocked.",
        "timestamp": "2025-11-21T00:47:29.072Z",
        "action_counter": 1752
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. Verified in-game at (16, 21) that this tile type acts as a wall and cannot be jumped from the north.",
        "timestamp": "2025-11-21T00:59:17.529Z",
        "action_counter": 1768
      },
      {
        "commit_message": "fix: Ensure FLOOR_UP_WALL is treated as a wall. Previous testing at (16, 21) confirmed it is not jumpable from the north.",
        "timestamp": "2025-11-21T01:01:08.516Z",
        "action_counter": 1771
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. Verified in-game at (12, 17) -> (12, 18) that this tile type acts as a wall and cannot be jumped from the north.",
        "timestamp": "2025-11-21T01:05:06.366Z",
        "action_counter": 1776
      },
      {
        "commit_message": "feat: Allow movement UP onto FLOOR_UP_WALL tiles. Verified in-game at Union Cave (5, 19) -> (5, 18) that this tile type acts as a climbable ramp from the south.",
        "timestamp": "2025-11-21T02:01:30.245Z",
        "action_counter": 1847
      },
      {
        "commit_message": "feat: Allow horizontal movement on FLOOR_UP_WALL. The tiles at row 18 act as a traversable ridge connecting the west and east sides of the room.",
        "timestamp": "2025-11-21T02:05:19.643Z",
        "action_counter": 1850
      },
      {
        "commit_message": "feat: Update find_path to automatically target adjacent traversable tiles if the destination is blocked by a wall or object. This eliminates the need for manual coordinate guessing when targeting NPCs or obstacles.",
        "timestamp": "2025-11-22T00:45:06.962Z",
        "action_counter": 3307
      },
      {
        "commit_message": "feat: Enhance find_path to treat tiles with object-linked markers as obstacles. This prevents the pathfinder from routing through off-screen NPCs or objects that are known to exist but not currently rendered in the viewport.",
        "timestamp": "2025-11-22T02:29:58.782Z",
        "action_counter": 3465
      },
      {
        "commit_message": "refactor: Change output format from coordinates to button presses (e.g. [\"Up\", \"Right\"]). This enables compatibility with the `autopress_buttons: true` feature for automated navigation.",
        "timestamp": "2025-11-22T06:33:20.386Z",
        "action_counter": 3846
      },
      {
        "commit_message": "fix: Update find_path to return a JSON array of button strings (e.g. ['Up', 'Right']) instead of coordinates, enabling compatibility with autopress_buttons. Also re-implements logic to path to adjacent tiles if the target is blocked.",
        "timestamp": "2025-11-22T06:37:44.405Z",
        "action_counter": 3851
      },
      {
        "commit_message": "fix: Rewrite find_path to output a JSON array of button strings (e.g. [\"Up\", \"Right\"]) instead of coordinate objects. Adds logic to automatically path to an adjacent tile if the target is blocked by a wall, object, or marker.",
        "timestamp": "2025-11-22T06:42:53.734Z",
        "action_counter": 3857
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE to the obstacles list in find_path. Previously, the pathfinder treated these trees as walkable FLOOR tiles, causing pathfinding failures on Route 36.",
        "timestamp": "2025-11-22T09:46:43.517Z",
        "action_counter": 4061
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE to obstacles list in find_path tool. This prevents pathfinding through solid trees on Route 36.",
        "timestamp": "2025-11-22T09:53:42.815Z",
        "action_counter": 4069
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE to obstacles list in find_path tool. This prevents pathfinding failures where the tool tries to route through solid trees on Route 36.",
        "timestamp": "2025-11-22T10:01:47.695Z",
        "action_counter": 4078
      },
      {
        "commit_message": "fix: Add LEDGE_HOP_DOWN, LEDGE_HOP_UP, LEDGE_HOP_LEFT, and LEDGE_HOP_RIGHT to the obstacles list in find_path. This prevents the pathfinder from incorrectly generating paths that try to walk up one-way ledges, which caused a navigation error on Route 37.",
        "timestamp": "2025-11-22T11:03:50.170Z",
        "action_counter": 4148
      },
      {
        "commit_message": "fix: Update find_path to treat tiles marked with 'Hole' or ðŸ•³ï¸ as obstacles. This prevents the pathfinder from routing the player into pits in the Burned Tower.",
        "timestamp": "2025-11-22T15:38:21.684Z",
        "action_counter": 4436
      },
      {
        "commit_message": "fix: Update find_path to treat tiles marked with 'Hole' or ðŸ•³ï¸ as obstacles. This prevents the pathfinder from routing the player into pits in the Burned Tower.",
        "timestamp": "2025-11-22T15:45:56.249Z",
        "action_counter": 4441
      },
      {
        "commit_message": "fix: Update find_path to correctly identify tiles with 'Hole' markers or object-linked markers as obstacles. This prevents pathfinding through dangerous tiles in the Burned Tower.",
        "timestamp": "2025-11-22T15:59:15.044Z",
        "action_counter": 4454
      },
      {
        "commit_message": "fix: Add PIT to obstacles list in find_path. This prevents the pathfinder from routing the player into pits in the Lighthouse.",
        "timestamp": "2025-11-23T02:50:16.179Z",
        "action_counter": 5202
      },
      {
        "commit_message": "fix: Add LADDER to obstacles list in find_path. This prevents the pathfinder from routing through ladders which are warps, avoiding accidental map transitions.",
        "timestamp": "2025-11-23T05:18:17.385Z",
        "action_counter": 5381
      },
      {
        "commit_message": "fix: Update find_path to be context-aware for Surfing. Now checks if the player is on a WATER tile; if so, removes WATER from the obstacle list. Also added BUOY to the base obstacle list to prevent pathing into buoys.",
        "timestamp": "2025-11-23T12:00:41.709Z",
        "action_counter": 5818
      },
      {
        "commit_message": "fix: Add FLOOR_UP_WALL, FLOOR_DOWN_WALL, FLOOR_LEFT_WALL, and FLOOR_RIGHT_WALL to the obstacles list in find_path. These tiles represent ledges or one-way walls in the current map data (Mt. Mortar) and were causing pathfinding failures.",
        "timestamp": "2025-11-24T01:30:19.414Z",
        "action_counter": 6532
      },
      {
        "commit_message": "fix: Explicitly add FLOOR_UP_WALL, FLOOR_DOWN_WALL, FLOOR_LEFT_WALL, and FLOOR_RIGHT_WALL to the base_obstacles set. These tiles are solid walls (ledge faces) and caused pathfinding errors when the tool incorrectly treated them as traversable.",
        "timestamp": "2025-11-24T02:01:48.846Z",
        "action_counter": 6571
      },
      {
        "commit_message": "fix: Update find_path to treat tiles marked with 'Trap' or 'ðŸ’£' as obstacles. This is critical for navigating the trap-filled corridor in Team Rocket Base B1F.",
        "timestamp": "2025-11-24T20:34:39.795Z",
        "action_counter": 7056
      },
      {
        "commit_message": "fix: Add COUNTER, BOOKSHELF, PC, TV, RADIO, WINDOW, TOWN_MAP, and MART_SHELF to the obstacle list in find_path. These are solid objects that block movement but were previously treated as traversable, causing pathfinding failures in the Rocket Base.",
        "timestamp": "2025-11-24T21:20:07.644Z",
        "action_counter": 7120
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE and CUT_TREE to obstacle_types in find_path. Previously, the tool treated these tiles as traversable, causing invalid paths through solid trees.",
        "timestamp": "2025-11-28T21:17:01.577Z",
        "action_counter": 12561
      },
      {
        "commit_message": "fix: Make obstacle detection robust by treating any tile type containing 'WALL' or 'TREE' as an obstacle. This prevents pathfinding failures on HEADBUTT_TREE or variant wall tiles that were previously missed.",
        "timestamp": "2025-11-28T21:27:51.596Z",
        "action_counter": 12576
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T21:45:16.721Z",
        "action_counter": 12601
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T21:48:50.709Z",
        "action_counter": 12606
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T21:53:24.421Z",
        "action_counter": 12612
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T21:56:57.360Z",
        "action_counter": 12616
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T21:59:09.404Z",
        "action_counter": 12620
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T22:03:11.092Z",
        "action_counter": 12625
      },
      {
        "commit_message": "fix: Added 'BOULDER' to obstacle keywords and explicitly checked for marker IDs to ensure dynamic objects are treated as obstacles. Added redundant checks for object attributes.",
        "timestamp": "2025-11-29T04:38:45.546Z",
        "action_counter": 13141
      },
      {
        "commit_message": "fix: Remove syntax error (garbage characters) from the end of the script and ensure 'BOULDER' is in the obstacle list.",
        "timestamp": "2025-11-29T04:41:30.820Z",
        "action_counter": 13146
      },
      {
        "commit_message": "fix: Remove 'LADDER' from obstacle_substrings. LADDER tiles are traversable and necessary for navigation in multi-floor areas like Dragon's Den. Previously, the tool incorrectly treated them as walls, causing pathfinding failures.",
        "timestamp": "2025-11-30T10:59:03.285Z",
        "action_counter": 14869
      },
      {
        "commit_message": "fix: Update find_path to be context-aware for Surfing. Now, if the player is surfing, all non-water tiles are treated as obstacles UNLESS they are the specific target destination. This prevents the pathfinder from creating routes that cut corners over land, which causes accidental dismounting.",
        "timestamp": "2025-11-30T11:33:19.757Z",
        "action_counter": 14914
      },
      {
        "commit_message": "feat: Update find_path to use Dijkstra with weighted edges. Adds high penalty for Land->Water transitions when player is surfing to prevent accidental dismounting/corner-cutting. Treats 'unseen' tiles as Water to allow optimistic pathfinding.",
        "timestamp": "2025-11-30T11:37:19.429Z",
        "action_counter": 14916
      },
      {
        "commit_message": "fix: Improve terrain handling. 1) When Walking, treat WATER tiles as obstacles. 2) When Surfing, penalize Water->Land transitions (dismounting) unless the land tile is the specific target. This prevents accidental dismounting and walking on water.",
        "timestamp": "2025-11-30T12:31:57.252Z",
        "action_counter": 14977
      },
      {
        "commit_message": "fix: Improve terrain handling. 1) When Walking, treat WATER tiles as obstacles. 2) When Surfing, penalize Water->Land transitions (dismounting) unless the land tile is the specific target. This prevents accidental dismounting and walking on water.",
        "timestamp": "2025-11-30T12:49:59.585Z",
        "action_counter": 14982
      },
      {
        "commit_message": "fix: Improve terrain handling. 1) When Walking, treat WATER tiles as obstacles. 2) When Surfing, penalize Water->Land transitions (dismounting) unless the land tile is the specific target. This prevents accidental dismounting and walking on water.",
        "timestamp": "2025-11-30T13:08:37.662Z",
        "action_counter": 14990
      },
      {
        "commit_message": "fix: Improve find_path robustness. 1) Better Player detection using has-player attribute. 2) Optimistic 'unseen' tile handling (matches current state). 3) Prevent start node from being treated as obstacle.",
        "timestamp": "2025-11-30T13:13:01.533Z",
        "action_counter": 14993
      },
      {
        "commit_message": "fix: Improve terrain handling. 1) When Surfing, penalize ANY transition between Water and Land (cost 1000). This encourages staying in the current medium (Water) until the destination requires landing, preventing inefficient 'island hopping' or accidental dismounting. 2) When Walking, treat Water as high-cost/obstacle to prefer land paths.",
        "timestamp": "2025-11-30T13:35:12.114Z",
        "action_counter": 14997
      },
      {
        "commit_message": "fix: Redefine find_path to strictly handle Surfing state. Detects player_on_water from map XML. If Surfing, penalizes Water->Land transitions (dismounting) unless destination is Land. If Walking, treats Water as high-cost. Optimistic handling for unseen tiles matching current medium.",
        "timestamp": "2025-11-30T13:57:04.458Z",
        "action_counter": 15011
      },
      {
        "commit_message": "fix: Improve find_path logic for surfing transitions. Explicitly penalize Water->Land (dismounting) unless destination is Land. Correctly detect 'is_water' property from map XML. Optimistic handling for unseen tiles.",
        "timestamp": "2025-11-30T13:58:34.916Z",
        "action_counter": 15013
      },
      {
        "commit_message": "fix: Add DOOR, CAVE, and STAIRS to obstacle list in find_path. This prevents the pathfinder from routing through warps as shortcuts, ensuring it sticks to the current map logic unless the warp is the explicit target.",
        "timestamp": "2025-11-30T14:01:17.738Z",
        "action_counter": 15014
      },
      {
        "commit_message": "fix: Redefine find_path to strictly handle Surfing state. Detects player_on_water from map XML. If Surfing, penalizes Water->Land transitions (dismounting) unless destination is Land. If Walking, treats Water as high-cost. Optimistic handling for unseen tiles matching current medium.",
        "timestamp": "2025-11-30T14:05:52.961Z",
        "action_counter": 15018
      },
      {
        "commit_message": "fix: Overhaul find_path logic for surfing. 1) Strictly detect player state (Water/Land). 2) If Surfing, apply massive 10000 cost to dismounting UNLESS destination is the target or adjacent. 3) If Walking, apply massive cost to entering water. 4) Treat warps (DOOR, CAVE) as obstacles to prevent accidental entry.",
        "timestamp": "2025-11-30T14:13:34.568Z",
        "action_counter": 15023
      },
      {
        "commit_message": "fix: Overhaul find_path logic for surfing. 1) Strictly detect player state (Water/Land) from XML. 2) If Surfing, apply massive 10000 cost to dismounting UNLESS destination is the target. 3) If Walking, apply massive cost to entering water. 4) Correct logic to check Water->Land transition.",
        "timestamp": "2025-11-30T14:29:22.468Z",
        "action_counter": 15036
      },
      {
        "commit_message": "fix: Overhaul find_path logic for surfing. 1) Strictly detect player state (Water/Land) from XML. 2) If Surfing, apply massive 10000 cost to dismounting UNLESS destination is the target. 3) If Walking, apply massive cost to entering water. 4) Correct logic to check Water->Land transition.",
        "timestamp": "2025-11-30T14:44:58.505Z",
        "action_counter": 15055
      },
      {
        "commit_message": "fix: Overhaul find_path. 1) Detect surfing state. 2) Penalize dismounting (Water->Land) unless target. 3) Penalize entering water (Land->Water) unless surfing. 4) Treat non-target Warps and Objects as obstacles. 5) Handle blocked targets by pathing to adjacent tiles.",
        "timestamp": "2025-12-01T00:58:00.885Z",
        "action_counter": 15865
      },
      {
        "commit_message": "fix: Overhaul find_path. 1) Detect surfing state. 2) Penalize dismounting (Water->Land) unless target. 3) Penalize entering water (Land->Water) unless surfing. 4) Treat non-target Warps and Objects as obstacles. 5) Handle blocked targets by pathing to adjacent tiles.",
        "timestamp": "2025-12-01T01:01:23.396Z",
        "action_counter": 15871
      },
      {
        "commit_message": "fix: Overhaul find_path logic. 1) Strictly detect surfing state from XML. 2) Penalize dismounting (Water->Land) unless target. 3) Penalize entering water (Land->Water) unless surfing. 4) Treat Warps and Objects as obstacles unless they are the target. 5) Handle blocked targets (like NPCs) by pathing to the nearest traversable adjacent tile.",
        "timestamp": "2025-12-01T01:06:11.937Z",
        "action_counter": 15879
      },
      {
        "commit_message": "fix: Add CUT_TREE, BUOY, and WHIRLPOOL to the list of impassable tile types in get_cost. This prevents the pathfinder from generating paths through obstacles that require HM interaction.",
        "timestamp": "2025-12-01T22:21:32.123Z",
        "action_counter": 16767
      },
      {
        "commit_message": "fix: Add strict directional logic for LEDGE_HOP tiles (DOWN, UP, LEFT, RIGHT). The pathfinder now returns infinity cost if attempting to enter a ledge tile from any direction other than the hop direction (e.g., entering LEDGE_HOP_DOWN from below is now blocked).",
        "timestamp": "2025-12-02T04:33:45.317Z",
        "action_counter": 17245
      },
      {
        "commit_message": "fix: Improve find_path robustness. 1) Strip whitespace and uppercase tile types. 2) Explicitly add WINDOW and CAVE_WALL to blocked types. 3) Fix potential edge cases with blocked targets.",
        "timestamp": "2025-12-02T23:35:55.644Z",
        "action_counter": 17976
      },
      {
        "commit_message": "fix: Add FLOOR_UP_WALL to impassable tile types. This tile type blocked movement on Route 9, acting as a wall. Adding it prevents the pathfinder from attempting to walk through these tiles.",
        "timestamp": "2025-12-03T00:05:44.630Z",
        "action_counter": 18005
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from impassable tile types. This tile type acts as a traversable plateau edge on Route 9, and treating it as a wall was blocking the only valid path around an obstacle.",
        "timestamp": "2025-12-03T03:37:35.832Z",
        "action_counter": 18248
      },
      {
        "commit_message": "fix: Re-add FLOOR_UP_WALL to impassable tile types. Movement test at (41, 15) -> (41, 16) confirmed this tile type blocks movement on Route 9, requiring the pathfinder to route around it.",
        "timestamp": "2025-12-03T03:43:12.611Z",
        "action_counter": 18254
      }
    ]
  },
  "scan_unseen": {
    "description": "Scans the map to find 'unseen' tiles that are reachable from the player's current position using a BFS algorithm. Useful for prioritizing exploration.",
    "input_schema": {},
    "python_script": "# injected imports [\"sys\", \"json\"]\n# injected variables [\"map_xml_string\", \"input_data\"]\n\nimport xml.etree.ElementTree as ET\nimport collections\nimport json\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    player_pos = None\n    grid = {}\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib.get('type', 'FLOOR')\n            seen = tile.attrib.get('seen') == 'true'\n            has_object = tile.get('has-object') == 'true' or tile.find('Object') is not None\n            grid[(x,y)] = {'type': t_type, 'seen': seen, 'obstacle': has_object}\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n\n    if not player_pos:\n        print(json.dumps([]))\n        exit()\n\n    queue = collections.deque([player_pos])\n    visited = {player_pos}\n    reachable_unseen = []\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    while queue:\n        cx, cy = queue.popleft()\n        # If current tile is unseen, add to list and stop expanding this branch\n        if not grid[(cx, cy)]['seen'] or grid[(cx, cy)]['type'] == 'unseen':\n            reachable_unseen.append((cx, cy))\n            continue\n\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) in grid and (nx, ny) not in visited:\n                tile = grid[(nx, ny)]\n                if tile['obstacle']:\n                    continue\n                t_type = tile['type']\n                if 'WALL' in t_type or 'BUOY' in t_type or 'CUT_TREE' in t_type or 'WHIRLPOOL' in t_type:\n                    continue\n                if 'LEDGE_HOP_DOWN' in t_type and dy != 1:\n                    continue\n                visited.add((nx, ny))\n                queue.append((nx, ny))\n                \n    print(json.dumps(list(reachable_unseen)))\nexcept Exception as e:\n    print(json.dumps([]))",
    "history": [
      {
        "commit_message": "feat: Add scan_unseen tool to identify reachable exploration targets.",
        "timestamp": "2025-11-30T19:03:12.982Z",
        "action_counter": 15329
      },
      {
        "commit_message": "fix: Add CUT_TREE and WHIRLPOOL to the exclusion list in the BFS. This prevents the scanner from reporting tiles behind these obstacles as reachable.",
        "timestamp": "2025-12-01T22:21:32.124Z",
        "action_counter": 16767
      }
    ]
  },
  "select_move": {
    "description": "Automatically selects a move in the battle menu by parsing the screen text for the cursor 'â–¶' and the target move name in a vertical list.",
    "input_schema": {
      "type": "object",
      "properties": {
        "move_name": {
          "type": "string"
        },
        "screen_text": {
          "type": "string"
        }
      },
      "required": [
        "move_name",
        "screen_text"
      ]
    },
    "python_script": "import json\n\ninput_data = locals().get('input_data', {})\nscreen_text = input_data.get('screen_text', '')\ntarget_move = input_data.get('move_name', '').upper().strip()\n\nif not screen_text or not target_move:\n    print(json.dumps([]))\n    exit()\n\nlines = screen_text.split('\\n')\ncursor_row = -1\ntarget_row = -1\n\nfor i, line in enumerate(lines):\n    if 'â–¶' in line:\n        cursor_row = i\n    if target_move in line.upper():\n        target_row = i\n\nif cursor_row != -1 and target_row != -1:\n    diff = target_row - cursor_row\n    buttons = []\n    if diff > 0:\n        buttons.extend(['Down'] * diff)\n    elif diff < 0:\n        buttons.extend(['Up'] * abs(diff))\n    buttons.append('A')\n    print(json.dumps(buttons))\nelse:\n    print(json.dumps([]))",
    "history": [
      {
        "commit_message": "feat: Add select_move tool to automate move selection in battle menus, preventing manual input errors.",
        "timestamp": "2025-11-25T17:55:51.068Z",
        "action_counter": 7861
      },
      {
        "commit_message": "fix: Refine select_move to strictly validate inputs and ensure robust cursor detection logic, addressing the persistent cursor memory issue identified in critique.",
        "timestamp": "2025-11-30T07:21:13.927Z",
        "action_counter": 14672
      },
      {
        "commit_message": "fix: Refine select_move to strictly validate inputs and ensure robust cursor detection logic, addressing the persistent cursor memory issue identified in critique.",
        "timestamp": "2025-11-30T07:23:59.588Z",
        "action_counter": 14676
      },
      {
        "commit_message": "fix: Refine select_move to strictly validate inputs and ensure robust cursor detection logic, addressing the persistent cursor memory issue identified in critique.",
        "timestamp": "2025-11-30T07:25:07.230Z",
        "action_counter": 14678
      },
      {
        "commit_message": "fix: Refine select_move logic to robustly detect cursor and target move from screen text, adding debug prints to diagnose issues. This ensures the tool correctly handles persistent cursor memory in menus.",
        "timestamp": "2025-11-30T07:34:46.846Z",
        "action_counter": 14693
      },
      {
        "commit_message": "fix: Remove debug print statements that were causing JSON parsing errors. The tool now strictly outputs only the JSON array of button presses.",
        "timestamp": "2025-11-30T16:50:55.137Z",
        "action_counter": 15149
      },
      {
        "commit_message": "fix: Remove debug print statements causing JSON errors. Improve cursor and target detection logic to strictly output valid JSON button arrays.",
        "timestamp": "2025-11-30T17:09:48.544Z",
        "action_counter": 15170
      },
      {
        "commit_message": "fix: Overhaul select_move with robust 2x2 grid parsing. Now detects 'â–¶' cursor and target move row/column to calculate navigation steps, preventing errors where the tool assumed the cursor was already correctly placed.",
        "timestamp": "2025-12-01T09:07:47.934Z",
        "action_counter": 16323
      },
      {
        "commit_message": "fix: Update select_move to handle vertical move lists used in Gen 2 (Crystal), replacing the incorrect 2x2 grid logic. Calculates button presses based on line difference between the cursor 'â–¶' and the target move in the screen text.",
        "timestamp": "2025-12-01T21:58:56.900Z",
        "action_counter": 16736
      }
    ]
  },
  "force_press_button": {
    "description": "Generates a sequence of identical button presses. Use with autopress_buttons: true to bypass harness checks or navigate menus efficiently.",
    "input_schema": {
      "type": "object",
      "properties": {
        "button": {
          "type": "string",
          "enum": [
            "A",
            "B",
            "Up",
            "Down",
            "Left",
            "Right",
            "Start",
            "Select"
          ]
        },
        "count": {
          "type": "integer",
          "minimum": 1,
          "maximum": 20
        }
      },
      "required": [
        "button",
        "count"
      ]
    },
    "python_script": "import json\nprint(json.dumps([input_data[\"button\"]] * int(input_data[\"count\"])))",
    "history": [
      {
        "commit_message": "feat: Add force_press_button tool to bypass harness text checks and automate repetitive inputs.",
        "timestamp": "2025-12-03T22:17:19.871Z",
        "action_counter": 18830
      }
    ]
  }
}