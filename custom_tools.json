{
  "object_finder": {
    "description": "Finds a specific map object by its ID and returns its coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "object_id": {
          "type": "string"
        }
      },
      "required": [
        "object_id"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntarget_id = input_data['object_id']\nroot = ET.fromstring(map_xml_string)\nfound = False\nfor row in root.findall('Row'):\n    y = row.get('id')\n    for tile in row.findall('Tile'):\n        x = tile.get('id')\n        for obj in tile.findall('Object'):\n            if obj.get('id') == target_id:\n                print(json.dumps({'x': x, 'y': y}))\n                found = True\n                break\n        if found:\n            break\n    if found:\n        break\n\nif not found:\n    print(json.dumps({'error': 'Object not found on screen.'}))"
  },
  "impassable_tile_scanner": {
    "description": "Scans the current map and returns a list of all impassable coordinates, including walls and all objects.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\nroot = ET.fromstring(map_xml_string)\nimpassable_coords = []\n\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.attrib['id'])\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.attrib['id'])\n        tile_type = tile_elem.attrib['type']\n        has_object = tile_elem.find('Object') is not None\n        \n        if tile_type == 'WALL' or has_object:\n            impassable_coords.append({'x': x, 'y': y})\n\nprint(json.dumps(impassable_coords))"
  },
  "smart_pathfinder": {
    "description": "A more robust pathfinder. It automatically avoids all on-screen objects and finds the nearest valid start tile if the player's current position is on a non-traversable tile.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "traversable_tiles": {
          "type": "string"
        },
        "debug": {
          "type": "string",
          "description": "Optional. Set to 'true' to enable debug logging."
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "traversable_tiles"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef find_path_on_graph(start_node, end_node, graph, debug=False):\n    open_set = []\n    heapq.heappush(open_set, (0, start_node))\n    came_from = {}\n    g_score = {node: float('inf') for node in graph}\n    g_score[start_node] = 0\n    f_score = {node: float('inf') for node in graph}\n    f_score[start_node] = heuristic(start_node, end_node)\n\n    if debug:\n        print(f\"Pathfinding from {start_node} to {end_node}...\")\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == end_node:\n            path = []\n            temp = current\n            while temp in came_from:\n                path.append(temp)\n                temp = came_from[temp]\n            path.append(start_node)\n            path.reverse()\n            return path\n\n        for neighbor, weight in graph.get(current, {}).items():\n            tentative_g_score = g_score[current] + weight\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + heuristic(neighbor, end_node)\n                if neighbor not in [i[1] for i in open_set]:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    base_traversable_tiles = {tile.strip() for tile in input_data.get('traversable_tiles', '').split(',')}\n    debug = input_data.get('debug', 'false').lower() == 'true'\n\n    root = ET.fromstring(map_xml_string)\n    \n    auto_avoid_set = set()\n    for obj in root.findall('.//Object'):\n        if 'x' in obj.attrib and 'y' in obj.attrib:\n            obj_x = int(obj.attrib['x'])\n            obj_y = int(obj.attrib['y'])\n            auto_avoid_set.add((obj_x, obj_y))\n    \n    if debug:\n        print(f\"Auto-avoiding objects at: {auto_avoid_set}\")\n\n    tile_data = {}\n    all_nodes = set()\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            if tile_elem.attrib.get('seen') != 'true':\n                continue\n            x = int(tile_elem.attrib['id'])\n            coord = (x, y)\n            \n            tile_type = tile_elem.attrib['type']\n            is_traversable = (tile_type in base_traversable_tiles) and (coord not in auto_avoid_set) and ('Object' not in [child.tag for child in tile_elem])\n            \n            if is_traversable:\n                all_nodes.add(coord)\n\n    graph = {}\n    for node in all_nodes:\n        graph[node] = {}\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (node[0] + dx, node[1] + dy)\n            if neighbor in all_nodes:\n                graph[node][neighbor] = 1\n\n    start_node = (start_x, start_y)\n    target_node = (end_x, end_y)\n\n    if start_node not in graph:\n        if debug:\n            print(f\"Start node {start_node} is not traversable. Finding closest valid start.\")\n        possible_starts = sorted(list(graph.keys()), key=lambda p: heuristic(start_node, p))\n        if not possible_starts:\n            print(json.dumps({'error': 'No traversable start tiles found anywhere on the map.'}))\n            exit()\n        start_node = possible_starts[0]\n        if debug:\n            print(f\"New start node: {start_node}\")\n\n    if target_node not in graph:\n        if debug:\n            print(f\"Target node {target_node} is not traversable. Finding closest adjacent node.\")\n        possible_targets = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_node = (end_x + dx, end_y + dy)\n            if adj_node in graph:\n                possible_targets.append(adj_node)\n        \n        if not possible_targets:\n            print(json.dumps({'error': 'No traversable adjacent tiles found for the target.'}))\n            exit()\n\n        closest_target = min(possible_targets, key=lambda p: heuristic(start_node, p))\n        target_node = closest_target\n        if debug:\n            print(f\"New target node: {closest_target}\")\n            \n    final_path = find_path_on_graph(start_node, target_node, graph, debug)\n    if final_path:\n        print(json.dumps({'path': [{'x': p[0], 'y': p[1]} for p in final_path]}))\n    else:\n        print(json.dumps({'error': 'No path found.'}))\n\nexcept Exception as e:\n    print(json.dumps({'error': f'An error occurred: {e}'}))"
  },
  "advanced_pathfinder": {
    "description": "A pathfinder that can navigate one-way ledges. Takes start/end coordinates and a list of traversable tile types. Automatically avoids on-screen objects.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "traversable_tiles": {
          "type": "string"
        },
        "debug": {
          "type": "string",
          "description": "Optional. Set to 'true' to enable debug logging."
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "traversable_tiles"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef find_path_on_graph(start_node, end_node, graph, tile_types, one_way_tiles, debug=False):\n    open_set = []\n    heapq.heappush(open_set, (0, start_node))\n    came_from = {}\n    g_score = {node: float('inf') for node in graph}\n    g_score[start_node] = 0\n    f_score = {node: float('inf') for node in graph}\n    f_score[start_node] = heuristic(start_node, end_node)\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == end_node:\n            path = []\n            temp = current\n            while temp in came_from:\n                path.append(temp)\n                temp = came_from[temp]\n            path.append(start_node)\n            path.reverse()\n            return path\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if neighbor not in graph:\n                continue\n\n            # Check if moving from neighbor to current is a valid one-way move\n            neighbor_type = tile_types.get(neighbor)\n            if neighbor_type in one_way_tiles:\n                valid_dx, valid_dy = one_way_tiles[neighbor_type]\n                # This checks if the move from neighbor to current is the allowed one-way direction.\n                # If so, we can't go backwards from current to neighbor.\n                if dx == -valid_dx and dy == -valid_dy:\n                    pass # This is a valid move\n                else:\n                    continue # Invalid move against a one-way tile\n\n            # Check if moving from current to neighbor is an invalid one-way move\n            current_type = tile_types.get(current)\n            if current_type in one_way_tiles:\n                valid_dx, valid_dy = one_way_tiles[current_type]\n                # This checks if the move from current to neighbor is the one-way direction.\n                if dx == valid_dx and dy == valid_dy:\n                    pass # This is a valid move\n                else:\n                    continue # Invalid move from a one-way tile\n\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + heuristic(neighbor, end_node)\n                if neighbor not in [i[1] for i in open_set]:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    base_traversable_tiles = {tile.strip() for tile in input_data.get('traversable_tiles', '').split(',')}\n    debug = input_data.get('debug', 'false').lower() == 'true'\n\n    one_way_tiles = {\n        'LEDGE_HOP_DOWN': (0, 1),\n        'LEDGE_HOP_LEFT': (-1, 0),\n        'LEDGE_HOP_RIGHT': (1, 0),\n        'FLOOR_UP_WALL': (0, 1)\n    }\n\n    root = ET.fromstring(map_xml_string)\n    \n    auto_avoid_set = set()\n    for obj in root.findall('.//Object'):\n        if 'x' in obj.attrib and 'y' in obj.attrib:\n            obj_x = int(obj.attrib['x'])\n            obj_y = int(obj.attrib['y'])\n            auto_avoid_set.add((obj_x, obj_y))\n    \n    tile_types = {}\n    all_nodes = set()\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            if tile_elem.attrib.get('seen') != 'true':\n                continue\n            x = int(tile_elem.attrib['id'])\n            coord = (x, y)\n            \n            tile_type = tile_elem.attrib['type']\n            tile_types[coord] = tile_type\n            \n            is_traversable = (tile_type in base_traversable_tiles or tile_type in one_way_tiles) and \\\n                             (coord not in auto_avoid_set) and \\\n                             ('Object' not in [child.tag for child in tile_elem])\n            \n            if is_traversable:\n                all_nodes.add(coord)\n\n    start_node = (start_x, start_y)\n    target_node = (end_x, end_y)\n\n    if start_node not in all_nodes:\n        if debug: print(f\"Start node {start_node} is not traversable. Finding closest valid start.\")\n        possible_starts = sorted(list(all_nodes), key=lambda p: heuristic(start_node, p))\n        if not possible_starts:\n            print(json.dumps({'error': 'No traversable start tiles found anywhere on the map.'}))\n            exit()\n        start_node = possible_starts[0]\n\n    if target_node not in all_nodes:\n        if debug: print(f\"Target node {target_node} is not traversable. Finding closest adjacent node.\")\n        possible_targets = [adj for dx, dy in [(0,1),(0,-1),(1,0),(-1,0)] if (adj := (end_x+dx, end_y+dy)) in all_nodes]\n        if not possible_targets:\n            print(json.dumps({'error': 'No traversable adjacent tiles found for the target.'}))\n            exit()\n        target_node = min(possible_targets, key=lambda p: heuristic(start_node, p))\n            \n    final_path = find_path_on_graph(start_node, target_node, all_nodes, tile_types, one_way_tiles, debug)\n    if final_path:\n        print(json.dumps({'path': [{'x': p[0], 'y': p[1]} for p in final_path]}))\n    else:\n        print(json.dumps({'error': 'No path found.'}))\n\nexcept Exception as e:\n    print(json.dumps({'error': f'An error occurred: {e}'}))"
  },
  "unseen_tile_scanner": {
    "description": "Scans the current map XML and returns a list of coordinates for all unseen tiles.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\n\nunseen_tiles = []\nroot = ET.fromstring(map_xml_string)\nfor row in root.findall('Row'):\n    for tile in row.findall('Tile'):\n        if tile.get('seen') == 'false':\n            unseen_tiles.append(tile.get('coordinate'))\nprint(unseen_tiles)"
  }
}