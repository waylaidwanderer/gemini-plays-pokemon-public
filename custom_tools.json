{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "get_impassable_tiles": {
    "description": "Extracts and returns a JSON list of all impassable tile coordinates from the current map XML.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET; import json; root = ET.fromstring(map_xml_string); impassable_tiles = []; for row_elem in root.findall('Row'): y = int(row_elem.get('id')); for tile_elem in row_elem.findall('Tile'): x = int(tile_elem.get('id')); if tile_elem.get('type') == 'impassable' or tile_elem.find('Object') is not None: impassable_tiles.append({'x': x, 'y': y}); print(json.dumps(impassable_tiles))"
  },
  "find_path_v2": {
    "description": "A new and improved pathfinding tool using the A* algorithm. It finds a path to specified X, Y coordinates, considering the current movement state (walking or surfing). It can avoid a specified list of coordinates and correctly handle ledges.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string",
          "nullable": true
        },
        "end_y": {
          "type": "string",
          "nullable": true
        },
        "movement_mode": {
          "type": "string",
          "enum": [
            "walking",
            "surfing"
          ]
        },
        "avoid_coords": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "start_x",
        "start_y",
        "movement_mode"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport heapq\n\ndef parse_map_xml(xml_string):\n    root = ET.fromstring(xml_string)\n    grid = {}\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tile_type = tile.get('type')\n            has_object = tile.find('Object') is not None\n            is_pikachu = has_object and tile.find('Object').get('id-name') == 'Pikachu'\n            grid[(x, y)] = {'type': tile_type, 'has_object': has_object, 'is_pikachu': is_pikachu}\n    return grid, width, height\n\ndef is_walkable(tile_data, movement_mode):\n    if not tile_data: return False\n    walkable_types = ['ground', 'grass', 'cleared_boulder_barrier', 'boulder_switch', 'open_gate', 'gate_offscreen', 'steps', 'elevated_ground', 'ladder_up', 'ladder_down', 'hole']\n    surfable_types = ['water']\n    if movement_mode == 'walking':\n        return tile_data.get('type') in walkable_types\n    elif movement_mode == 'surfing':\n        return tile_data.get('type') in surfable_types\n    return False\n\ndef get_neighbors(current_pos, grid, width, height, movement_mode):\n    x, y = current_pos\n    neighbors = []\n    for dx, dy, direction in [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n        nx, ny = x + dx, y + dy\n        if not (1 <= nx <= width and 1 <= ny <= height):\n            continue\n        next_tile_data = grid.get((nx, ny), {})\n        next_tile_type = next_tile_data.get('type')\n        if direction == 'Down' and next_tile_type == 'ledge':\n            final_y = ny + 1\n            if 1 <= final_y <= height:\n                landing_tile_data = grid.get((nx, final_y), {})\n                if is_walkable(landing_tile_data, movement_mode) and not (landing_tile_data.get('has_object') and not landing_tile_data.get('is_pikachu')):\n                    neighbors.append(((nx, final_y), 'Ledge'))\n            continue\n        if is_walkable(next_tile_data, movement_mode):\n            if not (next_tile_data.get('has_object') and not next_tile_data.get('is_pikachu')):\n                neighbors.append(((nx, ny), direction))\n    return neighbors\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef find_path_astar(grid, width, height, start, end, movement_mode, avoid_coords_set):\n    if not end:\n        return None\n    target_tile_data = grid.get(end, {})\n    if not is_walkable(target_tile_data, movement_mode) or (target_tile_data.get('has_object') and not target_tile_data.get('is_pikachu')):\n        best_adj = None\n        min_dist = float('inf')\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_x, adj_y = end[0] + dx, end[1] + dy\n            adj_tile_data = grid.get((adj_x, adj_y))\n            if adj_tile_data and is_walkable(adj_tile_data, movement_mode) and not (adj_tile_data.get('has_object') and not adj_tile_data.get('is_pikachu')):\n                dist = heuristic((adj_x, adj_y), start)\n                if dist < min_dist:\n                    min_dist = dist\n                    best_adj = (adj_x, adj_y)\n        if best_adj is None: return None\n        end = best_adj\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {pos: float('inf') for pos in grid}\n    g_score[start] = 0\n    f_score = {pos: float('inf') for pos in grid}\n    f_score[start] = heuristic(start, end)\n    while open_set:\n        _, current = heapq.heappop(open_set)\n        if current == end:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            return path[::-1]\n        for neighbor_pos, move_type in get_neighbors(current, grid, width, height, movement_mode):\n            if neighbor_pos in avoid_coords_set:\n                continue\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor_pos, float('inf')):\n                came_from[neighbor_pos] = current\n                g_score[neighbor_pos] = tentative_g_score\n                f_score[neighbor_pos] = g_score[neighbor_pos] + heuristic(neighbor_pos, end)\n                if neighbor_pos not in [i[1] for i in open_set]:\n                    heapq.heappush(open_set, (f_score[neighbor_pos], neighbor_pos))\n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    movement_mode = input_data['movement_mode']\n    end_x = int(input_data.get('end_x')) if input_data.get('end_x') else None\n    end_y = int(input_data.get('end_y')) if input_data.get('end_y') else None\n    avoid_coords_str = input_data.get('avoid_coords')\n    avoid_coords_list = json.loads(avoid_coords_str) if avoid_coords_str else []\n    avoid_coords_set = {(int(c['x']), int(c['y'])) for c in avoid_coords_list}\n    grid, width, height = parse_map_xml(map_xml_string)\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y) if end_x is not None and end_y is not None else None\n    path = find_path_astar(grid, width, height, start_node, end_node, movement_mode, avoid_coords_set)\n    if path:\n        # Reconstruct path with ledge tiles for animation\n        final_path = []\n        for i in range(len(path)):\n            final_path.append(path[i])\n            if i > 0:\n                prev_node = path[i-1]\n                curr_node = path[i]\n                if abs(curr_node[1] - prev_node[1]) == 2: # Ledge jump detected\n                    final_path.insert(len(final_path)-1, (curr_node[0], curr_node[1] - 1))\n        path_dicts = [{'x': str(p[0]), 'y': str(p[1])} for p in final_path]\n        print(json.dumps(path_dicts))\n    else:\n        print(json.dumps([]))\nexcept Exception as e:\n    print(json.dumps([{'error': str(e)}]))"
  }
}