{
  "find_wkg_node_by_coords": {
    "description": "Finds a World Knowledge Graph node ID by map ID and coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "map_id": {
          "type": "string"
        },
        "x": {
          "type": "string"
        },
        "y": {
          "type": "string"
        }
      },
      "required": [
        "map_id",
        "x",
        "y"
      ]
    },
    "python_script": "import json\n\ndef find_node():\n    try:\n        wkg = json.loads(world_knowledge_graph_json_string)\n        target_map_id = input_data['map_id']\n        target_x = int(input_data['x'])\n        target_y = int(input_data['y'])\n\n        for node in wkg['nodes']:\n            if str(node['map_id']) == str(target_map_id) and node['coordinates']['x'] == target_x and node['coordinates']['y'] == target_y:\n                print(json.dumps({'status': 'success', 'node_id': node['id']}))\n                return\n        \n        print(json.dumps({'status': 'error', 'message': f'Node not found on map {target_map_id} at ({target_x}, {target_y}).'}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'status': 'error', 'message': f'An exception occurred: {traceback.format_exc()}'}))\n\nfind_node()"
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map. It now correctly handles impassable tiles, dynamic transitions between walking and surfing, and navigates ledges. It outputs a JSON list of coordinate dictionaries. **REFINED:** Now uses manual string parsing instead of the forbidden xml.etree.ElementTree library and includes more robust error handling.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "is_surfing": {
          "type": "string",
          "enum": [
            "true",
            "false"
          ]
        },
        "can_surf": {
          "type": "string",
          "enum": [
            "true",
            "false"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "is_surfing",
        "can_surf"
      ]
    },
    "python_script": "import json\nimport heapq\n\ndef pathfinder_v3():\n    try:\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        end_x = int(input_data['end_x'])\n        end_y = int(input_data['end_y'])\n        is_surfing = input_data['is_surfing'].lower() == 'true'\n        can_surf = input_data['can_surf'].lower() == 'true'\n\n        # Manual XML parsing to avoid forbidden libraries\n        grid = {}\n        map_width_str = map_xml_string.split('width=\"')[1].split('\"')[0]\n        map_height_str = map_xml_string.split('height=\"')[1].split('\"')[0]\n        width = int(map_width_str)\n        height = int(map_height_str)\n\n        if not (1 <= start_x <= width and 1 <= start_y <= height and 1 <= end_x <= width and 1 <= end_y <= height):\n            print(json.dumps({'error': 'Start or end coordinates are out of map bounds.'}))\n            return\n\n        rows = map_xml_string.split('<Row id=')\n        for row_str in rows[1:]:\n            y = int(row_str.split('\"')[1])\n            tiles = row_str.split('<Tile id=')\n            for tile_str in tiles[1:]:\n                x = int(tile_str.split('\"')[1])\n                tile_type = tile_str.split('type=\"')[1].split('\"')[0]\n                has_object = 'has-object=\"true\"' in tile_str\n                if has_object and 'id-name=\"Pikachu\"' in tile_str:\n                    has_object = False\n                \n                is_teleporter = tile_type == 'teleport'\n                is_target_teleporter = is_teleporter and x == end_x and y == end_y\n\n                if tile_type in ['impassable', 'boulder_barrier', 'closed_gate'] or has_object or (is_teleporter and not is_target_teleporter):\n                    grid[(x, y)] = 'wall'\n                else:\n                    grid[(x, y)] = tile_type\n\n        if grid.get((end_x, end_y)) == 'wall':\n             print(json.dumps({'error': 'End coordinates are on an impassable tile.'}))\n             return\n\n        def get_neighbors(x, y):\n            neighbors = []\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if not (1 <= nx <= width and 1 <= ny <= height):\n                    continue\n\n                neighbor_tile = grid.get((nx, ny))\n                if neighbor_tile == 'wall':\n                    continue\n\n                if neighbor_tile == 'ledge' and dy == -1: # Cannot go up ledges\n                    continue\n\n                if neighbor_tile == 'water' and not can_surf:\n                    continue\n\n                if neighbor_tile == 'ledge' and dy == 1: # Jump down ledge\n                    nny = ny + 1\n                    if 1 <= nny <= height and grid.get((nx, nny)) != 'wall':\n                        neighbors.append((nx, nny))\n                else:\n                    neighbors.append((nx, ny))\n            return neighbors\n\n        start_node = (start_x, start_y)\n        end_node = (end_x, end_y)\n        open_set = [(0, start_node)]\n        came_from = {}\n        g_score = {start_node: 0}\n\n        while open_set:\n            _, current_node = heapq.heappop(open_set)\n\n            if current_node == end_node:\n                path = []\n                while current_node in came_from:\n                    path.append({'x': current_node[0], 'y': current_node[1]})\n                    current_node = came_from[current_node]\n                path.append({'x': start_node[0], 'y': start_node[1]})\n                print(json.dumps(path[::-1]))\n                return\n\n            cx, cy = current_node\n            for neighbor in get_neighbors(cx, cy):\n                new_g = g_score[current_node] + 1\n                if neighbor not in g_score or new_g < g_score[neighbor]:\n                    g_score[neighbor] = new_g\n                    f_score = new_g + abs(neighbor[0] - end_x) + abs(neighbor[1] - end_y)\n                    heapq.heappush(open_set, (f_score, neighbor))\n                    came_from[neighbor] = current_node\n\n        print(json.dumps([]))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))\n\npathfinder_v3()\n"
  },
  "wkg_pathfinder": {
    "description": "Finds the shortest path between two nodes in the World Knowledge Graph using BFS. Outputs a list of node IDs representing the path.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_node_id": {
          "type": "string"
        },
        "end_node_id": {
          "type": "string"
        }
      },
      "required": [
        "start_node_id",
        "end_node_id"
      ]
    },
    "python_script": "import json\nimport collections\n\ndef wkg_pathfinder(start_node_id, end_node_id):\n    try:\n        wkg = json.loads(world_knowledge_graph_json_string)\n        nodes = {node['id']: node for node in wkg.get('nodes', [])}\n        edges = wkg.get('edges', [])\n        \n        nodes_in_wkg = set(nodes.keys())\n        missing = []\n        if start_node_id not in nodes_in_wkg:\n            missing.append(\"Start node '{}'\".format(start_node_id))\n        if end_node_id not in nodes_in_wkg:\n            missing.append(\"End node '{}'\".format(end_node_id))\n        if missing:\n            print(json.dumps({'status': 'error', 'message': \"Node(s) not found in World Knowledge Graph: {}.\".format(', '.join(missing))}))\n            return\n\n        adj = collections.defaultdict(list)\n        for edge in edges:\n            source = edge['source_node_id']\n            dest = edge['destination_node_id']\n            adj[source].append(dest)\n            if not edge.get('is_one_way', False):\n                adj[dest].append(source)\n\n        queue = collections.deque([(start_node_id, [start_node_id])])\n        visited = {start_node_id}\n        \n        while queue:\n            current_node_id, path = queue.popleft()\n            \n            if current_node_id == end_node_id:\n                print(json.dumps({'status': 'success', 'path': path}))\n                return\n            \n            for neighbor_id in adj.get(current_node_id, []):\n                if neighbor_id not in visited:\n                    visited.add(neighbor_id)\n                    new_path = list(path)\n                    new_path.append(neighbor_id)\n                    queue.append((neighbor_id, new_path))\n        \n        print(json.dumps({'status': 'no_path_found', 'message': \"No path found from {} to {}.\".format(start_node_id, end_node_id)}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'status': 'error', 'message': 'An exception occurred: {}'.format(traceback.format_exc())}))\n\nwkg_pathfinder(input_data['start_node_id'], input_data['end_node_id'])"
  },
  "maze_solver": {
    "description": "Finds the nearest reachable, unvisited warp tile in a maze-like environment. REFINED: Excludes the player's current tile from the target list.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "all_warps": {
          "type": "string"
        },
        "map_markers": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "all_warps",
        "map_markers"
      ]
    },
    "python_script": "import json\nimport heapq\nfrom xml.etree import ElementTree as ET\n\ndef maze_solver():\n    try:\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        all_warps = json.loads(input_data['all_warps'])\n        map_markers = json.loads(input_data['map_markers'])\n\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        grid = [['' for _ in range(width + 1)] for _ in range(height + 1)]\n\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                if has_object:\n                    object_elem = tile_elem.find('Object')\n                    if object_elem is not None and object_elem.get('id-name') == 'Pikachu':\n                        has_object = False\n                \n                if tile_type in ['impassable', 'boulder_barrier', 'closed_gate'] or has_object:\n                    grid[y][x] = 'wall'\n                else:\n                    grid[y][x] = tile_type\n\n        visited_warps = set()\n        for marker in map_markers:\n            if 'Warp' in marker.get('label', ''):\n                visited_warps.add((marker['x'], marker['y']))\n\n        unvisited_warps = []\n        for warp in all_warps:\n            if (warp['x'], warp['y']) not in visited_warps and (warp['x'], warp['y']) != (start_x, start_y):\n                unvisited_warps.append(warp)\n        \n        def find_path(end_x, end_y):\n            start_node = (start_x, start_y)\n            end_node = (end_x, end_y)\n            open_set = [(0, start_node)]\n            came_from = {}\n            g_score = {start_node: 0}\n\n            while open_set:\n                _, current_node = heapq.heappop(open_set)\n\n                if current_node == end_node:\n                    path = []\n                    while current_node in came_from:\n                        path.append({'x': current_node[0], 'y': current_node[1]})\n                        current_node = came_from[current_node]\n                    path.append({'x': start_node[0], 'y': start_node[1]})\n                    return path[::-1]\n\n                cx, cy = current_node\n                \n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nx, ny = cx + dx, cy + dy\n                    if not (1 <= nx <= width and 1 <= ny <= height):\n                        continue\n                    \n                    neighbor_tile = grid[ny][nx]\n                    is_teleporter = neighbor_tile == 'teleport'\n                    is_target_teleporter = is_teleporter and nx == end_x and ny == end_y\n\n                    if neighbor_tile == 'wall' or (is_teleporter and not is_target_teleporter):\n                        continue\n                    \n                    if neighbor_tile == 'ledge' and dy == -1: continue\n\n                    neighbor = (nx, ny)\n                    if neighbor_tile == 'ledge' and dy == 1:\n                        nny = ny + 1\n                        if not (1 <= nny <= height) or grid[nny][nx] == 'wall': continue\n                        neighbor = (nx, nny)\n\n                    new_g = g_score[current_node] + 1\n                    if neighbor not in g_score or new_g < g_score[neighbor]:\n                        g_score[neighbor] = new_g\n                        f_score = new_g + abs(neighbor[0] - end_x) + abs(neighbor[1] - end_y)\n                        heapq.heappush(open_set, (f_score, neighbor))\n                        came_from[neighbor] = current_node\n            return None\n\n        shortest_path = None\n        target_warp = None\n\n        for warp in unvisited_warps:\n            path = find_path(warp['x'], warp['y'])\n            if path:\n                if not shortest_path or len(path) < len(shortest_path):\n                    shortest_path = path\n                    target_warp = warp\n        \n        if target_warp and shortest_path:\n            print(json.dumps({\n                'next_target_warp': {'x': target_warp['x'], 'y': target_warp['y']},\n                'path': shortest_path\n            }))\n        else:\n            print(json.dumps({'next_target_warp': None, 'path': []}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))\n\nmaze_solver()\n"
  },
  "data_extractor": {
    "description": "Parses the map_xml_string to extract a JSON object containing a list of all teleporter coordinates and a list of all map markers. This provides clean, structured data for other tools like maze_solver.",
    "input_schema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "python_script": "import json\nimport re\n\ndef extract_data():\n    try:\n        teleporter_coords = []\n        teleporter_pattern = r'<Tile[^>]*type=\\\"teleport\\\"[^>]*coordinate=\\\"\\\\(([^,]+), ([^)]+)\\\\)\\\"/>'\n        for match in re.finditer(teleporter_pattern, map_xml_string):\n            x, y = match.groups()\n            teleporter_coords.append({'x': int(x), 'y': int(y)})\n        \n        marker_data = []\n        marker_pattern = r'<Marker emoji=\\\"([^\\\"]+)\\\">([^<]+)</Marker>.*?coordinate=\\\"\\\\(([^,]+), ([^)]+)\\\\)\\\"' \n        for match in re.finditer(marker_pattern, map_xml_string):\n            emoji, label, x, y = match.groups()\n            marker_data.append({'x': int(x), 'y': int(y), 'emoji': emoji, 'label': label.strip()})\n\n        print(json.dumps({\n            \"all_warps\": teleporter_coords,\n            \"map_markers\": marker_data\n        }))\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))\n\nextract_data()"
  }
}