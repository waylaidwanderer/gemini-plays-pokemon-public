{
  "exp_calculator_tool": {
    "description": "Calculates the average EXP gain from a list of wild Pokémon encounters.",
    "input_schema": {
      "type": "object",
      "properties": {
        "encounters": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "pokemon_name": {
                "type": "string"
              },
              "level": {
                "type": "integer"
              },
              "exp_yield": {
                "type": "integer"
              }
            },
            "required": [
              "pokemon_name",
              "level",
              "exp_yield"
            ]
          }
        }
      },
      "required": [
        "encounters"
      ]
    },
    "python_script": "import json\n\ndef exp_calculator(input_data):\n    encounters = input_data['encounters']\n    if not encounters:\n        return 'No encounters provided.'\n    total_exp = sum(e['exp_yield'] for e in encounters)\n    average_exp = total_exp / len(encounters)\n    return f'Average EXP gain: {average_exp:.2f}'\n\nresult = exp_calculator(json.loads(input_data))\nprint(result)"
  },
  "inventory_scanner": {
    "description": "Scans the player's inventory list for a target item and returns whether it was found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory_list": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "inventory_list",
        "target_item"
      ]
    },
    "python_script": "import json\n\ntry:\n    inventory_list = json.loads(input_data['inventory_list'])\n    target_item = input_data['target_item']\n    found = False\n    for item in inventory_list:\n        if target_item.lower() in item.lower():\n            found = True\n            break\n    print(f'Item found: {found}')\nexcept Exception as e:\n    print(f'An error occurred: {e}')"
  },
  "pathfinder": {
    "description": "Calculates the shortest path from the player's current position to a target coordinate. It now requires party data to verify that a conscious Pokémon with the necessary HM (e.g., Surf, Strength) is available before planning a path that requires it. This version includes specific logic for handling 'steps' and 'ledge' tiles correctly and will find a path to an adjacent tile if the target is impassable.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "party_data": {
          "type": "string",
          "description": "A stringified JSON array of the player's party Pokémon, including their moves and fainted status."
        }
      },
      "required": [
        "target_x",
        "target_y",
        "party_data"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef pathfinder(input_data, map_xml_string):\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    party_data_str = input_data['party_data']\n\n    try:\n        party_data = json.loads(party_data_str)\n    except json.JSONDecodeError:\n        print(f\"Error: Invalid JSON in party_data: {party_data_str}\")\n        return\n\n    tree = ET.fromstring(map_xml_string)\n    root = tree\n\n    player_pos = None\n    for row in root.findall('Row'):\n        for tile in row.findall('Tile'):\n            if tile.get('has-player') == 'true':\n                player_pos = (int(tile.get('id')), int(row.get('id')))\n                break\n        if player_pos:\n            break\n\n    if not player_pos:\n        print(\"Player position not found in map data.\")\n        return\n\n    start_node = player_pos\n    goal_node = (target_x, target_y)\n\n    def has_hm(party, hm_name):\n        for pokemon in party:\n            if not pokemon.get('is_fainted'):\n                if any(move.upper() == hm_name.upper() for move in pokemon.get('moves', [])):\n                    return True\n        return False\n\n    can_surf = has_hm(party_data, 'SURF')\n\n    def get_tile(x, y):\n        row_str = f\".//Row[@id='{y}']\"\n        tile_str = f\".//Tile[@id='{x}']\"\n        row = root.find(row_str)\n        if row is not None:\n            return row.find(tile_str)\n        return None\n\n    def is_walkable(x, y, from_x, from_y):\n        tile = get_tile(x, y)\n        if tile is None or tile.get('seen') == 'false':\n            return False\n        \n        obj = tile.find('Object')\n        if obj is not None and obj.get('id-name') != 'PIKACHU':\n            return False\n\n        tile_type = tile.get('type')\n        if tile_type is None:\n            return False\n\n        if tile_type in ['impassable', 'boulder_barrier', 'closed_gate']:\n            return False\n        \n        from_tile = get_tile(from_x, from_y)\n        from_tile_type = from_tile.get('type') if from_tile is not None else None\n\n        if tile_type == 'ledge':\n            return from_y < y\n\n        if tile_type == 'steps':\n            return from_tile_type in ['ground', 'elevated_ground', 'steps']\n\n        if from_tile_type == 'steps':\n            return tile_type in ['ground', 'elevated_ground']\n\n        if tile_type == 'water':\n            return can_surf\n\n        walkable_types = ['ground', 'elevated_ground', 'grass', 'cleared_boulder_barrier', 'open_gate', 'gate_offscreen', 'ladder_up', 'ladder_down', 'teleport', 'hole', 'spinner_stop']\n        return tile_type in walkable_types or 'spinner' in tile_type\n\n    potential_goals = []\n    if is_walkable(goal_node[0], goal_node[1], goal_node[0], goal_node[1]):\n        potential_goals.append(goal_node)\n    else:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (goal_node[0] + dx, goal_node[1] + dy)\n            if get_tile(neighbor[0], neighbor[1]) is not None and is_walkable(neighbor[0], neighbor[1], goal_node[0], goal_node[1]):\n                potential_goals.append(neighbor)\n\n    if not potential_goals:\n        print(\"No path found to the goal or any adjacent tile.\")\n        return\n\n    # Find the path to the closest potential goal\n    final_path = None\n    for goal in potential_goals:\n        open_set = []\n        heapq.heappush(open_set, (0, start_node))\n        came_from = {}\n        g_score = {start_node: 0}\n        f_score = {start_node: abs(start_node[0] - goal[0]) + abs(start_node[1] - goal[1])}\n\n        while open_set:\n            _, current = heapq.heappop(open_set)\n\n            if current == goal:\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(start_node)\n                path.reverse()\n                if final_path is None or len(path) < len(final_path):\n                    final_path = path\n                break\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                neighbor = (current[0] + dx, current[1] + dy)\n                \n                if not is_walkable(neighbor[0], neighbor[1], current[0], current[1]):\n                    continue\n\n                tentative_g_score = g_score[current] + 1\n\n                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = tentative_g_score + (abs(neighbor[0] - goal[0]) + abs(neighbor[1] - goal[1]))\n                    if neighbor not in [i[1] for i in open_set]:\n                        heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    if final_path:\n        buttons = []\n        for i in range(len(final_path) - 1):\n            x1, y1 = final_path[i]\n            x2, y2 = final_path[i+1]\n            if x2 > x1: buttons.append('Right')\n            elif x2 < x1: buttons.append('Left')\n            elif y2 > y1: buttons.append('Down')\n            elif y2 < y1: buttons.append('Up')\n        print(buttons)\n    else:\n        print(\"No path found.\")\n"
  },
  "spinner_maze_solver": {
    "description": "Finds the shortest path in a spinner maze. It parses the map_xml_string, builds a graph including spinner traversals, and uses A* to find the path from the player's position to a target coordinate. Handles impassable targets by pathing to an adjacent tile.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\ndef spinner_maze_solver(input_data, map_xml_string):\n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n        root = ET.fromstring(map_xml_string)\n    except (ValueError, ET.ParseError):\n        return 'Error: Invalid input or map data.'\n\n    tile_map = {}\n    player_pos = None\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            has_obj = tile_elem.find('Object') is not None\n            obj_is_pikachu = False\n            if has_obj:\n                obj_elem = tile_elem.find('Object')\n                if obj_elem.get('id-name') == 'Pikachu':\n                    obj_is_pikachu = True\n            \n            spinner_info = tile_elem.find('Spinner')\n            spinner_direction = spinner_info.get('direction') if spinner_info is not None else None\n            tile_map[(x, y)] = {'type': tile_type, 'has_obj': has_obj, 'obj_is_pikachu': obj_is_pikachu, 'spinner': spinner_direction}\n\n            if tile_elem.find('Player') is not None:\n                player_pos = (x, y)\n\n    if not player_pos:\n        return 'Error: Player position not found.'\n\n    def is_walkable(coord, ignore_spinner=False):\n        if coord not in tile_map: return False\n        tile = tile_map[coord]\n        if tile['has_obj'] and not tile['obj_is_pikachu']: return False\n        walkable_types = ['ground', 'grass', 'steps', 'cleared_boulder_barrier', 'open_gate', 'gate_offscreen', 'teleport', 'ladder_up', 'ladder_down', 'spinner_stop']\n        if not ignore_spinner and tile['spinner']:\n             walkable_types.extend(['spinner_up', 'spinner_down', 'spinner_left', 'spinner_right'])\n        return tile['type'] in walkable_types\n\n    def get_spinner_destination(start_coord):\n        x, y = start_coord\n        path = [start_coord]\n        visited_spinners = {start_coord}\n        while True:\n            if (x, y) not in tile_map or not tile_map[(x, y)]['spinner']:\n                return (x, y), path\n            \n            direction = tile_map[(x, y)]['spinner']\n            if direction == 'up': y -= 1\n            elif direction == 'down': y += 1\n            elif direction == 'left': x -= 1\n            elif direction == 'right': x += 1\n            \n            if (x, y) in visited_spinners: return None, None # Infinite loop\n            visited_spinners.add((x, y))\n            path.append((x,y))\n            \n            if not (1 <= x <= width and 1 <= y <= height):\n                 return None, None # Out of bounds\n\n    target_node = (target_x, target_y)\n    is_target_impassable = not is_walkable(target_node, ignore_spinner=True)\n\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    open_set = [(0, player_pos)]\n    came_from = {}\n    g_score = {player_pos: 0}\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if not is_target_impassable and current == target_node:\n            break\n        if is_target_impassable and heuristic(current, target_node) == 1 and is_walkable(current):\n            break\n\n        # Standard moves\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not is_walkable(neighbor): continue\n\n            tentative_g_score = g_score[current] + 1\n            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                g_score[neighbor] = tentative_g_score\n                f_score = tentative_g_score + heuristic(neighbor, target_node)\n                heapq.heappush(open_set, (f_score, neighbor))\n                came_from[neighbor] = current\n\n        # Spinner move\n        if tile_map[current]['spinner']:\n            dest, spin_path = get_spinner_destination(current)\n            if dest and is_walkable(dest):\n                tentative_g_score = g_score[current] + len(spin_path) # Cost is path length\n                if dest not in g_score or tentative_g_score < g_score[dest]:\n                    g_score[dest] = tentative_g_score\n                    f_score = tentative_g_score + heuristic(dest, target_node)\n                    heapq.heappush(open_set, (f_score, dest))\n                    came_from[dest] = current # The start of the spin sequence\n\n    else:\n        return 'No path found.'\n\n    # Reconstruct path\n    path = []\n    temp_current = current\n    while temp_current in came_from:\n        path.append(temp_current)\n        temp_current = came_from[temp_current]\n    path.append(player_pos)\n    path.reverse()\n    \n    # Expand spinner sequences in the final path\n    final_path = []\n    for i in range(len(path) - 1):\n        final_path.append(path[i])\n        if tile_map[path[i]]['spinner'] and came_from.get(path[i+1]) == path[i]:\n            _, spin_path = get_spinner_destination(path[i])\n            # Exclude start and end as they are already in the main path\n            if spin_path and len(spin_path) > 2:\n                final_path.extend(spin_path[1:-1])\n    final_path.append(path[-1])\n\n    return final_path\n\nprint(spinner_maze_solver(input_data, map_xml_string))"
  }
}