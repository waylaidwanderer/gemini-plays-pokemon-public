{
  "get_reachable_unseen_tiles": {
    "description": "Finds all unseen tiles that are directly adjacent to reachable, passable tiles on the current map. Returns a JSON array of coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef run():\n    try:\n        root = ET.fromstring(map_xml_string)\n        player_pos = None\n        grid = {}\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                if tile.find('Player') is not None:\n                    player_pos = (x, y)\n                grid[(x, y)] = {\n                    'type': tile.attrib['type'],\n                    'seen': tile.attrib['seen'] == 'true',\n                    'has_object': tile.attrib.get('has-object') == 'true',\n                    'is_warp': tile.attrib.get('is-warp') == 'true'\n                }\n        \n        if not player_pos:\n            print(\"Error: Player pos not found.\")\n            return\n\n        passable_types = ['FLOOR', 'TALL_GRASS', 'LONG_GRASS', 'WARP_CARPET', 'WATER', 'ICE', 'LADDER', 'PIT']\n        \n        reachable = set()\n        queue = deque([player_pos])\n        visited = {player_pos}\n\n        while queue:\n            cx, cy = queue.popleft()\n            reachable.add((cx, cy))\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = cx + dx, cy + dy\n                if (nx, ny) in grid and (nx, ny) not in visited:\n                    tile = grid[(nx, ny)]\n                    if tile['seen'] and tile['type'] in passable_types and not tile['has_object'] and not tile['is_warp']:\n                        visited.add((nx, ny))\n                        queue.append((nx, ny))\n\n        unseen_reachable = set()\n        for rx, ry in reachable:\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = rx + dx, ry + dy\n                if (nx, ny) in grid and not grid[(nx, ny)]['seen']:\n                    unseen_reachable.add((nx, ny))\n\n        print(json.dumps(sorted(list(unseen_reachable))))\n    except Exception as e:\n        print(f\"Error: {str(e)}\")\n\nrun()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T06:20:54.963Z",
        "action_counter": 27975
      },
      {
        "commit_message": "Fixed the tool to execute the logic and print the result properly. Removed function wrapping to ensure execution in the harness environment.",
        "timestamp": "2025-12-28T06:21:58.588Z",
        "action_counter": 27977
      },
      {
        "commit_message": "Added 'ICE' and 'WARP_CARPET_DOWN' to passable types for better exploration.",
        "timestamp": "2025-12-28T07:02:21.682Z",
        "action_counter": 28055
      },
      {
        "commit_message": "Updating exploration tool to find reachable unseen tiles.",
        "timestamp": "2025-12-28T09:40:39.023Z",
        "action_counter": 28377
      },
      {
        "commit_message": "Refining exploration tool to accurately identify reachable unseen tiles from the current player position.",
        "timestamp": "2025-12-28T09:41:08.853Z",
        "action_counter": 28378
      }
    ]
  },
  "solve_ice_puzzle_v1_reusable": {
    "description": "Calculates a path through ice sliding tiles using the global map_xml_string. Returns a JSON array of button presses.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "type": "boolean"
        },
        "extra_obstacles": {
          "items": {
            "properties": {
              "x": {
                "type": "integer"
              },
              "y": {
                "type": "integer"
              }
            },
            "required": [
              "x",
              "y"
            ],
            "type": "object"
          },
          "type": "array"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y",
        "autopress_buttons"
      ],
      "type": "object"
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport sys\n\ndef solve():\n    try:\n        input_data = json.loads(sys.argv[1])\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n        extra_obstacles = input_data.get('extra_obstacles', [])\n    except (IndexError, ValueError, KeyError, json.JSONDecodeError):\n        print(json.dumps([]))\n        return\n\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    passable_types = {'FLOOR', 'ICE', 'LADDER', 'WARP', 'STAIRS', 'DOOR', 'CAVE'}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            is_warp = tile.attrib.get('is-warp') == 'true'\n            has_obj = tile.attrib.get('has-object') == 'true'\n            is_passable = t_type in passable_types and not has_obj\n            grid[(x, y)] = {'passable': is_passable, 'type': t_type, 'warp': is_warp}\n            \n    for obs in extra_obstacles:\n        ox, oy = int(obs['x']), int(obs['y'])\n        if (ox, oy) in grid:\n            grid[(ox, oy)]['passable'] = False\n\n    queue = [((start_x, start_y), [])]\n    visited = {(start_x, start_y)}\n    \n    while queue:\n        (curr_x, curr_y), path = queue.pop(0)\n        \n        if (curr_x, curr_y) == (target_x, target_y):\n            print(json.dumps(path))\n            return\n            \n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = curr_x + dx, curr_y + dy\n            if (nx, ny) not in grid or not grid[(nx, ny)]['passable']: continue\n            \n            # Slide\n            sx, sy = curr_x, curr_y\n            while True:\n                tx, ty = sx + dx, sy + dy\n                if (tx, ty) not in grid or not grid[(tx, ty)]['passable']: break\n                \n                sx, sy = tx, ty\n                # Stop if not ICE\n                if grid[(sx, sy)]['type'] != 'ICE': break\n                # Stop if Warp\n                if grid[(sx, sy)]['warp']: break\n            \n            if (sx, sy) not in visited:\n                visited.add((sx, sy))\n                queue.append(((sx, sy), path + [btn]))\n    print(json.dumps([]))\n\nsolve()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T11:43:15.128Z",
        "action_counter": 28591
      },
      {
        "commit_message": "Refined ice puzzle solver to treat warps (pits/ladders) and non-ice tiles as stopping points. Added robust input handling.",
        "timestamp": "2025-12-28T13:00:13.449Z",
        "action_counter": 28714
      },
      {
        "commit_message": "Improved traversability check to include all passable tile types and exclude VOID, WALL, and objects. Refined sliding logic for warps and non-ice tiles.",
        "timestamp": "2025-12-28T13:02:07.116Z",
        "action_counter": 28716
      }
    ]
  },
  "activate_strength_gneiss": {
    "description": "Robustly activates Strength using GNEISS (5th slot). Resets menu cursors.",
    "input_schema": {
      "type": "object"
    },
    "python_script": "import json\n# 1. Close any open menus\n# 2. Open Start menu\n# 3. Reset Start cursor to POKEDEX (Up 10)\n# 4. Move to POKEMON (Down 1)\n# 5. Enter Party (A)\n# 6. Reset Party cursor to Slot 1 (Up 6)\n# 7. Select GNEISS in Slot 5 (Down 4)\n# 8. Select (A)\n# 9. Select Strength (A)\n# 10. Close menus (B x3)\n# 11. Attempt Push (Up)\nbtns = [\"B\"]*3 + [\"Start\", \"sleep 500\"] + [\"Up\"]*10 + [\"Down\", \"A\", \"sleep 500\"] + [\"Up\"]*6 + [\"Down\"]*4 + [\"A\", \"sleep 500\", \"A\", \"sleep 1000\"] + [\"B\"]*3 + [\"Up\"]\nprint(json.dumps(btns))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T12:43:17.561Z",
        "action_counter": 28688
      },
      {
        "commit_message": "Improved robustness by ensuring the cursor starts at the top of the menu.",
        "timestamp": "2025-12-28T13:04:33.329Z",
        "action_counter": 28718
      },
      {
        "commit_message": "Fixed activate_strength_gneiss to assume cursor is on PACK and move to POKEMON.",
        "timestamp": "2025-12-28T13:08:22.104Z",
        "action_counter": 28722
      },
      {
        "commit_message": "Refined activate_strength_gneiss to be fully robust by resetting both Start and Party menu cursors. Added sleeps for menu stability.",
        "timestamp": "2025-12-28T13:16:48.667Z",
        "action_counter": 28727
      },
      {
        "commit_message": "Refined activate_strength_gneiss to be fully robust by closing any open menus, resetting the Start menu cursor to POKEDEX, and resetting the Party menu cursor to Slot 1. Added an 'Up' press at the end to immediately attempt a boulder push.",
        "timestamp": "2025-12-28T13:18:22.602Z",
        "action_counter": 28729
      }
    ]
  }
}