{
  "object_finder": {
    "description": "Finds a specific map object by its ID and returns its coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "object_id": {
          "type": "string"
        }
      },
      "required": [
        "object_id"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntarget_id = input_data['object_id']\nroot = ET.fromstring(map_xml_string)\nfound = False\nfor row in root.findall('Row'):\n    y = row.get('id')\n    for tile in row.findall('Tile'):\n        x = tile.get('id')\n        for obj in tile.findall('Object'):\n            if obj.get('id') == target_id:\n                print(json.dumps({'x': x, 'y': y}))\n                found = True\n                break\n        if found:\n            break\n    if found:\n        break\n\nif not found:\n    print(json.dumps({'error': 'Object not found on screen.'}))"
  },
  "warp_scanner": {
    "description": "Scans the current map XML and returns the coordinates of all warp tiles that do not have a map marker.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    unmarked_warps = []\n    for row_elem in root.findall('Row'):\n        for tile_elem in row_elem.findall('Tile'):\n            is_warp = tile_elem.find('Warp') is not None\n            has_marker = tile_elem.find('Marker') is not None\n            \n            if is_warp and not has_marker:\n                x = int(tile_elem.get('id'))\n                y = int(row_elem.get('id'))\n                unmarked_warps.append([x, y])\n                \n    print(json.dumps({\"unmarked_warps\": unmarked_warps, \"error\": None}))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({\"unmarked_warps\": [], \"error\": f\"An exception occurred: {str(e)}\\n{traceback.format_exc()}\"}))"
  },
  "pathfinder": {
    "description": "A* pathfinding tool that finds the shortest path between two points on the current map. It takes start and end coordinates, a list of traversable tile types, and returns a sequence of button presses to follow the path. It has improved logic to handle one-way ledges.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "traversable_tiles": {
          "type": "string",
          "description": "A comma-separated string of tile types that are considered traversable."
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "traversable_tiles"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\ndef to_buttons(path):\n    buttons = []\n    for i in range(len(path) - 1):\n        current_pos = path[i]\n        next_pos = path[i+1]\n        if next_pos[0] > current_pos[0]:\n            buttons.append(\"Right\")\n        elif next_pos[0] < current_pos[0]:\n            buttons.append(\"Left\")\n        elif next_pos[1] > current_pos[1]:\n            buttons.append(\"Down\")\n        elif next_pos[1] < current_pos[1]:\n            buttons.append(\"Up\")\n    return buttons\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    traversable_tiles = {tile.strip() for tile in input_data['traversable_tiles'].split(',')}\n\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    tile_data = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id'])\n            tile_type = tile_elem.attrib['type']\n            has_object = tile_elem.attrib.get('has-object') == 'true'\n            tile_data[(x, y)] = {'type': tile_type, 'has_object': has_object}\n\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n    \n    open_set = []\n    heapq.heappush(open_set, (0, start_node))\n    came_from = {}\n    g_score = {start_node: 0}\n    f_score = {start_node: abs(start_node[0] - end_node[0]) + abs(start_node[1] - end_node[1])}\n\n    path_found = False\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == end_node:\n            path = []\n            temp = current\n            while temp in came_from:\n                path.append(temp)\n                temp = came_from[temp]\n            path.append(start_node)\n            path.reverse()\n            buttons = to_buttons(path)\n            print(f'Path found: {buttons}')\n            path_found = True\n            break\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n\n            if not (1 <= neighbor[0] <= width and 1 <= neighbor[1] <= height):\n                continue\n\n            neighbor_info = tile_data.get(neighbor, {'type': 'WALL', 'has_object': False})\n            current_info = tile_data.get(current, {'type': 'WALL', 'has_object': False})\n\n            is_start_or_end = neighbor == end_node or current == start_node\n            if neighbor_info['type'] not in traversable_tiles or (neighbor_info['has_object'] and not is_start_or_end):\n                continue\n\n            # Ledge logic\n            if neighbor_info['type'] == 'FLOOR_UP_WALL' and current[1] < neighbor[1]: # Trying to move DOWN onto a FLOOR_UP_WALL\n                continue\n            if current_info['type'] == 'FLOOR_UP_WALL' and current[1] > neighbor[1]: # Trying to move UP off a FLOOR_UP_WALL\n                continue\n            if neighbor_info['type'] == 'LEDGE_HOP_RIGHT' and dx != 1:\n                continue\n            if neighbor_info['type'] == 'LEDGE_HOP_LEFT' and dx != -1:\n                continue\n            if neighbor_info['type'] == 'LEDGE_HOP_DOWN' and dy != 1:\n                continue\n\n            tentative_g_score = g_score.get(current, float('inf')) + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + abs(neighbor[0] - end_node[0]) + abs(neighbor[1] - end_node[1])\n                if neighbor not in [i[1] for i in open_set]:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    \n    if not path_found:\n        print(\"No path found.\")\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")"
  },
  "jigsaw_solver": {
    "description": "Solves the 16-piece Ruins of Alph jigsaw puzzle. It takes the current puzzle grid string and cursor position as input and returns a list of button presses to solve it.",
    "input_schema": {
      "type": "object",
      "properties": {
        "puzzle_grid": {
          "type": "string",
          "description": "A string representation of the current puzzle grid, with piece IDs and empty slots."
        },
        "cursor_x": {
          "type": "string"
        },
        "cursor_y": {
          "type": "string"
        }
      },
      "required": [
        "puzzle_grid",
        "cursor_x",
        "cursor_y"
      ]
    },
    "python_script": "import re\n\ndef parse_grid(grid_string):\n    pieces = {}\n    regex = 'Piece (\\\\d+) \\\\((\\\\d+),(\\\\d+)\\\\)|Empty \\\\((\\\\d+),(\\\\d+)\\\\)'\n    for match in re.finditer(regex, grid_string):\n        if match.group(1):\n            piece_id, x, y = int(match.group(1)), int(match.group(2)), int(match.group(3))\n            pieces[(x, y)] = piece_id\n        else:\n            x, y = int(match.group(4)), int(match.group(5))\n            pieces[(x, y)] = 0\n    return pieces\n\ndef get_solution_map():\n    return {\n        (1,1): 5, (2,1): 1, (3,1): 10, (4,1): 8,\n        (1,2): 14, (2,2): 6, (3,2): 13, (4,2): 11,\n        (1,3): 9, (2,3): 2, (3,3): 15, (4,3): 3,\n        (1,4): 16, (2,4): 4, (3,4): 7, (4,4): 12\n    }\n\ndef find_piece_pos(grid, piece_id):\n    for pos, pid in grid.items():\n        if pid == piece_id:\n            return pos\n    return None\n\ndef plan_move_buttons(start_pos, end_pos):\n    moves = []\n    dx = end_pos[0] - start_pos[0]\n    dy = end_pos[1] - start_pos[1]\n    if dx > 0: moves.extend(['Right'] * dx)\n    if dx < 0: moves.extend(['Left'] * abs(dx))\n    if dy > 0: moves.extend(['Down'] * dy)\n    if dy < 0: moves.extend(['Up'] * abs(dy))\n    return moves\n\ntry:\n    grid_string = input_data['puzzle_grid']\n    cursor_x = int(input_data['cursor_x'])\n    cursor_y = int(input_data['cursor_y'])\n    print(f'DEBUG: Received grid_string: {grid_string}')\n    print(f'DEBUG: Received cursor: ({cursor_x}, {cursor_y})')\n    \n    current_cursor_pos = (cursor_x, cursor_y)\n    current_grid = parse_grid(grid_string)\n    print(f'DEBUG: Parsed grid: {current_grid}')\n    \n    solution_map = get_solution_map()\n    actions = []\n    sim_grid = current_grid.copy()\n\n    # First, move any pieces that are in the solved area but are incorrect\n    misplaced_in_solution_area = {}\n    for target_pos, correct_pid in solution_map.items():\n        pid_at_target = sim_grid.get(target_pos)\n        if pid_at_target is not None and pid_at_target != 0 and pid_at_target != correct_pid:\n            misplaced_in_solution_area[target_pos] = pid_at_target\n\n    if misplaced_in_solution_area:\n        empty_border_spots = [pos for pos, pid in sim_grid.items() if pid == 0 and (pos[0] in [0, 5] or pos[1] in [0, 5])]\n        for start_pos, piece_id in misplaced_in_solution_area.items():\n            if not empty_border_spots:\n                break\n            end_pos = empty_border_spots.pop(0)\n            # Plan move\n            actions.extend(plan_move_buttons(current_cursor_pos, start_pos))\n            current_cursor_pos = start_pos\n            actions.append('A')\n            actions.extend(plan_move_buttons(current_cursor_pos, end_pos))\n            current_cursor_pos = end_pos\n            actions.append('A')\n            # Update sim_grid\n            sim_grid[end_pos] = piece_id\n            sim_grid[start_pos] = 0\n\n    # Now, place all the correct pieces\n    for target_pos, correct_pid in solution_map.items():\n        if sim_grid.get(target_pos) == correct_pid:\n            continue\n        \n        piece_current_pos = find_piece_pos(sim_grid, correct_pid)\n        if piece_current_pos is None:\n            continue\n\n        # Plan move to pick up piece\n        actions.extend(plan_move_buttons(current_cursor_pos, piece_current_pos))\n        current_cursor_pos = piece_current_pos\n        actions.append('A')\n\n        # Plan move to place piece\n        actions.extend(plan_move_buttons(current_cursor_pos, target_pos))\n        current_cursor_pos = target_pos\n        actions.append('A')\n\n        # Update simulation grid for next iteration\n        sim_grid[target_pos] = correct_pid\n        sim_grid[piece_current_pos] = 0\n\n    print(str(actions))\n\nexcept Exception as e:\n    print(f'An error occurred: {e}')"
  }
}