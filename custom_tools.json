{
  "maze_solver": {
    "description": "Solves invisible arrow tile mazes. It simulates movement from a starting point and explores the maze using a Breadth-First Search, returning the sequence of directional inputs to reach a target coordinate. It requires the map XML and a list of known arrow tile behaviors.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "arrow_tiles_json": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "arrow_tiles_json"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.attrib['width'])\nheight = int(root.attrib['height'])\n\ngrid = {}\nimpassable = set()\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.attrib['id'])\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.attrib['id'])\n        grid[(x, y)] = tile_elem.attrib['type']\n        if grid[(x, y)] in ['WALL', 'COUNTER', 'PC', 'BOOKSHELF'] or tile_elem.find('Object') is not None:\n            impassable.add((x, y))\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\narrow_tiles = json.loads(input_data['arrow_tiles_json'])\n\narrow_map = { (t['start_x'], t['start_y']): (t['end_x'], t['end_y']) for t in arrow_tiles }\n\nqueue = deque([((start_x, start_y), [])])\nvisited = set([(start_x, start_y)])\n\nwhile queue:\n    (x, y), path = queue.popleft()\n\n    if x == end_x and y == end_y:\n        print(json.dumps(path))\n        exit()\n\n    # Check arrow tile\n    if (x, y) in arrow_map:\n        next_x, next_y = arrow_map[(x, y)]\n        if (next_x, next_y) not in visited:\n            visited.add((next_x, next_y))\n            new_path = path + [f\"Step on arrow at ({x}, {y})\"]\n            queue.append(((next_x, next_y), new_path))\n        continue\n\n    # Standard movement\n    for move, (dx, dy) in {'Up': (0, -1), 'Down': (0, 1), 'Left': (-1, 0), 'Right': (1, 0)}.items():\n        nx, ny = x + dx, y + dy\n        if (nx, ny) not in impassable and (nx, ny) not in visited:\n            visited.add((nx, ny))\n            new_path = path + [move]\n            queue.append(((nx, ny), new_path))\n\nprint(json.dumps([])) # No path found"
  },
  "puzzle_solver": {
    "description": "Solves Sokoban-style boulder puzzles. Takes optional start coordinates, but requires goal coordinates for the final boulder position. It uses a Breadth-First Search algorithm to find the optimal sequence of moves.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer",
          "nullable": true
        },
        "start_y": {
          "type": "integer",
          "nullable": true
        },
        "goal_x": {
          "type": "integer"
        },
        "goal_y": {
          "type": "integer"
        }
      },
      "required": [
        "goal_x",
        "goal_y"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\n\n# Parse map data\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\n\nwalls = set()\nboulders = []\nplayer_start = None\n\nfor r_idx, row_elem in enumerate(root.findall('Row')):\n    y = r_idx + 1\n    for t_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n        x = t_idx + 1\n        tile_type = tile_elem.get('type')\n        if tile_type == 'WALL':\n            walls.add((x, y))\n        if tile_elem.find('Object[@id-name=\"BOULDER\"]') is not None:\n            boulders.append((x, y))\n        if tile_elem.find('Player') is not None:\n            player_start = (x, y)\n\n# Override start position if provided\nif 'start_x' in input_data and input_data['start_x'] is not None:\n    player_start = (int(input_data['start_x']), int(input_data['start_y']))\n\ngoal_pos = (int(input_data['goal_x']), int(input_data['goal_y']))\n\n# --- BFS Solver ---\ninitial_state = (player_start, tuple(sorted(boulders)))\nqueue = collections.deque([(initial_state, [])])\nvisited = {initial_state}\n\npath_found = False\nwhile queue:\n    (current_player, current_boulders), path = queue.popleft()\n\n    # Check for goal state\n    if goal_pos in current_boulders:\n        print(f\"Solution found: {path}\")\n        path_found = True\n        break\n\n    # Explore neighbors\n    for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n        next_player_pos = (current_player[0] + dx, current_player[1] + dy)\n\n        # Simple move (no push)\n        if next_player_pos not in walls and next_player_pos not in current_boulders:\n            new_state = (next_player_pos, current_boulders)\n            if new_state not in visited:\n                visited.add(new_state)\n                queue.append((new_state, path + [move]))\n            continue\n\n        # Boulder push\n        if next_player_pos in current_boulders:\n            boulder_to_push = next_player_pos\n            next_boulder_pos = (boulder_to_push[0] + dx, boulder_to_push[1] + dy)\n\n            if next_boulder_pos not in walls and next_boulder_pos not in current_boulders:\n                new_boulders = list(current_boulders)\n                new_boulders.remove(boulder_to_push)\n                new_boulders.append(next_boulder_pos)\n                new_boulders_tuple = tuple(sorted(new_boulders))\n                \n                new_state = (next_player_pos, new_boulders_tuple)\n                if new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, path + [f\"Push {move}\"])) \n\nif not path_found:\n    print(\"No solution found.\")"
  },
  "maze_mapper_v2": {
    "description": "Systematically explores a grid-based maze from a starting point. This version persists its own state of visited coordinates and a queue by passing them in and out. Use the 'reset' action with start coordinates to clear the memory and begin a new maze. Use the 'explore' action to get the next tile, passing in the state from the previous call.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "action": {
          "type": "string",
          "enum": [
            "explore",
            "reset"
          ]
        },
        "visited": {
          "type": "array",
          "items": {
            "type": "array",
            "items": {
              "type": "integer"
            }
          }
        },
        "queue": {
          "type": "array",
          "items": {
            "type": "array",
            "items": {
              "type": "integer"
            }
          }
        }
      },
      "required": [
        "action"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\n# 1. Load state from input_data. Default to empty lists if not provided.\ninput_visited_str = input_data.get('visited', '[]')\ninput_queue_str = input_data.get('queue', '[]')\n\ninput_visited = json.loads(input_visited_str)\ninput_queue = json.loads(input_queue_str)\n\n# 2. Convert loaded lists into the required Python data structures.\n# JSON converts tuples to lists, so we must convert them back to tuples for the set.\nvisited = set(tuple(item) for item in input_visited)\nqueue = deque(tuple(item) for item in input_queue)\n\naction = input_data.get('action')\n\nif action == 'reset':\n    visited.clear()\n    queue.clear()\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    start_coord = (start_x, start_y)\n    \n    visited.add(start_coord)\n    queue.append(start_coord)\n    \n    # 3. Return the initial state.\n    output_state = {\n        'status': 'Maze mapper reset and seeded.',\n        'visited': list(visited),\n        'queue': list(queue)\n    }\n    print(json.dumps(output_state))\n    exit()\n\n# If not resetting, it's an 'explore' action.\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.attrib['width'])\nheight = int(root.attrib['height'])\n\nimpassable_tiles = set()\nfor row in root.findall('Row'):\n    y = int(row.attrib['id'])\n    for tile in row.findall('Tile'):\n        x = int(tile.attrib['id'])\n        tile_type = tile.attrib['type']\n        if tile_type in ['WALL', 'COUNTER'] or tile.find('Object') is not None:\n            impassable_tiles.add((x, y))\n\nif not queue:\n    # This now correctly signifies that the exploration is complete.\n    output_error = {\n        'error': 'Queue is empty. The maze is fully explored or no path exists.',\n        'visited': list(visited),\n        'queue': list(queue)\n    }\n    print(json.dumps(output_error))\n    exit()\n\n# Pop a tile to explore.\ncurrent_x, current_y = queue.popleft()\n\n# Find its neighbors and add them to the queue for next time.\nfor dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n    next_x, next_y = current_x + dx, current_y + dy\n\n    if not (1 <= next_x <= width and 1 <= next_y <= height):\n        continue\n\n    neighbor_coord = (next_x, next_y)\n\n    if neighbor_coord not in visited and neighbor_coord not in impassable_tiles:\n        visited.add(neighbor_coord)\n        queue.append(neighbor_coord)\n\n# 3. Return the explored tile location and the updated state for the next call.\noutput_data = {\n    'x': current_x,\n    'y': current_y,\n    'visited': sorted(list(visited)), # Convert to a sorted list for consistent output\n    'queue': list(queue)             # Convert deque to list for JSON serialization\n}\nprint(json.dumps(output_data))\n"
  },
  "bfs_pathfinder": {
    "description": "A simple but robust pathfinding tool using Breadth-First Search. Finds a path from a start to an end coordinate, avoiding impassable tiles. Less efficient than A* but more reliable and less prone to implementation bugs.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "can_surf": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.attrib['width'])\nheight = int(root.attrib['height'])\nimpassable_tiles = set()\n\ncan_surf = str(input_data.get('can_surf', 'false')).lower() == 'true'\n\nfor row in root.findall('Row'):\n    y = int(row.attrib['id']) - 1\n    for tile in row.findall('Tile'):\n        x = int(tile.attrib['id']) - 1\n        tile_type = tile.attrib['type']\n        if tile_type in ['WALL', 'COUNTER', 'MART_SHELF', 'PC', 'BOOKSHELF', 'HEADBUTT_TREE', 'CUT_TREE', 'TV', 'TOWN_MAP', 'WINDOW', 'ROCK', 'BUOY', 'VOID']:\n            impassable_tiles.add((x, y))\n        if not can_surf and tile_type in ['WATER', 'SEA']:\n            impassable_tiles.add((x, y))\n        if tile.find('Object') is not None:\n            impassable_tiles.add((x, y))\n\nstart_x = int(input_data['start_x']) - 1\nstart_y = int(input_data['start_y']) - 1\nend_x = int(input_data['end_x']) - 1\nend_y = int(input_data['end_y']) - 1\n\nif (start_x, start_y) in impassable_tiles:\n    print('No path found')\n    exit()\n\nqueue = deque([[(start_x, start_y)]])\nvisited = set([(start_x, start_y)])\n\ngoal_coords = set()\nif (end_x, end_y) not in impassable_tiles:\n    goal_coords.add((end_x, end_y))\nelse:\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        adj_x, adj_y = end_x + dx, end_y + dy\n        if 0 <= adj_x < width and 0 <= adj_y < height and (adj_x, adj_y) not in impassable_tiles:\n            goal_coords.add((adj_x, adj_y))\n\nif not goal_coords:\n    print('No path found')\n    exit()\n\nwhile queue:\n    path = queue.popleft()\n    x, y = path[-1]\n\n    if (x, y) in goal_coords:\n        output_path = []\n        for coord in path:\n            output_path.append({'x': coord[0] + 1, 'y': coord[1] + 1})\n        print(json.dumps(output_path))\n        exit()\n\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        neighbor_x, neighbor_y = x + dx, y + dy\n\n        if 0 <= neighbor_x < width and 0 <= neighbor_y < height and (neighbor_x, neighbor_y) not in impassable_tiles and (neighbor_x, neighbor_y) not in visited:\n            visited.add((neighbor_x, neighbor_y))\n            new_path = list(path)\n            new_path.append((neighbor_x, neighbor_y))\n            queue.append(new_path)\n\nprint('No path found')"
  },
  "ice_puzzle_solver": {
    "description": "Solves ice-tile sliding puzzles by modeling the gym as a graph of FLOOR tiles. It uses a Breadth-First Search algorithm to find the optimal sequence of directional inputs to navigate from a starting coordinate to a target coordinate.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.attrib['width'])\nheight = int(root.attrib['height'])\n\nobstacles = set()\nfloor_tiles = set()\n\nfor row in root.findall('Row'):\n    y = int(row.attrib['id'])\n    for tile in row.findall('Tile'):\n        x = int(tile.attrib['id'])\n        if tile.attrib['type'] == 'FLOOR':\n            floor_tiles.add((x, y))\n        is_obstacle = False\n        if tile.attrib['type'] in ['WALL', 'ROCK']:\n            is_obstacle = True\n        if tile.find('Object') is not None:\n            is_obstacle = True\n        if is_obstacle:\n            obstacles.add((x, y))\n\nadj = {floor_tile: [] for floor_tile in floor_tiles}\n\nfor floor_tile in floor_tiles:\n    fx, fy = floor_tile\n    for move, (dx, dy) in {'Up': (0, -1), 'Down': (0, 1), 'Left': (-1, 0), 'Right': (1, 0)}.items():\n        start_slide_x, start_slide_y = fx + dx, fy + dy\n        if (start_slide_x, start_slide_y) in obstacles or not (1 <= start_slide_x <= width and 1 <= start_slide_y <= height):\n            continue\n\n        final_x, final_y = start_slide_x, start_slide_y\n        while True:\n            next_x, next_y = final_x + dx, final_y + dy\n            if not (1 <= next_x <= width and 1 <= next_y <= height):\n                break \n            if (next_x, next_y) in obstacles:\n                break \n            \n            final_x, final_y = next_x, next_y\n            \n            if (final_x, final_y) in floor_tiles:\n                break\n\n        if (final_x, final_y) in floor_tiles:\n            adj[floor_tile].append(((final_x, final_y), move))\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nstart_node = (start_x, start_y)\nend_node = (end_x, end_y)\n\nqueue = deque([(start_node, [])])\nvisited = {start_node}\n\nwhile queue:\n    current_node, path = queue.popleft()\n    if current_node == end_node:\n        print(json.dumps(path))\n        exit()\n\n    if current_node in adj:\n        for neighbor, move in adj[current_node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                new_path = path + [move]\n                queue.append((neighbor, new_path))\n\nprint('No path found')"
  }
}