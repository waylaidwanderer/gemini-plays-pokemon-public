{
  "battle_select_move": {
    "description": "Navigates the battle menu to select a specific move slot (1-4). Assumes the cursor is currently on 'FIGHT'. Resets cursor position to Top (Slot 1) before navigating to ensure accuracy. Menu is a Vertical List.",
    "input_schema": {
      "type": "object",
      "properties": {
        "move_slot": {
          "type": "integer",
          "enum": [
            1,
            2,
            3,
            4
          ],
          "description": "The move slot to select (1=Top, 2=Second, 3=Third, 4=Bottom)"
        },
        "autopress_buttons": {
          "type": "boolean",
          "description": "If true and the tool returns a list of buttons, they will be pressed automatically.",
          "default": false
        }
      },
      "required": [
        "move_slot",
        "autopress_buttons"
      ]
    },
    "python_script": "def run(input_data):\n    slot = input_data['move_slot']\n    buttons = [\"A\"] # Enter Fight\n    if slot == 2:\n        buttons.append(\"Down\")\n    elif slot == 3:\n        buttons.append(\"Down\")\n        buttons.append(\"Down\")\n    elif slot == 4:\n        buttons.append(\"Down\")\n        buttons.append(\"Down\")\n        buttons.append(\"Down\")\n    buttons.append(\"A\") # Select Move\n    print(f'{{\"buttons\": {buttons}, \"message\": \"Selected Move Slot {slot} (Assuming starting at Top)\"}}')",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-19T12:37:54.505Z",
        "action_counter": 4591
      },
      {
        "commit_message": "Updated logic for vertical list menu layout (1 column, 4 rows).",
        "timestamp": "2026-01-19T12:41:47.811Z",
        "action_counter": 4596
      },
      {
        "commit_message": "Fixing previous error: Added commit message. Tool for selecting battle moves reliably.",
        "timestamp": "2026-01-20T03:11:51.896Z",
        "action_counter": 5642
      }
    ]
  },
  "bfs_check_path": {
    "description": "Checks if a path exists between two points using BFS on the Mental Map. Returns True/False and the path length.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef check_path(start_x, start_y, target_x, target_y):\n    try:\n        # map_xml_string is injected into the environment\n        if 'map_xml_string' not in globals():\n            print(\"Error: map_xml_string not found in globals.\")\n            return\n\n        root = ET.fromstring(map_xml_string)\n        \n        # Parse map dimensions\n        width = int(root.attrib['width'])\n        height = int(root.attrib['height'])\n        \n        # Build grid of walkable tiles\n        walkable = set()\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                t_type = tile.attrib.get('type', 'unseen')\n                \n                # Define walkable types\n                # Excluding known walls/obstacles\n                # TYPE_2889: Tree/Wall\n                # TYPE_80fc: Wall/Roof?\n                # TYPE_5519: Cut Tree\n                # TYPE_fed7: Ledge (Usually one way, treating as obstacle for general BFS unless logic added)\n                # TYPE_c453: Ledge\n                if t_type not in ['TYPE_2889', 'TYPE_80fc', 'TYPE_5519', 'TYPE_fed7', 'TYPE_c453']: \n                    walkable.add((x, y))\n                    \n        start = (start_x, start_y)\n        target = (target_x, target_y)\n        \n        if start not in walkable:\n            print(f\"Start {start} is not walkable or is an obstacle.\")\n            # return # Attempt to path anyway if start is 'obstacle' (e.g. current pos on ledge)\n            \n        if target not in walkable:\n            print(f\"Target {target} is not walkable or is an obstacle.\")\n            return\n\n        queue = deque([(start, 0)])\n        visited = {start}\n        \n        while queue:\n            (curr_x, curr_y), dist = queue.popleft()\n            \n            if (curr_x, curr_y) == target:\n                print(f\"Path found! Distance: {dist}\")\n                return\n            \n            # Check neighbors (Up, Down, Left, Right)\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = curr_x + dx, curr_y + dy\n                \n                if (nx, ny) in walkable and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append(((nx, ny), dist + 1))\n                    \n        print(\"No path found.\")\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n\ncheck_path(start_x, start_y, target_x, target_y)",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T13:46:49.913Z",
        "action_counter": 1128
      },
      {
        "commit_message": "Initial definition of BFS pathfinding tool to check connectivity on the Mental Map.",
        "timestamp": "2026-01-17T18:35:27.285Z",
        "action_counter": 1502
      },
      {
        "commit_message": "Initial definition of BFS path checking tool to replace the broken connectivity tool.",
        "timestamp": "2026-01-17T21:09:57.634Z",
        "action_counter": 1713
      }
    ]
  },
  "check_path_connectivity": {
    "description": "Checks if a path exists between two coordinates using BFS on the Mental Map XML. Returns path length and steps if found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\n\nstart_x = input_data['start_x']\nstart_y = input_data['start_y']\ntarget_x = input_data['target_x']\ntarget_y = input_data['target_y']\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get(\"width\"))\n    height = int(root.get(\"height\"))\n    grid = {}\n    \n    for row in root.findall(\"Row\"):\n        y = int(row.get(\"id\"))\n        for tile in row.findall(\"Tile\"):\n            x = int(tile.get(\"id\"))\n            t_type = tile.get(\"type\")\n            grid[(x, y)] = t_type\n\n    start = (start_x, start_y)\n    target = (target_x, target_y)\n    \n    if start not in grid or target not in grid:\n        print(f\"Error: Coordinates out of bounds or not in map data.\")\n        exit()\n\n    queue = collections.deque([[start]])\n    visited = set([start])\n    \n    found = False\n    final_path = []\n    \n    # Simple passable check - assume anything not explicitly a known wall is passable for now\n    # This can be refined\n    WALL_TYPES = [\"TYPE_2889\", \"TYPE_80fc\", \"TYPE_5519\", \"TYPE_a336\", \"TYPE_fed7\"] \n    # Note: TYPE_c453 is ledge, handled as one-way usually, but for simple connectivity checks might treat as passable or blocked depending on direction. \n    # For this simple BFS, let's treat it as passable but risky, or just block it if we want strictness.\n    # Let's verify specific blocked types from notepad.\n    \n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n        \n        if (x, y) == target:\n            found = True\n            final_path = path\n            break\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < width and 0 <= ny < height:\n                if (nx, ny) not in visited:\n                    tile_type = grid.get((nx, ny), \"unseen\")\n                    if tile_type not in WALL_TYPES:\n                        visited.add((nx, ny))\n                        new_path = list(path)\n                        new_path.append((nx, ny))\n                        queue.append(new_path)\n\n    if found:\n        print(f\"Path found! Length: {len(final_path)}. Path: {final_path}\")\n    else:\n        print(\"No path found.\")\n\nexcept Exception as e:\n    print(f\"Error parsing map or finding path: {e}\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T04:38:25.635Z",
        "action_counter": 310
      },
      {
        "commit_message": "Fixed autopress_buttons support by returning JSON list of buttons.",
        "timestamp": "2026-01-17T05:14:56.870Z",
        "action_counter": 363
      },
      {
        "commit_message": "Initial definition of check_path_connectivity tool to help verify navigation paths.",
        "timestamp": "2026-01-17T19:59:31.235Z",
        "action_counter": 1608
      },
      {
        "commit_message": "Initial definition of check_path_connectivity tool for verifying paths on the mental map.",
        "timestamp": "2026-01-18T00:52:36.653Z",
        "action_counter": 2016
      }
    ]
  },
  "find_nearest_unseen": {
    "description": "Finds the 5 nearest 'unseen' tiles in the Mental Map to the current player position using Manhattan distance. Returns a list of coordinates sorted by distance.",
    "input_schema": {
      "type": "object",
      "properties": {
        "player_x": {
          "type": "integer"
        },
        "player_y": {
          "type": "integer"
        }
      },
      "required": [
        "player_x",
        "player_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ndef find_nearest_unseen(map_xml, p_x, p_y):\n    try:\n        root = ET.fromstring(map_xml)\n        unseen_tiles = []\n        for row in root.findall(\"Row\"):\n            r_id = int(row.get(\"id\"))\n            for tile in row.findall(\"Tile\"):\n                t_id = int(tile.get(\"id\"))\n                t_type = tile.get(\"type\")\n                if t_type == \"unseen\":\n                    dist = abs(p_x - t_id) + abs(p_y - r_id)\n                    unseen_tiles.append((dist, t_id, r_id))\n        \n        if not unseen_tiles:\n            print(\"[]\")\n            return\n\n        unseen_tiles.sort()\n        # Return list of dicts for JSON parsing\n        result = [{\"x\": t[1], \"y\": t[2], \"dist\": t[0]} for t in unseen_tiles[:5]]\n        print(json.dumps(result))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\np_x = input_data.get('player_x', 0)\np_y = input_data.get('player_y', 0)\nfind_nearest_unseen(map_xml_string, p_x, p_y)",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T05:16:24.634Z",
        "action_counter": 364
      },
      {
        "commit_message": "Initial definition of the find_nearest_unseen tool for fog-of-war clearing.",
        "timestamp": "2026-01-19T20:13:05.535Z",
        "action_counter": 5044
      }
    ]
  },
  "patrol_grass": {
    "description": "Moves the player Left and Right to search for wild Pokemon, and presses A to handle battle introductions.",
    "input_schema": {},
    "python_script": "import json\ncmds = [\"Left\", \"Right\", \"Left\", \"Right\", \"A\", \"A\", \"A\", \"A\"]\nprint(json.dumps(cmds))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T02:06:33.549Z",
        "action_counter": 93
      }
    ]
  },
  "scan_surroundings": {
    "description": "Scans the Mental Map around the player and returns the type and coordinates of nearby tiles. Useful for identifying walls, ledges, and navigable paths without walking into them.",
    "input_schema": {
      "type": "object",
      "properties": {
        "radius": {
          "type": "integer",
          "description": "The radius of tiles to scan around the player. Defaults to 2."
        }
      },
      "required": [
        "radius"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    player_pos = None\n    \n    # Find player position\n    for row in root.findall(\"Row\"):\n        for tile in row.findall(\"Tile\"):\n            if tile.find(\"Player\") is not None:\n                player_pos = (int(tile.get(\"id\")), int(row.get(\"id\")))\n                break\n        if player_pos: break\n\n    if not player_pos:\n        print(\"Error: Player not found in Mental Map.\")\n    else:\n        px, py = player_pos\n        radius = input_data.get('radius', 2)\n        map_id = root.get('id')\n        print(f\"Scanning radius {radius} around {player_pos} on map {map_id}:\")\n        \n        for y in range(py - radius, py + radius + 1):\n            row = root.find(f\"./Row[@id='{y}']\")\n            if row is not None:\n                row_str = \"\"\n                for x in range(px - radius, px + radius + 1):\n                    tile = row.find(f\"./Tile[@id='{x}']\")\n                    if tile is not None:\n                        t_type = tile.get(\"type\")\n                        row_str += f\"[{x},{y}: {t_type}] \"\n                    else:\n                        row_str += f\"[{x},{y}: N/A] \"\n                print(row_str)\n            else:\n                print(f\"Row {y} not found.\")\n\nexcept Exception as e:\n    print(f\"Error executing scan_surroundings: {e}\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T03:27:06.196Z",
        "action_counter": 213
      }
    ]
  }
}