{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "inventory_scanner": {
    "description": "Scans the player's inventory list for a target item and returns whether it was found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory_list": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "inventory_list",
        "target_item"
      ]
    },
    "python_script": "import json\n\ntry:\n    inventory_list = json.loads(input_data['inventory_list'])\n    target_item = input_data['target_item']\n    found = False\n    for item in inventory_list:\n        if target_item.lower() in item.lower():\n            found = True\n            break\n    print(f'Item found: {found}')\nexcept Exception as e:\n    print(f'An error occurred: {e}')"
  },
  "pathfinder": {
    "description": "Calculates the shortest path from the player's current position to a target coordinate on the current map. This version uses a stateful (walk/surf) A* algorithm, can find paths to tiles adjacent to impassable targets, correctly handles one-way ledge traversal, and now correctly treats spinner tiles as walkable.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\n\ndef heuristic(x, y, target_x, target_y):\n    return abs(x - target_x) + abs(y - target_y)\n\ndef pathfinder(input_data, map_xml_string):\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n\n    try:\n        root = ET.fromstring(map_xml_string)\n    except ET.ParseError as e:\n        return f'Error parsing map XML: {e}'\n\n    player_pos = None\n    for row_elem in root.findall('Row'):\n        for tile_elem in row_elem.findall('Tile'):\n            if tile_elem.find('Player') is not None:\n                player_pos = (int(tile_elem.get('id')), int(row_elem.get('id')))\n                break\n        if player_pos:\n            break\n\n    if not player_pos:\n        return 'Player position not found on the map.'\n\n    start_x, start_y = player_pos\n    start_node = (start_x, start_y)\n    \n    tile_map = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            has_obj = tile_elem.find('Object') is not None\n            obj_is_pikachu = False\n            if has_obj:\n                obj_elem = tile_elem.find('Object')\n                if obj_elem.get('id-name') == 'Pikachu':\n                    obj_is_pikachu = True\n            tile_map[(x, y)] = {'type': tile_type, 'has_obj': has_obj, 'obj_is_pikachu': obj_is_pikachu}\n\n    def is_walkable(x, y, on_water):\n        if (x, y) not in tile_map:\n            return False\n        tile_data = tile_map[(x, y)]\n        tile_type = tile_data['type']\n        \n        if tile_data['has_obj'] and not tile_data['obj_is_pikachu']:\n            return False\n\n        walkable_ground = ['ground', 'grass', 'steps', 'cleared_boulder_barrier', 'open_gate', 'gate_offscreen', 'teleport', 'ladder_up', 'ladder_down', 'spinner_stop', 'spinner_up', 'spinner_down', 'spinner_left', 'spinner_right']\n        \n        if on_water:\n            return tile_type == 'water'\n        else:\n            return tile_type in walkable_ground\n\n    open_set = [(heuristic(start_x, start_y, target_x, target_y), 0, start_node, False, [])]\n    closed_set = set()\n    \n    is_target_walkable_land = is_walkable(target_x, target_y, False)\n    is_target_walkable_water = is_walkable(target_x, target_y, True)\n    is_target_impassable = not is_target_walkable_land and not is_target_walkable_water\n\n    while open_set:\n        _, cost, current, on_water, path = heapq.heappop(open_set)\n\n        if (current, on_water) in closed_set:\n            continue\n\n        closed_set.add((current, on_water))\n        new_path = path + [current]\n\n        if current == (target_x, target_y):\n            return new_path\n        \n        if is_target_impassable and (abs(current[0] - target_x) + abs(current[1] - target_y) == 1):\n            if is_walkable(current[0], current[1], on_water):\n                 return new_path\n\n        x, y = current\n        for dx, dy, move in [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n            next_x, next_y = x + dx, y + dy\n\n            if (dx, dy) == (0, 1) and (next_x, next_y) in tile_map and tile_map[(next_x, next_y)]['type'] == 'ledge':\n                next_y += 1\n            \n            next_on_water = on_water\n\n            if (next_x, next_y) not in tile_map:\n                continue\n                \n            tile_type = tile_map[(next_x, next_y)]['type']\n\n            if tile_type == 'ledge' and (dx, dy) != (0, 1):\n                continue\n            \n            if tile_type == 'water' and not on_water:\n                next_on_water = True\n            elif tile_type != 'water' and on_water:\n                if tile_map[current]['type'] == 'water':\n                    next_on_water = False\n                else:\n                    continue\n\n            if is_walkable(next_x, next_y, next_on_water):\n                if ((next_x, next_y), next_on_water) not in closed_set:\n                    new_cost = cost + 1\n                    priority = new_cost + heuristic(next_x, next_y, target_x, target_y)\n                    heapq.heappush(open_set, (priority, new_cost, (next_x, next_y), next_on_water, new_path))\n\n    return 'No path found.'\n\nprint(pathfinder(input_data, map_xml_string))"
  },
  "pokemon_locator": {
    "description": "Scans a provided JSON list of Pokémon strings from a PC box to check if a target Pokémon (by nickname or species) is present.",
    "input_schema": {
      "type": "object",
      "properties": {
        "pokemon_in_box": {
          "type": "string"
        },
        "target_pokemon": {
          "type": "string"
        }
      },
      "required": [
        "pokemon_in_box",
        "target_pokemon"
      ]
    },
    "python_script": "import json\n\npokemon_in_box_str = input_data.get('pokemon_in_box', '[]')\ntarget_pokemon = input_data.get('target_pokemon', '').upper()\n\ntry:\n    pokemon_in_box = json.loads(pokemon_in_box_str)\n    if not isinstance(pokemon_in_box, list):\n        raise TypeError(\"Input is not a list.\")\nexcept (json.JSONDecodeError, TypeError) as e:\n    print(f\"Error: Could not parse the 'pokemon_in_box' input as a valid JSON list of strings. Details: {e}\")\nelse:\n    found = False\n    for pokemon_string in pokemon_in_box:\n        if target_pokemon in str(pokemon_string).upper():\n            found = True\n            break\n\n    if found:\n        print(f\"Found '{input_data['target_pokemon']}' in the current box.\")\n    else:\n        print(f\"Did not find '{input_data['target_pokemon']}' in the current box.\")"
  },
  "spinner_maze_solver": {
    "description": "Finds the shortest path in a spinner maze. It parses the map_xml_string, builds a graph including spinner traversals, and uses A* to find the path from the player's position to a target coordinate. Handles impassable targets by pathing to an adjacent tile.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef spinner_maze_solver(input_data, map_xml_string):\n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n    except (ValueError, KeyError) as e:\n        return f'Invalid input: {e}'\n\n    try:\n        root = ET.fromstring(map_xml_string)\n    except ET.ParseError as e:\n        return f'Error parsing map XML: {e}'\n\n    player_pos = None\n    for row_elem in root.findall('Row'):\n        for tile_elem in row_elem.findall('Tile'):\n            if tile_elem.find('Player') is not None:\n                player_pos = (int(tile_elem.get('id')), int(row_elem.get('id')))\n                break\n        if player_pos:\n            break\n\n    if not player_pos:\n        return 'Player position not found on the map.'\n\n    start_node = player_pos\n    target_node = (target_x, target_y)\n\n    grid = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            has_obj = tile_elem.find('Object') is not None\n            obj_is_pikachu = False\n            if has_obj:\n                obj_elem = tile_elem.find('Object')\n                obj_name = obj_elem.get('id-name')\n                if obj_name and obj_name == 'Pikachu':\n                    obj_is_pikachu = True\n            \n            is_impassable = tile_type == 'impassable' or (has_obj and not obj_is_pikachu)\n            \n            spinner_info = None\n            if tile_elem.find('Spinner') is not None:\n                spinner_elem = tile_elem.find('Spinner')\n                direction = spinner_elem.get('direction')\n                end_coord_str = spinner_elem.get('end-coordinate')\n                end_coord = tuple(map(int, end_coord_str.strip('()').split(','))) if end_coord_str else None\n                spinner_info = {'direction': direction, 'end': end_coord}\n\n            grid[(x, y)] = {'impassable': is_impassable, 'spinner': spinner_info}\n\n    open_set = [(heuristic(start_node, target_node), start_node)]\n    came_from = {}\n    g_score = {start_node: 0}\n\n    is_target_impassable = grid.get(target_node, {}).get('impassable', True)\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if not is_target_impassable and current == target_node:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start_node)\n            return path[::-1]\n        \n        if is_target_impassable and heuristic(current, target_node) == 1:\n            if not grid.get(current, {}).get('impassable', True):\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(start_node)\n                return path[::-1]\n\n        current_spinner = grid[current]['spinner']\n        if current_spinner and current_spinner['end']:\n            neighbor = current_spinner['end']\n            if neighbor in grid and not grid[neighbor]['impassable']:\n                tentative_g_score = g_score[current] + 1 \n                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score = tentative_g_score + heuristic(neighbor, target_node)\n                    heapq.heappush(open_set, (f_score, neighbor))\n            continue\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if neighbor not in grid or grid[neighbor]['impassable']:\n                continue\n\n            tentative_g_score = g_score[current] + 1\n            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score = tentative_g_score + heuristic(neighbor, target_node)\n                heapq.heappush(open_set, (f_score, neighbor))\n\n    return 'No path found.'\n\nprint(spinner_maze_solver(input_data, map_xml_string))"
  }
}