{
  "automated_explorer": {
    "description": "Finds the nearest reachable unseen tile and generates a path to an adjacent traversable tile. Now correctly handles water traversal with SURF, defeated trainers, and uses robust pathfinding logic.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\nimport json\n\ndef find_all_reachable_and_paths(start, grid, width, height, is_surfing_state):\n    queue = collections.deque([start])\n    came_from = {start: None}\n    \n    while queue:\n        current = queue.popleft()\n        \n        for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = current[0] + move_x, current[1] + move_y\n            next_pos = (next_x, next_y)\n            \n            if not (1 <= next_x <= width and 1 <= next_y <= height):\n                continue\n            \n            if next_pos in came_from:\n                continue\n                \n            current_tile_info = grid.get(current, {})\n            next_tile_info = grid.get(next_pos, {})\n            next_tile_type = next_tile_info.get('type')\n            \n            if move_y == 1 and current_tile_info.get('type') != 'ledge' and next_tile_type == 'ledge':\n                ledge_jump_pos = (next_x, next_y + 1)\n                if ledge_jump_pos in came_from: continue\n                if grid.get(ledge_jump_pos, {}).get('type') not in ['impassable', 'unknown']:\n                    came_from[next_pos] = current\n                    came_from[ledge_jump_pos] = next_pos\n                    queue.append(ledge_jump_pos)\n                continue\n\n            impassable_types = ['impassable', 'unknown']\n            if current_tile_info.get('type') != 'water':\n                 impassable_types.append('ledge')\n            \n            if next_tile_type in impassable_types:\n                continue\n\n            if next_tile_type == 'water' and not is_surfing_state:\n                continue\n            \n            if next_tile_info.get('has_object') and next_tile_info.get('object_name') != 'Pikachu' and not next_tile_info.get('is_defeated_trainer', False):\n                continue\n\n            current_elevation = 'elevated' if current_tile_info.get('type') == 'elevated_ground' else 'ground'\n            next_elevation = 'elevated' if next_tile_type == 'elevated_ground' else 'ground'\n            if current_elevation != next_elevation and current_tile_info.get('type') not in ['steps', 'ladder_up', 'ladder_down'] and next_tile_type not in ['steps', 'ladder_up', 'ladder_down']:\n                continue\n            \n            came_from[next_pos] = current\n            queue.append(next_pos)\n            \n    return came_from\n\ndef reconstruct_path(came_from, end):\n    if end not in came_from:\n        return None\n    path = []\n    current = end\n    while current is not None:\n        path.append(list(current))\n        current = came_from.get(current)\n    return path[::-1]\n\ndef main():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        start_node = (start_x, start_y)\n\n        grid = {}\n        unseen_tiles = []\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                is_defeated = any(marker.get('emoji') == '☠️' for marker in tile_elem.findall('Marker'))\n                grid[(x, y)] = {\n                    'type': tile_elem.get('type'),\n                    'has_object': tile_elem.get('has-object') == 'true',\n                    'object_name': tile_elem.find('Object').get('id-name') if tile_elem.find('Object') is not None else None,\n                    'is_defeated_trainer': is_defeated\n                }\n                if tile_elem.get('seen') == 'false':\n                    unseen_tiles.append((x, y))\n\n        is_surfing_state = grid.get(start_node, {}).get('type') == 'water'\n\n        if not unseen_tiles:\n            print(json.dumps({'status': 'success', 'message': 'No unseen tiles found.'}))\n            return\n\n        came_from = find_all_reachable_and_paths(start_node, grid, width, height, is_surfing_state)\n        reachable_nodes = set(came_from.keys())\n        \n        targetable_unseen_tiles = [tile for tile in unseen_tiles if any((tile[0] + dx, tile[1] + dy) in reachable_nodes for dx, dy in [(0,1),(0,-1),(1,0),(-1,0)])]\n\n        if not targetable_unseen_tiles:\n            print(json.dumps({'status': 'error', 'message': 'No unseen tiles are adjacent to reachable areas.', 'reachable_nodes_count': len(reachable_nodes)}))\n            return\n\n        shortest_path = None\n        target_unseen = None\n        \n        sorted_targets = sorted(targetable_unseen_tiles, key=lambda t: (abs(t[0] - start_x) + abs(t[1] - start_y)))\n\n        for tile in sorted_targets:\n            best_adj_path = None\n            for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adj_x, adj_y = tile[0] + move_x, tile[1] + move_y\n                adj_pos = (adj_x, adj_y)\n                if adj_pos in reachable_nodes:\n                    path = reconstruct_path(came_from, adj_pos)\n                    if path and (best_adj_path is None or len(path) < len(best_adj_path)):\n                        best_adj_path = path\n            \n            if best_adj_path:\n                shortest_path = best_adj_path\n                target_unseen = tile\n                break\n        \n        if shortest_path:\n            print(json.dumps({'status': 'success', 'path': shortest_path, 'target_unseen_tile': target_unseen}))\n        else:\n            print(json.dumps({'status': 'error', 'message': 'Could not find a path to any adjacent tile of any reachable unseen tiles.'}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'status': 'error', 'message': f'An exception occurred: {traceback.format_exc()}'}))\n\nmain()"
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map using the Breadth-First Search (BFS) algorithm. It considers tile types (including elevation, water), impassable objects (excluding Pikachu), and special ledge traversal rules. It now detects and reports if a destination is on an unreachable map segment. The output is a JSON string containing the path or debug info.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\nimport json\n\ndef find_path():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        start = (int(input_data['start_x']), int(input_data['start_y']))\n        end = (int(input_data['end_x']), int(input_data['end_y']))\n\n        grid = {}\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                object_name = None\n                if has_object:\n                    obj_elem = tile_elem.find('Object')\n                    if obj_elem is not None:\n                        object_name = obj_elem.get('id-name')\n                grid[(x, y)] = {'type': tile_type, 'has_object': has_object, 'object_name': object_name}\n\n        queue = collections.deque([start])\n        came_from = {start: None}\n\n        while queue:\n            current = queue.popleft()\n            if current == end:\n                break\n\n            for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                next_x, next_y = current[0] + move_x, current[1] + move_y\n                next_pos = (next_x, next_y)\n\n                if not (1 <= next_x <= width and 1 <= next_y <= height) or next_pos in came_from:\n                    continue\n\n                current_tile_info = grid.get(current, {})\n                next_tile_info = grid.get(next_pos, {})\n                next_tile_type = next_tile_info.get('type')\n\n                if next_tile_type in ['impassable', 'unknown', 'closed_gate']:\n                    continue\n\n                if next_tile_info.get('has_object') and next_tile_info.get('object_name') != 'Pikachu':\n                    if next_pos != end:\n                        continue\n                \n                if next_tile_type == 'ledge':\n                    if move_y == 1:\n                        ledge_jump_pos = (next_x, next_y + 1)\n                        if ledge_jump_pos in came_from: continue\n                        if grid.get(ledge_jump_pos, {}).get('type') not in ['impassable', 'unknown', 'closed_gate']:\n                            came_from[next_pos] = current\n                            came_from[ledge_jump_pos] = next_pos\n                            queue.append(ledge_jump_pos)\n                        continue\n                    else:\n                        continue\n\n                current_is_elevated = current_tile_info.get('type') == 'elevated_ground'\n                next_is_elevated = next_tile_info.get('type') == 'elevated_ground'\n                if current_is_elevated != next_is_elevated:\n                    if not (current_tile_info.get('type') in ['steps', 'ladder_up', 'ladder_down'] or next_tile_type in ['steps', 'ladder_up', 'ladder_down']):\n                        continue\n                \n                came_from[next_pos] = current\n                queue.append(next_pos)\n\n        if end in came_from:\n            path = []\n            current = end\n            while current is not None:\n                path.append(list(current))\n                current = came_from.get(current)\n            print(json.dumps({\"status\": \"success\", \"path\": path[::-1]}))\n        else:\n            print(json.dumps({\"status\": \"error\", \"message\": \"No path found. The destination is on an unreachable segment of the map.\"}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({\"status\": \"error\", \"message\": f'An exception occurred: {traceback.format_exc()}'}))\n\nfind_path()\n"
  },
  "wkg_pathfinder": {
    "description": "Calculates the shortest path between two maps in the World Knowledge Graph, returning a sequence of map IDs and warp coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_map_id": {
          "type": "string"
        },
        "end_map_id": {
          "type": "string"
        }
      },
      "required": [
        "start_map_id",
        "end_map_id"
      ]
    },
    "python_script": "import json\nimport collections\n\nstart_map_id = input_data['start_map_id']\nend_map_id = input_data['end_map_id']\n\nwkg = json.loads(world_knowledge_graph_json_string)\nnodes = {node['id']: node for node in wkg.get('nodes', [])}\nedges = wkg.get('edges', [])\n\nadj = collections.defaultdict(list)\nfor edge in edges:\n    source_node = nodes.get(edge['source_node_id'])\n    dest_node = nodes.get(edge['destination_node_id'])\n    if source_node and dest_node:\n        source_map = source_node['map_id']\n        dest_map = dest_node['map_id']\n        \n        adj[source_map].append({\n            \"to_map\": dest_map,\n            \"warp_coords\": edge['source_coordinates'],\n            \"arrival_coords\": edge['destination_coordinates']\n        })\n        if not edge.get('is_one_way', False):\n            adj[dest_map].append({\n                \"to_map\": source_map,\n                \"warp_coords\": edge['destination_coordinates'],\n                \"arrival_coords\": edge['source_coordinates']\n            })\n\nqueue = collections.deque([(start_map_id, [])])\nvisited = {start_map_id}\n\npath_found = None\n\nwhile queue:\n    current_map, path = queue.popleft()\n    \n    if current_map == end_map_id:\n        path_found = path\n        break\n        \n    if current_map in adj:\n        for edge_info in adj[current_map]:\n            neighbor_map = edge_info['to_map']\n            if neighbor_map not in visited:\n                visited.add(neighbor_map)\n                new_path = path + [edge_info]\n                queue.append((neighbor_map, new_path))\n\nif path_found is not None:\n    formatted_path = []\n    last_map = start_map_id\n    for step in path_found:\n        formatted_path.append({\n            \"from_map\": last_map,\n            \"to_map\": step[\"to_map\"],\n            \"warp_coords\": step[\"warp_coords\"]\n        })\n        last_map = step[\"to_map\"]\n    \n    print(json.dumps({\"status\": \"success\", \"path\": formatted_path}))\nelse:\n    print(json.dumps({\"status\": \"error\", \"message\": \"No path found between the specified maps.\"}))\n"
  },
  "find_wkg_node_by_coords": {
    "description": "Finds a World Knowledge Graph node ID by map ID and coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "map_id": {
          "type": "string"
        },
        "x": {
          "type": "string"
        },
        "y": {
          "type": "string"
        }
      },
      "required": [
        "map_id",
        "x",
        "y"
      ]
    },
    "python_script": "import json\n\ndef find_node():\n    try:\n        wkg = json.loads(world_knowledge_graph_json_string)\n        target_map_id = input_data['map_id']\n        target_x = int(input_data['x'])\n        target_y = int(input_data['y'])\n\n        for node in wkg['nodes']:\n            if str(node['map_id']) == str(target_map_id) and node['coordinates']['x'] == target_x and node['coordinates']['y'] == target_y:\n                print(json.dumps({'status': 'success', 'node_id': node['id']}))\n                return\n        \n        print(json.dumps({'status': 'error', 'message': f'Node not found on map {target_map_id} at ({target_x}, {target_y}).'}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'status': 'error', 'message': f'An exception occurred: {traceback.format_exc()}'}))\n\nfind_node()"
  }
}