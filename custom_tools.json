{
  "advance_dialogue": {
    "description": "Presses the 'A' button a specified number of times with short delays to advance dialogue.",
    "input_schema": {
      "type": "object",
      "properties": {
        "num_presses": {
          "type": "integer",
          "description": "Number of times to press A. Default is 5.",
          "default": 5
        }
      }
    },
    "python_script": "import json\nnum = input_data.get('num_presses', 5)\nbuttons = []\nfor _ in range(num):\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\") # Wait 0.5s between presses\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-22T03:56:36.634Z",
        "action_counter": 8282
      },
      {
        "commit_message": "Fixed bug where output was not valid JSON. Added json import and usage.",
        "timestamp": "2026-01-22T03:57:54.764Z",
        "action_counter": 8284
      }
    ]
  },
  "bfs_navigate": {
    "description": "Navigates to a target coordinate using BFS. You MUST provide the list of valid walkable tile TYPE IDs for the current map.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "walkable_types": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "target_x",
        "target_y",
        "walkable_types"
      ]
    },
    "python_script": "import sys\nimport xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef get_player_pos(root):\n    for row in root.findall('Row'):\n        for tile in row.findall('Tile'):\n            if tile.find('Player') is not None:\n                return int(tile.get('id')), int(row.get('id'))\n    return None\n\ndef bfs(start, target, grid, walkable_types, width, height):\n    queue = [(0, start, [])]\n    visited = set([start])\n    \n    while queue:\n        cost, current, path = heapq.heappop(queue)\n        \n        if current == target:\n            return path\n        \n        x, y = current\n        neighbors = [\n            (x, y - 1, 'Up'), (x, y + 1, 'Down'),\n            (x - 1, y, 'Left'), (x + 1, y, 'Right')\n        ]\n        \n        for nx, ny, direction in neighbors:\n            if 0 <= nx < width and 0 <= ny < height:\n                tile_type = grid.get((nx, ny))\n                if (nx, ny) not in visited and tile_type in walkable_types:\n                    visited.add((nx, ny))\n                    heapq.heappush(queue, (cost + 1, (nx, ny), path + [direction]))\n    return None\n\ntry:\n    # input_data is injected\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    walkable_types = set(input_data['walkable_types'])\n    autopress = input_data.get('autopress_buttons', False)\n\n    # map_xml_string is injected\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = {}\n    player_pos = None\n    \n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tile_type = tile.get('type')\n            grid[(x, y)] = tile_type\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n                \n    if not player_pos:\n        print(json.dumps({\"error\": \"Player not found\"}))\n        sys.exit(0)\n        \n    path = bfs(player_pos, (target_x, target_y), grid, walkable_types, width, height)\n    \n    if path:\n        print(json.dumps(path))\n    else:\n        print(json.dumps({\"error\": \"No path found\"}))\n\nexcept Exception as e:\n    print(json.dumps({\"error\": str(e)}))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-20T20:26:14.582Z",
        "action_counter": 6490
      },
      {
        "commit_message": "Fixed NameError by ensuring variable scope is correct in the try/except block.",
        "timestamp": "2026-01-22T02:39:20.905Z",
        "action_counter": 8194
      }
    ]
  },
  "buy_current_item": {
    "description": "Automates the purchase of the currently selected item in a shop menu by setting the quantity and confirming. Assumes the cursor is already on the desired item.",
    "input_schema": {
      "type": "object",
      "properties": {
        "quantity": {
          "type": "integer",
          "description": "The number of items to buy.",
          "minimum": 1,
          "maximum": 99
        }
      },
      "required": [
        "quantity"
      ]
    },
    "python_script": "def run(input_data):\n    quantity = input_data.get('quantity', 1)\n    buttons = []\n    \n    # Select the item\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # Adjust quantity\n    if quantity > 1:\n        # Press Up quantity-1 times (assuming Up increments from 1)\n        # Note: In some games Down goes to max, but Up is safer for specific counts\n        for _ in range(quantity - 1):\n            buttons.append(\"Up\")\n            # buttons.append(\"sleep 100\") # Small delay if needed\n            \n    # Confirm quantity\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # Handle \"Here you go\" dialogue?\n    # Usually requires one more A or B to clear text.\n    # Let's add one A to be safe, but user might need to handle dialogue.\n    buttons.append(\"A\")\n    \n    print(f'{{\"buttons\": {buttons}}}')",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-22T06:18:21.849Z",
        "action_counter": 8464
      }
    ]
  },
  "check_execution_env": {
    "description": "A simple system check to verify code execution environment availability.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "python_script": "print(\"Execution environment is active.\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-21T08:14:32.627Z",
        "action_counter": 7236
      }
    ]
  },
  "check_path_connectivity": {
    "description": "Checks if a path exists between two coordinates using BFS on the Mental Map XML. Returns path length and steps if found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\n\nstart_x = input_data['start_x']\nstart_y = input_data['start_y']\ntarget_x = input_data['target_x']\ntarget_y = input_data['target_y']\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get(\"width\"))\n    height = int(root.get(\"height\"))\n    grid = {}\n    \n    for row in root.findall(\"Row\"):\n        y = int(row.get(\"id\"))\n        for tile in row.findall(\"Tile\"):\n            x = int(tile.get(\"id\"))\n            t_type = tile.get(\"type\")\n            grid[(x, y)] = t_type\n\n    start = (start_x, start_y)\n    target = (target_x, target_y)\n    \n    if start not in grid or target not in grid:\n        print(f\"Error: Coordinates out of bounds or not in map data.\")\n        exit()\n\n    queue = collections.deque([[start]])\n    visited = set([start])\n    \n    found = False\n    final_path = []\n    \n    # Simple passable check - assume anything not explicitly a known wall is passable for now\n    # This can be refined\n    WALL_TYPES = [\"TYPE_2889\", \"TYPE_80fc\", \"TYPE_5519\", \"TYPE_a336\", \"TYPE_fed7\"] \n    # Note: TYPE_c453 is ledge, handled as one-way usually, but for simple connectivity checks might treat as passable or blocked depending on direction. \n    # For this simple BFS, let's treat it as passable but risky, or just block it if we want strictness.\n    # Let's verify specific blocked types from notepad.\n    \n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n        \n        if (x, y) == target:\n            found = True\n            final_path = path\n            break\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < width and 0 <= ny < height:\n                if (nx, ny) not in visited:\n                    tile_type = grid.get((nx, ny), \"unseen\")\n                    if tile_type not in WALL_TYPES:\n                        visited.add((nx, ny))\n                        new_path = list(path)\n                        new_path.append((nx, ny))\n                        queue.append(new_path)\n\n    if found:\n        print(f\"Path found! Length: {len(final_path)}. Path: {final_path}\")\n    else:\n        print(\"No path found.\")\n\nexcept Exception as e:\n    print(f\"Error parsing map or finding path: {e}\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T04:38:25.635Z",
        "action_counter": 310
      },
      {
        "commit_message": "Fixed autopress_buttons support by returning JSON list of buttons.",
        "timestamp": "2026-01-17T05:14:56.870Z",
        "action_counter": 363
      },
      {
        "commit_message": "Initial definition of check_path_connectivity tool to help verify navigation paths.",
        "timestamp": "2026-01-17T19:59:31.235Z",
        "action_counter": 1608
      },
      {
        "commit_message": "Initial definition of check_path_connectivity tool for verifying paths on the mental map.",
        "timestamp": "2026-01-18T00:52:36.653Z",
        "action_counter": 2016
      }
    ]
  },
  "find_map_edge": {
    "description": "Finds a path from the current position to a specified map edge (North, South, East, West) and returns the button sequence.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "edge": {
          "type": "string",
          "enum": [
            "North",
            "South",
            "East",
            "West"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "edge"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef find_edge_path(xml_string, sx, sy, edge):\n    try:\n        root = ET.fromstring(xml_string)\n    except:\n        print(\"[]\")\n        return\n\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    # Parse grid\n    grid = set()\n    rows = root.findall('Row')\n    for row in rows:\n        y = int(row.get('id'))\n        tiles = row.findall('Tile')\n        for tile in tiles:\n            x = int(tile.get('id'))\n            t_type = tile.get('type')\n            # Common walkable types + doors + unseen\n            # Adjust this list as we discover more types\n            if t_type in ['TYPE_3fe2', 'TYPE_ffbb', 'TYPE_201b', 'TYPE_unseen', 'TYPE_989e', 'TYPE_1dc2', 'TYPE_2889', 'TYPE_4e8c']:\n                grid.add((x,y))\n\n    queue = deque([(sx, sy, [])])\n    visited = set([(sx, sy)])\n    \n    while queue:\n        x, y, path = queue.popleft()\n        \n        # Check condition\n        at_edge = False\n        if edge == \"North\" and y == 0: at_edge = True\n        elif edge == \"South\" and y == height - 1: at_edge = True\n        elif edge == \"West\" and x == 0: at_edge = True\n        elif edge == \"East\" and x == width - 1: at_edge = True\n        \n        if at_edge:\n            # Convert to buttons\n            buttons = []\n            curr_x, curr_y = sx, sy\n            full_path = path + [(x, y)]\n            for px, py in full_path[1:]:\n                if px > curr_x: buttons.append(\"Right\")\n                elif px < curr_x: buttons.append(\"Left\")\n                elif py > curr_y: buttons.append(\"Down\")\n                elif py < curr_y: buttons.append(\"Up\")\n                curr_x, curr_y = px, py\n            print(str(buttons).replace(\"'\", '\"'))\n            return\n\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) in grid and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, path + [(x, y)]))\n    \n    print(\"[]\")\n\nfind_edge_path(map_xml_string, start_x, start_y, edge)",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-20T18:27:53.838Z",
        "action_counter": 6331
      }
    ]
  },
  "find_nearest_unseen": {
    "description": "Finds the 5 nearest 'unseen' tiles in the Mental Map to the current player position using Manhattan distance. Returns a list of coordinates sorted by distance.",
    "input_schema": {
      "type": "object",
      "properties": {
        "player_x": {
          "type": "integer"
        },
        "player_y": {
          "type": "integer"
        }
      },
      "required": [
        "player_x",
        "player_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ndef find_nearest_unseen(map_xml, p_x, p_y):\n    try:\n        root = ET.fromstring(map_xml)\n        unseen_tiles = []\n        for row in root.findall(\"Row\"):\n            r_id = int(row.get(\"id\"))\n            for tile in row.findall(\"Tile\"):\n                t_id = int(tile.get(\"id\"))\n                t_type = tile.get(\"type\")\n                if t_type == \"unseen\":\n                    dist = abs(p_x - t_id) + abs(p_y - r_id)\n                    unseen_tiles.append((dist, t_id, r_id))\n        \n        if not unseen_tiles:\n            print(\"[]\")\n            return\n\n        unseen_tiles.sort()\n        # Return list of dicts for JSON parsing\n        result = [{\"x\": t[1], \"y\": t[2], \"dist\": t[0]} for t in unseen_tiles[:5]]\n        print(json.dumps(result))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\np_x = input_data.get('player_x', 0)\np_y = input_data.get('player_y', 0)\nfind_nearest_unseen(map_xml_string, p_x, p_y)",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T05:16:24.634Z",
        "action_counter": 364
      },
      {
        "commit_message": "Initial definition of the find_nearest_unseen tool for fog-of-war clearing.",
        "timestamp": "2026-01-19T20:13:05.535Z",
        "action_counter": 5044
      }
    ]
  },
  "patrol_grass": {
    "description": "Moves the player Left and Right to search for wild Pokemon, and presses A to handle battle introductions.",
    "input_schema": {},
    "python_script": "import json\ncmds = [\"Left\", \"Right\", \"Left\", \"Right\", \"A\", \"A\", \"A\", \"A\"]\nprint(json.dumps(cmds))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T02:06:33.549Z",
        "action_counter": 93
      }
    ]
  },
  "scan_map_tiles": {
    "description": "Scans the Mental Map for specific rows, columns, or rectangular regions and returns tile types. Modes: 'row' (scans full rows), 'col' (scans full columns), 'rect' (scans a region defined by [x_min, x_max, y_min, y_max]).",
    "input_schema": {
      "type": "object",
      "properties": {
        "mode": {
          "type": "string",
          "enum": [
            "row",
            "col",
            "rect"
          ],
          "description": "The scanning mode."
        },
        "values": {
          "type": "array",
          "items": {
            "type": "integer"
          },
          "description": "For 'row'/'col', a list of indices. For 'rect', a list of 4 integers: [x_min, x_max, y_min, y_max]."
        }
      },
      "required": [
        "mode",
        "values"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\n\ndef scan_map_tiles(mode, values, map_xml):\n    try:\n        root = ET.fromstring(map_xml)\n        results = []\n        \n        if mode == \"row\":\n            target_rows = [str(v) for v in values]\n            for row in root.findall('Row'):\n                if row.get('id') in target_rows:\n                    row_data = []\n                    for tile in row.findall('Tile'):\n                        row_data.append(f\"({tile.get('id')}, {row.get('id')}): {tile.get('type')}\")\n                    results.append(f\"Row {row.get('id')}: \" + \", \".join(row_data))\n                    \n        elif mode == \"col\":\n             target_cols = set(values)\n             cols_data = {c: [] for c in target_cols}\n             for row in root.findall('Row'):\n                 rid = row.get('id')\n                 for tile in row.findall('Tile'):\n                     tid = int(tile.get('id'))\n                     if tid in target_cols:\n                         cols_data[tid].append(f\"({tid}, {rid}): {tile.get('type')}\")\n             for c in sorted(list(target_cols)):\n                 results.append(f\"Col {c}: \" + \", \".join(cols_data[c]))\n                 \n        elif mode == \"rect\":\n            # Expecting [x_min, x_max, y_min, y_max]\n            if len(values) != 4:\n                return \"Error: 'rect' mode requires exactly 4 values: [x_min, x_max, y_min, y_max]\"\n            x_min, x_max, y_min, y_max = values\n            for row in root.findall('Row'):\n                rid = int(row.get('id'))\n                if y_min <= rid <= y_max:\n                    for tile in row.findall('Tile'):\n                        tid = int(tile.get('id'))\n                        if x_min <= tid <= x_max:\n                            results.append(f\"({tid}, {rid}): {tile.get('type')}\")\n                            \n        return \"\\n\".join(results)\n    except Exception as e:\n        return f\"Error: {e}\"\n\nprint(scan_map_tiles(mode, values, map_xml_string))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-20T06:28:37.825Z",
        "action_counter": 5911
      }
    ]
  },
  "scan_surroundings": {
    "description": "Scans the Mental Map around the player and returns the type and coordinates of nearby tiles. Useful for identifying walls, ledges, and navigable paths without walking into them.",
    "input_schema": {
      "type": "object",
      "properties": {
        "radius": {
          "type": "integer",
          "description": "The radius of tiles to scan around the player. Defaults to 2."
        }
      },
      "required": [
        "radius"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    player_pos = None\n    \n    # Find player position\n    for row in root.findall(\"Row\"):\n        for tile in row.findall(\"Tile\"):\n            if tile.find(\"Player\") is not None:\n                player_pos = (int(tile.get(\"id\")), int(row.get(\"id\")))\n                break\n        if player_pos: break\n\n    if not player_pos:\n        print(\"Error: Player not found in Mental Map.\")\n    else:\n        px, py = player_pos\n        radius = input_data.get('radius', 2)\n        map_id = root.get('id')\n        print(f\"Scanning radius {radius} around {player_pos} on map {map_id}:\")\n        \n        for y in range(py - radius, py + radius + 1):\n            row = root.find(f\"./Row[@id='{y}']\")\n            if row is not None:\n                row_str = \"\"\n                for x in range(px - radius, px + radius + 1):\n                    tile = row.find(f\"./Tile[@id='{x}']\")\n                    if tile is not None:\n                        t_type = tile.get(\"type\")\n                        row_str += f\"[{x},{y}: {t_type}] \"\n                    else:\n                        row_str += f\"[{x},{y}: N/A] \"\n                print(row_str)\n            else:\n                print(f\"Row {y} not found.\")\n\nexcept Exception as e:\n    print(f\"Error executing scan_surroundings: {e}\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T03:27:06.196Z",
        "action_counter": 213
      }
    ]
  },
  "test_sandbox": {
    "description": "A simple test to verify if the Python sandbox is functioning correctly.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "python_script": "print(\"Sandbox is working!\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-21T08:09:47.817Z",
        "action_counter": 7231
      }
    ]
  },
  "find_reachable_exits": {
    "description": "Uses BFS to find all reachable tiles on the map boundaries (Row 0, Col 0, Row H-1, Col W-1) and specific warp tiles (TYPE_201b) from the current position. Returns a list of reachable exit coordinates and warp locations.",
    "input_schema": {
      "type": "object",
      "properties": {
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "autopress_buttons"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get(\"width\"))\n        height = int(root.get(\"height\"))\n        \n        walkable = set()\n        warps = set()\n        \n        # Parse map\n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                x = int(tile.get('id'))\n                t_type = tile.get('type')\n                \n                # Walkable types based on observation:\n                # TYPE_3fe2: Standard floor\n                # TYPE_4e8c: Tracks (Walkable?)\n                # TYPE_201b: Door/Warp Mat\n                # TYPE_bc52: Carpet/Floor variation? (Adding common ones just in case)\n                # We will be generous and assume anything NOT 2889 (Wall) might be walkable if we are desperate,\n                # but let's stick to positive inclusion first.\n                \n                if t_type in ['TYPE_3fe2', 'TYPE_4e8c', 'TYPE_201b', 'TYPE_c453', 'TYPE_ffbb']: \n                    walkable.add((x, y))\n                \n                if t_type == 'TYPE_201b':\n                    warps.add((x, y))\n\n        # Find player position dynamically or pass it?\n        # The prompt says player position is in game state. \n        # But for the tool, I'll scan the XML for <Player/> tag to be safe, or just use a known start.\n        # Actually, let's scan for Player tag.\n        start_pos = None\n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                if tile.find('Player') is not None:\n                    start_pos = (int(tile.get('id')), y)\n                    break\n            if start_pos: break\n            \n        if not start_pos:\n            print(\"Player not found in XML. Defaulting to (33, 10).\")\n            start_pos = (33, 10)\n            if start_pos not in walkable:\n                walkable.add(start_pos)\n\n        queue = deque([start_pos])\n        visited = {start_pos}\n        exits = []\n        reachable_warps = []\n        \n        while queue:\n            cx, cy = queue.popleft()\n            \n            # Check if boundary\n            if cx == 0 or cy == 0 or cx == width - 1 or cy == height - 1:\n                exits.append((cx, cy))\n            \n            # Check if warp\n            if (cx, cy) in warps:\n                reachable_warps.append((cx, cy))\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = cx + dx, cy + dy\n                if (nx, ny) in walkable and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n        \n        print(f\"Analysis complete from {start_pos}.\")\n        print(f\"Reachable Map Edge Exits: {sorted(list(set(exits)))}\")\n        print(f\"Reachable Warp Tiles: {sorted(list(set(reachable_warps)))}\")\n        \n        if not exits and not reachable_warps:\n             print(\"No exits found! You might be trapped or walkable types are missing.\")\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-23T20:36:44.830Z",
        "action_counter": 9932
      }
    ]
  }
}