{
  "find_path": {
    "description": "Finds the shortest path between two points on the current map using BFS. It avoids walls, impassable trees, objects, and correctly handles one-way ledges.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef find_path_script(map_xml_string, start_x_str, start_y_str, end_x_str, end_y_str):\n    start_x, start_y, end_x, end_y = int(start_x_str), int(start_y_str), int(end_x_str), int(end_y_str)\n    \n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = [[None for _ in range(width)] for _ in range(height)]\n    impassable_tiles = {\"WALL\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"LEDGE\", \"WATER\"}\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            has_object = tile_elem.find('Object') is not None\n            \n            if has_object:\n                grid[y][x] = 'OBJECT_OBSTACLE'\n            elif tile_type == 'unseen':\n                grid[y][x] = 'FLOOR'\n            else:\n                grid[y][x] = tile_type\n\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n\n    if not (0 <= start_x < width and 0 <= start_y < height and 0 <= end_x < width and 0 <= end_y < height):\n        return \"Start or end coordinates are out of bounds.\"\n\n    if grid[start_y][start_x] in impassable_tiles or grid[start_y][start_x] == 'OBJECT_OBSTACLE':\n        return f\"Start tile ({start_x},{start_y}) with type {grid[start_y][start_x]} is impassable.\"\n    if grid[end_y][end_x] in impassable_tiles or grid[end_y][end_x] == 'OBJECT_OBSTACLE':\n        return f\"End tile ({end_x},{end_y}) with type {grid[end_y][end_x]} is impassable.\"\n\n    queue = deque([[start_node]])\n    visited = {start_node}\n\n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n\n        if (x, y) == end_node:\n            return f\"Path found: {path}\"\n\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = x + dx, y + dy\n\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:\n                current_tile_type = grid[y][x]\n                next_tile_type = grid[ny][nx]\n\n                can_move = next_tile_type not in impassable_tiles and next_tile_type != 'OBJECT_OBSTACLE'\n\n                if 'LEDGE' in current_tile_type:\n                    is_hop_down = 'DOWN' in current_tile_type and dy == 1\n                    is_hop_right = 'RIGHT' in current_tile_type and dx == 1\n                    is_hop_left = 'LEFT' in current_tile_type and dx == -1\n                    if is_hop_down or is_hop_right or is_hop_left:\n                        can_move = True\n                    elif any(s in current_tile_type for s in ['DOWN', 'RIGHT', 'LEFT']):\n                        can_move = False\n\n                if can_move:\n                    visited.add((nx, ny))\n                    new_path = list(path)\n                    new_path.append((nx, ny))\n                    queue.append(new_path)\n    \n    return \"No path found.\"\n\nprint(find_path_script(map_xml_string, input_data['start_x'], input_data['start_y'], input_data['end_x'], input_data['end_y']))"
  },
  "pathfinder_pro": {
    "description": "Finds the shortest path on the current map using BFS. Avoids a comprehensive list of impassable tiles, objects, and correctly handles one-way ledges.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\n\nimpassable_static = {\n    \"WALL\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"WATER\", \"MART_SHELF\",\n    \"COUNTER\", \"BUOY\", \"TOWN_MAP\", \"WINDOW\", \"BOOKSHELF\", \"TV\", \"RADIO\"\n}\n\ngrid = {}\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.get('id'))\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.get('id'))\n        tile_type = tile_elem.get('type')\n        has_object = tile_elem.find('Object') is not None\n        is_impassable = tile_type in impassable_static or has_object\n        grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n\nstart_node = (start_x, start_y)\nend_node = (end_x, end_y)\n\nif grid.get(start_node, {}).get('impassable'):\n    print(f\"Start tile {start_node} is impassable.\")\nelif grid.get(end_node, {}).get('impassable'):\n    print(f\"End tile {end_node} is impassable.\")\nelse:\n    queue = deque([[start_node]])\n    visited = {start_node}\n    path_found = False\n\n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n\n        if (x, y) == end_node:\n            str_path = [f\"({px},{py})\" for px, py in path]\n            print(f\"Path found: {''.join(str_path)}\")\n            path_found = True\n            break\n\n        moves = {'Up': (0, -1), 'Down': (0, 1), 'Left': (-1, 0), 'Right': (1, 0)}\n        \n        for move, (dx, dy) in moves.items():\n            nx, ny = x + dx, y + dy\n            \n            if (nx, ny) in grid and (nx, ny) not in visited:\n                current_tile = grid.get((x, y), {})\n                next_tile = grid.get((nx, ny), {})\n                \n                can_move = not next_tile.get('impassable', True)\n                \n                current_type = current_tile.get('type', '')\n                if 'LEDGE' in current_type:\n                    if 'DOWN' in current_type and move == 'Down':\n                        can_move = True\n                    elif 'LEFT' in current_type and move == 'Left':\n                        can_move = True\n                    elif 'RIGHT' in current_type and move == 'Right':\n                        can_move = True\n                    elif any(s in current_type for s in ['DOWN', 'LEFT', 'RIGHT']):\n                        can_move = False\n\n                next_type = next_tile.get('type', '')\n                if next_type == 'LEDGE' and dy == -1:\n                     can_move = False\n\n                if can_move:\n                    visited.add((nx, ny))\n                    new_path = list(path)\n                    new_path.append((nx, ny))\n                    queue.append(new_path)\n\n    if not path_found:\n        print(\"No path found.\")"
  },
  "path_master": {
    "description": "Finds the shortest path on the current map using BFS. Avoids a comprehensive list of impassable tiles, objects (which are also impassable), and correctly handles one-way ledges.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nroot = ET.fromstring(map_xml_string)\n\nimpassable_types = {\n    \"WALL\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"WATER\", \"MART_SHELF\",\n    \"COUNTER\", \"BUOY\", \"TOWN_MAP\", \"WINDOW\", \"BOOKSHELF\", \"TV\", \"RADIO\", \"VOID\"\n}\n\ngrid = {}\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.get('id'))\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.get('id'))\n        tile_type = tile_elem.get('type')\n        has_object = tile_elem.find('Object') is not None\n        is_impassable = tile_type in impassable_types or has_object\n        grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n\nstart_node = (start_x, start_y)\nend_node = (end_x, end_y)\n\nif grid.get(start_node, {}).get('impassable'):\n    print(f\"Path Error: Start tile {start_node} is impassable.\")\nelif grid.get(end_node, {}).get('impassable'):\n    print(f\"Path Error: End tile {end_node} is impassable.\")\nelse:\n    queue = deque([[start_node]])\n    visited = {start_node}\n    path_found = False\n\n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n\n        if (x, y) == end_node:\n            moves = []\n            for i in range(len(path) - 1):\n                cx, cy = path[i]\n                nx, ny = path[i+1]\n                if nx > cx: moves.append('Right')\n                elif nx < cx: moves.append('Left')\n                elif ny > cy: moves.append('Down')\n                elif ny < cy: moves.append('Up')\n            print(f\"Path found: {', '.join(moves)}\")\n            path_found = True\n            break\n\n        # Order: Up, Down, Left, Right\n        for move, (dx, dy) in [('Up', (0, -1)), ('Down', (0, 1)), ('Left', (-1, 0)), ('Right', (1, 0))]:\n            nx, ny = x + dx, y + dy\n            \n            if (nx, ny) in grid and (nx, ny) not in visited:\n                current_tile_type = grid.get((x, y), {}).get('type', '')\n                next_tile = grid.get((nx, ny), {})\n                \n                can_move = not next_tile.get('impassable', True)\n                \n                # Handle one-way ledges based on current tile type\n                if 'LEDGE' in current_tile_type:\n                    if 'DOWN' in current_tile_type and move != 'Down': can_move = False\n                    elif 'LEFT' in current_tile_type and move != 'Left': can_move = False\n                    elif 'RIGHT' in current_tile_type and move != 'Right': can_move = False\n                \n                # Prevent moving up into a ledge\n                if 'LEDGE' in next_tile.get('type', '') and move == 'Up':\n                    can_move = False\n\n                if can_move:\n                    visited.add((nx, ny))\n                    new_path = list(path)\n                    new_path.append((nx, ny))\n                    queue.append(new_path)\n\n    if not path_found:\n        print(\"No path found.\")"
  },
  "path_wizard": {
    "description": "A more robust pathfinding tool that uses BFS to find the shortest path on the current map. It avoids a comprehensive list of impassable tiles, objects, and correctly handles one-way ledges. Includes enhanced debugging.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nroot = ET.fromstring(map_xml_string)\n\nimpassable_types = {\n    \"WALL\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"WATER\", \"MART_SHELF\",\n    \"COUNTER\", \"BUOY\", \"TOWN_MAP\", \"WINDOW\", \"BOOKSHELF\", \"TV\", \"RADIO\", \"VOID\"\n}\n\ngrid = {}\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.get('id'))\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.get('id'))\n        tile_type = tile_elem.get('type')\n        has_object = tile_elem.find('Object') is not None\n        is_impassable = tile_type in impassable_types or has_object\n        grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n\nstart_node = (start_x, start_y)\nend_node = (end_x, end_y)\n\nif grid.get(start_node, {}).get('impassable'):\n    print(f\"Path Error: Start tile {start_node} is impassable because its type is '{grid.get(start_node, {}).get('type')}' or it has an object.\")\nelif grid.get(end_node, {}).get('impassable'):\n    print(f\"Path Error: End tile {end_node} is impassable because its type is '{grid.get(end_node, {}).get('type')}' or it has an object.\")\nelse:\n    queue = deque([[start_node]])\n    visited = {start_node}\n    path_found = False\n\n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n\n        if (x, y) == end_node:\n            moves = []\n            for i in range(len(path) - 1):\n                cx, cy = path[i]\n                nx, ny = path[i+1]\n                if nx > cx: moves.append('Right')\n                elif nx < cx: moves.append('Left')\n                elif ny > cy: moves.append('Down')\n                elif ny < cy: moves.append('Up')\n            print(f\"Path found: {', '.join(moves)}\")\n            path_found = True\n            break\n\n        for move, (dx, dy) in [('Up', (0, -1)), ('Down', (0, 1)), ('Left', (-1, 0)), ('Right', (1, 0))]:\n            nx, ny = x + dx, y + dy\n            \n            if (nx, ny) in grid and (nx, ny) not in visited:\n                current_tile_type = grid.get((x, y), {}).get('type', '')\n                next_tile = grid.get((nx, ny), {})\n                next_tile_type = next_tile.get('type', '')\n                \n                can_move = not next_tile.get('impassable', True)\n                \n                if 'LEDGE' in current_tile_type:\n                    if ('DOWN' in current_tile_type and move != 'Down') or \\\n                       ('LEFT' in current_tile_type and move != 'Left') or \\\n                       ('RIGHT' in current_tile_type and move != 'Right'):\n                        can_move = False\n                \n                if 'LEDGE' in next_tile_type and move == 'Up':\n                    can_move = False\n\n                if can_move:\n                    visited.add((nx, ny))\n                    new_path = list(path)\n                    new_path.append((nx, ny))\n                    queue.append(new_path)\n\n    if not path_found:\n        print(\"No path found. Could not reach destination.\")"
  }
}