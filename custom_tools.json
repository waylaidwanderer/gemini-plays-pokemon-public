{
  "gem_pathfinder_v2": {
    "description": "A new, rebuilt A* pathfinding tool. This version is designed from the ground up to be more reliable, with a specific focus on correctly handling elevation changes via 'steps' and other connector tiles. It treats objects as impassable obstacles, unless explicitly ignored. It now supports a surfing mode.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        },
        "ignorable_coords": {
          "type": "string",
          "nullable": true
        },
        "is_surfing": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\nclass AStar:\n    def __init__(self, map_xml_string):\n        self.root = ET.fromstring(map_xml_string)\n        self.width = int(self.root.get('width'))\n        self.height = int(self.root.get('height'))\n        \n        self.tile_map = {}\n        parsed_tiles = {}\n        for row_node in self.root:\n            if row_node.tag != 'Row': continue\n            y = int(row_node.get('id'))\n            for tile_node in row_node:\n                if tile_node.tag != 'Tile': continue\n                x = int(tile_node.get('id'))\n                parsed_tiles[(x, y)] = tile_node\n        \n        for y in range(1, self.height + 1):\n            for x in range(1, self.width + 1):\n                if (x, y) in parsed_tiles:\n                    self.tile_map[(x, y)] = parsed_tiles[(x, y)]\n                else:\n                    default_tile = ET.Element('Tile')\n                    default_tile.set('type', 'ground')\n                    self.tile_map[(x, y)] = default_tile\n\n        self.player_pos = self._get_player_pos()\n        self.elevation_map = {\n            'ground': 0, 'grass': 0, 'steps': 1, 'boulder_switch': 1,\n            'cleared_boulder_barrier': 1, 'ladder_up': 1, 'ladder_down': 1, 'elevated_ground': 2\n        }\n\n    def _get_tile(self, x, y):\n        return self.tile_map.get((x, y))\n\n    def _get_player_pos(self):\n        for (x, y), tile_node in self.tile_map.items():\n            if tile_node.find('Player') is not None:\n                return x, y\n        return None\n\n    def _get_impassable_objects(self, ignorable_coords_str):\n        objects = set()\n        ignorable = []\n        if ignorable_coords_str and ignorable_coords_str.lower() != 'null':\n            try: \n                ignorable_data = json.loads(ignorable_coords_str)\n                if isinstance(ignorable_data, list):\n                    ignorable = [(d['x'], d['y']) for d in ignorable_data if isinstance(d, dict) and 'x' in d and 'y' in d]\n            except (json.JSONDecodeError, TypeError): pass\n        \n        for (x, y), t in self.tile_map.items():\n            if (x, y) in ignorable: continue\n            if t.get('type') in {'impassable', 'boulder_barrier'}: \n                objects.add((x, y))\n            elif t.find(\"Object[@id!='15']\") is not None: \n                objects.add((x, y))\n            elif t.find('Boulder') is not None: \n                objects.add((x, y))\n        return objects\n\n    def is_traversable(self, current_pos, neighbor_pos, traversable_tiles, impassable_objects, end_node):\n        n_x, n_y = neighbor_pos\n        \n        if (n_x, n_y) in impassable_objects and (n_x, n_y) != end_node:\n            return False\n\n        neighbor_tile = self._get_tile(n_x, n_y)\n        if not neighbor_tile:\n            return False\n\n        neighbor_type = neighbor_tile.get('type')\n        if neighbor_type == 'impassable' and (n_x, n_y) != end_node:\n            return False\n\n        if neighbor_pos != end_node and neighbor_type not in traversable_tiles and neighbor_type != 'ledge':\n            return False\n\n        current_tile = self._get_tile(current_pos[0], current_pos[1])\n        current_type = current_tile.get('type')\n\n        if neighbor_type == 'ledge':\n            return n_y > current_pos[1]\n\n        current_elev = self.elevation_map.get(current_type, -1)\n        neighbor_elev = self.elevation_map.get(neighbor_type, -1)\n        \n        if abs(current_elev - neighbor_elev) > 1:\n            return False\n        if neighbor_elev > current_elev and current_type not in {'steps', 'ladder_up', 'ladder_down', 'cleared_boulder_barrier'}:\n            return False\n        if current_elev > neighbor_elev and neighbor_type not in {'steps', 'ladder_up', 'ladder_down', 'cleared_boulder_barrier'}:\n             return False\n\n        return True\n\n    def _search(self, start_node, end_node, impassable, traversable_tiles):\n        open_list, counter, closed_set, came_from, g_score = [], 0, set(), {start_node: None}, {start_node: 0}\n        heapq.heappush(open_list, (0, counter, start_node))\n        \n        while open_list:\n            _, _, current = heapq.heappop(open_list)\n            if current in closed_set: continue\n            closed_set.add(current)\n\n            if current == end_node:\n                path = []\n                _curr = end_node\n                while _curr: path.append(_curr); _curr = came_from.get(_curr)\n                path.reverse()\n                return path\n\n            for neighbor in [(current[0]-1, current[1]), (current[0]+1, current[1]), (current[0], current[1]-1), (current[0], current[1]+1)]:\n                if not (1 <= neighbor[0] <= self.width and 1 <= neighbor[1] <= self.height): continue\n                if self.is_traversable(current, neighbor, traversable_tiles, impassable, end_node):\n                    tentative_g = g_score.get(current, float('inf')) + 1\n                    if tentative_g < g_score.get(neighbor, float('inf')):\n                        came_from[neighbor], g_score[neighbor] = current, tentative_g\n                        h = abs(neighbor[0] - end_node[0]) + abs(neighbor[1] - end_node[1])\n                        counter += 1\n                        heapq.heappush(open_list, (tentative_g + h, counter, neighbor))\n        return None\n\n    def find_path(self, target_x, target_y, ignorable_coords_str=None, is_surfing=False):\n        if not self.player_pos: return print(json.dumps({\"error\": \"Player position not found.\"}))\n        \n        traversable_tiles = {'ground', 'grass', 'elevated_ground', 'steps', 'cleared_boulder_barrier', 'boulder_switch', 'ladder_up', 'ladder_down'}\n        if is_surfing: traversable_tiles.add('water')\n        \n        start_node, end_node = self.player_pos, (int(target_x), int(target_y))\n        \n        impassable_pass1 = self._get_impassable_objects(ignorable_coords_str)\n        effective_end_node = end_node\n        \n        if end_node in impassable_pass1:\n            potential_goals = []\n            for neighbor in [(end_node[0]-1, end_node[1]), (end_node[0]+1, end_node[1]), (end_node[0], end_node[1]-1), (end_node[0], end_node[1]+1)]:\n                if (1 <= neighbor[0] <= self.width and 1 <= neighbor[1] <= self.height) and (neighbor not in impassable_pass1):\n                    neighbor_tile = self._get_tile(neighbor[0], neighbor[1])\n                    if neighbor_tile is not None and neighbor_tile.get('type') in traversable_tiles:\n                         potential_goals.append(neighbor)\n            if not potential_goals: \n                return print(json.dumps({\"error\": \"No traversable tile adjacent to the impassable destination.\"}))\n            potential_goals.sort(key=lambda p: abs(p[0] - start_node[0]) + abs(p[1] - start_node[1]))\n            effective_end_node = potential_goals[0]\n\n        path = self._search(start_node, effective_end_node, impassable_pass1, traversable_tiles)\n\n        if path is None:\n            boulders = []\n            for (x, y), t in self.tile_map.items():\n                if t.find('Boulder') is not None:\n                    boulders.append({'x': x, 'y': y})\n            \n            if boulders:\n                all_ignorable_coords = boulders\n                if ignorable_coords_str and ignorable_coords_str.lower() != 'null':\n                    try:\n                        user_ignorable = json.loads(ignorable_coords_str)\n                        if isinstance(user_ignorable, list):\n                            all_ignorable_coords.extend(user_ignorable)\n                    except (json.JSONDecodeError, TypeError): pass\n                \n                impassable_pass2 = self._get_impassable_objects(json.dumps(all_ignorable_coords))\n                path = self._search(start_node, effective_end_node, impassable_pass2, traversable_tiles)\n\n        if path:\n            return print(json.dumps([{'x': p[0], 'y': p[1]} for p in path]))\n        else:\n            return print(json.dumps({\"error\": \"No path found.\"}))\n\ntry:\n    pathfinder = AStar(map_xml_string)\n    pathfinder.find_path(input_data['target_x'], input_data['target_y'], input_data.get('ignorable_coords'), input_data.get('is_surfing') == 'true')\nexcept Exception as e:\n    print(json.dumps({\"error\": f\"An unexpected error occurred: {str(e)}\"}))",
    "history": [
      {
        "commit_message": "feat: Recreate pathfinder with verbose logging. The previous tool was deleted to break an update loop. This new version is defined from scratch and includes extensive (but commented out) print statements for debugging, as mandated by Overwatch critique, to diagnose any future pathing failures.",
        "timestamp": "2025-08-06T03:44:02.536Z",
        "action_counter": 123461
      },
      {
        "commit_message": "refactor(gem_pathfinder_v2): Implement two-pass system based on debugger agent's diagnosis. The first pass treats all obstacles as impassable. If it fails, a second pass is initiated which re-classifies all boulders as ignorable. This allows the tool to find paths that require moving boulders, fixing the critical flaw where it would incorrectly report 'no path found' in solvable puzzle rooms.",
        "timestamp": "2025-08-06T04:49:08.593Z",
        "action_counter": 123544
      }
    ]
  },
  "get_complete_puzzle_state": {
    "description": "A wrapper tool that gathers all necessary data for the puzzle_strategist_agent. It parses the map XML to find the player's position, all boulders, switches, and barriers, and a comprehensive list of all impassable tiles, including objects like defeated trainers.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\npuzzle_state = {\n    \"player_pos\": {},\n    \"boulders\": [],\n    \"switches\": [],\n    \"barriers\": [],\n    \"impassable_tiles\": []\n}\n\nroot = ET.fromstring(map_xml_string)\nimpassable_types = ['impassable', 'boulder_barrier', 'closed_gate']\n\nfor row in root.findall('Row'):\n    y = int(row.get('id'))\n    for tile in row.findall('Tile'):\n        x = int(tile.get('id'))\n        coord = {'x': x, 'y': y}\n\n        if tile.find('Player') is not None:\n            puzzle_state[\"player_pos\"] = coord\n\n        if tile.find('Boulder') is not None:\n            puzzle_state[\"boulders\"].append(coord)\n        if tile.get('type') == 'boulder_switch':\n            puzzle_state[\"switches\"].append(coord)\n        if tile.get('type') == 'boulder_barrier':\n            puzzle_state[\"barriers\"].append(coord)\n\n        is_impassable = False\n        if tile.get('type') in impassable_types:\n            is_impassable = True\n        \n        for obj in tile.findall('Object'):\n            if obj.get('id-name') != 'Pikachu':\n                is_impassable = True\n                break\n        \n        if is_impassable:\n            puzzle_state[\"impassable_tiles\"].append(coord)\n\nprint(json.dumps(puzzle_state))",
    "history": [
      {
        "commit_message": "feat: Create get_complete_puzzle_state tool. This automates the data gathering process for the puzzle_strategist_agent, preventing user error. It combines the functionality of get_puzzle_elements and get_impassable_coords, ensuring a complete and accurate dataset is always provided to the agent for strategic planning.",
        "timestamp": "2025-08-03T05:08:52.744Z",
        "action_counter": 118100
      }
    ]
  },
  "log_summarizer": {
    "description": "Summarizes a long log file, focusing on the beginning and end, to prevent truncation when passing it to another agent.",
    "input_schema": {
      "type": "object",
      "properties": {
        "log_text": {
          "type": "string"
        },
        "max_chars": {
          "type": "string"
        }
      },
      "required": [
        "log_text",
        "max_chars"
      ]
    },
    "python_script": "import json\n\nlog_text = input_data['log_text']\nmax_chars = int(input_data.get('max_chars', 8000))\n\nif len(log_text) <= max_chars:\n    print(log_text)\nelse:\n    half_chars = (max_chars - 50) // 2\n    start = log_text[:half_chars]\n    end = log_text[-half_chars:]\n    summary = f\"{start}\\n\\n... (log truncated, see original tool output for full text) ...\\n\\n{end}\"\n    print(summary)",
    "history": [
      {
        "commit_message": "feat: Create log_summarizer tool. This tool will prevent log truncation issues when passing verbose tool output to debugger agents, which was a critical failure identified in the last overwatch critique. This is a necessary step to break the current unproductive debugging loop.",
        "timestamp": "2025-08-05T13:18:24.116Z",
        "action_counter": 122522
      },
      {
        "commit_message": "feat: Create log_summarizer tool. This tool will prevent log truncation issues when passing verbose tool output to debugger agents, which was a critical failure identified in the last overwatch critique. This is a necessary step to break the current unproductive debugging loop.",
        "timestamp": "2025-08-05T15:11:16.035Z",
        "action_counter": 122635
      }
    ]
  },
  "landmass_analyzer": {
    "description": "Analyzes the map to identify all disconnected, traversable landmasses. Helps diagnose navigation puzzles and prevent getting stuck in isolated areas.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ndef get_neighbors(x, y, width, height):\n    neighbors = []\n    if x > 1: neighbors.append((x - 1, y))\n    if x < width: neighbors.append((x + 1, y))\n    if y > 1: neighbors.append((x, y - 1))\n    if y < height: neighbors.append((x, y + 1))\n    return neighbors\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\n\ntile_data = {}\nfor row in root.findall('Row'):\n    y = int(row.get('id'))\n    for tile in row.findall('Tile'):\n        x = int(tile.get('id'))\n        tile_data[(x, y)] = tile\n\nplayer_pos = None\nfor (x, y), tile in tile_data.items():\n    if tile.find('Player') is not None:\n        player_pos = (x, y)\n        break\n\ntraversable_types = {'ground', 'grass', 'elevated_ground', 'steps', 'cleared_boulder_barrier', 'boulder_switch', 'ladder_up', 'ladder_down'}\ntraversable_nodes = set()\nfor (x, y), tile in tile_data.items():\n    if tile.get('type') in traversable_types and tile.find('Object[@id!=\\\"15\\\"]') is None and tile.find('Boulder') is None:\n        traversable_nodes.add((x, y))\n\nlandmasses = []\nvisited = set()\n\nfor node in traversable_nodes:\n    if node not in visited:\n        current_landmass = set()\n        q = [node]\n        visited.add(node)\n        while q:\n            curr_x, curr_y = q.pop(0)\n            current_landmass.add((curr_x, curr_y))\n            for nx, ny in get_neighbors(curr_x, curr_y, width, height):\n                if (nx, ny) in traversable_nodes and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    q.append((nx, ny))\n        landmasses.append(sorted(list(current_landmass)))\n\nplayer_landmass_id = -1\nif player_pos:\n    for i, mass in enumerate(landmasses):\n        if player_pos in mass:\n            player_landmass_id = i\n            break\n\nresult = {\n    'player_landmass_id': player_landmass_id,\n    'total_landmasses': len(landmasses),\n    'landmasses': landmasses\n}\n\nprint(json.dumps(result))",
    "history": [
      {
        "commit_message": "feat: Create landmass_analyzer tool. This tool identifies disconnected traversable areas on a map, which will prevent getting stuck in navigational loops like the one experienced on Victory Road 2F. This directly addresses an Overwatch critique and improves long-term strategic navigation.",
        "timestamp": "2025-08-06T05:09:44.480Z",
        "action_counter": 123572
      }
    ]
  }
}