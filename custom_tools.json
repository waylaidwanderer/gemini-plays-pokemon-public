{
  "path_master_v13": {
    "description": "A more robust pathfinding tool using A* search. This version has improved logic for handling complex mazes and one-way tiles, and provides better diagnostic information on failure.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "on_screen_impassable_coordinates": {
          "type": "string",
          "description": "A JSON string of a list of [x, y] coordinates for on-screen objects to treat as impassable."
        },
        "extra_impassable_coordinates": {
          "type": "string",
          "description": "A JSON string of a list of additional [x, y] coordinates to treat as impassable."
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport heapq\n\ndef find_path_a_star(grid, start, end, all_impassable, debug_info):\n    impassable_base = {\n        'WALL', 'VOID', 'WATER', 'CUT_TREE', 'COUNTER', 'BUOY', 'HEADBUTT_TREE', 'unseen',\n        'MART_SHELF', 'BOOKSHELF', 'TV', 'RADIO', 'PC', 'TOWN_MAP', 'WINDOW', 'PAINTING', 'STATUE', 'PILLAR',\n        'BED', 'TABLE', 'CHAIR'\n    }\n    \n    debug_info['impassable_base_types'] = list(impassable_base)\n    debug_info['impassable_coordinates_from_input'] = [list(coord) for coord in all_impassable]\n    debug_info['rejection_log'] = []\n\n    if start not in grid:\n        debug_info['error'] = f'Start position {start} not in grid.'\n        return None, None\n    if end not in grid:\n        debug_info['error'] = f'End position {end} not in grid.'\n        return None, None\n\n    if grid.get(start, {}).get('type') in impassable_base or start in all_impassable:\n        debug_info['error'] = f'Start position {start} is on an impassable tile type or object.'\n        return None, None\n\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {pos: float('inf') for pos in grid}\n    g_score[start] = 0\n    f_score = {pos: float('inf') for pos in grid}\n    f_score[start] = heuristic(start, end)\n    \n    open_set_hash = {start}\n\n    while open_set:\n        _, current_pos = heapq.heappop(open_set)\n        open_set_hash.remove(current_pos)\n\n        if current_pos == end:\n            path = []\n            while current_pos in came_from:\n                path.append(list(current_pos))\n                current_pos = came_from[current_pos]\n            path.append(list(start))\n            return path[::-1], None\n\n        current_type = grid.get(current_pos, {}).get('type')\n\n        for move_x, move_y, move_name in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            next_pos = (current_pos[0] + move_x, current_pos[1] + move_y)\n            \n            rejection_reason = \"\"\n\n            if next_pos not in grid:\n                rejection_reason = 'Out of bounds'\n            else:\n                next_type = grid.get(next_pos, {}).get('type')\n                \n                if next_type in impassable_base:\n                    rejection_reason = f'Impassable base type: {next_type}'\n                elif next_pos in all_impassable and next_pos != end:\n                    rejection_reason = 'Impassable coordinate'\n                elif current_type == 'LEDGE_HOP_DOWN' and move_name != 'Down':\n                    rejection_reason = f'Cannot move {move_name} from LEDGE_HOP_DOWN'\n                elif current_type == 'LEDGE_HOP_LEFT' and move_name != 'Left':\n                    rejection_reason = f'Cannot move {move_name} from LEDGE_HOP_LEFT'\n                elif current_type == 'LEDGE_HOP_RIGHT' and move_name != 'Right':\n                    rejection_reason = f'Cannot move {move_name} from LEDGE_HOP_RIGHT'\n                elif current_type == 'FLOOR_UP_WALL' and move_name in ['Up', 'Down']:\n                    rejection_reason = f'Cannot move {move_name} from FLOOR_UP_WALL'\n                elif next_type == 'FLOOR_UP_WALL' and move_name != 'Up':\n                    rejection_reason = 'Cannot enter FLOOR_UP_WALL except by moving Up'\n                elif next_type == 'LEDGE_HOP_DOWN' and move_name == 'Up':\n                    rejection_reason = 'Cannot move Up onto a LEDGE_HOP_DOWN'\n                elif next_type == 'LEDGE_HOP_LEFT' and move_name == 'Right':\n                    rejection_reason = 'Cannot move Right onto a LEDGE_HOP_LEFT'\n                elif next_type == 'LEDGE_HOP_RIGHT' and move_name == 'Left':\n                    rejection_reason = 'Cannot move Left onto a LEDGE_HOP_RIGHT'\n            \n            if rejection_reason:\n                debug_info['rejection_log'].append({'from': list(current_pos), 'to': list(next_pos), 'reason': rejection_reason})\n                continue\n            \n            tentative_g_score = g_score[current_pos] + 1\n            if tentative_g_score < g_score.get(next_pos, float('inf')):\n                came_from[next_pos] = current_pos\n                g_score[next_pos] = tentative_g_score\n                f_score[next_pos] = tentative_g_score + heuristic(next_pos, end)\n                if next_pos not in open_set_hash:\n                    heapq.heappush(open_set, (f_score[next_pos], next_pos))\n                    open_set_hash.add(next_pos)\n\n    blocked_at = None\n    if 'rejection_log' in debug_info and debug_info['rejection_log']:\n        last_rejection = debug_info['rejection_log'][-1]\n        if last_rejection['to'] == list(end):\n             blocked_at = last_rejection['to']\n\n    debug_info['error'] = 'No path found to destination.'\n    return None, blocked_at\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    \n    on_screen_impassable_str = input_data.get('on_screen_impassable_coordinates')\n    loaded_on_screen = json.loads(on_screen_impassable_str) if on_screen_impassable_str else []\n    on_screen_impassable = {tuple(coord) for coord in loaded_on_screen} if loaded_on_screen else set()\n\n    extra_impassable_str = input_data.get('extra_impassable_coordinates')\n    loaded_extra = json.loads(extra_impassable_str) if extra_impassable_str else []\n    extra_impassable = {tuple(coord) for coord in loaded_extra} if loaded_extra else set()\n    \n    debug_info = {\n        'inputs': {\n            'start': [start_x, start_y],\n            'end': [end_x, end_y],\n            'on_screen_impassable': list(on_screen_impassable),\n            'extra_impassable': list(extra_impassable)\n        }\n    }\n\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    \n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            grid[(x, y)] = {'type': tile.get('type')}\n\n    all_impassable = on_screen_impassable.union(extra_impassable)\n    \n    path, blocked_at = find_path_a_star(grid, (start_x, start_y), (end_x, end_y), all_impassable, debug_info)\n    \n    print(json.dumps({'path': path if path else [], 'blocked_at': blocked_at, 'debug': debug_info}))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'path': [], 'blocked_at': None, 'debug': {'error': f'An exception occurred: {str(e)}\\n{traceback.format_exc()}'}}))\n"
  },
  "path_master_v14": {
    "description": "A more robust pathfinding tool using A* search. This version has improved logic for handling complex mazes and one-way tiles, and provides better diagnostic information on failure, including a list of tile types in the path.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "on_screen_impassable_coordinates": {
          "type": "string",
          "description": "A JSON string of a list of [x, y] coordinates for on-screen objects to treat as impassable."
        },
        "extra_impassable_coordinates": {
          "type": "string",
          "description": "A JSON string of a list of additional [x, y] coordinates to treat as impassable."
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport heapq\n\ndef find_path_a_star(grid, start, end, all_impassable, debug_info):\n    impassable_base = {\n        'WALL', 'VOID', 'WATER', 'CUT_TREE', 'COUNTER', 'BUOY', 'HEADBUTT_TREE', 'unseen',\n        'MART_SHELF', 'BOOKSHELF', 'TV', 'RADIO', 'PC', 'TOWN_MAP', 'WINDOW', 'PAINTING', 'STATUE', 'PILLAR',\n        'BED', 'TABLE', 'CHAIR'\n    }\n    \n    debug_info['impassable_base_types'] = list(impassable_base)\n    debug_info['impassable_coordinates_from_input'] = [list(coord) for coord in all_impassable]\n    debug_info['rejection_log'] = []\n\n    if start not in grid:\n        debug_info['error'] = f'Start position {start} not in grid.'\n        return None, None, None\n    if end not in grid:\n        debug_info['error'] = f'End position {end} not in grid.'\n        return None, None, None\n\n    if grid.get(start, {}).get('type') in impassable_base or start in all_impassable:\n        debug_info['error'] = f'Start position {start} is on an impassable tile type or object.'\n        return None, None, None\n\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {pos: float('inf') for pos in grid}\n    g_score[start] = 0\n    f_score = {pos: float('inf') for pos in grid}\n    f_score[start] = heuristic(start, end)\n    \n    open_set_hash = {start}\n\n    while open_set:\n        _, current_pos = heapq.heappop(open_set)\n        open_set_hash.remove(current_pos)\n\n        if current_pos == end:\n            path = []\n            path_tile_types = []\n            temp_pos = current_pos\n            while temp_pos in came_from:\n                path.append(list(temp_pos))\n                path_tile_types.append(grid.get(temp_pos, {}).get('type'))\n                temp_pos = came_from[temp_pos]\n            path.append(list(start))\n            path_tile_types.append(grid.get(start, {}).get('type'))\n            return path[::-1], path_tile_types[::-1], None\n\n        current_type = grid.get(current_pos, {}).get('type')\n\n        for move_x, move_y, move_name in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            next_pos = (current_pos[0] + move_x, current_pos[1] + move_y)\n            \n            rejection_reason = \"\"\n\n            if next_pos not in grid:\n                rejection_reason = 'Out of bounds'\n            else:\n                next_type = grid.get(next_pos, {}).get('type')\n                \n                if next_type in impassable_base:\n                    rejection_reason = f'Impassable base type: {next_type}'\n                elif next_pos in all_impassable and next_pos != end:\n                    rejection_reason = 'Impassable coordinate'\n                elif current_type == 'LEDGE_HOP_DOWN' and move_name != 'Down':\n                    rejection_reason = f'Cannot move {move_name} from LEDGE_HOP_DOWN'\n                elif current_type == 'LEDGE_HOP_LEFT' and move_name != 'Left':\n                    rejection_reason = f'Cannot move {move_name} from LEDGE_HOP_LEFT'\n                elif current_type == 'LEDGE_HOP_RIGHT' and move_name != 'Right':\n                    rejection_reason = f'Cannot move {move_name} from LEDGE_HOP_RIGHT'\n                elif current_type == 'FLOOR_UP_WALL' and move_name in ['Up', 'Down']:\n                    rejection_reason = f'Cannot move {move_name} from FLOOR_UP_WALL'\n                elif next_type == 'FLOOR_UP_WALL' and move_name != 'Up':\n                    rejection_reason = 'Cannot enter FLOOR_UP_WALL except by moving Up'\n                elif next_type == 'LEDGE_HOP_DOWN' and move_name == 'Up':\n                    rejection_reason = 'Cannot move Up onto a LEDGE_HOP_DOWN'\n                elif next_type == 'LEDGE_HOP_LEFT' and move_name == 'Right':\n                    rejection_reason = 'Cannot move Right onto a LEDGE_HOP_LEFT'\n                elif next_type == 'LEDGE_HOP_RIGHT' and move_name == 'Left':\n                    rejection_reason = 'Cannot move Left onto a LEDGE_HOP_RIGHT'\n            \n            if rejection_reason:\n                debug_info['rejection_log'].append({'from': list(current_pos), 'to': list(next_pos), 'reason': rejection_reason})\n                continue\n            \n            tentative_g_score = g_score[current_pos] + 1\n            if tentative_g_score < g_score.get(next_pos, float('inf')):\n                came_from[next_pos] = current_pos\n                g_score[next_pos] = tentative_g_score\n                f_score[next_pos] = tentative_g_score + heuristic(next_pos, end)\n                if next_pos not in open_set_hash:\n                    heapq.heappush(open_set, (f_score[next_pos], next_pos))\n                    open_set_hash.add(next_pos)\n\n    blocked_at = None\n    if 'rejection_log' in debug_info and debug_info['rejection_log']:\n        last_rejection = debug_info['rejection_log'][-1]\n        if last_rejection['to'] == list(end):\n             blocked_at = last_rejection['to']\n\n    debug_info['error'] = 'No path found to destination.'\n    return None, None, blocked_at\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    \n    on_screen_impassable_str = input_data.get('on_screen_impassable_coordinates')\n    loaded_on_screen = json.loads(on_screen_impassable_str) if on_screen_impassable_str else []\n    on_screen_impassable = {tuple(map(int, coord)) for coord in loaded_on_screen} if loaded_on_screen else set()\n\n    extra_impassable_str = input_data.get('extra_impassable_coordinates')\n    loaded_extra = json.loads(extra_impassable_str) if extra_impassable_str else []\n    extra_impassable = {tuple(map(int, coord)) for coord in loaded_extra} if loaded_extra else set()\n    \n    debug_info = {\n        'inputs': {\n            'start': [start_x, start_y],\n            'end': [end_x, end_y],\n            'on_screen_impassable': [list(c) for c in on_screen_impassable],\n            'extra_impassable': [list(c) for c in extra_impassable]\n        }\n    }\n\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    \n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            grid[(x, y)] = {'type': tile.get('type')}\n\n    all_impassable = on_screen_impassable.union(extra_impassable)\n    \n    path, path_tile_types, blocked_at = find_path_a_star(grid, (start_x, start_y), (end_x, end_y), all_impassable, debug_info)\n    \n    print(json.dumps({'path': path if path else [], 'path_tile_types': path_tile_types, 'blocked_at': blocked_at, 'debug': debug_info}))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'path': [], 'path_tile_types': None, 'blocked_at': None, 'debug': {'error': f'An exception occurred: {str(e)}\\\n{traceback.format_exc()}'}}))\n"
  }
}