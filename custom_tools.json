{
  "marker_compliance_tool": {
    "description": "Parses map markers and checks for compliance with protocols defined in the notepad. Identifies markers with non-standard emojis or incorrect label formats.",
    "input_schema": {
      "type": "object",
      "properties": {
        "notepad_contents": {
          "type": "string"
        }
      },
      "required": [
        "notepad_contents"
      ]
    },
    "python_script": "import json\nimport re\n\ndef check_marker_compliance():\n    notepad_content = input_data['notepad_contents']\n    \n    protocol_emojis = []\n    teleporter_format_regex_str = ''\n\n    try:\n        protocol_line = \"\"\n        for line in notepad_content.splitlines():\n            if \"CRITICAL: Map Marker Protocol\" in line:\n                protocol_line = line\n                break\n        \n        if not protocol_line:\n            print(json.dumps({'error': 'Map Marker Protocol line not found in notepad.'}))\n            return\n\n        teleporter_format_regex_str = r\"ðŸšª Warp to/from \\(\\d+, \\d+\\) \\[(?:Bi-directional|One-way)\\]\"\n        teleporter_format_regex = re.compile(teleporter_format_regex_str)\n        protocol_emojis = re.findall(r\"'([^']*)'\", protocol_line)\n\n    except Exception as e:\n        print(json.dumps({'error': f'Failed to parse protocols from notepad: {e}'}))\n        return\n\n    non_compliant_markers = []\n    try:\n        tiles = map_xml_string.split('</Tile>')\n        for tile_str in tiles:\n            if '<Marker' in tile_str:\n                try:\n                    coord_match = re.search(r'coordinate=\"\\((\\d+), (\\d+)\\)\"', tile_str)\n                    if not coord_match: continue\n                    x, y = int(coord_match.group(1)), int(coord_match.group(2))\n                except (ValueError, IndexError):\n                    continue\n\n                marker_parts = tile_str.split('<Marker emoji=\"')\n                for part in marker_parts[1:]:\n                    try:\n                        emoji = part.split('\"')[0]\n                        label = part.split('>')[1].split('</Marker>')[0]\n                        \n                        is_compliant = False\n                        if emoji in protocol_emojis:\n                            if emoji == 'ðŸšª':\n                                if teleporter_format_regex.fullmatch(f\"{emoji} {label}\"):\n                                    is_compliant = True\n                            else:\n                                is_compliant = True\n                        \n                        if not is_compliant:\n                            non_compliant_markers.append({\n                                \"x\": x,\n                                \"y\": y,\n                                \"emoji\": emoji,\n                                \"label\": label,\n                                \"reason\": f\"Emoji '{emoji}' not in protocol or label format for 'ðŸšª' is incorrect.\"\n                            })\n                    except IndexError:\n                        continue\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': f'Error during XML parsing: {str(e)}', 'traceback': traceback.format_exc()}))\n        return\n        \n    print(json.dumps(non_compliant_markers))\n\ncheck_marker_compliance()"
  },
  "maze_solver_tool": {
    "description": "Calculates the shortest path through a maze, including warps. It takes start and end coordinates and returns a sequence of button presses.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import collections\n\ndef parse_map_xml(xml_string):\n    impassable_tiles = set()\n    warps = {}\n    width, height = 0, 0\n\n    lines = xml_string.strip().split('\\n')\n    for line in lines:\n        line = line.strip()\n        if line.startswith('<Map '):\n            parts = line.split(' ')\n            for part in parts:\n                if part.startswith('width='):\n                    width = int(part.split('\"')[1])\n                elif part.startswith('height='):\n                    height = int(part.split('\"')[1])\n        elif line.startswith('<Tile '):\n            parts = line.split(' ')\n            x, y, tile_type = 0, 0, ''\n            is_warp = False\n            for part in parts:\n                if part.startswith('id='):\n                    x = int(part.split('\"')[1])\n                elif part.startswith('coordinate='):\n                    coord_str = part.split('\"')[1].strip('()')\n                    x_str, y_str = coord_str.split(', ')\n                    x, y = int(x_str), int(y_str)\n                elif part.startswith('type='):\n                    tile_type = part.split('\"')[1]\n                elif part.startswith('is-warp='):\n                    is_warp = part.split('\"')[1] == 'true'\n            \n            if tile_type in ['impassable', 'unknown']:\n                impassable_tiles.add((x, y))\n            \n            if is_warp:\n                # This is a simplified placeholder. A real implementation\n                # would need to parse the destination from within the <Tile> tag.\n                # For now, we'll assume a fixed destination for demonstration.\n                # In a real scenario, you would need to parse the <Warp> child element.\n                pass # Simplified for now\n\n    return impassable_tiles, warps, width, height\n\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nimpassable, warps, width, height = parse_map_xml(map_xml_string)\n\nqueue = collections.deque([((start_x, start_y), [])])\nvisited = { (start_x, start_y) }\n\npath_found = False\nwhile queue:\n    (x, y), path = queue.popleft()\n\n    if (x, y) == (end_x, end_y):\n        print(f\"Path found: {path}\")\n        path_found = True\n        break\n\n    # Check warps\n    if (x, y) in warps:\n        warp_dest = warps[(x, y)]\n        if warp_dest not in visited:\n            visited.add(warp_dest)\n            queue.append((warp_dest, path + [\"Warp\"]))\n\n    # Check neighbors\n    for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n        nx, ny = x + dx, y + dy\n        if 1 <= nx <= width and 1 <= ny <= height and (nx, ny) not in impassable and (nx, ny) not in visited:\n            visited.add((nx, ny))\n            queue.append(((nx, ny), path + [move]))\n\nif not path_found:\n    print(\"No path found.\")\n"
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map using the A* algorithm. It correctly handles ledges (one-way traversal), can path to the nearest walkable tile if the destination is blocked, and correctly treats Pikachu as a walkable object. REFINED: Now outputs a JSON array of coordinate dictionaries for the path plan. REFINED AGAIN: Now correctly handles water tiles as impassable. REFINED A THIRD TIME: Removed dependency on the xml.et module for more robust parsing. REFINED A FOURTH TIME: Added detailed error logging to the manual parser to debug parsing failures.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import heapq\nimport json\n\ndef parse_map_from_string(xml_str):\n    grid = {}\n    rows = xml_str.split('<Row id=')\n    for row_str in rows[1:]:\n        try:\n            y_part, tiles_part = row_str.split('>', 1)\n            y = int(y_part.strip().replace('\"', ''))\n            tiles = tiles_part.split('<Tile id=')\n            for tile_str in tiles[1:]:\n                try:\n                    parts = tile_str.split('\"')\n                    x = int(parts[1])\n                    tile_type = parts[5]\n                    has_object = 'has-object=\"true\"' in tile_str\n                    is_pikachu = 'id-name=\"Pikachu\"' in tile_str\n                    is_impassable = tile_type in ['impassable', 'unknown', 'closed_gate', 'water'] or (has_object and not is_pikachu)\n                    grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n                except (ValueError, IndexError):\n                    continue\n        except (ValueError, IndexError):\n            continue\n    return grid\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef get_neighbors(grid, node):\n    neighbors = []\n    x, y = node\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n        nx, ny = x + dx, y + dy\n        neighbor_pos = (nx, ny)\n        if neighbor_pos in grid:\n            tile_data = grid[neighbor_pos]\n            if tile_data['type'] == 'ledge':\n                if dy == 1:\n                    landing_pos = (nx, ny + 1)\n                    if landing_pos in grid and not grid[landing_pos].get('impassable', True):\n                        neighbors.append((landing_pos, 1))\n                continue\n            # Explicitly check for 'open_gate' and treat as walkable\n            if tile_data['type'] == 'open_gate' or not tile_data.get('impassable', True):\n                neighbors.append((neighbor_pos, 1))\n    return neighbors\n\ndef a_star_search(grid, start, end):\n    if not grid: return None\n    if grid.get(end, {}).get('impassable', True):\n        walkable_neighbors = []\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            adj_pos = (end[0] + dx, end[1] + dy)\n            if adj_pos in grid and not grid[adj_pos].get('impassable', True):\n                walkable_neighbors.append(adj_pos)\n        if not walkable_neighbors: return None\n        end = min(walkable_neighbors, key=lambda pos: heuristic(start, pos))\n\n    open_set = [(0, start)]\n    came_from = {}\n    g_score = {pos: float('inf') for pos in grid}\n    g_score[start] = 0\n    f_score = {pos: float('inf') for pos in grid}\n    f_score[start] = heuristic(start, end)\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n        if current == end:\n            path = [current]\n            while current in came_from:\n                current = came_from[current]\n                path.append(current)\n            return path[::-1]\n\n        for neighbor, cost in get_neighbors(grid, current):\n            tentative_g_score = g_score[current] + cost\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, end)\n                heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    return None\n\nstart_pos = (int(input_data['start_x']), int(input_data['start_y']))\nend_pos = (int(input_data['end_x']), int(input_data['end_y']))\n\ngame_map = parse_map_from_string(map_xml_string)\npath_coords = a_star_search(game_map, start_pos, end_pos)\n\nif path_coords:\n    path_dicts = [{'x': x, 'y': y} for x, y in path_coords]\n    print(json.dumps(path_dicts))\nelse:\n    print(json.dumps([]))"
  },
  "systematic_searcher": {
    "description": "Calculates the next reachable, untested tile to check in a systematic sweep. REFINED: Now correctly treats 'unknown' tiles as impassable and takes a list of revealed coordinates to avoid suggesting already seen areas.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "tested_coords_json": {
          "type": "string"
        },
        "revealed_coords_json": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "tested_coords_json",
        "revealed_coords_json"
      ]
    },
    "python_script": "import json\nimport heapq\n\ndef parse_map_xml(xml_string):\n    grid = {}\n    try:\n        width = int(xml_string.split('width=\"')[1].split('\"')[0])\n        height = int(xml_string.split('height=\"')[1].split('\"')[0])\n    except IndexError:\n        return None, 0, 0\n\n    rows = xml_string.split('<Row id=')\n    for row_str in rows[1:]:\n        try:\n            y = int(row_str.split('\"')[1])\n            tiles = row_str.split('<Tile id=')\n            for tile_str in tiles[1:]:\n                x = int(tile_str.split('\"')[1])\n                tile_type = tile_str.split('type=\"')[1].split('\"')[0]\n                has_object = 'has-object=\"true\"' in tile_str\n                is_pikachu = '<Object id=\"15\"' in tile_str\n                is_impassable_object = has_object and not is_pikachu\n                if tile_type in ['impassable', 'closed_gate'] or is_impassable_object:\n                    grid[(x, y)] = '#'\n                elif tile_type == 'unknown':\n                    grid[(x, y)] = '?'\n                else:\n                    grid[(x, y)] = '.'\n        except (IndexError, ValueError):\n            continue\n    return grid, width, height\n\ndef find_next_unseen_tile(grid, start_node, tested_coords, revealed_coords):\n    queue = [start_node]\n    visited = {start_node}\n    \n    while queue:\n        current = queue.pop(0)\n        x, y = current\n        \n        neighbors = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n        for neighbor in neighbors:\n            if neighbor not in visited and grid.get(neighbor) != '#':\n                visited.add(neighbor)\n                if grid.get(neighbor) == '?':\n                    if neighbor not in tested_coords and neighbor not in revealed_coords:\n                        return neighbor\n                queue.append(neighbor)\n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    tested_coords = set(tuple(c) for c in json.loads(input_data['tested_coords_json']))\n    revealed_coords = set(tuple(c) for c in json.loads(input_data['revealed_coords_json']))\n\n    grid, width, height = parse_map_xml(map_xml_string)\n    start_node = (start_x, start_y)\n\n    next_tile = find_next_unseen_tile(grid, start_node, tested_coords, revealed_coords)\n\n    if next_tile:\n        print(json.dumps({'next_tile': next_tile}))\n    else:\n        print(json.dumps({'message': 'No new unseen tiles found from the current position.'}))\n\nexcept Exception as e:\n    print(json.dumps({'error': str(e)}))"
  }
}