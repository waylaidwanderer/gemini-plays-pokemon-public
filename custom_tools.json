{
  "maze_solver": {
    "description": "Solves invisible arrow tile mazes. It simulates movement from a starting point and explores the maze using a Breadth-First Search, returning the sequence of directional inputs to reach a target coordinate. It requires the map XML and a list of known arrow tile behaviors.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "arrow_tiles_json": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "arrow_tiles_json"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef parse_map(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    grid = [['' for _ in range(width + 2)] for _ in range(height + 2)]\n    impassable_types = ['WALL', 'COUNTER', 'MART_SHELF', 'PC', 'BOOKSHELF', 'HEADBUTT_TREE', 'CUT_TREE', 'TV', 'TOWN_MAP', 'WINDOW', 'RADIO', 'ROCK', 'BUOY', 'VOID']\n    \n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            \n            is_impassable = tile_type in impassable_types\n            if tile_elem.find('Object') is not None:\n                is_impassable = True\n\n            grid[y][x] = '#' if is_impassable else '.'\n            \n    return grid, width, height\n\ndef solve_maze(grid, width, height, start_x, start_y, end_x, end_y, move_outcomes):\n    q = deque([((start_x, start_y), [])])\n    visited = { (start_x, start_y) }\n    \n    while q:\n        (current_x, current_y), path = q.popleft()\n\n        if (current_x, current_y) == (end_x, end_y):\n            return path\n\n        moves = {'Up': (0, -1), 'Down': (0, 1), 'Left': (-1, 0), 'Right': (1, 0)}\n        \n        for move_name, (dx, dy) in moves.items():\n            start_pos_key = f\"{current_x},{current_y}\"\n            \n            if start_pos_key in move_outcomes and move_name in move_outcomes[start_pos_key]:\n                final_x, final_y = move_outcomes[start_pos_key][move_name]\n\n                if (final_x, final_y) not in visited:\n                    visited.add((final_x, final_y))\n                    new_path = path + [move_name]\n                    q.append(((final_x, final_y), new_path))\n\n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    arrow_tiles_json = input_data['arrow_tiles_json']\n    \n    move_outcomes = json.loads(arrow_tiles_json)\n\n    grid, width, height = parse_map(map_xml_string)\n\n    path = solve_maze(grid, width, height, start_x, start_y, end_x, end_y, move_outcomes)\n\n    if path:\n        print(json.dumps({\"status\": \"success\", \"path\": path}))\n    else:\n        print(json.dumps({\"status\": \"failure\", \"message\": \"No path found with the provided tile data. More exploration may be needed.\"}))\n\nexcept Exception as e:\n    print(json.dumps({\"status\": \"error\", \"message\": str(e)}))"
  },
  "pathfinder": {
    "description": "Finds the shortest path on the current map using A*. It automatically detects and avoids impassable tiles (including water if SURF is not available) and ALL on-screen objects/NPCs. This version can also be given a list of specific coordinates to avoid, such as known pitfalls.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "can_surf": {
          "type": "boolean",
          "default": false
        },
        "avoid_coords": {
          "type": "string",
          "description": "A JSON string of a list of [x, y] coordinates to avoid.",
          "default": "[]"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef parse_map_xml(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    grid = [['' for _ in range(width)] for _ in range(height)]\n    objects = []\n    one_way_tiles = {}\n    for y, row_elem in enumerate(root.findall('Row')):\n        for x, tile_elem in enumerate(row_elem.findall('Tile')):\n            tile_type = tile_elem.get('type')\n            grid[y][x] = tile_type if tile_type is not None else ''\n            if tile_elem.find('Object') is not None:\n                objects.append((x, y))\n            if tile_type and 'LEDGE_HOP' in tile_type:\n                if 'DOWN' in tile_type: one_way_tiles[(x, y)] = (0, 1)\n                elif 'LEFT' in tile_type: one_way_tiles[(x, y)] = (-1, 0)\n                elif 'RIGHT' in tile_type: one_way_tiles[(x, y)] = (1, 0)\n                elif 'UP' in tile_type: one_way_tiles[(x, y)] = (0, -1)\n    return grid, objects, one_way_tiles, width, height\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef get_neighbors(grid, node, one_way_tiles, width, height):\n    neighbors = []\n    x, y = node\n    if node in one_way_tiles:\n        dx, dy = one_way_tiles[node]\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < width and 0 <= ny < height:\n            if (nx, ny) in one_way_tiles:\n                ow_dx, ow_dy = one_way_tiles[(nx, ny)]\n                if (dx, dy) == (-ow_dx, -ow_dy):\n                    return []\n            neighbors.append((nx, ny))\n        return neighbors\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nx, ny = x + dx, y + dy\n        if not (0 <= nx < width and 0 <= ny < height):\n            continue\n        if (nx, ny) in one_way_tiles:\n            ow_dx, ow_dy = one_way_tiles[(nx, ny)]\n            if (dx, dy) == (-ow_dx, -ow_dy):\n                continue\n        neighbors.append((nx, ny))\n    return neighbors\n\ndef is_impassable(grid, pos, objects, impassable_tile_types, avoided_coords):\n    x, y = pos\n    if grid[y][x] in impassable_tile_types:\n        return True\n    if pos in objects or pos in avoided_coords:\n        return True\n    return False\n\ndef a_star(start, end, grid, objects, one_way_tiles, width, height, impassable_tile_types, avoided_coords):\n    open_set = []\n    heapq.heappush(open_set, (heuristic(start, end), start))\n    came_from = {}\n    g_score = { (x,y): float('inf') for x in range(width) for y in range(height) }\n    g_score[start] = 0\n    while open_set:\n        _, current = heapq.heappop(open_set)\n        if current == end:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            return path[::-1]\n        for neighbor in get_neighbors(grid, current, one_way_tiles, width, height):\n            if is_impassable(grid, neighbor, objects, impassable_tile_types, avoided_coords):\n                continue\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score_neighbor = tentative_g_score + heuristic(neighbor, end)\n                heapq.heappush(open_set, (f_score_neighbor, neighbor))\n    return None\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\ncan_surf = input_data.get('can_surf', 'false').lower() == 'true'\navoid_coords_json = input_data.get('avoid_coords', '[]')\navoided_coords = [tuple(coord) for coord in json.loads(avoid_coords_json)]\ngrid, objects, one_way_tiles, width, height = parse_map_xml(map_xml_string)\nstart_node = (start_x, start_y)\nend_node = (end_x, end_y)\nimpassable_tile_types = ['WALL', 'COUNTER', 'PC', 'BOOKSHELF', 'TV', 'ROCK', 'CUT_TREE', 'BOULDER', 'MART_SHELF', 'WARP', 'DOOR', 'STAIRS', 'LADDER', 'WARP_PANEL']\nif not can_surf:\n    impassable_tile_types.append('WATER')\npath = None\nif is_impassable(grid, end_node, objects, impassable_tile_types, avoided_coords):\n    possible_goals = get_neighbors(grid, end_node, one_way_tiles, width, height)\n    objects_for_adj_check = [obj for obj in objects if obj != start_node]\n    valid_adjacent_goals = [p for p in possible_goals if not is_impassable(grid, p, objects_for_adj_check, impassable_tile_types, avoided_coords)]\n    if valid_adjacent_goals:\n        valid_adjacent_goals.sort(key=lambda p: heuristic(start_node, p))\n        for new_end_node in valid_adjacent_goals:\n            pathfinding_objects = [obj for obj in objects if obj != start_node and obj != new_end_node]\n            path = a_star(start_node, new_end_node, grid, pathfinding_objects, one_way_tiles, width, height, impassable_tile_types, avoided_coords + [end_node])\n            if path:\n                break\nelse:\n    pathfinding_objects = [obj for obj in objects if obj != start_node and obj != end_node]\n    path = a_star(start_node, end_node, grid, pathfinding_objects, one_way_tiles, width, height, impassable_tile_types, avoided_coords)\nif path:\n    directions = []\n    for i in range(len(path) - 1):\n        x1, y1 = path[i]\n        x2, y2 = path[i+1]\n        if x2 > x1: directions.append('Right')\n        elif x2 < x1: directions.append('Left')\n        elif y2 > y1: directions.append('Down')\n        elif y2 < y1: directions.append('Up')\n    print(','.join(directions))\nelse:\n    print('No path found.')"
  },
  "puzzle_solver": {
    "description": "Solves Sokoban-style boulder puzzles. Takes optional start coordinates, but requires goal coordinates for the final boulder position. It uses a Breadth-First Search algorithm to find the optimal sequence of moves.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer",
          "nullable": true
        },
        "start_y": {
          "type": "integer",
          "nullable": true
        },
        "goal_x": {
          "type": "integer"
        },
        "goal_y": {
          "type": "integer"
        }
      },
      "required": [
        "goal_x",
        "goal_y"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\n\n# Parse map data\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\n\nwalls = set()\nboulders = []\nplayer_start = None\n\nfor r_idx, row_elem in enumerate(root.findall('Row')):\n    y = r_idx + 1\n    for t_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n        x = t_idx + 1\n        tile_type = tile_elem.get('type')\n        if tile_type == 'WALL':\n            walls.add((x, y))\n        if tile_elem.find('Object[@id-name=\"BOULDER\"]') is not None:\n            boulders.append((x, y))\n        if tile_elem.find('Player') is not None:\n            player_start = (x, y)\n\n# Override start position if provided\nif 'start_x' in input_data and input_data['start_x'] is not None:\n    player_start = (int(input_data['start_x']), int(input_data['start_y']))\n\ngoal_pos = (int(input_data['goal_x']), int(input_data['goal_y']))\n\n# --- BFS Solver ---\ninitial_state = (player_start, tuple(sorted(boulders)))\nqueue = collections.deque([(initial_state, [])])\nvisited = {initial_state}\n\npath_found = False\nwhile queue:\n    (current_player, current_boulders), path = queue.popleft()\n\n    # Check for goal state\n    if goal_pos in current_boulders:\n        print(f\"Solution found: {path}\")\n        path_found = True\n        break\n\n    # Explore neighbors\n    for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n        next_player_pos = (current_player[0] + dx, current_player[1] + dy)\n\n        # Simple move (no push)\n        if next_player_pos not in walls and next_player_pos not in current_boulders:\n            new_state = (next_player_pos, current_boulders)\n            if new_state not in visited:\n                visited.add(new_state)\n                queue.append((new_state, path + [move]))\n            continue\n\n        # Boulder push\n        if next_player_pos in current_boulders:\n            boulder_to_push = next_player_pos\n            next_boulder_pos = (boulder_to_push[0] + dx, boulder_to_push[1] + dy)\n\n            if next_boulder_pos not in walls and next_boulder_pos not in current_boulders:\n                new_boulders = list(current_boulders)\n                new_boulders.remove(boulder_to_push)\n                new_boulders.append(next_boulder_pos)\n                new_boulders_tuple = tuple(sorted(new_boulders))\n                \n                new_state = (next_player_pos, new_boulders_tuple)\n                if new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, path + [f\"Push {move}\"])) \n\nif not path_found:\n    print(\"No solution found.\")"
  },
  "dungeon_analyst": {
    "description": "Analyzes the connectivity of interconnected maps (like a dungeon) using their XML data. It builds a graph of all warps to identify partitioned areas, dead ends, and suggests an optimal exploration route to uncover the entire dungeon.",
    "input_schema": {
      "type": "object",
      "properties": {
        "maps": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "map_id": {
                "type": "string"
              },
              "map_xml": {
                "type": "string"
              }
            },
            "required": [
              "map_id",
              "map_xml"
            ]
          }
        }
      },
      "required": [
        "maps"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\nmaps_data = json.loads(input_data['maps'])\ngraph = {}\nmap_names = {m['map_id']: ET.fromstring(m['map_xml']).get('name') for m in maps_data}\n\nfor map_info in maps_data:\n    map_id = map_info['map_id']\n    root = ET.fromstring(map_info['map_xml'])\n    if map_id not in graph:\n        graph[map_id] = []\n    for warp in root.findall('.//Warp'):\n        dest_map_id = warp.get('dest_map_id')\n        if dest_map_id:\n            graph[map_id].append(dest_map_id)\n\n# Basic analysis for now, will be improved\nstart_map = maps_data[0]['map_id']\nqueue = [start_map]\nvisited = {start_map}\nexploration_route = [map_names[start_map]]\n\nwhile queue:\n    current_map = queue.pop(0)\n    for neighbor in graph.get(current_map, []):\n        if neighbor not in visited:\n            visited.add(neighbor)\n            queue.append(neighbor)\n            exploration_route.append(map_names[neighbor])\n\nall_maps = set(map_names.keys())\nunreachable = all_maps - visited\n\nanalysis = f\"Reachable maps: {[map_names[m] for m in visited]}. \"\nif unreachable:\n    analysis += f\"Unreachable maps: {[map_names[m] for m in unreachable]}.\"\nelse:\n    analysis += \"All maps are connected.\"\n\nprint(json.dumps({'connectivity_analysis': analysis, 'optimal_exploration_route': exploration_route}))"
  },
  "pathfinder_v2": {
    "description": "Finds the shortest path on the current map using a new A* implementation. It avoids impassable tiles, and a user-provided list of coordinates to avoid (for handling off-screen or specific NPCs).",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "can_surf": {
          "type": "boolean",
          "default": false
        },
        "avoid_coords": {
          "type": "string",
          "description": "A JSON string of a list of [x, y] coordinates to avoid.",
          "default": "[]"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef pathfinder_v2(map_xml_string, start_x, start_y, end_x, end_y, can_surf=False, avoid_coords_str='[]'):\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.attrib['width'])\n    map_height = int(root.attrib['height'])\n    impassable_types = {'WALL', 'COUNTER', 'MART_SHELF', 'PC', 'BOOKSHELF', 'HEADBUTT_TREE', 'CUT_TREE', 'TV', 'TOWN_MAP', 'WINDOW', 'ROCK', 'BUOY', 'VOID'}\n    if not can_surf:\n        impassable_types.add('WATER')\n        impassable_types.add('SEA')\n    # Grid is 0-indexed, matching the XML data's 'id' attributes.\n    grid = [[0 for _ in range(map_width)] for _ in range(map_height)]\n    for row in root.findall('Row'):\n        # XML 'id' attributes are 0-indexed strings.\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            if tile.attrib.get('type') in impassable_types:\n                grid[y][x] = 1\n    # Convert 1-indexed input avoid_coords to 0-indexed for the grid.\n    avoid_coords = json.loads(avoid_coords_str)\n    for x, y in avoid_coords:\n        if 1 <= y <= map_height and 1 <= x <= map_width:\n            grid[y - 1][x - 1] = 1\n    # Convert 1-indexed start/end coordinates to 0-indexed for the algorithm.\n    start_node = (start_x - 1, start_y - 1)\n    goal_node = (end_x - 1, end_y - 1)\n    if not (0 <= start_node[0] < map_width and 0 <= start_node[1] < map_height and 0 <= goal_node[0] < map_width and 0 <= goal_node[1] < map_height):\n        return None\n    if grid[goal_node[1]][goal_node[0]] == 1 or grid[start_node[1]][start_node[0]] == 1:\n        return None\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    open_set = []\n    came_from = {}\n    g_score = { (x,y): float('inf') for x in range(map_width) for y in range(map_height) }\n    g_score[start_node] = 0\n    f_score = { (x,y): float('inf') for x in range(map_width) for y in range(map_height) }\n    f_score[start_node] = heuristic(start_node, goal_node)\n    heapq.heappush(open_set, (f_score[start_node], start_node))\n    while open_set:\n        _, current = heapq.heappop(open_set)\n        if current == goal_node:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(current)\n            return path[::-1]\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < map_width and 0 <= neighbor[1] < map_height):\n                continue\n            if grid[neighbor[1]][neighbor[0]] == 1:\n                continue\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal_node)\n                heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    return None\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    can_surf = input_data.get('can_surf', 'false').lower() == 'true'\n    avoid_coords_str = input_data.get('avoid_coords', '[]')\n    path = pathfinder_v2(map_xml_string, start_x, start_y, end_x, end_y, can_surf, avoid_coords_str)\n    if path:\n        directions = []\n        for i in range(len(path) - 1):\n            x1, y1 = path[i]\n            x2, y2 = path[i+1]\n            if x2 > x1: directions.append('Right')\n            elif x2 < x1: directions.append('Left')\n            elif y2 > y1: directions.append('Down')\n            elif y2 < y1: directions.append('Up')\n        print(json.dumps(directions))\n    else:\n        print(json.dumps(None))\nexcept Exception as e:\n    print(json.dumps(f\"Error: {str(e)}\"))"
  }
}