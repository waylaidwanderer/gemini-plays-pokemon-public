{
  "path_analyzer": {
    "description": "Finds a path using BFS on the current map XML, handling one-way ledges (LEDGE_HOP_DOWN), slopes (FLOOR_UP_WALL), and water. Returns a JSON array of button strings. v3.2",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "ignore_objects": {
          "type": "boolean",
          "default": false
        },
        "allow_water": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\nimport sys\n\ndef find_path(xml_str, start_x, start_y, target_x, target_y, ignore_objects=False, allow_water=False):\n    try:\n        root = ET.fromstring(xml_str)\n    except Exception:\n        return []\n        \n    grid = {}\n    traversable_types = ['FLOOR', 'DOOR', 'LEDGE_HOP_DOWN', 'FLOOR_UP_WALL', 'WARP_CARPET_DOWN', 'unseen']\n    if allow_water:\n        traversable_types.append('WATER')\n        \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tile_type = tile.attrib['type']\n            has_object = tile.attrib.get('has-object') == 'true'\n            traversable = tile_type in traversable_types\n            if not ignore_objects and has_object:\n                traversable = False\n            grid[(x, y)] = (traversable, tile_type)\n\n    queue = deque([(start_x, start_y, [])])\n    visited = set([(start_x, start_y)])\n    \n    while queue:\n        cx, cy, path = queue.popleft()\n        if (cx, cy) == (target_x, target_y):\n            return path\n            \n        _, curr_ttype = grid.get((cx, cy), (False, 'WALL'))\n        \n        for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) in grid:\n                traversable, target_ttype = grid[(nx, ny)]\n                can_move = False\n                if traversable:\n                    can_move = True\n                    # Leaving current tile\n                    if curr_ttype == 'LEDGE_HOP_DOWN' and move != 'Down':\n                        can_move = False\n                    if curr_ttype == 'FLOOR_UP_WALL' and move != 'Up':\n                        can_move = False\n                        \n                    # Entering target tile\n                    if target_ttype == 'LEDGE_HOP_DOWN' and move != 'Down':\n                        can_move = False\n                    if target_ttype == 'FLOOR_UP_WALL' and move != 'Up':\n                        can_move = False\n                \n                if can_move and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [move]))\n    return []\n\nraw_input = sys.stdin.read()\nif not raw_input:\n    print(json.dumps([]))\n    sys.exit(0)\n\ntry:\n    input_data = json.loads(raw_input)\n    path = find_path(map_xml_string, int(input_data['start_x']), int(input_data['start_y']), int(input_data['target_x']), int(input_data['target_y']), input_data.get('ignore_objects', False), input_data.get('allow_water', False))\n    print(json.dumps(path))\nexcept Exception:\n    print(json.dumps([]))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-16T05:15:05.934Z",
        "action_counter": 50221
      },
      {
        "commit_message": "Initial creation of path_analyzer tool.",
        "timestamp": "2026-01-16T06:26:27.167Z",
        "action_counter": 50342
      },
      {
        "commit_message": "Refined input handling in path_analyzer to prevent JSONDecodeError. Added sys.stdin.read() check.",
        "timestamp": "2026-01-16T06:28:11.692Z",
        "action_counter": 50348
      },
      {
        "commit_message": "Fixed path_analyzer to return an empty array instead of null when no path is found, preventing tool execution errors.",
        "timestamp": "2026-01-16T06:33:16.036Z",
        "action_counter": 50360
      },
      {
        "commit_message": "Added allow_water parameter and fixed input_data handling.",
        "timestamp": "2026-01-16T06:38:17.802Z",
        "action_counter": 50368
      },
      {
        "commit_message": "Fixed missing input_data definition in path_analyzer.",
        "timestamp": "2026-01-16T06:38:37.665Z",
        "action_counter": 50369
      },
      {
        "commit_message": "Refined traversal logic for ledges and slopes in path_analyzer.",
        "timestamp": "2026-01-16T06:40:42.264Z",
        "action_counter": 50372
      },
      {
        "commit_message": "Updated path_analyzer to treat 'unseen' tiles as traversable for planning purposes.",
        "timestamp": "2026-01-16T06:46:52.048Z",
        "action_counter": 50377
      },
      {
        "commit_message": "Refined traversal logic for ledges and slopes in path_analyzer v3.1.",
        "timestamp": "2026-01-16T06:52:21.698Z",
        "action_counter": 50384
      },
      {
        "commit_message": "Refined traversal logic for ledges and slopes in path_analyzer v3.1.",
        "timestamp": "2026-01-16T06:57:42.816Z",
        "action_counter": 50392
      },
      {
        "commit_message": "Refined ledge and terrace logic to strictly enforce one-way movement. Added logic to prevent leaving or entering LEDGE_HOP_DOWN except via Down, and FLOOR_UP_WALL except via Up.",
        "timestamp": "2026-01-16T18:57:33.743Z",
        "action_counter": 51304
      }
    ]
  },
  "surf_navigator": {
    "description": "Navigates water areas by avoiding buoys and identifying landing spots. Prints a JSON array of button strings. v2.0",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef solve(input_data):\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    start_pos = None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            grid[(x, y)] = tile\n            if tile.find('Player') is not None:\n                start_pos = (x, y)\n\n    if start_pos is None: return [\"Error: Player not found on map\"]\n    \n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    \n    queue = deque([(start_pos[0], start_pos[1], [])])\n    visited = {start_pos}\n    \n    while queue:\n        x, y, path = queue.popleft()\n        if (x, y) == (target_x, target_y):\n            return path\n            \n        for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) not in grid: continue\n            tile = grid[(nx, ny)]\n            t_type = tile.attrib['type']\n            \n            # Avoid buoys and walls\n            if t_type in ['BUOY', 'WALL']: continue\n            \n            # Check for objects\n            if tile.find('Object') is not None: continue\n            \n            if (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, path + [move]))\n    return [\"No path found\"]\n\nprint(json.dumps(solve(input_data)))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-16T13:08:32.733Z",
        "action_counter": 50922
      },
      {
        "commit_message": "Removed hardcoded start position. Now takes target_x and target_y and assumes start is current player position.",
        "timestamp": "2026-01-16T13:14:31.671Z",
        "action_counter": 50927
      }
    ]
  }
}