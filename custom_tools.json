{
  "path_master": {
    "description": "Finds the shortest path on the current map using A*. Avoids impassable tiles, objects, and defeated trainer markers.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\nmap_xml_string = globals().get(\"map_xml_string\")\nroot = ET.fromstring(map_xml_string)\nmap_width = int(root.attrib['width'])\nmap_height = int(root.attrib['height'])\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\nstart_node = (start_x, start_y)\nend_node = (end_x, end_y)\n\nimpassable = set()\nfor row in root.findall('Row'):\n    y = int(row.attrib['id'])\n    for tile in row.findall('Tile'):\n        x = int(tile.attrib['id'])\n        tile_type = tile.attrib['type']\n        \n        is_impassable = False\n        if tile_type in ['WALL', 'VOID', 'PILLAR', 'COUNTER', 'MART_SHELF', 'BOOKSHELF', 'TV', 'RADIO', 'PC', 'TOWN_MAP', 'WINDOW', 'PAINTING', 'CUT_TREE', 'WATER', 'BUOY']:\n            is_impassable = True\n        if tile.find('Object') is not None:\n            is_impassable = True\n        for marker in tile.findall('Marker'):\n            if marker.attrib.get('emoji') == '☠️':\n                is_impassable = True\n                break\n\n        if is_impassable:\n            impassable.add((x, y))\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\nopen_set = []\nheapq.heappush(open_set, (0, start_node))\ncame_from = {}\ng_score = {start_node: 0}\nf_score = {start_node: heuristic(start_node, end_node)}\n\npath_found = False\nwhile open_set:\n    _, current = heapq.heappop(open_set)\n\n    if current == end_node:\n        path = []\n        while current in came_from:\n            path.append(f\"{current[0]},{current[1]}\")\n            current = came_from[current]\n        path.append(f\"{start_node[0]},{start_node[1]}\")\n        print(','.join(path[::-1]))\n        path_found = True\n        break\n\n    neighbors = []\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        neighbor = (current[0] + dx, current[1] + dy)\n        nx, ny = neighbor\n\n        if not (0 < nx <= map_width and 0 < ny <= map_height):\n            continue\n        if neighbor in impassable:\n            continue\n        \n        neighbors.append(neighbor)\n\n    for neighbor in neighbors:\n        tentative_g_score = g_score.get(current, float('inf')) + 1\n        if tentative_g_score < g_score.get(neighbor, float('inf')):\n            came_from[neighbor] = current\n            g_score[neighbor] = tentative_g_score\n            f_score[neighbor] = tentative_g_score + heuristic(neighbor, end_node)\n            if neighbor not in [i[1] for i in open_set]:\n                heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\nif not path_found:\n    print(\"No path found\")"
  },
  "unstick_me_tool": {
    "description": "Analyzes the map XML to find the nearest traversable tile adjacent to an 'unseen' area. Returns coordinates for a new navigation goal. Can also check for softlock conditions by analyzing warp connectivity.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport collections\n\ndef run_unstick_me_tool(start_x_str, start_y_str):\n    start_x, start_y = int(start_x_str), int(start_y_str)\n\n    try:\n        root = ET.fromstring(map_xml_string)\n        map_id = root.get('name')\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n    except ET.ParseError as e:\n        print(f\"Error parsing map_xml_string: {e}\")\n        return\n\n    grid = [['VOID' for _ in range(width + 1)] for _ in range(height + 1)]\n    objects = set()\n    unseen_tiles = []\n    warps = []\n\n    impassable_types = {'WALL', 'WATER', 'CUT_TREE', 'BUOY', 'TOWN_MAP', 'WINDOW', 'BOOKSHELF', 'TV', 'RADIO', 'VOID', 'MART_SHELF', 'COUNTER', 'PC', 'HEADBUTT_TREE', 'PILLAR'}\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            grid[y][x] = tile_type\n            if tile_elem.get('seen') == 'false':\n                unseen_tiles.append((x, y))\n            if tile_elem.find('Object') is not None:\n                objects.add((x, y))\n            if tile_elem.get('is-warp') == 'true':\n                warps.append((x, y))\n\n    def is_traversable(x, y):\n        if not (0 <= x < width and 0 <= y < height):\n            return False\n        return grid[y][x] not in impassable_types and (x, y) not in objects\n\n    # 1. Find nearest unseen tile\n    queue = collections.deque([((start_x, start_y), [])])\n    visited = {(start_x, start_y)}\n\n    while queue:\n        (x, y), path = queue.popleft()\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if is_traversable(nx, ny) and (nx, ny) not in visited:\n                if (nx, ny) in unseen_tiles:\n                    print(json.dumps({'status': 'unseen_found', 'goal': {'x': x, 'y': y}, 'path_to_goal': path + [(x,y)]}))\n                    return\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [(x, y)]))\n\n    # 2. If no unseen tiles are reachable, check for warp softlock\n    try:\n        wkg = json.loads(world_knowledge_graph_json_string)\n    except json.JSONDecodeError:\n        print(json.dumps({'status': 'error', 'message': 'Could not parse World Knowledge Graph.'}))\n        return\n\n    reachable_warps = []\n    for warp_x, warp_y in warps:\n        # Simple check if warp is adjacent to a visited tile\n        for vx, vy in visited:\n            if abs(vx - warp_x) + abs(vy - warp_y) == 1:\n                reachable_warps.append((warp_x, warp_y))\n                break\n\n    if not reachable_warps:\n        print(json.dumps({'status': 'softlocked', 'message': 'No reachable unseen tiles or warps found on this map.'}))\n        return\n\n    # Check if any reachable warps lead to a new map\n    current_map_nodes = {node['id']: node for node in wkg['nodes'] if node['map_id'] == map_id}\n    \n    for warp_x, warp_y in reachable_warps:\n        for node_id, node in current_map_nodes.items():\n            if node['coordinates']['x'] == warp_x and node['coordinates']['y'] == warp_y:\n                for edge in wkg['edges']:\n                    if edge['source_node_id'] == node_id:\n                        dest_node_id = edge['destination_node_id']\n                        dest_node = next((n for n in wkg['nodes'] if n['id'] == dest_node_id), None)\n                        if dest_node and dest_node['map_id'] != map_id:\n                            print(json.dumps({'status': 'warp_found', 'goal': {'x': warp_x, 'y': warp_y}, 'destination_map': dest_node['map_id']}))\n                            return\n\n    print(json.dumps({'status': 'no_escape', 'message': 'Reachable warps found, but none appear to lead to a new map according to the World Knowledge Graph.'}))\n\nrun_unstick_me_tool(input_data['start_x'], input_data['start_y'])"
  }
}