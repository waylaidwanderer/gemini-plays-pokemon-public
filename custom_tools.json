{
  "path_executor": {
    "description": "Executes a path provided by a pathfinding tool. Takes a JSON string of coordinates, the player's current coordinates, and the final destination. It provides the next single move (e.g., 'Up', 'Down') or confirms arrival. It can re-plan if interrupted.",
    "input_schema": {
      "type": "object",
      "properties": {
        "path_json": {
          "type": "string"
        },
        "player_x": {
          "type": "integer"
        },
        "player_y": {
          "type": "integer"
        },
        "destination_x": {
          "type": "integer"
        },
        "destination_y": {
          "type": "integer"
        }
      },
      "required": [
        "path_json",
        "player_x",
        "player_y",
        "destination_x",
        "destination_y"
      ]
    },
    "python_script": "import json\n\npath_json = input_data['path_json']\nplayer_x = int(input_data['player_x'])\nplayer_y = int(input_data['player_y'])\ndestination_x = int(input_data['destination_x'])\ndestination_y = int(input_data['destination_y'])\n\npath = json.loads(path_json)\n\nif not path:\n    print(json.dumps({'action': 'REPLAN', 'reason': 'Path is empty.'}))\n    exit()\n\n# Check for arrival first\nif player_x == destination_x and player_y == destination_y:\n    print(json.dumps({'action': 'ARRIVED'}))\n    exit()\n\n# Find the player's current index in the path\ncurrent_index = -1\nfor i, step in enumerate(path):\n    if step['x'] == player_x and step['y'] == player_y:\n        current_index = i\n        break\n\n# If player is not on the path, replan\nif current_index == -1:\n    print(json.dumps({'action': 'REPLAN', 'reason': 'Player is not on the planned path.'}))\n    exit()\n\n# If the player is at the last step of the path, but not the destination, they have arrived at the path's end\nif current_index + 1 >= len(path):\n    # This can happen if the path leads to a tile adjacent to an impassable destination\n    print(json.dumps({'action': 'ARRIVED'}))\n    exit()\n\n# Determine the next move\nnext_step = path[current_index + 1]\nnext_x = next_step['x']\nnext_y = next_step['y']\n\nnext_move = ''\nif next_x > player_x:\n    next_move = 'Right'\nelif next_x < player_x:\n    next_move = 'Left'\nelif next_y > player_y:\n    next_move = 'Down'\nelif next_y < player_y:\n    next_move = 'Up'\n\nif not next_move:\n    # This case should ideally not happen if the path is valid, but as a fallback\n    print(json.dumps({'action': 'REPLAN', 'reason': 'Cannot determine next move from current position.'}))\nelse:\n    print(json.dumps({'action': 'MOVE', 'next_move': next_move}))\n"
  },
  "pathfinder": {
    "description": "Finds the shortest path between two points on the current map using the A* algorithm. It considers specified traversable tiles and avoids obstacles, including on-screen NPCs, defeated trainers marked with '☠️', and any additional obstacles provided via a JSON string. It correctly handles one-way ledges.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "traversable_tiles": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "obstacles_json": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "traversable_tiles"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\nimport json\n\ndef find_path(start_x, start_y, end_x, end_y, traversable_tiles, xml_string, obstacles_json):\n    root = ET.fromstring(xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = {}\n    obstacles = set()\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            coord = (x, y)\n            grid[coord] = tile_elem.get('type')\n            obj_elem = tile_elem.find('Object')\n            if obj_elem is not None and obj_elem.get('id-name') is not None:\n                obstacles.add(coord)\n            for marker_elem in tile_elem.findall('Marker'):\n                if marker_elem.get('emoji') == '☠️':\n                    obstacles.add(coord)\n\n    if obstacles_json:\n        try:\n            additional_obstacles = json.loads(obstacles_json)\n            for obs in additional_obstacles:\n                obstacles.add((int(obs['x']), int(obs['y'])))\n        except (json.JSONDecodeError, KeyError, TypeError) as e:\n            pass\n\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n\n    potential_goals = []\n    if grid.get(end_node) in traversable_tiles and end_node not in obstacles:\n        potential_goals.append(end_node)\n    else:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_node = (end_node[0] + dx, end_node[1] + dy)\n            if grid.get(adj_node) in traversable_tiles and adj_node not in obstacles:\n                potential_goals.append(adj_node)\n\n    if not potential_goals:\n        return json.dumps({'error': 'No traversable destination or adjacent tile found.'})\n\n    shortest_path = None\n    for goal_node in potential_goals:\n        path = a_star(start_node, goal_node, grid, obstacles, width, height, traversable_tiles)\n        if path:\n            if shortest_path is None or len(path) < len(shortest_path):\n                shortest_path = path\n\n    if shortest_path:\n        return json.dumps([{'x': x, 'y': y} for x, y in shortest_path])\n    else:\n        return json.dumps({'error': 'No path found.'})\n\ndef a_star(start, goal, grid, obstacles, width, height, traversable_tiles):\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {start: 0}\n    f_score = {start: abs(start[0] - goal[0]) + abs(start[1] - goal[1])}\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == goal:\n            path = []\n            node = current\n            while node in came_from:\n                path.append(node)\n                node = came_from[node]\n            path.append(start)\n            return path[::-1]\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n\n            if not (1 <= neighbor[0] <= width and 1 <= neighbor[1] <= height):\n                continue\n\n            neighbor_tile_type = grid.get(neighbor, 'WALL')\n            if neighbor_tile_type not in traversable_tiles or neighbor in obstacles:\n                continue\n            \n            # Corrected Ledge Logic\n            if 'LEDGE_HOP_DOWN' in neighbor_tile_type and dy == -1: # Trying to move UP onto a DOWN ledge\n                continue\n            if 'LEDGE_HOP_LEFT' in neighbor_tile_type and dx == 1: # Trying to move RIGHT onto a LEFT ledge\n                continue\n            if 'LEDGE_HOP_RIGHT' in neighbor_tile_type and dx == -1: # Trying to move LEFT onto a RIGHT ledge\n                continue\n\n            tentative_g_score = g_score.get(current, float('inf')) + 1\n\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + (abs(neighbor[0] - goal[0]) + abs(neighbor[1] - goal[1]))\n                if neighbor not in [item[1] for item in open_set]:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    return None\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\ntraversable_tiles = input_data['traversable_tiles']\nobstacles_json = input_data.get('obstacles_json')\n\nresult = find_path(start_x, start_y, end_x, end_y, traversable_tiles, map_xml_string, obstacles_json)\nprint(result)"
  },
  "puzzle_solver": {
    "description": "Solves Sokoban-style boulder puzzles. Takes optional start coordinates, but requires goal coordinates for the final boulder position. It uses a Breadth-First Search algorithm to find the optimal sequence of moves.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer",
          "nullable": true
        },
        "start_y": {
          "type": "integer",
          "nullable": true
        },
        "goal_x": {
          "type": "integer"
        },
        "goal_y": {
          "type": "integer"
        }
      },
      "required": [
        "goal_x",
        "goal_y"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\n\n# Parse map data\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\n\nwalls = set()\nboulders = []\nplayer_start = None\n\nfor r_idx, row_elem in enumerate(root.findall('Row')):\n    y = r_idx + 1\n    for t_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n        x = t_idx + 1\n        tile_type = tile_elem.get('type')\n        if tile_type == 'WALL':\n            walls.add((x, y))\n        if tile_elem.find('Object[@id-name=\"BOULDER\"]') is not None:\n            boulders.append((x, y))\n        if tile_elem.find('Player') is not None:\n            player_start = (x, y)\n\n# Override start position if provided\nif 'start_x' in input_data and input_data['start_x'] is not None:\n    player_start = (int(input_data['start_x']), int(input_data['start_y']))\n\ngoal_pos = (int(input_data['goal_x']), int(input_data['goal_y']))\n\n# --- BFS Solver ---\ninitial_state = (player_start, tuple(sorted(boulders)))\nqueue = collections.deque([(initial_state, [])])\nvisited = {initial_state}\n\npath_found = False\nwhile queue:\n    (current_player, current_boulders), path = queue.popleft()\n\n    # Check for goal state\n    if goal_pos in current_boulders:\n        print(f\"Solution found: {path}\")\n        path_found = True\n        break\n\n    # Explore neighbors\n    for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n        next_player_pos = (current_player[0] + dx, current_player[1] + dy)\n\n        # Simple move (no push)\n        if next_player_pos not in walls and next_player_pos not in current_boulders:\n            new_state = (next_player_pos, current_boulders)\n            if new_state not in visited:\n                visited.add(new_state)\n                queue.append((new_state, path + [move]))\n            continue\n\n        # Boulder push\n        if next_player_pos in current_boulders:\n            boulder_to_push = next_player_pos\n            next_boulder_pos = (boulder_to_push[0] + dx, boulder_to_push[1] + dy)\n\n            if next_boulder_pos not in walls and next_boulder_pos not in current_boulders:\n                new_boulders = list(current_boulders)\n                new_boulders.remove(boulder_to_push)\n                new_boulders.append(next_boulder_pos)\n                new_boulders_tuple = tuple(sorted(new_boulders))\n                \n                new_state = (next_player_pos, new_boulders_tuple)\n                if new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, path + [f\"Push {move}\"])) \n\nif not path_found:\n    print(\"No solution found.\")"
  },
  "sokoban_solver": {
    "description": "Solves complex Sokoban-style boulder puzzles with multiple boulders. It models the player and all boulders as a combined state and uses a Breadth-First Search algorithm to find the shortest sequence of pushes to clear a path for the player to a target destination.",
    "input_schema": {
      "type": "object",
      "properties": {
        "player_start_x": {
          "type": "integer"
        },
        "player_start_y": {
          "type": "integer"
        },
        "player_goal_x": {
          "type": "integer"
        },
        "player_goal_y": {
          "type": "integer"
        }
      },
      "required": [
        "player_start_x",
        "player_start_y",
        "player_goal_x",
        "player_goal_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\n# --- Helper Functions ---\ndef parse_map_xml(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    grid = [['' for _ in range(width)] for _ in range(height)]\n    boulders = []\n    player_pos = None\n\n    for y, row_elem in enumerate(root.findall('Row')):\n        for x, tile_elem in enumerate(row_elem.findall('Tile')):\n            grid[y][x] = tile_elem.attrib['type']\n            if tile_elem.find('Player') is not None:\n                player_pos = (x, y)\n            if tile_elem.find('Object[@id-name=\"BOULDER\"]') is not None:\n                boulders.append((x, y))\n    return grid, tuple(sorted(boulders)), player_pos, width, height\n\ndef is_valid_move(grid, x, y, width, height):\n    return 0 <= x < width and 0 <= y < height and grid[y][x] not in ['WALL', 'COUNTER', 'PC', 'MART_SHELF', 'ROCK_SMASH_BOULDER', 'TREE']\n\n# --- Main Solver Logic ---\n\n# Parse Inputs\nplayer_start_x = int(input_data['player_start_x']) - 1\nplayer_start_y = int(input_data['player_start_y']) - 1\nplayer_goal_x = int(input_data['player_goal_x']) - 1\nplayer_goal_y = int(input_data['player_goal_y']) - 1\n\n# Parse Map\ngrid, initial_boulders, _, width, height = parse_map_xml(map_xml_string)\n\n# BFS Initialization\ninitial_state = ((player_start_x, player_start_y), initial_boulders)\nqueue = deque([(initial_state, [])])\nvisited = {initial_state}\n\npath_found = False\n\nwhile queue:\n    (current_pos, current_boulders), path = queue.popleft()\n    px, py = current_pos\n\n    if (px, py) == (player_goal_x, player_goal_y):\n        print(f'{{\"status\": \"success\", \"path\": {path}}}')\n        path_found = True\n        break\n\n    for move, (dx, dy) in {'Up': (0, -1), 'Down': (0, 1), 'Left': (-1, 0), 'Right': (1, 0)}.items():\n        nx, ny = px + dx, py + dy\n\n        if not is_valid_move(grid, nx, ny, width, height):\n            continue\n\n        # Case 1: Move to an empty space\n        if (nx, ny) not in current_boulders:\n            new_state = ((nx, ny), current_boulders)\n            if new_state not in visited:\n                visited.add(new_state)\n                queue.append((new_state, path + [move]))\n            continue\n\n        # Case 2: Push a boulder\n        boulder_to_push = (nx, ny)\n        push_to_x, push_to_y = nx + dx, ny + dy\n\n        if is_valid_move(grid, push_to_x, push_to_y, width, height) and (push_to_x, push_to_y) not in current_boulders:\n            new_boulders = list(current_boulders)\n            new_boulders.remove(boulder_to_push)\n            new_boulders.append((push_to_x, push_to_y))\n            new_boulders_tuple = tuple(sorted(new_boulders))\n\n            # Player moves into the boulder's old spot\n            new_player_pos = (nx, ny)\n            new_state = (new_player_pos, new_boulders_tuple)\n\n            if new_state not in visited:\n                visited.add(new_state)\n                # The action is a 'Push' followed by the direction\n                queue.append((new_state, path + [f'Push {move}']))\n\nif not path_found:\n    print('{\"status\": \"failure\", \"reason\": \"No solution found\"}')"
  }
}