{
  "object_finder": {
    "description": "Finds a specific map object by its ID and returns its coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "object_id": {
          "type": "string"
        }
      },
      "required": [
        "object_id"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntarget_id = input_data['object_id']\nroot = ET.fromstring(map_xml_string)\nfound = False\nfor row in root.findall('Row'):\n    y = row.get('id')\n    for tile in row.findall('Tile'):\n        x = tile.get('id')\n        for obj in tile.findall('Object'):\n            if obj.get('id') == target_id:\n                print(json.dumps({'x': x, 'y': y}))\n                found = True\n                break\n        if found:\n            break\n    if found:\n        break\n\nif not found:\n    print(json.dumps({'error': 'Object not found on screen.'}))"
  },
  "impassable_tile_scanner": {
    "description": "Scans the current map and returns a list of all impassable coordinates, including walls and all objects.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\nroot = ET.fromstring(map_xml_string)\nimpassable_coords = []\n\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.attrib['id'])\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.attrib['id'])\n        tile_type = tile_elem.attrib['type']\n        has_object = tile_elem.find('Object') is not None\n        \n        if tile_type == 'WALL' or has_object:\n            impassable_coords.append({'x': x, 'y': y})\n\nprint(json.dumps(impassable_coords))"
  },
  "smart_pathfinder": {
    "description": "A more robust pathfinder. It automatically avoids all on-screen objects and finds the nearest valid start tile if the player's current position is on a non-traversable tile. It now treats all ledge-type tiles as impassable to prevent generating invalid paths.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "traversable_tiles": {
          "type": "string"
        },
        "on_screen_objects": {
          "type": "string",
          "description": "A JSON string of a list of objects currently on screen, e.g., '[{\"id\": 6, \"position\": {\"x\": 21, \"y\": 12}}]'"
        },
        "debug": {
          "type": "string",
          "description": "Optional. Set to 'true' to enable debug logging."
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "traversable_tiles",
        "on_screen_objects"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\nimport sys\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef find_path_on_graph(start_node, end_node, graph, debug=False):\n    open_set = []\n    heapq.heappush(open_set, (0, start_node))\n    came_from = {}\n    g_score = {node: float('inf') for node in graph}\n    g_score[start_node] = 0\n    f_score = {node: float('inf') for node in graph}\n    f_score[start_node] = heuristic(start_node, end_node)\n\n    if debug:\n        print(f\"Pathfinding from {start_node} to {end_node}...\")\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == end_node:\n            path = []\n            temp = current\n            while temp in came_from:\n                path.append(temp)\n                temp = came_from[temp]\n            path.append(start_node)\n            path.reverse()\n            return path\n\n        for neighbor, weight in graph.get(current, {}).items():\n            tentative_g_score = g_score[current] + weight\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + heuristic(neighbor, end_node)\n                if neighbor not in [i[1] for i in open_set]:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    base_traversable_tiles = {tile.strip() for tile in input_data.get('traversable_tiles', '').split(',')}\n    on_screen_objects_str = input_data.get('on_screen_objects', '[]')\n    debug = input_data.get('debug', 'false').lower() == 'true'\n\n    root = ET.fromstring(map_xml_string)\n    \n    impassable_from_objects = set()\n    try:\n        on_screen_objects = json.loads(on_screen_objects_str)\n        for obj in on_screen_objects:\n            pos = obj.get('position')\n            if pos and 'x' in pos and 'y' in pos:\n                impassable_from_objects.add((int(pos['x']), int(pos['y'])))\n    except json.JSONDecodeError:\n        if debug:\n            print(\"Warning: Could not decode on_screen_objects JSON.\")\n    \n    if debug:\n        print(f\"Impassable from on-screen objects: {impassable_from_objects}\")\n\n    graph = {}\n    all_nodes = set()\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            if tile_elem.attrib.get('seen') != 'true':\n                continue\n            x = int(tile_elem.attrib['id'])\n            coord = (x, y)\n            \n            tile_type = tile_elem.attrib['type']\n            # CRITICAL FIX: Treat all ledges as impassable to prevent invalid paths.\n            is_traversable = (tile_type in base_traversable_tiles) and (coord not in impassable_from_objects) and ('LEDGE' not in tile_type)\n            \n            if is_traversable:\n                all_nodes.add(coord)\n\n    for node in all_nodes:\n        graph[node] = {}\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (node[0] + dx, node[1] + dy)\n            if neighbor in all_nodes:\n                graph[node][neighbor] = 1\n\n    start_node = (start_x, start_y)\n    target_node = (end_x, end_y)\n\n    if start_node not in graph:\n        if debug:\n            print(f\"Start node {start_node} is not traversable. Finding closest valid start.\")\n        possible_starts = sorted(list(graph.keys()), key=lambda p: heuristic(start_node, p))\n        if not possible_starts:\n            print(json.dumps({'error': 'No traversable start tiles found anywhere on the map.'}))\n            sys.exit()\n        start_node = possible_starts[0]\n        if debug:\n            print(f\"New start node: {start_node}\")\n\n    if target_node not in graph:\n        if debug:\n            print(f\"Target node {target_node} is not traversable. Finding closest adjacent node.\")\n        possible_targets = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_node = (end_x + dx, end_y + dy)\n            if adj_node in graph:\n                possible_targets.append(adj_node)\n        \n        if not possible_targets:\n            if debug:\n                print(\"No traversable adjacent tiles. Searching for closest valid tile on the entire map.\")\n            possible_targets = sorted(list(graph.keys()), key=lambda p: heuristic(target_node, p))\n            if not possible_targets:\n                print(json.dumps({'error': 'No traversable target tiles found anywhere on the map.'}))\n                sys.exit()\n\n        closest_target = min(possible_targets, key=lambda p: heuristic(start_node, p))\n        target_node = closest_target\n        if debug:\n            print(f\"New target node: {closest_target}\")\n            \n    final_path = find_path_on_graph(start_node, target_node, graph, debug)\n    if final_path:\n        print(json.dumps({'path': [{'x': p[0], 'y': p[1]} for p in final_path]}))\n    else:\n        print(json.dumps({'error': 'No path found.'}))\n\nexcept Exception as e:\n    print(json.dumps({'error': f'An error occurred: {e}'}))"
  },
  "unseen_tile_scanner": {
    "description": "Scans the current map XML and returns a list of coordinates for all unseen tiles.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\n\nunseen_tiles = []\nroot = ET.fromstring(map_xml_string)\nfor row in root.findall('Row'):\n    for tile in row.findall('Tile'):\n        if tile.get('seen') == 'false':\n            unseen_tiles.append(tile.get('coordinate'))\nprint(unseen_tiles)"
  }
}