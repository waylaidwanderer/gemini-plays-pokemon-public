{
  "calculate_xp_requirements": {
    "description": "Calculates the experience points required for the next level for a given Pokémon species and its current level and experience. Supports the four standard experience curves found in Pokémon Crystal (Fast, Medium Fast, Medium Slow, Slow).",
    "input_schema": {
      "type": "object",
      "properties": {
        "growth_rate": {
          "type": "string",
          "enum": [
            "Fast",
            "Medium Fast",
            "Medium Slow",
            "Slow"
          ]
        },
        "current_level": {
          "type": "integer"
        },
        "current_exp": {
          "type": "integer"
        }
      },
      "required": [
        "growth_rate",
        "current_level",
        "current_exp"
      ]
    },
    "python_script": "import json\n\ngrowth_rate = input_data[\"growth_rate\"]\ncurrent_level = int(input_data[\"current_level\"])\ncurrent_exp = int(input_data[\"current_exp\"])\n\ndef get_total_exp(n, rate):\n    if rate == \"Fast\":\n        return int(0.8 * (n ** 3))\n    elif rate == \"Medium Fast\":\n        return n ** 3\n    elif rate == \"Medium Slow\":\n        return int(1.2 * (n ** 3) - 15 * (n ** 2) + 100 * n - 140)\n    elif rate == \"Slow\":\n        return int(1.25 * (n ** 3))\n    return 0\n\nnext_level = current_level + 1\ntarget_exp = get_total_exp(next_level, growth_rate)\nremaining = max(0, target_exp - current_exp)\n\nresult = {\n    \"growth_rate\": growth_rate,\n    \"current_level\": current_level,\n    \"current_exp\": current_exp,\n    \"next_level\": next_level,\n    \"total_exp_next_level\": target_exp,\n    \"exp_remaining\": remaining\n}\nprint(json.dumps(result))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T04:58:09.193Z",
        "action_counter": 817
      },
      {
        "commit_message": "Added calculate_xp_requirements tool to automate experience tracking.",
        "timestamp": "2025-12-18T14:00:59.942Z",
        "action_counter": 1772
      }
    ]
  },
  "find_path_v3": {
    "description": "Finds a shortest path to a target coordinate, correctly handling ledges as one-way traversal and objects as walls. Returns a list of button strings.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import collections\nimport json\nimport xml.etree.ElementTree as ET\n\ndef solve():\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    player_pos = None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib.get('type', 'unseen')\n            seen = tile.attrib.get('seen') == 'true'\n            is_wall = t_type in ['WALL', 'WATER', 'BLOCK', 'HEADBUTT_TREE', 'CUT_TREE', 'VOID'] or tile.find('Object') is not None\n            if not seen and t_type == 'unseen':\n                is_wall = True\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n            grid[(x, y)] = {'type': t_type, 'wall': is_wall, 'seen': seen}\n\n    if player_pos is None:\n        print(json.dumps([]))\n        return\n    \n    target = (int(input_data['target_x']), int(input_data['target_y']))\n    if player_pos == target:\n        print(json.dumps([]))\n        return\n\n    queue = collections.deque([(player_pos, [])])\n    visited = {player_pos}\n\n    while queue:\n        (cx, cy), path = queue.popleft()\n        curr_tile = grid.get((cx, cy), {'type': 'FLOOR', 'wall': False})\n        \n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            if curr_tile['type'] == 'LEDGE_HOP_DOWN' and btn != 'Down': continue\n            if curr_tile['type'] == 'LEDGE_HOP_UP' and btn != 'Up': continue\n            if curr_tile['type'] == 'LEDGE_HOP_LEFT' and btn != 'Left': continue\n            if curr_tile['type'] == 'LEDGE_HOP_RIGHT' and btn != 'Right': continue\n            \n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) not in grid: continue\n            next_tile = grid[(nx, ny)]\n            \n            if next_tile['type'] == 'LEDGE_HOP_DOWN':\n                if btn != 'Down': continue\n                nx, ny = nx + dx, ny + dy\n                if (nx, ny) not in grid: continue\n                next_tile = grid[(nx, ny)]\n            elif next_tile['type'] == 'LEDGE_HOP_UP':\n                if btn != 'Up': continue\n                nx, ny = nx + dx, ny + dy\n                if (nx, ny) not in grid: continue\n                next_tile = grid[(nx, ny)]\n            elif next_tile['type'] == 'LEDGE_HOP_LEFT':\n                if btn != 'Left': continue\n                nx, ny = nx + dx, ny + dy\n                if (nx, ny) not in grid: continue\n                next_tile = grid[(nx, ny)]\n            elif next_tile['type'] == 'LEDGE_HOP_RIGHT':\n                if btn != 'Right': continue\n                nx, ny = nx + dx, ny + dy\n                if (nx, ny) not in grid: continue\n                next_tile = grid[(nx, ny)]\n            \n            if next_tile['wall'] and (nx, ny) != target: continue\n            \n            if (nx, ny) == target:\n                print(json.dumps(path + [btn]))\n                return\n            \n            if (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [btn]))\n    \n    print(json.dumps([]))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T05:31:42.338Z",
        "action_counter": 871
      },
      {
        "commit_message": "Removing catch-all exception and refining wall logic for target tile.",
        "timestamp": "2025-12-18T05:35:51.251Z",
        "action_counter": 881
      },
      {
        "commit_message": "Refined pathfinding logic to correctly handle ledges as one-way jumps and treat unseen tiles as obstacles.",
        "timestamp": "2025-12-18T06:35:14.636Z",
        "action_counter": 995
      }
    ]
  },
  "list_reachable_unseen_v3": {
    "description": "Finds all 'unseen' tiles that are currently reachable from the player's position, correctly handling ledges and objects. Returns a list of (x, y) coordinates.",
    "input_schema": {},
    "python_script": "import collections\nimport json\nimport xml.etree.ElementTree as ET\n\ndef solve():\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    player_pos = None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib.get('type', 'unseen')\n            is_wall = t_type in ['WALL', 'WATER', 'BLOCK', 'HEADBUTT_TREE', 'CUT_TREE', 'VOID'] or tile.find('Object') is not None\n            if tile.find('Player') is not None: player_pos = (x, y)\n            grid[(x, y)] = {'type': t_type, 'wall': is_wall, 'seen': tile.attrib.get('seen') == 'true'}\n    \n    if player_pos is None:\n        print(json.dumps([]))\n        return\n\n    reachable_unseen = []\n    queue = collections.deque([player_pos])\n    visited = {player_pos}\n    \n    while queue:\n        cx, cy = queue.popleft()\n        \n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) in grid:\n                curr = grid[(cx, cy)]\n                next_tile = grid[(nx, ny)]\n                \n                # Check if next tile is unseen\n                if not next_tile['seen']:\n                    if (nx, ny) not in reachable_unseen:\n                        reachable_unseen.append((nx, ny))\n                    continue # Cannot walk into unseen tile\n                \n                # Ledge logic\n                if curr['type'] == 'LEDGE_HOP_DOWN' and btn != 'Down': continue\n                if next_tile['type'] == 'LEDGE_HOP_DOWN' and btn != 'Down': continue\n                \n                if next_tile['wall']: continue\n                \n                if (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n                    \n    print(json.dumps(reachable_unseen))\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T06:06:05.223Z",
        "action_counter": 935
      }
    ]
  },
  "press_sequence": {
    "description": "Executes a specific sequence of button presses, allowing for mixed directional and action inputs. Useful for complex menu navigation.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nprint(json.dumps(input_data['buttons']))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T06:11:16.135Z",
        "action_counter": 948
      }
    ]
  }
}