{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "inventory_scanner": {
    "description": "Scans the player's inventory list for a target item and returns whether it was found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory_list": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "inventory_list",
        "target_item"
      ]
    },
    "python_script": "import json\n\ntry:\n    inventory_list = json.loads(input_data['inventory_list'])\n    target_item = input_data['target_item']\n    found = False\n    for item in inventory_list:\n        if target_item.lower() in item.lower():\n            found = True\n            break\n    print(f'Item found: {found}')\nexcept Exception as e:\n    print(f'An error occurred: {e}')"
  },
  "gem_path_planner_v4": {
    "description": "A custom pathfinding tool designed by Gem. It finds a path from a start to a target coordinate, avoiding impassable tiles and objects. This version fixes the water-to-land transition logic.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        },
        "movement_type": {
          "type": "string",
          "enum": [
            "walking",
            "surfing"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y",
        "movement_type"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\ndef parse_map_xml(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    grid = [['' for _ in range(width)] for _ in range(height)]\n    objects = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id')) - 1\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id')) - 1\n            grid[y][x] = tile_elem.get('type')\n            obj_node = tile_elem.find('Object')\n            if obj_node is not None and obj_node.get('id-name') != 'Pikachu':\n                objects[(x + 1, y + 1)] = True\n    return grid, objects, width, height\n\ndef is_valid(x, y, width, height):\n    return 1 <= x <= width and 1 <= y <= height\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef get_neighbors(current_pos, grid, objects, width, height, movement_type):\n    x, y = current_pos\n    current_tile_type = grid[y-1][x-1]\n    neighbors = []\n    standard_walkable = ['ground', 'grass', 'cleared_boulder_barrier', 'open_gate', 'gate_offscreen', 'boulder_switch', 'spinner_stop']\n\n    for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n        nx, ny = x + dx, y + dy\n        if not is_valid(nx, ny, width, height):\n            continue\n        \n        neighbor_pos = (nx, ny)\n        if neighbor_pos in objects:\n            continue\n            \n        neighbor_tile_type = grid[ny-1][nx-1]\n\n        if neighbor_tile_type == 'ledge':\n            if dy == 1:\n                if is_valid(nx, ny + 1, width, height):\n                    landing_pos = (nx, ny + 1)\n                    if landing_pos in objects: continue\n                    landing_tile_type = grid[ny][nx-1]\n                    if movement_type == 'walking' and (landing_tile_type in standard_walkable or landing_tile_type == 'elevated_ground'):\n                         neighbors.append((landing_pos, move, 1))\n                    elif movement_type == 'surfing' and landing_tile_type == 'water':\n                         neighbors.append((landing_pos, move, 1))\n            continue\n\n        can_traverse = False\n        if movement_type == 'walking':\n            is_standard_current = current_tile_type in standard_walkable\n            is_ladder_current = current_tile_type in ['ladder_up', 'ladder_down']\n            is_elevated_current = current_tile_type == 'elevated_ground'\n            is_steps_current = current_tile_type == 'steps'\n            is_ground_current = current_tile_type == 'ground'\n\n            is_standard_neighbor = neighbor_tile_type in standard_walkable\n            is_ladder_neighbor = neighbor_tile_type in ['ladder_up', 'ladder_down']\n            is_elevated_neighbor = neighbor_tile_type == 'elevated_ground'\n            is_steps_neighbor = neighbor_tile_type == 'steps'\n            is_ground_neighbor = neighbor_tile_type == 'ground'\n\n            if (is_standard_current or is_ladder_current) and (is_standard_neighbor or is_ladder_neighbor):\n                can_traverse = True\n            elif is_elevated_current and (is_elevated_neighbor or is_steps_neighbor or is_ladder_neighbor):\n                can_traverse = True\n            elif is_steps_current and (is_ground_neighbor or is_elevated_neighbor):\n                can_traverse = True\n            elif (is_ground_current or is_elevated_current) and is_steps_neighbor:\n                can_traverse = True\n            elif is_ladder_current and (is_ground_neighbor or is_elevated_neighbor):\n                 can_traverse = True\n            elif neighbor_tile_type.startswith('spinner'):\n                can_traverse = True\n            elif current_tile_type in standard_walkable and neighbor_tile_type == 'water':\n                can_traverse = True\n\n        elif movement_type == 'surfing':\n            if neighbor_tile_type == 'water':\n                can_traverse = True\n            elif neighbor_tile_type in standard_walkable:\n                can_traverse = True\n        \n        if can_traverse:\n            neighbors.append((neighbor_pos, move, 1))\n            \n    return neighbors\n\ndef a_star_search(start, target, grid, objects, width, height, movement_type):\n    walkable_land_tiles = ['ground', 'grass', 'steps', 'elevated_ground', 'cleared_boulder_barrier', 'open_gate', 'gate_offscreen', 'boulder_switch', 'spinner_stop', 'ladder_up', 'ladder_down']\n    \n    def is_traversable(pos):\n        if not is_valid(pos[0], pos[1], width, height): return False\n        if pos in objects: return False\n        tile_type = grid[pos[1]-1][pos[0]-1]\n        if movement_type == 'walking': return tile_type in walkable_land_tiles or tile_type.startswith('spinner') or tile_type == 'water'\n        elif movement_type == 'surfing': return tile_type == 'water' or tile_type in walkable_land_tiles\n        return False\n\n    if is_traversable(target):\n        path = a_star_search_single(start, target, grid, objects, width, height, movement_type)\n    else:\n        best_path = None\n        min_len = float('inf')\n        adjacent_tiles = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_target = (target[0] + dx, target[1] + dy)\n            if is_traversable(adj_target):\n                adjacent_tiles.append(adj_target)\n\n        if not adjacent_tiles:\n            return None, 'No traversable adjacent tiles found for the target.'\n\n        for adj_target in adjacent_tiles:\n            path = a_star_search_single(start, adj_target, grid, objects, width, height, movement_type)\n            if path and len(path) < min_len:\n                min_len = len(path)\n                best_path = path\n        path = best_path\n    \n    if not path:\n        return None, 'No path could be found to the target or any adjacent tile.'\n    return path, None\n\ndef a_star_search_single(start, target, grid, objects, width, height, movement_type):\n    open_set = [(0, start)]\n    came_from = {}\n    g_score = {start: 0}\n    f_score = {start: heuristic(start, target)}\n    while open_set:\n        _, current = heapq.heappop(open_set)\n        if current == target:\n            return reconstruct_path(came_from, current)\n        for neighbor_pos, move, cost in get_neighbors(current, grid, objects, width, height, movement_type):\n            tentative_g_score = g_score[current] + cost\n            if tentative_g_score < g_score.get(neighbor_pos, float('inf')):\n                came_from[neighbor_pos] = (current, move)\n                g_score[neighbor_pos] = tentative_g_score\n                f_score[neighbor_pos] = tentative_g_score + heuristic(neighbor_pos, target)\n                heapq.heappush(open_set, (f_score[neighbor_pos], neighbor_pos))\n    return None\n\ndef reconstruct_path(came_from, current):\n    path = []\n    while current in came_from:\n        current, move = came_from[current]\n        path.append(move)\n    return path[::-1]\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    movement_type = input_data['movement_type']\n    grid, objects, map_width, map_height = parse_map_xml(map_xml_string)\n    start_node = (start_x, start_y)\n    target_node = (target_x, target_y)\n    path, error_msg = a_star_search(start_node, target_node, grid, objects, map_width, map_height, movement_type)\n    if path:\n        print(f\"Path found: {', '.join(path)}\")\n    else:\n        print(f'No path found. {error_msg}')\nexcept Exception as e:\n    print(f'An error occurred in the pathfinding tool: {e}')"
  },
  "gem_path_planner_v8": {
    "description": "A custom pathfinding tool by Gem. Finds a path from start to target. v8 adds a check to correctly avoid impassable tiles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        },
        "movement_type": {
          "type": "string",
          "enum": [
            "walking",
            "surfing"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y",
        "movement_type"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\ndef parse_map_xml(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    grid = [['' for _ in range(width)] for _ in range(height)]\n    objects = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id')) - 1\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id')) - 1\n            grid[y][x] = tile_elem.get('type')\n            obj_node = tile_elem.find('Object')\n            if obj_node is not None and obj_node.get('id-name') != 'Pikachu':\n                objects[(x + 1, y + 1)] = True\n    return grid, objects, width, height\n\ndef is_valid(x, y, width, height):\n    return 1 <= x <= width and 1 <= y <= height\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef get_neighbors(current_pos, grid, objects, width, height, movement_type):\n    x, y = current_pos\n    current_tile_type = grid[y-1][x-1]\n    neighbors = []\n    standard_walkable = ['ground', 'grass', 'cleared_boulder_barrier', 'open_gate', 'gate_offscreen', 'boulder_switch', 'spinner_stop', 'hole', 'steps', 'elevated_ground']\n\n    for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n        nx, ny = x + dx, y + dy\n        if not is_valid(nx, ny, width, height):\n            continue\n        \n        neighbor_pos = (nx, ny)\n        if neighbor_pos in objects:\n            continue\n            \n        neighbor_tile_type = grid[ny-1][nx-1]\n        if neighbor_tile_type == 'impassable':\n            continue\n\n        if neighbor_tile_type == 'ledge':\n            if dy == 1:\n                if is_valid(nx, ny + 1, width, height):\n                    landing_pos = (nx, ny + 1)\n                    if landing_pos in objects: continue\n                    landing_tile_type = grid[ny][nx-1]\n                    if movement_type == 'walking' and (landing_tile_type in standard_walkable):\n                         neighbors.append((landing_pos, move, 1))\n                    elif movement_type == 'surfing' and landing_tile_type == 'water':\n                         neighbors.append((landing_pos, move, 1))\n            continue\n\n        can_traverse = False\n        if movement_type == 'walking':\n            if current_tile_type in standard_walkable and neighbor_tile_type in standard_walkable:\n                can_traverse = True\n            elif current_tile_type == 'steps' and neighbor_tile_type in ['ground', 'elevated_ground']:\n                can_traverse = True\n            elif neighbor_tile_type == 'steps' and current_tile_type in ['ground', 'elevated_ground']:\n                can_traverse = True\n            elif current_tile_type in ['ladder_up', 'ladder_down'] and neighbor_tile_type in standard_walkable:\n                can_traverse = True\n            elif neighbor_tile_type in ['ladder_up', 'ladder_down'] and current_tile_type in standard_walkable:\n                can_traverse = True\n            elif neighbor_tile_type.startswith('spinner'):\n                can_traverse = True\n\n        elif movement_type == 'surfing':\n            if neighbor_tile_type == 'water':\n                can_traverse = True\n            elif current_tile_type == 'water' and neighbor_tile_type in ['ground', 'grass', 'steps']:\n                can_traverse = True\n            elif current_tile_type != 'water' and neighbor_tile_type in standard_walkable:\n                can_traverse = True\n        \n        if can_traverse:\n            neighbors.append((neighbor_pos, move, 1))\n            \n    return neighbors\n\ndef a_star_search(start, target, grid, objects, width, height, movement_type):\n    walkable_land_tiles = ['ground', 'grass', 'steps', 'elevated_ground', 'cleared_boulder_barrier', 'open_gate', 'gate_offscreen', 'boulder_switch', 'spinner_stop', 'ladder_up', 'ladder_down', 'hole']\n    \n    def is_traversable(pos):\n        if not is_valid(pos[0], pos[1], width, height): return False\n        if pos in objects: return False\n        tile_type = grid[pos[1]-1][pos[0]-1]\n        if tile_type == 'impassable': return False\n        if movement_type == 'walking': return tile_type in walkable_land_tiles or tile_type.startswith('spinner')\n        elif movement_type == 'surfing': return tile_type == 'water' or tile_type in walkable_land_tiles\n        return False\n\n    path = a_star_search_single(start, target, grid, objects, width, height, movement_type)\n    if not path:\n        best_path = None\n        min_len = float('inf')\n        adjacent_tiles = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_target = (target[0] + dx, target[1] + dy)\n            if is_traversable(adj_target):\n                adjacent_tiles.append(adj_target)\n\n        if not adjacent_tiles:\n            return None, 'No traversable adjacent tiles found for the target.'\n\n        for adj_target in adjacent_tiles:\n            path_to_adj = a_star_search_single(start, adj_target, grid, objects, width, height, movement_type)\n            if path_to_adj and len(path_to_adj) < min_len:\n                min_len = len(path_to_adj)\n                best_path = path_to_adj\n        path = best_path\n\n    if not path:\n        return None, 'No path could be found to the target or any adjacent tile.'\n    return path, None\n\ndef a_star_search_single(start, target, grid, objects, width, height, movement_type):\n    open_set = [(0, start)]\n    came_from = {}\n    g_score = {start: 0}\n    f_score = {start: heuristic(start, target)}\n    while open_set:\n        _, current = heapq.heappop(open_set)\n        if current == target:\n            return reconstruct_path(came_from, current)\n        for neighbor_pos, move, cost in get_neighbors(current, grid, objects, width, height, movement_type):\n            tentative_g_score = g_score[current] + cost\n            if tentative_g_score < g_score.get(neighbor_pos, float('inf')):\n                came_from[neighbor_pos] = (current, move)\n                g_score[neighbor_pos] = tentative_g_score\n                f_score[neighbor_pos] = tentative_g_score + heuristic(neighbor_pos, target)\n                heapq.heappush(open_set, (f_score[neighbor_pos], neighbor_pos))\n    return None\n\ndef reconstruct_path(came_from, current):\n    path = []\n    while current in came_from:\n        current, move = came_from[current]\n        path.append(move)\n    return path[::-1]\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    movement_type = input_data['movement_type']\n    grid, objects, map_width, map_height = parse_map_xml(map_xml_string)\n    start_node = (start_x, start_y)\n    target_node = (target_x, target_y)\n    path, error_msg = a_star_search(start_node, target_node, grid, objects, map_width, map_height, movement_type)\n    if path:\n        print(f\"Path found: {', '.join(path)}\")\n    else:\n        print(f'No path found. {error_msg}')\nexcept Exception as e:\n    print(f'An error occurred in the pathfinding tool: {e}')"
  }
}