{
  "boulder_puzzle_solver": {
    "description": "Analyzes the map XML for a boulder puzzle and provides a step-by-step solution. This version includes A* pathfinding to ensure the player can reach the boulders before attempting a push. It correctly handles puzzles with more boulders than switches, includes an iteration limit, and validates that the player can reach the exact push position. **This version now correctly checks for the SURF HM and allows the player pathfinding to traverse water tiles AND handles elevation changes via steps tiles.**",
    "input_schema": {
      "type": "object",
      "properties": {
        "boulder_coords": {
          "type": "string"
        },
        "switch_coords": {
          "type": "string"
        },
        "party_data": {
          "type": "string"
        }
      },
      "required": [
        "boulder_coords",
        "switch_coords",
        "party_data"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\nfrom collections import deque\n\ndef solve_boulder_puzzle(input_data):\n    # REFACTOR: Pass map data as arguments to helper functions to fix nonlocal scope issue.\n    def parse_map_and_party(xml_string, party_str):\n        grid, player_pos, map_width, map_height, party_data = {}, None, 0, 0, []\n        ground_tiles, elevated_ground_tiles, steps_tiles = set(), set(), set()\n        root = ET.fromstring(xml_string)\n        map_width = int(root.get('width'))\n        map_height = int(root.get('height'))\n        for r_elem in root.findall('Row'):\n            y = int(r_elem.get('id'))\n            for t_elem in r_elem.findall('Tile'):\n                x = int(t_elem.get('id'))\n                tile_type = t_elem.get('type')\n                obj = t_elem.find('Object')\n                obj_name = obj.get('id-name') if obj is not None else None\n                if t_elem.find('Player') is not None: player_pos = (x, y)\n                grid[(x, y)] = {'type': tile_type, 'has_object': t_elem.get('has-object') == 'true', 'is_warp': t_elem.get('is-warp') == 'true', 'object_id_name': obj_name}\n                if tile_type == 'ground': ground_tiles.add((x, y))\n                elif tile_type == 'elevated_ground': elevated_ground_tiles.add((x, y))\n                elif tile_type == 'steps': steps_tiles.add((x, y))\n        party_data = json.loads(party_str) if party_str else []\n        map_data = {'grid': grid, 'width': map_width, 'height': map_height, 'ground': ground_tiles, 'elevated': elevated_ground_tiles, 'steps': steps_tiles}\n        return map_data, player_pos, party_data\n\n    def has_hm(party, hm_name):\n        for p in party:\n            if not p.get('is_fainted', False):\n                for m in p.get('moves', []):\n                    if (isinstance(m, dict) and m.get('name') == hm_name) or (isinstance(m, str) and m == hm_name): return True\n        return False\n\n    def is_player_traversable(map_data, from_coord, to_coord, boulders):\n        if to_coord not in map_data['grid']: return False\n        to_tile = map_data['grid'][to_coord]\n        if to_tile['type'] in ['impassable', 'boulder_barrier'] or to_coord in boulders: return False\n        if to_tile['has_object'] and not to_tile['is_warp'] and to_tile.get('object_id_name') != 'PIKACHU': return False\n        from_type, to_type = map_data['grid'][from_coord]['type'], to_tile['type']\n        if (from_coord in map_data['elevated'] and to_coord in map_data['ground']) or \\\n           (from_coord in map_data['ground'] and to_coord in map_data['elevated']):\n            if from_coord not in map_data['steps'] and to_coord not in map_data['steps']:\n                return False\n        return True\n\n    def get_player_neighbors(map_data, node, boulders):\n        x, y = node; neighbors = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 1 <= nx <= map_data['width'] and 1 <= ny <= map_data['height']:\n                if is_player_traversable(map_data, (x, y), (nx, ny), boulders): neighbors.append((nx, ny))\n        return neighbors\n\n    def player_a_star(map_data, start, goal, boulders):\n        frontier = [(0, start)]; came_from = {start: None}; cost_so_far = {start: 0}\n        iters = 0\n        while frontier:\n            iters += 1\n            if iters > 2000: return None\n            _, current = heapq.heappop(frontier)\n            if current == goal: break\n            for next_node in get_player_neighbors(map_data, current, boulders):\n                new_cost = cost_so_far[current] + 1\n                if next_node not in cost_so_far or new_cost < cost_so_far[next_node]:\n                    cost_so_far[next_node] = new_cost\n                    priority = new_cost + abs(goal[0] - next_node[0]) + abs(goal[1] - next_node[1])\n                    heapq.heappush(frontier, (priority, next_node)); came_from[next_node] = current\n        else: return None\n        path = []; current = goal\n        while current is not None: path.append(current); current = came_from.get(current)\n        path.reverse()\n        return path\n\n    def get_boulder_neighbors(map_data, party, state, p_pos):\n        neighbors = []; boulders = set(state)\n        for i, boulder in enumerate(state):\n            bx, by = boulder\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                p_req = (bx - dx, by - dy); new_b_pos = (bx + dx, by + dy)\n                if p_req not in map_data['grid'] or new_b_pos not in map_data['grid']: continue\n                if new_b_pos in boulders or map_data['grid'][new_b_pos]['type'] in ['impassable', 'boulder_barrier'] or (map_data['grid'][new_b_pos]['has_object'] and not map_data['grid'][new_b_pos]['is_warp'] and map_data['grid'][new_b_pos].get('object_id_name') != 'PIKACHU'): continue\n                b_start_type = map_data['grid'][boulder]['type']; b_end_type = map_data['grid'][new_b_pos]['type']\n                p_req_type = map_data['grid'][p_req]['type']\n                if (b_start_type in ['elevated_ground', 'ground'] and b_end_type in ['elevated_ground', 'ground'] and b_start_type != b_end_type): continue\n                if (p_req_type in ['elevated_ground', 'ground'] and b_start_type in ['elevated_ground', 'ground'] and p_req_type != b_start_type): continue\n                path_to_push = player_a_star(map_data, p_pos, p_req, boulders)\n                if path_to_push:\n                    new_state_list = list(state); new_state_list[i] = new_b_pos; new_state_tuple = tuple(sorted(new_state_list))\n                    move = {'boulder_index': i, 'start_pos': boulder, 'end_pos': new_b_pos, 'player_path': path_to_push}\n                    neighbors.append((new_state_tuple, move))\n        return neighbors\n\n    def puzzle_heuristic(state, switches):\n        total_dist = 0; unplaced_boulders = sorted([b for b in state if b not in switches]); open_switches = sorted([s for s in switches if s not in state])\n        for b in unplaced_boulders:\n            if not open_switches: break\n            min_dist = float('inf'); best_s = None\n            for s in open_switches:\n                dist = abs(b[0] - s[0]) + abs(b[1] - s[1])\n                if dist < min_dist: min_dist = dist; best_s = s\n            total_dist += min_dist\n            if best_s: open_switches.remove(best_s)\n        return total_dist\n\n    def puzzle_a_star_solver(map_data, party, start_state, switches, p_pos):\n        start_node = (tuple(sorted(start_state)), p_pos); frontier = [(puzzle_heuristic(start_node[0], switches), start_node)]; came_from = {start_node: (None, None)}; cost_so_far = {start_node: 0}\n        iters = 0\n        while frontier:\n            iters += 1\n            if iters > 15000: return 'timeout'\n            _, current_node = heapq.heappop(frontier)\n            current_state, current_p_pos = current_node\n            if len(switches) > 0 and set(switches).issubset(set(current_state)):\n                path = []; curr = current_node\n                while curr is not None:\n                    parent, move = came_from.get(curr, (None, None))\n                    if move: path.append(move)\n                    curr = parent\n                path.reverse(); return path\n            for next_state, move in get_boulder_neighbors(map_data, party, current_state, current_p_pos):\n                new_cost = cost_so_far[current_node] + 1; next_p_pos = move['start_pos']; next_node = (next_state, next_p_pos)\n                if next_node not in cost_so_far or new_cost < cost_so_far[next_node]:\n                    cost_so_far[next_node] = new_cost; priority = new_cost + puzzle_heuristic(next_state, switches)\n                    heapq.heappush(frontier, (priority, next_node)); came_from[next_node] = (current_node, move)\n        return None\n\n    try:\n        map_data, player_pos, party_data = parse_map_and_party(map_xml_string, input_data['party_data'])\n        boulder_coords = [tuple(coord) for coord in json.loads(input_data['boulder_coords'])]\n        switch_coords = [tuple(coord) for coord in json.loads(input_data['switch_coords'])]\n        solution = puzzle_a_star_solver(map_data, party_data, boulder_coords, switch_coords, player_pos)\n        if solution == 'timeout': print(json.dumps({'error': 'Solver timed out.'}))\n        elif solution: print(json.dumps({'solution_path': solution}))\n        else: print(json.dumps({'error': 'No solution found.'}))\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': f'An error occurred: {str(e)}', 'traceback': traceback.format_exc()}))\n\nsolve_boulder_puzzle(input_data)"
  },
  "find_closest_unseen_tile": {
    "description": "Finds the closest reachable unseen tile and a reachable adjacent tile to pathfind to. This version uses a more robust traversal logic that correctly handles non-adjacent traversals like warps and ladders.",
    "input_schema": {
      "type": "object",
      "properties": {
        "party_data": {
          "type": "string"
        }
      },
      "required": [
        "party_data"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport collections\nimport heapq\n\ndef parse_party_data(party_data_str):\n    try:\n        party_data = json.loads(party_data_str)\n        hms_known = set()\n        for pokemon in party_data:\n            for move in pokemon.get('moves', []):\n                if isinstance(move, dict):\n                    move_name = move.get('name', '').upper()\n                    if move_name == 'CUT':\n                        hms_known.add('cut')\n                    elif move_name == 'SURF':\n                        hms_known.add('surf')\n        return hms_known\n    except (json.JSONDecodeError, TypeError):\n        return set()\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(start, goal, walls, map_width, map_height, hms_known, water_tiles, cut_trees, ledges):\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {start: 0}\n    f_score = {start: heuristic(start, goal)}\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == goal:\n            return True # Path found\n\n        if current in ledges:\n            neighbors = [(current[0], current[1] + 1)]\n        else:\n            neighbors = [(current[0] + dx, current[1] + dy) for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]]\n\n        for neighbor in neighbors:\n            if not (1 <= neighbor[0] <= map_width and 1 <= neighbor[1] <= map_height):\n                continue\n\n            if neighbor in ledges and current[1] != neighbor[1] - 1:\n                continue\n\n            tentative_g_score = g_score[current] + 1\n\n            if tentative_g_score >= g_score.get(neighbor, float('inf')):\n                continue\n\n            if neighbor in walls or (neighbor in cut_trees and 'cut' not in hms_known) or (neighbor in water_tiles and 'surf' not in hms_known):\n                continue\n\n            came_from[neighbor] = current\n            g_score[neighbor] = tentative_g_score\n            f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n            heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    return False # No path found\n\ntry:\n    party_data_str = input_data['party_data']\n    hms = parse_party_data(party_data_str)\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.attrib['width'])\n    map_height = int(root.attrib['height'])\n\n    player_pos = None\n    unseen_tiles = []\n    walls = set()\n    water_tiles = set()\n    cut_trees = set()\n    ledges = set()\n\n    for tile in root.findall('.//Tile'):\n        x, y = int(tile.get('id')), int(tile.get('coordinate').split(',')[1].strip(')'))\n        tile_type = tile.get('type')\n\n        if tile.get('seen') != 'true':\n            unseen_tiles.append((x, y))\n        if tile.find('Player') is not None:\n            player_pos = (x, y)\n        \n        impassable_types = ['impassable', 'boulder_barrier', 'closed_gate', 'unknown']\n        obj = tile.find('Object')\n        is_impassable_obj = obj is not None and obj.get('id-name') != 'Pikachu'\n        if tile_type in impassable_types or is_impassable_obj:\n            walls.add((x, y))\n        elif tile_type == 'water':\n            water_tiles.add((x, y))\n        elif tile_type == 'cuttable':\n            cut_trees.add((x, y))\n        elif tile_type == 'ledge':\n            ledges.add((x, y))\n\n    if not player_pos:\n        print(json.dumps({'error': 'Player not found.'}))\n    else:\n        reachable_unseen = []\n        for ux, uy in unseen_tiles:\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adj_tile = (ux + dx, uy + dy)\n                if not (1 <= adj_tile[0] <= map_width and 1 <= adj_tile[1] <= map_height):\n                    continue\n                if adj_tile in walls or adj_tile in unseen_tiles:\n                    continue\n                \n                if a_star_search(player_pos, adj_tile, walls, map_width, map_height, hms, water_tiles, cut_trees, ledges):\n                    dist = heuristic(player_pos, adj_tile)\n                    reachable_unseen.append({'unseen': (ux, uy), 'adj': adj_tile, 'dist': dist})\n                    break\n\n        if not reachable_unseen:\n            print(json.dumps({'message': 'No reachable unseen tiles found.'}))\n        else:\n            closest = min(reachable_unseen, key=lambda x: x['dist'])\n            print(json.dumps({\n                'closest_reachable_unseen_tile': {'x': closest['unseen'][0], 'y': closest['unseen'][1]},\n                'adjacent_tile': {'x': closest['adj'][0], 'y': closest['adj'][1]}\n            }))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))"
  },
  "grid_parser_debugger": {
    "description": "A diagnostic tool to parse the map_xml_string and print a list of all coordinates identified as impassable walls. Used to debug grid-parsing logic in other tools.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    walls = []\n    for tile in root.findall('.//Tile'):\n        x_str = tile.get('id')\n        y_str_part = tile.get('coordinate').split(',')\n        if len(y_str_part) < 2:\n            continue\n        y_str = y_str_part[1].strip(')')\n        if not x_str or not y_str:\n            continue\n        x, y = int(x_str), int(y_str)\n        tile_type = tile.get('type')\n        \n        impassable_types = ['impassable', 'boulder_barrier', 'closed_gate', 'unknown']\n        obj = tile.find('Object')\n        is_impassable_obj = obj is not None and obj.get('id-name') != 'Pikachu'\n        \n        if tile_type in impassable_types or is_impassable_obj:\n            walls.append({'x': x, 'y': y, 'type': tile_type, 'has_impassable_object': is_impassable_obj})\n            \n    print(json.dumps(walls, indent=2))\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))"
  },
  "pathfinder": {
    "description": "Finds a path to a target coordinate using a Breadth-First Search algorithm. This is a rebuilt version with verified grid-parsing.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\ntry:\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\nexcept (ValueError, ET.ParseError) as e:\n    print(json.dumps({'error': f'Failed to parse inputs or map XML: {e}'}))\n    exit()\nplayer_pos = None\nfor row_elem in root.findall('Row'):\n    tile_with_player = row_elem.find('Tile[Player]')\n    if tile_with_player is not None:\n        player_pos = (int(tile_with_player.attrib['id']), int(row_elem.attrib['id']))\n        break\nif player_pos is None:\n    print(json.dumps({'error': 'Player start position not found.'}))\n    exit()\ngrid = [['' for _ in range(width + 1)] for _ in range(height + 1)]\nimpassable_base_types = ['impassable', 'cuttable', 'boulder_barrier', 'closed_gate', 'water']\nfor r_elem in root.findall('Row'):\n    y = int(r_elem.attrib['id'])\n    for t_elem in r_elem.findall('Tile'):\n        x = int(t_elem.attrib['id'])\n        tile_type = t_elem.attrib['type']\n        obj = t_elem.find('Object')\n        has_blocking_obj = obj is not None and obj.attrib.get('id-name') != 'Pikachu'\n        if tile_type in impassable_base_types or has_blocking_obj:\n            grid[y][x] = 'impassable'\n        else:\n            grid[y][x] = tile_type\nstart = player_pos\ngoal = (target_x, target_y)\nif not (1 <= goal[0] <= width and 1 <= goal[1] <= height and grid[goal[1]][goal[0]] != 'impassable'):\n    found_new_goal = False\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n        n_goal = (goal[0] + dx, goal[1] + dy)\n        if 1 <= n_goal[0] <= width and 1 <= n_goal[1] <= height and grid[n_goal[1]][n_goal[0]] != 'impassable':\n            goal = n_goal\n            found_new_goal = True\n            break\n    if not found_new_goal:\n        print(json.dumps({'error': 'Target is on an impassable tile with no valid neighbors.'}))\n        exit()\nqueue = deque([(start, [start])])\nvisited = {start}\nwhile queue:\n    current, path = queue.popleft()\n    if current == goal:\n        print(json.dumps(path))\n        exit()\n    (x, y) = current\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n        neighbor = (x + dx, y + dy)\n        nx, ny = neighbor\n        if not (1 <= nx <= width and 1 <= ny <= height and grid[ny][nx] != 'impassable' and neighbor not in visited):\n            continue\n        neighbor_tile_type = grid[ny][nx]\n        if neighbor_tile_type == 'ledge' and dy != 1:\n            continue\n        visited.add(neighbor)\n        new_path = list(path)\n        new_path.append(neighbor)\n        queue.append((neighbor, new_path))\nprint(json.dumps([]))"
  },
  "robust_pathfinder": {
    "description": "A more robust A* pathfinding tool that can be told to avoid specific 'hazard' coordinates. This version includes corrected ledge traversal logic and accounts for the player's movement state (walking vs. surfing).",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "party_data": {
          "type": "string"
        },
        "movement_state": {
          "type": "string"
        },
        "hazard_coords": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "target_x",
        "target_y",
        "party_data",
        "movement_state"
      ]
    },
    "python_script": "\nimport heapq\nimport xml.etree.ElementTree as ET\nimport json\n\ndef parse_party_data(party_data_str):\n    try:\n        party_data = json.loads(party_data_str)\n        hms_known = set()\n        for pokemon in party_data:\n            if not isinstance(pokemon, dict):\n                continue\n            for move in pokemon.get('moves', []):\n                if isinstance(move, dict):\n                    move_name = move.get('name', '').upper()\n                    if move_name == 'CUT':\n                        hms_known.add('cut')\n                    elif move_name == 'SURF':\n                        hms_known.add('surf')\n                    elif move_name == 'STRENGTH':\n                        hms_known.add('strength')\n        return hms_known\n    except (json.JSONDecodeError, TypeError):\n        return set()\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(start, goal, walls, map_width, map_height, hms_known, water_tiles, cut_trees, ledges, movement_state, ground_tiles, elevated_ground_tiles, steps_tiles):\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {start: 0}\n    f_score = {start: heuristic(start, goal)}\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            return path[::-1]\n\n        if current in ledges:\n            neighbors = [(current[0], current[1] + 1)]\n        else:\n            neighbors = [(current[0] + dx, current[1] + dy) for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]]\n\n        for neighbor in neighbors:\n            if not (1 <= neighbor[0] <= map_width and 1 <= neighbor[1] <= map_height):\n                continue\n\n            if neighbor in ledges and current[1] != neighbor[1] - 1:\n                continue\n\n            is_invalid_elevation_change = False\n            if (current in elevated_ground_tiles and neighbor in ground_tiles) or \\\n               (current in ground_tiles and neighbor in elevated_ground_tiles):\n                if neighbor not in steps_tiles and current not in steps_tiles:\n                    is_invalid_elevation_change = True\n\n            tentative_g_score = g_score[current] + 1\n\n            if tentative_g_score >= g_score.get(neighbor, float('inf')):\n                continue\n\n            is_water_impassable = (neighbor in water_tiles and movement_state == 'walking')\n            if neighbor in walls or (neighbor in cut_trees and 'cut' not in hms_known) or is_water_impassable or is_invalid_elevation_change:\n                continue\n\n            came_from[neighbor] = current\n            g_score[neighbor] = tentative_g_score\n            f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n            heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    return None\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.get('width'))\n    map_height = int(root.get('height'))\n    \n    player_pos = None\n    walls = set()\n    water_tiles = set()\n    cut_trees = set()\n    ledges = set()\n    ground_tiles = set()\n    elevated_ground_tiles = set()\n    steps_tiles = set()\n\n    for tile in root.findall('.//Tile'):\n        x_str = tile.get('id')\n        y_str_part = tile.get('coordinate').split(',')\n        if len(y_str_part) < 2:\n            continue\n        y_str = y_str_part[1].strip(')')\n        if not x_str or not y_str:\n            continue\n        x, y = int(x_str), int(y_str)\n        tile_type = tile.get('type')\n        \n        if tile.find('Player') is not None:\n            player_pos = (x, y)\n        \n        impassable_types = ['impassable', 'boulder_barrier', 'closed_gate', 'unknown']\n        obj = tile.find('Object')\n        is_impassable_obj = obj is not None and obj.get('id-name') != 'Pikachu'\n        if tile_type in impassable_types or is_impassable_obj:\n            walls.add((x, y))\n        elif tile_type == 'water':\n            water_tiles.add((x, y))\n        elif tile_type == 'cuttable':\n            cut_trees.add((x, y))\n        elif tile_type == 'ledge':\n            ledges.add((x,y))\n        elif tile_type == 'ground':\n            ground_tiles.add((x, y))\n        elif tile_type == 'elevated_ground':\n            elevated_ground_tiles.add((x, y))\n        elif tile_type == 'steps':\n            steps_tiles.add((x, y))\n\n    if 'hazard_coords' in input_data and input_data['hazard_coords']:\n        try:\n            hazards = json.loads(input_data['hazard_coords'])\n            for hx, hy in hazards:\n                walls.add((int(hx), int(hy)))\n        except (json.JSONDecodeError, ValueError, TypeError):\n            pass\n\n    start_pos = player_pos\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    goal_pos = (target_x, target_y)\n    \n    party_data_str = input_data.get('party_data', '[]')\n    hms = parse_party_data(party_data_str)\n    movement_state = input_data.get('movement_state', 'walking')\n\n    if not start_pos:\n        print(json.dumps({'error': 'Player position not found in map data.'}))\n    else:\n        path = a_star_search(start_pos, goal_pos, walls, map_width, map_height, hms, water_tiles, cut_trees, ledges, movement_state, ground_tiles, elevated_ground_tiles, steps_tiles)\n        if path:\n            final_path = []\n            i = 0\n            while i < len(path):\n                current_tile = path[i]\n                final_path.append(current_tile)\n                if current_tile in ledges and i > 0:\n                    if i + 1 < len(path):\n                        next_tile_on_path = path[i+1]\n                        if next_tile_on_path[0] == current_tile[0] and next_tile_on_path[1] == current_tile[1] + 1:\n                             i += 1\n                i += 1\n            print(json.dumps(final_path))\n        else:\n            print(json.dumps({'error': 'No path found.'}))\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))\n"
  }
}