{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "inventory_scanner": {
    "description": "Scans the player's inventory list for a target item and returns whether it was found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory_list": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "inventory_list",
        "target_item"
      ]
    },
    "python_script": "import json\n\ntry:\n    inventory_list = json.loads(input_data['inventory_list'])\n    target_item = input_data['target_item']\n    found = False\n    for item in inventory_list:\n        if target_item.lower() in item.lower():\n            found = True\n            break\n    print(f'Item found: {found}')\nexcept Exception as e:\n    print(f'An error occurred: {e}')"
  },
  "gem_path_planner_v10": {
    "description": "A custom pathfinding tool by Gem. Finds a path from start to target. v10 fixes elevation change logic.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        },
        "movement_type": {
          "type": "string",
          "enum": [
            "walking",
            "surfing"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y",
        "movement_type"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\nclass AStar:\n    def __init__(self, map_xml_string):\n        self.root = ET.fromstring(map_xml_string)\n        self.width = int(self.root.get('width'))\n        self.height = int(self.root.get('height'))\n        self.grid = [[None for _ in range(self.width)] for _ in range(self.height)]\n        self.impassable_objects = set()\n\n        for row_elem in self.root.findall('Row'):\n            y = int(row_elem.get('id')) - 1\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id')) - 1\n                tile_type = tile_elem.get('type')\n                self.grid[y][x] = tile_type\n                if tile_elem.find('Object') is not None:\n                    obj = tile_elem.find('Object')\n                    if obj.get('id-name') != 'Pikachu':\n                        self.impassable_objects.add((x, y))\n\n    def heuristic(self, a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def get_neighbors(self, pos, movement_type):\n        x, y = pos\n        neighbors = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if not (0 <= nx < self.width and 0 <= ny < self.height):\n                continue\n            \n            if (nx, ny) in self.impassable_objects:\n                continue\n\n            current_tile_type = self.grid[y][x]\n            neighbor_tile_type = self.grid[ny][nx]\n\n            valid_move = False\n            if movement_type == 'walking':\n                walkable_land = ['ground', 'grass', 'elevated_ground', 'ladder_up', 'ladder_down', 'hole']\n                if current_tile_type in walkable_land and neighbor_tile_type in walkable_land:\n                    valid_move = True\n                elif current_tile_type == 'steps' and neighbor_tile_type in ['ground', 'elevated_ground']:\n                    valid_move = True\n                elif neighbor_tile_type == 'steps' and current_tile_type in ['ground', 'elevated_ground']:\n                    valid_move = True\n            \n            elif movement_type == 'surfing':\n                if current_tile_type == 'water' and neighbor_tile_type == 'water': valid_move = True\n                elif current_tile_type == 'water' and neighbor_tile_type in ['ground', 'elevated_ground', 'steps']: valid_move = True\n                elif neighbor_tile_type == 'water' and current_tile_type in ['ground', 'elevated_ground', 'steps']: valid_move = True\n\n            if valid_move:\n                neighbors.append((nx, ny))\n        return neighbors\n\n    def find_path(self, start, end, movement_type):\n        open_set = []\n        heapq.heappush(open_set, (0, start))\n        came_from = {}\n        g_score = { (x,y): float('inf') for y in range(self.height) for x in range(self.width) }\n        g_score[start] = 0\n        f_score = { (x,y): float('inf') for y in range(self.height) for x in range(self.width) }\n        f_score[start] = self.heuristic(start, end)\n\n        while open_set:\n            _, current = heapq.heappop(open_set)\n            if current == end:\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(start)\n                return path[::-1]\n\n            for neighbor in self.get_neighbors(current, movement_type):\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score[neighbor]:\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = g_score[neighbor] + self.heuristic(neighbor, end)\n                    if neighbor not in [i[1] for i in open_set]:\n                        heapq.heappush(open_set, (f_score[neighbor], neighbor))\n        return None\n\ntry:\n    start_x = int(input_data['start_x']) - 1\n    start_y = int(input_data['start_y']) - 1\n    target_x = int(input_data['target_x']) - 1\n    target_y = int(input_data['target_y']) - 1\n    movement_type = input_data['movement_type']\n    pathfinder = AStar(map_xml_string)\n    path = pathfinder.find_path((start_x, start_y), (target_x, target_y), movement_type)\n    if path:\n        buttons = []\n        for i in range(len(path) - 1):\n            cx, cy = path[i]\n            nx, ny = path[i+1]\n            if nx > cx: buttons.append('Right')\n            elif nx < cx: buttons.append('Left')\n            elif ny > cy: buttons.append('Down')\n            elif ny < cy: buttons.append('Up')\n        print(','.join(buttons))\n    else:\n        print('No path found')\nexcept Exception as e:\n    print(f'An error occurred: {e}')"
  },
  "gem_path_planner_v11": {
    "description": "A custom pathfinding tool by Gem. Finds a path from start to target. v11 has more robust elevation change logic.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        },
        "movement_type": {
          "type": "string",
          "enum": [
            "walking",
            "surfing"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y",
        "movement_type"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\nclass AStar:\n    def __init__(self, map_xml_string):\n        self.root = ET.fromstring(map_xml_string)\n        self.width = int(self.root.get('width'))\n        self.height = int(self.root.get('height'))\n        self.grid = [[None for _ in range(self.width)] for _ in range(self.height)]\n        self.impassable_objects = set()\n\n        for row_elem in self.root.findall('Row'):\n            y = int(row_elem.get('id')) - 1\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id')) - 1\n                tile_type = tile_elem.get('type')\n                self.grid[y][x] = tile_type\n                if tile_elem.find('Object') is not None:\n                    obj = tile_elem.find('Object')\n                    if obj.get('id-name') != 'Pikachu':\n                        self.impassable_objects.add((x, y))\n\n    def heuristic(self, a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def get_neighbors(self, pos, movement_type):\n        x, y = pos\n        neighbors = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if not (0 <= nx < self.width and 0 <= ny < self.height):\n                continue\n            \n            if (nx, ny) in self.impassable_objects:\n                continue\n\n            current_tile_type = self.grid[y][x]\n            neighbor_tile_type = self.grid[ny][nx]\n\n            valid_move = False\n            if movement_type == 'walking':\n                if current_tile_type in ['ground', 'grass'] and neighbor_tile_type in ['ground', 'grass']: valid_move = True\n                elif current_tile_type == 'elevated_ground' and neighbor_tile_type == 'elevated_ground': valid_move = True\n                elif current_tile_type == 'steps' and neighbor_tile_type in ['ground', 'elevated_ground']: valid_move = True\n                elif neighbor_tile_type == 'steps' and current_tile_type in ['ground', 'elevated_ground']: valid_move = True\n                elif neighbor_tile_type in ['ladder_up', 'ladder_down', 'hole']: valid_move = True\n            \n            elif movement_type == 'surfing':\n                if current_tile_type == 'water' and neighbor_tile_type == 'water': valid_move = True\n                elif current_tile_type == 'water' and neighbor_tile_type in ['ground', 'elevated_ground', 'steps']: valid_move = True\n                elif neighbor_tile_type == 'water' and current_tile_type in ['ground', 'elevated_ground', 'steps']: valid_move = True\n\n            if valid_move:\n                neighbors.append((nx, ny))\n        return neighbors\n\n    def find_path(self, start, end, movement_type):\n        open_set = []\n        heapq.heappush(open_set, (0, start))\n        came_from = {}\n        g_score = { (x,y): float('inf') for y in range(self.height) for x in range(self.width) }\n        g_score[start] = 0\n        f_score = { (x,y): float('inf') for y in range(self.height) for x in range(self.width) }\n        f_score[start] = self.heuristic(start, end)\n\n        while open_set:\n            _, current = heapq.heappop(open_set)\n            if current == end:\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(start)\n                return path[::-1]\n\n            for neighbor in self.get_neighbors(current, movement_type):\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score[neighbor]:\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = g_score[neighbor] + self.heuristic(neighbor, end)\n                    if neighbor not in [i[1] for i in open_set]:\n                        heapq.heappush(open_set, (f_score[neighbor], neighbor))\n        return None\n\ntry:\n    start_x = int(input_data['start_x']) - 1\n    start_y = int(input_data['start_y']) - 1\n    target_x = int(input_data['target_x']) - 1\n    target_y = int(input_data['target_y']) - 1\n    movement_type = input_data['movement_type']\n    pathfinder = AStar(map_xml_string)\n    path = pathfinder.find_path((start_x, start_y), (target_x, target_y), movement_type)\n    if path:\n        buttons = []\n        for i in range(len(path) - 1):\n            cx, cy = path[i]\n            nx, ny = path[i+1]\n            if nx > cx: buttons.append('Right')\n            elif nx < cx: buttons.append('Left')\n            elif ny > cy: buttons.append('Down')\n            elif ny < cy: buttons.append('Up')\n        print(','.join(buttons))\n    else:\n        print('No path found')\nexcept Exception as e:\n    print(f'An error occurred: {e}')"
  },
  "gem_path_planner_v12": {
    "description": "A custom pathfinding tool by Gem. Finds a path from start to target. v12 has even more robust elevation change logic.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        },
        "movement_type": {
          "type": "string",
          "enum": [
            "walking",
            "surfing"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y",
        "movement_type"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\nclass AStar:\n    def __init__(self, map_xml_string):\n        self.root = ET.fromstring(map_xml_string)\n        self.width = int(self.root.get('width'))\n        self.height = int(self.root.get('height'))\n        self.grid = [[None for _ in range(self.width)] for _ in range(self.height)]\n        self.impassable_objects = set()\n\n        for row_elem in self.root.findall('Row'):\n            y = int(row_elem.get('id')) - 1\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id')) - 1\n                tile_type = tile_elem.get('type')\n                self.grid[y][x] = tile_type\n                if tile_elem.find('Object') is not None:\n                    obj = tile_elem.find('Object')\n                    if obj.get('id-name') != 'Pikachu':\n                        self.impassable_objects.add((x, y))\n\n    def heuristic(self, a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def get_neighbors(self, pos, movement_type):\n        x, y = pos\n        neighbors = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if not (0 <= nx < self.width and 0 <= ny < self.height):\n                continue\n            \n            if (nx, ny) in self.impassable_objects:\n                continue\n\n            current_tile_type = self.grid[y][x]\n            neighbor_tile_type = self.grid[ny][nx]\n\n            valid_move = False\n            if movement_type == 'walking':\n                walkable_land = ['ground', 'grass', 'ladder_up', 'ladder_down', 'hole']\n                elevated_walkable = ['elevated_ground']\n                \n                if current_tile_type in walkable_land and neighbor_tile_type in walkable_land:\n                    valid_move = True\n                elif current_tile_type in elevated_walkable and neighbor_tile_type in elevated_walkable:\n                    valid_move = True\n                elif current_tile_type == 'steps' and (neighbor_tile_type in walkable_land or neighbor_tile_type in elevated_walkable):\n                    valid_move = True\n                elif neighbor_tile_type == 'steps' and (current_tile_type in walkable_land or current_tile_type in elevated_walkable):\n                    valid_move = True\n            \n            elif movement_type == 'surfing':\n                if current_tile_type == 'water' and neighbor_tile_type == 'water': valid_move = True\n                elif current_tile_type == 'water' and neighbor_tile_type in ['ground', 'elevated_ground', 'steps']: valid_move = True\n                elif neighbor_tile_type == 'water' and current_tile_type in ['ground', 'elevated_ground', 'steps']: valid_move = True\n\n            if valid_move:\n                neighbors.append((nx, ny))\n        return neighbors\n\n    def find_path(self, start, end, movement_type):\n        open_set = []\n        heapq.heappush(open_set, (0, start))\n        came_from = {}\n        g_score = { (x,y): float('inf') for y in range(self.height) for x in range(self.width) }\n        g_score[start] = 0\n        f_score = { (x,y): float('inf') for y in range(self.height) for x in range(self.width) }\n        f_score[start] = self.heuristic(start, end)\n\n        while open_set:\n            _, current = heapq.heappop(open_set)\n            if current == end:\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(start)\n                return path[::-1]\n\n            for neighbor in self.get_neighbors(current, movement_type):\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score[neighbor]:\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = g_score[neighbor] + self.heuristic(neighbor, end)\n                    if neighbor not in [i[1] for i in open_set]:\n                        heapq.heappush(open_set, (f_score[neighbor], neighbor))\n        return None\n\ntry:\n    start_x = int(input_data['start_x']) - 1\n    start_y = int(input_data['start_y']) - 1\n    target_x = int(input_data['target_x']) - 1\n    target_y = int(input_data['target_y']) - 1\n    movement_type = input_data['movement_type']\n    pathfinder = AStar(map_xml_string)\n    path = pathfinder.find_path((start_x, start_y), (target_x, target_y), movement_type)\n    if path:\n        buttons = []\n        for i in range(len(path) - 1):\n            cx, cy = path[i]\n            nx, ny = path[i+1]\n            if nx > cx: buttons.append('Right')\n            elif nx < cx: buttons.append('Left')\n            elif ny > cy: buttons.append('Down')\n            elif ny < cy: buttons.append('Up')\n        print(','.join(buttons))\n    else:\n        print('No path found')\nexcept Exception as e:\n    print(f'An error occurred: {e}')"
  }
}