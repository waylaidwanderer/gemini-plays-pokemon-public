{
  "exp_calculator_tool": {
    "description": "Calculates the average EXP gain from a list of wild Pokémon encounters.",
    "input_schema": {
      "type": "object",
      "properties": {
        "encounters": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "pokemon_name": {
                "type": "string"
              },
              "level": {
                "type": "integer"
              },
              "exp_yield": {
                "type": "integer"
              }
            },
            "required": [
              "pokemon_name",
              "level",
              "exp_yield"
            ]
          }
        }
      },
      "required": [
        "encounters"
      ]
    },
    "python_script": "import json\n\ndef exp_calculator(input_data):\n    encounters = input_data['encounters']\n    if not encounters:\n        return 'No encounters provided.'\n    total_exp = sum(e['exp_yield'] for e in encounters)\n    average_exp = total_exp / len(encounters)\n    return f'Average EXP gain: {average_exp:.2f}'\n\nresult = exp_calculator(json.loads(input_data))\nprint(result)"
  },
  "inventory_scanner": {
    "description": "Scans the player's inventory list for a target item and returns whether it was found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory_list": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "inventory_list",
        "target_item"
      ]
    },
    "python_script": "import json\n\ntry:\n    inventory_list = json.loads(input_data['inventory_list'])\n    target_item = input_data['target_item']\n    found = False\n    for item in inventory_list:\n        if target_item.lower() in item.lower():\n            found = True\n            break\n    print(f'Item found: {found}')\nexcept Exception as e:\n    print(f'An error occurred: {e}')"
  },
  "pathfinder": {
    "description": "Calculates the shortest path from the player's current position to a target coordinate. It now requires party data to verify that a conscious Pokémon with the necessary HM (e.g., Surf, Strength, Cut) is available before planning a path that requires it. This version includes specific logic for handling 'steps' and 'ledge' tiles correctly and will find a path to an adjacent tile if the target is impassable. It also now correctly handles pathing from water to ground and outputs a JSON array of coordinates for the path_plan.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "party_data": {
          "type": "string",
          "description": "A stringified JSON array of the player's party Pokémon, including their moves and fainted status."
        }
      },
      "required": [
        "target_x",
        "target_y",
        "party_data"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef find_path(input_data):\n    def parse_map(xml_string):\n        root = ET.fromstring(xml_string)\n        grid = {}\n        player_pos = None\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                is_warp = tile_elem.get('is-warp') == 'true'\n                object_id_name = None\n                obj_elem = tile_elem.find('Object')\n                if obj_elem is not None:\n                    object_id_name = obj_elem.get('id-name')\n                if tile_elem.find('Player') is not None:\n                    player_pos = (x, y)\n                grid[(x, y)] = {'type': tile_type, 'has_object': has_object, 'is_warp': is_warp, 'object_id_name': object_id_name}\n        return grid, player_pos, int(root.get('width')), int(root.get('height'))\n\n    def has_hm(party, hm_name):\n        return any(hm_name in move['name'] for pokemon in party if not pokemon.get('is_fainted', False) for move in pokemon.get('moves', []))\n\n    def is_traversable(from_x, from_y, to_x, to_y, grid, party):\n        if (to_x, to_y) not in grid:\n            return False\n        to_tile = grid.get((to_x, to_y))\n        from_tile = grid.get((from_x, from_y))\n        from_type = from_tile['type'] if from_tile else 'ground'\n        to_type = to_tile['type']\n\n        if to_type == 'impassable':\n            return False\n\n        if to_tile['has_object'] and not to_tile['is_warp'] and to_tile.get('object_id_name') != 'PIKACHU':\n            return False\n        \n        if from_type == 'water' and to_type == 'elevated_ground': return False\n        if from_type == 'elevated_ground' and to_type == 'water': return False\n        if {from_type, to_type} == {'ground', 'elevated_ground'}: return False\n        \n        general_traversable = ['ground', 'grass', 'cleared_boulder_barrier', 'open_gate', 'gate_offscreen', 'spinner_stop', 'teleport', 'hole', 'ladder_up', 'ladder_down', 'elevated_ground', 'steps', 'spinner_up', 'spinner_down', 'spinner_left', 'spinner_right']\n        \n        if from_type == 'water':\n            return to_type == 'water' or to_type in ['ground', 'steps']\n        \n        if to_type == 'water':\n            if from_type in ['ground', 'steps'] and has_hm(party, 'SURF'):\n                return True\n            return False\n        \n        if to_type in general_traversable:\n            return True\n        \n        if to_type == 'cuttable' and has_hm(party, 'CUT'):\n            return True\n            \n        if to_type == 'ledge':\n            return from_y == to_y - 1 and from_x == to_x\n            \n        return False\n\n    def get_neighbors(node, grid, party, map_width, map_height):\n        x, y = node\n        neighbors = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 1 <= nx <= map_width and 1 <= ny <= map_height:\n                if is_traversable(x, y, nx, ny, grid, party):\n                    cost = 1\n                    to_tile_type = grid.get((nx, ny), {}).get('type')\n                    if to_tile_type == 'ledge' and dy == 1:\n                        if is_traversable(nx, ny, nx, ny + 1, grid, party):\n                           neighbors.append(((nx, ny + 1), cost))\n                        continue \n                    neighbors.append(((nx, ny), cost))\n        return neighbors\n\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def a_star(start, goal, grid, party, map_width, map_height):\n        original_goal = goal\n        if not is_traversable(start[0], start[1], goal[0], goal[1], grid, party):\n            found_new_goal = False\n            for dx, dy in sorted([(0, 1), (0, -1), (1, 0), (-1, 0)], key=lambda p: heuristic((start[0]+p[0], start[1]+p[1]), original_goal)):\n                new_goal_x, new_goal_y = original_goal[0] + dx, original_goal[1] + dy\n                if (new_goal_x, new_goal_y) in grid and is_traversable(new_goal_x - dx, new_goal_y - dy, new_goal_x, new_goal_y, grid, party):\n                    goal = (new_goal_x, new_goal_y)\n                    found_new_goal = True\n                    break\n            if not found_new_goal:\n                return None\n\n        frontier = [(0, start)]\n        came_from = {start: None}\n        cost_so_far = {start: 0}\n        while frontier:\n            _, current = heapq.heappop(frontier)\n            if current == goal:\n                break\n            for next_node, cost in get_neighbors(current, grid, party, map_width, map_height):\n                new_cost = cost_so_far[current] + cost\n                if next_node not in cost_so_far or new_cost < cost_so_far[next_node]:\n                    cost_so_far[next_node] = new_cost\n                    priority = new_cost + heuristic(goal, next_node)\n                    heapq.heappush(frontier, (priority, next_node))\n                    came_from[next_node] = current\n        else:\n            return None\n        path = []\n        current = goal\n        while current is not None:\n            path.append(current)\n            current = came_from.get(current)\n        path.reverse()\n        return path\n\n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n        party = json.loads(input_data['party_data'])\n        grid, player_pos, map_width, map_height = parse_map(map_xml_string)\n        if player_pos is None:\n            print(json.dumps({'error': 'Player position not found on the map.'}))\n            return\n        path_plan = a_star(player_pos, (target_x, target_y), grid, party, map_width, map_height)\n        if path_plan:\n            path_json = [{'x': x, 'y': y} for x, y in path_plan]\n            print(json.dumps({'path_plan': path_json}))\n        else:\n            print(json.dumps({'error': 'No path found to the target.'}))\n    except Exception as e:\n        print(json.dumps({'error': f'An error occurred: {str(e)}'}))\n\nfind_path(input_data)"
  },
  "spinner_maze_solver": {
    "description": "Finds the shortest path in a spinner maze. It parses the map_xml_string, builds a graph including spinner traversals, and uses A* to find the path from the player's position to a target coordinate. Handles impassable targets by pathing to an adjacent tile. This version correctly handles spinner loops.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef spinner_maze_solver(input_data, map_xml_string):\n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n        root = ET.fromstring(map_xml_string)\n    except (ValueError, ET.ParseError):\n        print(json.dumps({'error': 'Invalid input or map data.'}))\n        return\n\n    tile_map = {}\n    player_pos = None\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            has_obj = tile_elem.find('Object') is not None and tile_elem.find('Object').get('id-name') != 'PIKACHU'\n            spinner_info = tile_elem.find('Spinner')\n            spinner_direction = spinner_info.get('direction') if spinner_info is not None else None\n            tile_map[(x, y)] = {'type': tile_type, 'has_obj': has_obj, 'spinner': spinner_direction}\n            if tile_elem.find('Player') is not None:\n                player_pos = (x, y)\n\n    if not player_pos:\n        print(json.dumps({'error': 'Player position not found.'}))\n        return\n\n    def is_walkable(coord):\n        if coord not in tile_map: return False\n        tile = tile_map[coord]\n        if tile['has_obj']: return False\n        return tile['type'] not in ['impassable', 'boulder_barrier', 'unknown', 'closed_gate']\n\n    def get_spinner_destination(start_coord):\n        x, y = start_coord\n        path = [start_coord]\n        visited = {start_coord}\n        while tile_map.get((x,y), {}).get('spinner') and tile_map[(x,y)]['spinner'] != 'stop':\n            direction = tile_map[(x, y)]['spinner']\n            if direction == 'up': y -= 1\n            elif direction == 'down': y += 1\n            elif direction == 'left': x -= 1\n            elif direction == 'right': x += 1\n            if not (1 <= x <= width and 1 <= y <= height) or (x, y) in visited:\n                return None, [] # Loop or out of bounds\n            visited.add((x, y))\n            path.append((x, y))\n        return (x, y), path\n\n    target_node = (target_x, target_y)\n    if not is_walkable(target_node):\n        # Find adjacent walkable tile if target is not\n        found_new_target = False\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            adj_target = (target_x + dx, target_y + dy)\n            if is_walkable(adj_target):\n                target_node = adj_target\n                found_new_target = True\n                break\n        if not found_new_target:\n            print(json.dumps({'error': 'Target is impassable and no adjacent traversable tile found.'}))\n            return\n\n    open_set = [(0, player_pos)]\n    came_from = {}\n    g_score = {player_pos: 0}\n\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == target_node:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(player_pos)\n            path.reverse()\n            \n            final_path = []\n            for i in range(len(path) - 1):\n                start_node = path[i]\n                final_path.append(start_node)\n                if tile_map[start_node]['spinner']:\n                    _, spin_path = get_spinner_destination(start_node)\n                    if spin_path and len(spin_path) > 1:\n                        final_path.extend(spin_path[1:])\n            if path[-1] not in final_path:\n                final_path.append(path[-1])\n\n            print(json.dumps([{'x': x, 'y': y} for x, y in final_path]))\n            return\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not is_walkable(neighbor): continue\n\n            move_cost = 1\n            final_dest = neighbor\n            if tile_map[neighbor]['spinner']:\n                dest, spin_path = get_spinner_destination(neighbor)\n                if dest is None: continue # Spinner leads to loop/invalid state\n                final_dest = dest\n                move_cost = len(spin_path)\n            \n            tentative_g_score = g_score[current] + move_cost\n            if final_dest not in g_score or tentative_g_score < g_score[final_dest]:\n                g_score[final_dest] = tentative_g_score\n                f_score = tentative_g_score + heuristic(final_dest, target_node)\n                heapq.heappush(open_set, (f_score, final_dest))\n                came_from[final_dest] = current\n\n    print(json.dumps({'error': 'No path found.'}))\n\nspinner_maze_solver(input_data, map_xml_string)"
  },
  "boulder_puzzle_solver": {
    "description": "Analyzes the map XML for a boulder puzzle and provides a step-by-step solution to move boulders onto switches.",
    "input_schema": {
      "type": "object",
      "properties": {
        "boulder_coords": {
          "type": "string",
          "description": "A stringified JSON array of initial boulder coordinates."
        },
        "switch_coords": {
          "type": "string",
          "description": "A stringified JSON array of switch coordinates."
        }
      },
      "required": [
        "boulder_coords",
        "switch_coords"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport collections\n\ndef solve_boulder_puzzle(input_data):\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    player_pos = None\n    map_width = int(root.get('width'))\n    map_height = int(root.get('height'))\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            has_obj = tile_elem.get('has-object') == 'true'\n            is_impassable = tile_type in ['impassable', 'boulder_barrier', 'unknown'] or has_obj\n            grid[(x, y)] = not is_impassable\n            if tile_elem.find('Player') is not None:\n                player_pos = (x, y)\n\n    initial_boulders = frozenset(tuple(b.values()) for b in json.loads(input_data['boulder_coords']))\n    switches = frozenset(tuple(s.values()) for s in json.loads(input_data['switch_coords']))\n\n    initial_state = (player_pos, initial_boulders)\n    queue = collections.deque([(initial_state, [])])\n    visited = {initial_state}\n\n    while queue:\n        (current_player_pos, current_boulders), path = queue.popleft()\n\n        if current_boulders == switches:\n            print(json.dumps({'solution_path': path}))\n            return\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_player_pos = (current_player_pos[0] + dx, current_player_pos[1] + dy)\n\n            if not grid.get(next_player_pos, False):\n                continue\n\n            if next_player_pos in current_boulders:\n                boulder_to_push = next_player_pos\n                next_boulder_pos = (boulder_to_push[0] + dx, boulder_to_push[1] + dy)\n\n                if not grid.get(next_boulder_pos, False) or next_boulder_pos in current_boulders:\n                    continue\n\n                new_boulders = frozenset(b for b in current_boulders if b != boulder_to_push) | {next_boulder_pos}\n                new_state = (boulder_to_push, new_boulders)\n                if new_state not in visited:\n                    visited.add(new_state)\n                    new_path = path + [f'Push boulder from {boulder_to_push} to {next_boulder_pos}']\n                    queue.append((new_state, new_path))\n            else:\n                new_state = (next_player_pos, current_boulders)\n                if new_state not in visited:\n                    visited.add(new_state)\n                    new_path = path + [f'Move player to {next_player_pos}']\n                    queue.append((new_state, new_path))\n\n    print(json.dumps({'error': 'No solution found.'}))\n\nsolve_boulder_puzzle(input_data)"
  }
}