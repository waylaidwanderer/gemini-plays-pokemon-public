{
  "find_path_v2": {
    "description": "Finds the shortest path between two coordinates on the current map using BFS, considering walls and objects as obstacles. Returns a JSON array of coordinates or buttons.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "type": "boolean"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "autopress_buttons"
      ],
      "type": "object"
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        \n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        end_x = int(input_data['end_x'])\n        end_y = int(input_data['end_y'])\n        \n        passable_tiles = set()\n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                x = int(tile.get('id'))\n                tile_type = tile.get('type')\n                has_object = tile.get('has-object') == 'true'\n                # Treat unseen tiles as potentially passable for pathfinding\n                # Row 0 is marked as WALL but might be passable\n                if tile_type in ['FLOOR', 'PIT', 'LADDER', 'ICE'] and not has_object:\n                    passable_tiles.add((x, y))\n                elif tile.get('seen') == 'false':\n                    passable_tiles.add((x, y))\n        \n        # Ensure start and end are considered passable for BFS\n        passable_tiles.add((start_x, start_y))\n        passable_tiles.add((end_x, end_y))\n\n        queue = deque([(start_x, start_y, [])])\n        visited = set([(start_x, start_y)])\n        \n        while queue:\n            x, y, path = queue.popleft()\n            if x == end_x and y == end_y:\n                full_path = [{\"x\": start_x, \"y\": start_y}] + path\n                if input_data.get('autopress_buttons'):\n                    buttons = []\n                    curr_x, curr_y = start_x, start_y\n                    for step in path:\n                        if step['x'] > curr_x: buttons.append('Right')\n                        elif step['x'] < curr_x: buttons.append('Left')\n                        elif step['y'] > curr_y: buttons.append('Down')\n                        elif step['y'] < curr_y: buttons.append('Up')\n                        curr_x, curr_y = step['x'], step['y']\n                    print(json.dumps(buttons))\n                else:\n                    print(json.dumps(full_path))\n                return\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < width and 0 <= ny < height and (nx, ny) in passable_tiles and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [{\"x\": nx, \"y\": ny}]))\n        \n        print(json.dumps({\"error\": \"No path found\"}))\n    except Exception as e:\n        print(json.dumps({\"error\": str(e)}))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T20:27:16.465Z",
        "action_counter": 29425
      },
      {
        "commit_message": "Refined to correctly identify objects using 'has-object' attribute and added logic for boulder bridges in pits.",
        "timestamp": "2025-12-28T20:30:14.390Z",
        "action_counter": 29431
      },
      {
        "commit_message": "Refined to correctly handle autopress_buttons by outputting button strings and fixed pathfinding logic for boulder bridges.",
        "timestamp": "2025-12-28T20:30:50.776Z",
        "action_counter": 29432
      },
      {
        "commit_message": "Refined to handle boulder bridges in Blackthorn Gym 1F and improved object detection.",
        "timestamp": "2025-12-28T20:47:40.334Z",
        "action_counter": 29458
      },
      {
        "commit_message": "Fixing missing commit message and improving tile passability logic.",
        "timestamp": "2025-12-28T22:59:48.479Z",
        "action_counter": 29673
      }
    ]
  },
  "solve_gym_puzzle_v3": {
    "description": "Calculates the sequence of button presses to solve the Blackthorn Gym boulder puzzle using persistent Mental Map data. Handles player movement and boulder pushing. Returns a JSON array of buttons.",
    "input_schema": {
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ],
      "type": "object"
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        \n        passable = set()\n        pits = set()\n        boulders = {}\n        \n        # Identify passable tiles and on-screen boulders\n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                x = int(tile.get('id'))\n                t_type = tile.get('type')\n                if t_type in ['FLOOR', 'LADDER', 'ICE']:\n                    has_obj = tile.get('has-object') == 'true'\n                    if has_obj:\n                        obj = tile.find('Object')\n                        if obj is not None and obj.get('id-name') == 'BOULDER':\n                            boulders[int(obj.get('id'))] = (x, y)\n                        else:\n                            continue\n                    passable.add((x, y))\n                elif t_type == 'PIT':\n                    pits.add((x, y))\n        \n        # Include off-screen boulders from markers\n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                x = int(tile.get('id'))\n                for marker in tile.findall('Marker'):\n                    if 'Boulder' in marker.text:\n                        bid = int(marker.get('object_id'))\n                        if bid not in boulders:\n                            boulders[bid] = (x, y)\n                            passable.add((x, y))\n\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        \n        def solve_one(b_id, current_boulders, p_pos):\n            bx, by = current_boulders[b_id]\n            others = {pos for id, pos in current_boulders.items() if id != b_id}\n            q = deque([(bx, by, p_pos[0], p_pos[1], [])])\n            v = set([(bx, by, p_pos[0], p_pos[1])])\n            while q:\n                cbx, cby, cpx, cpy, path = q.popleft()\n                if (cbx, cby) in pits: return path\n                if len(path) > 250: continue\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    npx, npy = cpx + dx, cpy + dy\n                    if 0 <= npx < width and 0 <= npy < height and (npx, npy) in passable and (npx, npy) not in others:\n                        if (npx, npy) == (cbx, cby):\n                            nbx, nby = cbx + dx, cby + dy\n                            if 0 <= nbx < width and 0 <= nby < height and ((nbx, nby) in passable or (nbx, nby) in pits) and (nbx, nby) not in others:\n                                if (nbx, nby, npx, npy) not in v:\n                                    v.add((nbx, nby, npx, npy))\n                                    btn = 'Up' if dy==-1 else 'Down' if dy==1 else 'Left' if dx==-1 else 'Right'\n                                    q.append((nbx, nby, npx, npy, path + [btn]))\n                        else:\n                            if (cbx, cby, npx, npy) not in v:\n                                v.add((cbx, cby, npx, npy))\n                                btn = 'Up' if dy==-1 else 'Down' if dy==1 else 'Left' if dx==-1 else 'Right'\n                                q.append((cbx, cby, npx, npy, path + [btn]))\n            return None\n\n        # Try to solve for each boulder in order\n        for b_id in sorted(boulders.keys()):\n            path = solve_one(b_id, boulders, (start_x, start_y))\n            if path:\n                print(json.dumps(path))\n                return\n        print(json.dumps({\"error\": \"No solution found\"}))\n    except Exception as e:\n        print(json.dumps({\"error\": str(e)}))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T23:28:51.968Z",
        "action_counter": 29702
      },
      {
        "commit_message": "Improving boulder puzzle solver to handle off-screen boulders via markers and increasing search depth.",
        "timestamp": "2025-12-28T23:36:42.932Z",
        "action_counter": 29717
      }
    ]
  },
  "analyze_missing_links": {
    "description": "Tests if making specific tiles passable would solve the boulder puzzle.",
    "input_schema": {
      "properties": {
        "test_tiles": {
          "items": {
            "properties": {
              "x": {
                "type": "integer"
              },
              "y": {
                "type": "integer"
              }
            },
            "required": [
              "x",
              "y"
            ],
            "type": "object"
          },
          "type": "array"
        }
      },
      "required": [
        "test_tiles"
      ],
      "type": "object"
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width, height = int(root.get('width')), int(root.get('height'))\n        passable, pits, boulders = set(), [(2, 5), (8, 3), (8, 7)], {6: (3, 3), 7: (6, 1), 8: (8, 14)}\n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                x = int(tile.get('id'))\n                if tile.get('type') in ['FLOOR', 'LADDER', 'ICE'] and (tile.get('has-object') != 'true' or (tile.find('Object') is not None and tile.find('Object').get('id-name') == 'BOULDER')):\n                    passable.add((x, y))\n        extra = {(t['x'], t['y']) for t in input_data['test_tiles']}\n        temp_passable = passable | extra\n        results = {}\n        for bid, bstart in boulders.items():\n            q, v = deque([bstart]), {bstart}\n            reachable_pit = None\n            while q:\n                bx, by = q.popleft()\n                if (bx, by) in pits: reachable_pit = (bx, by); break\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nbx, nby, px, py = bx + dx, by + dy, bx - dx, by - dy\n                    if 0 <= nbx < width and 0 <= nby < height and 0 <= px < width and 0 <= py < height and ((nbx, nby) in temp_passable or (nbx, nby) in pits) and (px, py) in temp_passable:\n                        if (nbx, nby) not in v:\n                            v.add((nbx, nby))\n                            q.append((nbx, nby))\n            results[bid] = str(reachable_pit) if reachable_pit else None\n        print(json.dumps(results))\n    except Exception as e:\n        print(json.dumps({'error': str(e)}))\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T23:46:49.073Z",
        "action_counter": 29731
      }
    ]
  }
}