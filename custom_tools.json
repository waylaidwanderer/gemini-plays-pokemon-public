{
  "find_adjacent_traversable_tiles": {
    "description": "Takes a target coordinate and finds all adjacent (non-diagonal) tiles that are traversable, returning them as a list of coordinates. This is useful for finding valid spots to stand when trying to interact with an object or NPC.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntry:\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n\n    root = ET.fromstring(map_xml_string)\n    \n    impassable_types = {\n        'WALL', 'VOID', 'WATER', 'BOOKSHELF', 'COUNTER', 'CUT_TREE',\n        'HEADBUTT_TREE', 'MART_SHELF', 'PC', 'PILLAR', 'RADIO', 'TOWN_MAP',\n        'TV', 'WINDOW'\n    }\n\n    grid = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            has_object = tile_elem.find('Object') is not None\n            \n            is_impassable = (tile_type in impassable_types) or has_object\n            grid[(x, y)] = not is_impassable\n\n    adjacent_traversable = []\n    for dx, dy, direction in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n        nx, ny = target_x + dx, target_y + dy\n        neighbor_coord = (nx, ny)\n\n        if grid.get(neighbor_coord, False):\n            adjacent_traversable.append({'x': nx, 'y': ny, 'direction_from_target': direction})\n            \n    print(json.dumps(adjacent_traversable))\n\nexcept Exception as e:\n    print(json.dumps({\"error\": str(e)}))",
    "history": [
      {
        "commit_message": "feat: Create tool to find valid interaction spots. This tool, `find_adjacent_traversable_tiles`, replaces the functionality of the deleted `hypothesis_generator` agent. It deterministically parses the map XML to find all valid, traversable tiles adjacent to a target coordinate. This provides a reliable method for generating testable puzzle hypotheses and directly addresses the system critique regarding the faulty agent.",
        "timestamp": "2025-10-31T11:18:33.232Z",
        "action_counter": 10203
      }
    ]
  },
  "path_with_obstacle_avoidance": {
    "description": "A combined pathfinding tool that first automatically detects on-screen obstacles and then generates a path to the target, avoiding them. This automates the two-step process of calling get_on_screen_object_locations and then generate_path_plan.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\nimport json\nimport sys\n\n# --- Start of combined logic from get_on_screen_object_locations ---\nobject_locations = {}\ntry:\n    root = ET.fromstring(map_xml_string)\n    for tile_elem in root.findall('.//Object/..'):\n        obj_elem = tile_elem.find('Object')\n        obj_id = obj_elem.get('id')\n        if obj_id == '0': # Skip player\n            continue\n        \n        coord_str = tile_elem.get('coordinate')\n        if coord_str:\n            x_str, y_str = coord_str.strip('()').split(',')\n            x, y = int(x_str.strip()), int(y_str.strip())\n            object_locations[obj_id] = [x, y]\nexcept ET.ParseError:\n    pass\nobject_locations_json_str = json.dumps(object_locations)\n# --- End of combined logic ---\n\n# --- Start of logic from generate_path_plan ---\nstart_x_str = input_data['start_x']\nstart_y_str = input_data['start_y']\ntarget_x_str = input_data['target_x']\ntarget_y_str = input_data['target_y']\n\nstart_x, start_y = int(start_x_str), int(start_y_str)\ntarget_x, target_y = int(target_x_str), int(target_y_str)\n\nroot = ET.fromstring(map_xml_string)\nmap_id = root.get('id')\nimpassable_types = {'WALL', 'WATER', 'COUNTER', 'MART_SHELF', 'PC', 'TV', 'BOOKSHELF', 'RADIO', 'TOWN_MAP', 'WINDOW', 'CUT_TREE', 'HEADBUTT_TREE'}\n\ntile_data = {}\nfor tile_elem in root.findall('.//Tile'):\n    coord_str = tile_elem.get('coordinate')\n    x_str, y_str = coord_str.strip('()').split(',')\n    x, y = int(x_str.strip()), int(y_str.strip())\n    tile_data[(x, y)] = {'type': tile_elem.get('type'), 'is_warp': tile_elem.get('is-warp') == 'true'}\n\nobstacle_coords = set()\nif object_locations_json_str and object_locations_json_str != 'null':\n    try:\n        loaded_locations = json.loads(object_locations_json_str)\n        if isinstance(loaded_locations, dict):\n            for obj_id, coords in loaded_locations.items():\n                if isinstance(coords, list) and len(coords) == 2:\n                    obstacle_coords.add((int(coords[0]), int(coords[1])))\n    except (json.JSONDecodeError, TypeError):\n        pass\n\nstart_node = (start_x, start_y)\ntarget_node = (target_x, target_y)\n\nqueue = collections.deque([[start_node]])\nvisited = {start_node}\n\nwhile queue:\n    path = queue.popleft()\n    x, y = path[-1]\n\n    if (x, y) == target_node:\n        print(json.dumps([{'x': px, 'y': py} for px, py in path]))\n        sys.exit()\n\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n        nx, ny = x + dx, y + dy\n        neighbor_node = (nx, ny)\n\n        if neighbor_node in visited or neighbor_node not in tile_data:\n            continue\n        \n        if neighbor_node in obstacle_coords:\n            continue\n\n        current_tile_data = tile_data.get((x,y))\n        neighbor_tile_data = tile_data.get(neighbor_node)\n\n        current_tile_type = current_tile_data['type']\n        neighbor_tile_type = neighbor_tile_data['type']\n\n        if neighbor_tile_type in impassable_types:\n            continue\n        \n        if neighbor_tile_data['is_warp'] and neighbor_node != target_node:\n            continue\n\n        if current_tile_type == 'LEDGE_HOP_DOWN' and dy == -1: continue\n        if current_tile_type == 'LEDGE_HOP_LEFT' and dx == 1: continue\n        if current_tile_type == 'LEDGE_HOP_RIGHT' and dx == -1: continue\n        if current_tile_type == 'FLOOR_UP_WALL' and dy == -1 and map_id == '3_37': continue\n\n        # Corrected logic for moving ONTO a ledge\n        if neighbor_tile_type == 'LEDGE_HOP_DOWN' and dy == -1: continue\n        if neighbor_tile_type == 'LEDGE_HOP_LEFT' and dx == 1: continue\n        if neighbor_tile_type == 'LEDGE_HOP_RIGHT' and dx == -1: continue\n        \n        if neighbor_tile_type == 'FLOOR_UP_WALL' and dy == 1 and map_id in ['10_9', '10_1', '3_37', '3_38', '3_78']:\n            continue\n        \n        visited.add(neighbor_node)\n        new_path = list(path)\n        new_path.append(neighbor_node)\n        queue.append(new_path)\n\nprint(json.dumps([]))",
    "history": [
      {
        "commit_message": "feat: Create automated obstacle avoidance pathfinder. This new tool, `path_with_obstacle_avoidance`, combines the functionality of `get_on_screen_object_locations` and `generate_path_plan` into a single call. It automatically detects on-screen NPCs and treats them as obstacles, streamlining the re-pathing process after an interruption and addressing a recurring process failure of not accounting for on-screen objects.",
        "timestamp": "2025-11-03T17:58:14.496Z",
        "action_counter": 17465
      },
      {
        "commit_message": "fix: Correct inverted ledge traversal logic. The tool was created with a copy of an old, buggy version of the `generate_path_plan` script. The logic for preventing movement *onto* a ledge was inverted (e.g., checking `dy == 1` instead of `dy == -1` for a down-ledge). This commit corrects the directional checks to align with game mechanics, resolving the critical pathfinding failure that caused the tool to generate paths up cliffs.",
        "timestamp": "2025-11-03T17:59:43.152Z",
        "action_counter": 17468
      },
      {
        "commit_message": "fix: Correct player-skipping logic to properly detect all NPC obstacles. The original condition `if obj_id is None or obj_id == '0':` incorrectly skipped NPCs that were missing an `id` attribute. The new condition `if obj_id == '0':` ensures only the player is skipped, resolving the critical pathing failure where the tool routed through an on-screen trainer.",
        "timestamp": "2025-11-03T20:55:04.807Z",
        "action_counter": 17681
      }
    ]
  },
  "deterministic_battle_strategist": {
    "description": "A deterministic, non-LLM tool that analyzes battle state and recommends the next action (FIGHT/RUN) and move. A reliable backup for the simple_battle_strategist agent.",
    "input_schema": {
      "type": "object",
      "properties": {
        "my_pokemon_level": {
          "type": "integer"
        },
        "my_pokemon_hp_current": {
          "type": "integer"
        },
        "my_pokemon_hp_max": {
          "type": "integer"
        },
        "opponent_pokemon_name": {
          "type": "string"
        },
        "opponent_pokemon_level": {
          "type": "integer",
          "nullable": true
        },
        "move_1_name": {
          "type": "string"
        },
        "move_1_pp_current": {
          "type": "integer"
        },
        "move_2_name": {
          "type": "string",
          "nullable": true
        },
        "move_2_pp_current": {
          "type": "integer",
          "nullable": true
        },
        "move_3_name": {
          "type": "string",
          "nullable": true
        },
        "move_3_pp_current": {
          "type": "integer",
          "nullable": true
        },
        "move_4_name": {
          "type": "string",
          "nullable": true
        },
        "move_4_pp_current": {
          "type": "integer",
          "nullable": true
        },
        "current_objective": {
          "type": "string",
          "enum": [
            "TRAINING",
            "TRAVELING"
          ]
        },
        "battle_type": {
          "type": "string",
          "enum": [
            "WILD",
            "TRAINER"
          ]
        }
      },
      "required": [
        "my_pokemon_level",
        "my_pokemon_hp_current",
        "my_pokemon_hp_max",
        "opponent_pokemon_name",
        "move_1_name",
        "move_1_pp_current",
        "current_objective",
        "battle_type"
      ]
    },
    "python_script": "import json\n\n# --- Knowledge Base ---\nKNOWN_POKEMON_TYPES = {\n    'BEEDRILL': ['Bug', 'Poison'], 'BELLSPROUT': ['Grass', 'Poison'], 'CATERPIE': ['Bug'],\n    'CROCONAW': ['Water'], 'DUNSPARCE': ['Normal'], 'EKANS': ['Poison'], 'GASTLY': ['Ghost', 'Poison'],\n    'GEODUDE': ['Rock', 'Ground'], 'HOOTHOOT': ['Normal', 'Flying'], 'HOPPIP': ['Grass', 'Flying'],\n    'KAKUNA': ['Bug', 'Poison'], 'LEDYBA': ['Bug', 'Flying'], 'METAPOD': ['Bug'], 'ODDISH': ['Grass', 'Poison'],\n    'ONIX': ['Rock', 'Ground'], 'PARAS': ['Bug', 'Grass'], 'PIDGEY': ['Normal', 'Flying'], 'POLIWAG': ['Water'],\n    'PSYDUCK': ['Water'], 'RATTATA': ['Normal'], 'SANDSHREW': ['Ground'], 'SCYTHER': ['Bug', 'Flying'],\n    'SLOWPOKE': ['Water', 'Psychic'], 'SPEAROW': ['Normal', 'Flying'], 'SPINARAK': ['Bug', 'Poison'],\n    'VENONAT': ['Bug', 'Poison'], 'VULPIX': ['Fire'], 'WEEDLE': ['Bug', 'Poison'], 'WOOPER': ['Water', 'Ground'],\n    'ZUBAT': ['Poison', 'Flying']\n}\n\nKNOWN_MOVE_TYPES = {\n    'TACKLE': 'Normal', 'QUICK ATTACK': 'Normal', 'EMBER': 'Fire', 'FLAME WHEEL': 'Fire',\n    'HIDDEN POWER': 'Psychic', 'LEER': 'Normal', 'GROWL': 'Normal', 'CHARM': 'Normal'\n}\n\nSTATUS_MOVES = {'LEER', 'GROWL', 'CHARM'}\n\nTYPE_CHART = {\n    'Fire': {'super_effective': ['Bug', 'Grass'], 'not_very_effective': ['Water', 'Fire', 'Rock', 'Ground'], 'no_effect': []},\n    'Ground': {'super_effective': ['Fire'], 'not_very_effective': [], 'no_effect': []},\n    'Normal': {'super_effective': [], 'not_very_effective': ['Rock', 'Ground'], 'no_effect': ['Ghost']},\n    'Psychic': {'super_effective': [], 'not_very_effective': ['Bug'], 'no_effect': []}\n}\n\n# --- Input Parsing ---\nmy_level = int(input_data['my_pokemon_level'])\nopponent_name = input_data['opponent_pokemon_name']\nopponent_level_str = input_data.get('opponent_pokemon_level')\nopponent_level = int(opponent_level_str) if opponent_level_str and opponent_level_str != 'null' else None\nobjective = input_data['current_objective']\nbattle_type = input_data['battle_type']\nmy_hp_current = int(input_data['my_pokemon_hp_current'])\nmy_hp_max = int(input_data['my_pokemon_hp_max'])\n\nmoves_input = [\n    (input_data.get('move_1_name'), input_data.get('move_1_pp_current')),\n    (input_data.get('move_2_name'), input_data.get('move_2_pp_current')),\n    (input_data.get('move_3_name'), input_data.get('move_3_pp_current')),\n    (input_data.get('move_4_name'), input_data.get('move_4_pp_current'))\n]\n\nmoves = [(name, int(pp)) for name, pp in moves_input if name and pp is not None]\n\n# --- Logic ---\nif battle_type == 'TRAINER':\n    pass\nelif objective == 'TRAINING':\n    if (my_hp_current / my_hp_max) < 0.25:\n        print(json.dumps({'action': 'RUN', 'move_to_use': None}))\n        exit()\nelse: # Traveling\n    if opponent_level is not None and my_level >= opponent_level + 20:\n        pass # Fall through to fight\n    elif opponent_level is None:\n        pass # Level unknown, fall through to effectiveness check\n    else:\n        print(json.dumps({'action': 'RUN', 'move_to_use': None}))\n        exit()\n\n# --- Move Selection ---\nopponent_types = KNOWN_POKEMON_TYPES.get(opponent_name, [])\n\nscored_moves = []\nfor name, pp in moves:\n    if pp == 0 or name in STATUS_MOVES:\n        continue\n\n    move_type = KNOWN_MOVE_TYPES.get(name)\n    if not move_type or not opponent_types:\n        effectiveness = 1.0\n    else:\n        effectiveness = 1.0\n        chart = TYPE_CHART.get(move_type, {})\n        for opp_type in opponent_types:\n            if opp_type in chart.get('super_effective', []): effectiveness *= 2.0\n            if opp_type in chart.get('not_very_effective', []): effectiveness *= 0.5\n            if opp_type in chart.get('no_effect', []): effectiveness *= 0.0\n    \n    scored_moves.append({'name': name, 'pp': pp, 'effectiveness': effectiveness})\n\nif not scored_moves:\n    print(json.dumps({'action': 'RUN', 'move_to_use': None}))\n    exit()\n\nbest_move = sorted(scored_moves, key=lambda x: (x['effectiveness'], x['pp']), reverse=True)[0]\n\nif objective == 'TRAVELING' and best_move['effectiveness'] <= 0.5:\n    print(json.dumps({'action': 'RUN', 'move_to_use': None}))\n    exit()\n\nprint(json.dumps({'action': 'FIGHT', 'move_to_use': best_move['name']}))\n",
    "history": [
      {
        "commit_message": "feat: Create deterministic battle strategist. This tool replaces the unreliable simple_battle_strategist agent, which has been failing due to server errors. It uses a hardcoded type chart and logic to provide a stable and consistent source of battle advice, directly addressing a critical system critique.",
        "timestamp": "2025-11-03T18:25:45.289Z",
        "action_counter": 17503
      },
      {
        "commit_message": "fix: Correctly filter status moves. The previous version had a flawed check that failed to exclude status moves like LEER, causing it to give incorrect battle advice. This commit introduces a dedicated `STATUS_MOVES` set and adds a clear check (`if name in STATUS_MOVES`) to the move evaluation loop, ensuring that only damaging moves are considered. This resolves the critical logic bug.",
        "timestamp": "2025-11-03T18:29:57.269Z",
        "action_counter": 17510
      },
      {
        "commit_message": "fix: Handle null opponent level in wild battles. The script was crashing with a ValueError when `opponent_pokemon_level` was the string 'null'. This commit adds an explicit check for 'null' before attempting integer conversion, preventing the crash and allowing the tool to function correctly in wild encounters where the opponent's level is not displayed.",
        "timestamp": "2025-11-03T19:50:14.395Z",
        "action_counter": 17599
      },
      {
        "commit_message": "feat: Add Sandshrew type and improve run logic. The tool previously recommended fighting a Sandshrew with a Fire-type because it lacked type information and its run logic was too simple. This commit adds 'SANDSHREW' to the `KNOWN_POKEMON_TYPES` dictionary and introduces a new check to automatically run from wild battles when traveling if the best available move is not very effective. This improves strategic decision-making and prevents wasting resources on unfavorable encounters.",
        "timestamp": "2025-11-03T20:58:14.951Z",
        "action_counter": 17685
      },
      {
        "commit_message": "fix: Prevent automatic run when opponent level is unknown. The previous logic would default to 'RUN' during wild encounters where the opponent's level is not displayed, bypassing the more nuanced type-effectiveness check. This commit adds a specific condition to handle `opponent_level` being `None`, allowing the script to fall through to the effectiveness logic and make a more intelligent decision. This resolves the critical failure where the tool recommended running from a battle with a clear type advantage.",
        "timestamp": "2025-11-03T21:39:18.957Z",
        "action_counter": 17743
      }
    ]
  },
  "find_reachable_unseen_tiles": {
    "description": "Parses the map XML and current player position to return a list of unseen tiles that are confirmed to be reachable, filtering out those blocked by walls or other obstacles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\nimport json\nimport sys\n\nstart_x_str = input_data['start_x']\nstart_y_str = input_data['start_y']\nstart_x, start_y = int(start_x_str), int(start_y_str)\n\nroot = ET.fromstring(map_xml_string)\nmap_id = root.get('id')\nimpassable_types = {'WALL', 'WATER', 'COUNTER', 'MART_SHELF', 'PC', 'TV', 'BOOKSHELF', 'RADIO', 'TOWN_MAP', 'WINDOW', 'CUT_TREE', 'HEADBUTT_TREE'}\n\ntile_data = {}\nunseen_tiles = []\nfor tile_elem in root.findall('.//Tile'):\n    coord_str = tile_elem.get('coordinate')\n    x_str, y_str = coord_str.strip('()').split(',')\n    x, y = int(x_str.strip()), int(y_str.strip())\n    tile_type = tile_elem.get('type')\n    is_warp = tile_elem.get('is-warp') == 'true'\n    tile_data[(x, y)] = {'type': tile_type, 'is_warp': is_warp}\n    if tile_elem.get('seen') == 'false':\n        unseen_tiles.append((x, y))\n\nstart_node = (start_x, start_y)\nqueue = collections.deque([start_node])\nvisited = {start_node}\nreachable_unseen = []\n\nwhile queue:\n    x, y = queue.popleft()\n\n    if (x, y) in unseen_tiles and (x, y) not in reachable_unseen:\n        reachable_unseen.append({'x': x, 'y': y})\n\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n        nx, ny = x + dx, y + dy\n        neighbor_node = (nx, ny)\n\n        if neighbor_node in visited or neighbor_node not in tile_data:\n            continue\n\n        current_tile_data = tile_data.get((x,y))\n        neighbor_tile_data = tile_data.get(neighbor_node)\n        current_tile_type = current_tile_data['type']\n        neighbor_tile_type = neighbor_tile_data['type']\n\n        if neighbor_tile_type in impassable_types:\n            continue\n        \n        if neighbor_tile_data['is_warp']:\n            continue\n\n        if current_tile_type == 'LEDGE_HOP_DOWN' and dy == -1: continue\n        if current_tile_type == 'LEDGE_HOP_LEFT' and dx == 1: continue\n        if current_tile_type == 'LEDGE_HOP_RIGHT' and dx == -1: continue\n        if neighbor_tile_type == 'LEDGE_HOP_DOWN' and dy == -1: continue\n        if neighbor_tile_type == 'LEDGE_HOP_LEFT' and dx == 1: continue\n        if neighbor_tile_type == 'LEDGE_HOP_RIGHT' and dx == -1: continue\n        if neighbor_tile_type == 'FLOOR_UP_WALL' and dy == 1 and map_id in ['10_9', '10_1', '3_37', '3_38', '3_78']: continue\n        \n        visited.add(neighbor_node)\n        queue.append(neighbor_node)\n\nprint(json.dumps(reachable_unseen))",
    "history": [
      {
        "commit_message": "feat: Create tool to find reachable unseen tiles. This tool automates the process of checking for explorable areas by performing a BFS from the player's position and returning a list of all unseen tiles that are confirmed to be reachable. This addresses a recurring strategic need for efficient exploration.",
        "timestamp": "2025-11-04T01:31:43.456Z",
        "action_counter": 18091
      }
    ]
  },
  "automated_navigation_tool": {
    "description": "Automates navigation to a target coordinate. The tool generates a path, executes movement, automatically handles battle interruptions by attempting to run, and then re-paths from the new location until the destination is reached. This tool is intended to be called repeatedly across turns until it reports success.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        },
        "state_json": {
          "type": "string",
          "description": "A JSON string representing the tool's state from the previous turn. Use an empty dict '{}' for the first call."
        }
      },
      "required": [
        "target_x",
        "target_y",
        "state_json"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nimport collections\n\n# This tool is stateful and designed to be called across multiple turns.\n# It returns a JSON object with 'status' ('IN_PROGRESS', 'SUCCESS', 'FAILURE'),\n# 'next_state_json' (to be passed in the next call), and 'buttons_to_press'.\n\ninput_data_dict = json.loads(input_data['state_json'])\nstate = input_data_dict.get('state', 'START')\ntarget_x = int(input_data['target_x'])\ntarget_y = int(input_data['target_y'])\n\ndef get_player_pos():\n    root = ET.fromstring(map_xml_string)\n    player_tile = root.find('.//Player/..')\n    if player_tile is not None:\n        coord_str = player_tile.get('coordinate')\n        x_str, y_str = coord_str.strip('()').split(',')\n        return int(x_str.strip()), int(y_str.strip())\n    return None, None\n\ndef pathfind(start_x, start_y, end_x, end_y):\n    # This is the logic from path_with_obstacle_avoidance\n    object_locations = {}\n    try:\n        root = ET.fromstring(map_xml_string)\n        for tile_elem in root.findall('.//Object/..'):\n            obj_elem = tile_elem.find('Object')\n            obj_id = obj_elem.get('id')\n            if obj_id == '0': continue\n            coord_str = tile_elem.get('coordinate')\n            if coord_str:\n                x_str, y_str = coord_str.strip('()').split(',')\n                x, y = int(x_str.strip()), int(y_str.strip())\n                object_locations[obj_id] = [x, y]\n    except ET.ParseError:\n        pass\n    \n    root = ET.fromstring(map_xml_string)\n    map_id = root.get('id')\n    impassable_types = {'WALL', 'WATER', 'COUNTER', 'MART_SHELF', 'PC', 'TV', 'BOOKSHELF', 'RADIO', 'TOWN_MAP', 'WINDOW', 'CUT_TREE', 'HEADBUTT_TREE'}\n    tile_data = {}\n    for tile_elem in root.findall('.//Tile'):\n        coord_str = tile_elem.get('coordinate')\n        x_str, y_str = coord_str.strip('()').split(',')\n        x, y = int(x_str.strip()), int(y_str.strip())\n        tile_data[(x, y)] = {'type': tile_elem.get('type'), 'is_warp': tile_elem.get('is-warp') == 'true'}\n\n    obstacle_coords = set(tuple(coords) for coords in object_locations.values())\n    start_node = (start_x, start_y)\n    target_node = (end_x, end_y)\n    if start_node == target_node: return []\n\n    queue = collections.deque([[start_node]])\n    visited = {start_node}\n\n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n        if (x, y) == target_node: return path\n\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = x + dx, y + dy\n            neighbor_node = (nx, ny)\n            if neighbor_node in visited or neighbor_node not in tile_data: continue\n            if neighbor_node in obstacle_coords: continue\n            current_tile_data = tile_data.get((x,y))\n            neighbor_tile_data = tile_data.get(neighbor_node)\n            if not current_tile_data or not neighbor_tile_data: continue\n            if neighbor_tile_data['type'] in impassable_types: continue\n            if neighbor_tile_data['is_warp'] and neighbor_node != target_node: continue\n            if current_tile_data['type'] == 'LEDGE_HOP_DOWN' and dy == -1: continue\n            if current_tile_data['type'] == 'LEDGE_HOP_LEFT' and dx == 1: continue\n            if current_tile_data['type'] == 'LEDGE_HOP_RIGHT' and dx == -1: continue\n            if neighbor_tile_data['type'] == 'LEDGE_HOP_DOWN' and dy == -1: continue\n            if neighbor_tile_data['type'] == 'LEDGE_HOP_LEFT' and dx == 1: continue\n            if neighbor_tile_data['type'] == 'LEDGE_HOP_RIGHT' and dx == -1: continue\n            if neighbor_tile_data['type'] == 'FLOOR_UP_WALL' and dy == 1 and map_id in ['10_9', '10_1', '3_37', '3_38', '3_78']: continue\n            visited.add(neighbor_node)\n            new_path = list(path)\n            new_path.append(neighbor_node)\n            queue.append(new_path)\n    return None # No path found\n\nplayer_x, player_y = get_player_pos()\n\nif player_x is None:\n    # Not in overworld (e.g., in battle). Assume we need to run.\n    output = {\n        'status': 'IN_PROGRESS',\n        'message': 'In battle, attempting to run.',\n        'next_state_json': json.dumps({'state': 'BATTLE_RECOVERY'}),\n        'buttons_to_press': ['tool:select_battle_option:{\"option_to_select\":\"RUN\"}'] # Special format for autopress\n    }\nelse:\n    if (player_x, player_y) == (target_x, target_y):\n        output = {\n            'status': 'SUCCESS',\n            'message': 'Destination reached.',\n            'next_state_json': json.dumps({}),\n            'buttons_to_press': []\n        }\n    else:\n        # Either START or BATTLE_RECOVERY, we need to pathfind.\n        path = pathfind(player_x, player_y, target_x, target_y)\n        if path is not None and len(path) > 1:\n            output = {\n                'status': 'IN_PROGRESS',\n                'message': f'Pathing from ({player_x}, {player_y}) to ({target_x}, {target_y}).',\n                'next_state_json': json.dumps({'state': 'MOVING'}),\n                'path_plan': [{'x': p[0], 'y': p[1]} for p in path] # This will be used by the runner\n            }\n        else:\n            output = {\n                'status': 'FAILURE',\n                'message': f'No path found from ({player_x}, {player_y}) to ({target_x}, {target_y}).',\n                'next_state_json': json.dumps({}),\n                'buttons_to_press': []\n            }\n\nprint(json.dumps(output))",
    "history": [
      {
        "commit_message": "feat: Create automated navigation tool. This tool, `automated_navigation_tool`, automates the entire process of navigating to a destination, including pathfinding, executing movement, handling random battle interruptions by running, and re-pathing. This is a major process improvement designed to eliminate the significant time wasted on manual battle handling during exploration and puzzle-solving.",
        "timestamp": "2025-11-04T03:40:39.797Z",
        "action_counter": 18295
      }
    ]
  }
}