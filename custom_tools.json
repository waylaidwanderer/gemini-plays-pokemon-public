{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "boulder_push_planner": {
    "description": "Analyzes the map to find a sequence of moves for the player to push a specific boulder to a specific hole. It considers impassable terrain and other objects.",
    "input_schema": {
      "type": "object",
      "properties": {
        "boulder_start_x": {
          "type": "string"
        },
        "boulder_start_y": {
          "type": "string"
        },
        "hole_x": {
          "type": "string"
        },
        "hole_y": {
          "type": "string"
        },
        "player_x": {
          "type": "string"
        },
        "player_y": {
          "type": "string"
        }
      },
      "required": [
        "boulder_start_x",
        "boulder_start_y",
        "hole_x",
        "hole_y",
        "player_x",
        "player_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\n\ndef parse_map():\n    grid = [['' for _ in range(width)] for _ in range(height)]\n    impassable = set()\n    for r_idx, row_elem in enumerate(root.findall('Row')):\n        y = int(row_elem.get('id')) - 1\n        for c_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n            x = int(tile_elem.get('id')) - 1\n            tile_type = tile_elem.get('type')\n            grid[y][x] = tile_type\n            traversable_types = {'ground', 'grass', 'open_gate', 'cleared_boulder_barrier', 'boulder_switch', 'teleport', 'hole', 'spinner_stop', 'cuttable', 'elevated_ground', 'ladder_up', 'ladder_down', 'steps', 'water'}\n            if tile_type not in traversable_types or tile_elem.find('Object') is not None:\n                impassable.add((x, y))\n    return grid, impassable\n\ngrid, initial_impassable = parse_map()\n\nplayer_start_x, player_start_y = int(input_data['player_x']) - 1, int(input_data['player_y']) - 1\nboulder_start_x, boulder_start_y = int(input_data['boulder_start_x']) - 1, int(input_data['boulder_start_y']) - 1\nhole_x, hole_y = int(input_data['hole_x']) - 1, int(input_data['hole_y']) - 1\n\ndef find_path(start, end, impassable):\n    q = deque([(start, [])])\n    visited = {start}\n    while q:\n        (x, y), path = q.popleft()\n        if (x, y) == end:\n            return path\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited and (nx, ny) not in impassable:\n                visited.add((nx, ny))\n                q.append(((nx, ny), path + [(nx, ny)]))\n    return None\n\n\ndef solve_boulder_puzzle():\n    # State: (player_pos, boulder_pos, path_to_state)\n    q = deque([((player_start_x, player_start_y), (boulder_start_x, boulder_start_y), [])])\n    visited_states = {((player_start_x, player_start_y), (boulder_start_x, boulder_start_y))}\n\n    while q:\n        player_pos, boulder_pos, full_path = q.popleft()\n\n        if boulder_pos == (hole_x, hole_y):\n            return full_path\n\n        # Try to push the boulder in each of the 4 directions\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            # Player needs to be on the opposite side to push\n            player_target_pos = (boulder_pos[0] - dx, boulder_pos[1] - dy)\n            new_boulder_pos = (boulder_pos[0] + dx, boulder_pos[1] + dy)\n\n            # Check if new boulder position is valid\n            if not (0 <= new_boulder_pos[0] < width and 0 <= new_boulder_pos[1] < height):\n                continue\n            if new_boulder_pos in initial_impassable and new_boulder_pos != (hole_x, hole_y):\n                continue\n\n            # Path for player to get to the pushing position\n            current_impassable = initial_impassable.copy()\n            current_impassable.add(boulder_pos)\n            path_to_push_pos = find_path(player_pos, player_target_pos, current_impassable)\n\n            if path_to_push_pos is not None:\n                # If player can reach, check if this state has been visited\n                new_state = (boulder_pos, new_boulder_pos)\n                if new_state not in visited_states:\n                    visited_states.add(new_state)\n                    # The new player position is where the boulder was\n                    new_player_pos = boulder_pos\n                    # The path to push is the path to get behind the boulder, then the push itself\n                    move_sequence = [{'type': 'move', 'path': [{'x': p[0]+1, 'y': p[1]+1} for p in path_to_push_pos]}] if path_to_push_pos else []\n                    move_sequence.append({'type': 'push', 'direction': (dx, dy)})\n                    \n                    new_full_path = full_path + move_sequence\n                    q.append((new_player_pos, new_boulder_pos, new_full_path))\n\n    return None\n\nplan = solve_boulder_puzzle()\n\nif plan:\n    print(json.dumps({'plan': plan, 'reasoning': 'Found a plan to push the boulder to the hole.'}))\nelse:\n    print(json.dumps({'plan': None, 'reasoning': 'Could not find a plan.'}))"
  },
  "find_path": {
    "description": "A consolidated pathfinding tool. Finds a path to specified X, Y coordinates. If no coordinates are provided, it finds a path to the nearest reachable unseen tile. It automatically paths to an adjacent tile if the target is impassable. It can now handle mixed traversal types (walking and surfing) and elevation changes via steps.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string",
          "nullable": true
        },
        "end_y": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\ngrid = [['' for _ in range(width)] for _ in range(height)]\nimpassable_coords = set()\nunseen_tiles = []\n\nwalk_types = {'ground', 'grass', 'open_gate', 'cleared_boulder_barrier', 'boulder_switch', 'teleport', 'hole', 'spinner_stop', 'cuttable', 'elevated_ground', 'ladder_up', 'ladder_down', 'steps'}\nsurf_types = {'water'}\n\nfor r_idx, row_elem in enumerate(root.findall('Row')):\n    y = int(row_elem.get('id')) - 1\n    for c_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n        x = int(tile_elem.get('id')) - 1\n        tile_type = tile_elem.get('type')\n        grid[y][x] = tile_type\n        if tile_elem.get('seen') == 'false':\n            unseen_tiles.append((x, y))\n        if tile_elem.find('Object') is not None and (tile_elem.find('Object').get('id-name') != 'Pikachu'):\n            impassable_coords.add((x, y))\n\nstart_x, start_y = int(input_data['start_x']) - 1, int(input_data['start_y']) - 1\nend_x = int(input_data.get('end_x', None)) - 1 if input_data.get('end_x') else None\nend_y = int(input_data.get('end_y', None)) - 1 if input_data.get('end_y') else None\n\ndef is_target_adjacent(current_x, current_y, target_x, target_y):\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        if current_x == target_x + dx and current_y == target_y + dy:\n            return True\n    return False\n\ndef find_path_bfs():\n    traversable_types = walk_types | surf_types\n    if (start_x, start_y) in impassable_coords or grid[start_y][start_x] not in traversable_types:\n        return []\n        \n    queue = deque([((start_x, start_y), [(start_x, start_y)])])\n    visited = {(start_x, start_y)}\n\n    target_is_impassable = False\n    if end_x is not None and end_y is not None:\n        if not (0 <= end_x < width and 0 <= end_y < height) or (end_x, end_y) in impassable_coords or grid[end_y][end_x] not in traversable_types:\n            target_is_impassable = True\n\n    while queue:\n        (current_x, current_y), path = queue.popleft()\n\n        if end_x is not None and end_y is not None:\n            if not target_is_impassable:\n                if current_x == end_x and current_y == end_y:\n                    return path\n            else:\n                if is_target_adjacent(current_x, current_y, end_x, end_y):\n                    return path\n        elif unseen_tiles:\n            for ux, uy in unseen_tiles:\n                if is_target_adjacent(current_x, current_y, ux, uy):\n                    return path\n        \n        for move in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = current_x + move[0], current_y + move[1]\n\n            if not (0 <= next_x < width and 0 <= next_y < height) or (next_x, next_y) in visited:\n                continue\n\n            current_tile_type = grid[current_y][current_x]\n            next_tile_type = grid[next_y][next_x]\n\n            if next_tile_type == 'ledge':\n                if next_y > current_y:\n                    ledge_jump_y = next_y + 1\n                    if 0 <= ledge_jump_y < height and (next_x, ledge_jump_y) not in visited and (next_x, ledge_jump_y) not in impassable_coords:\n                        new_path = path + [(next_x, next_y), (next_x, ledge_jump_y)]\n                        visited.add((next_x, next_y))\n                        visited.add((next_x, ledge_jump_y))\n                        queue.append(((next_x, ledge_jump_y), new_path))\n                continue\n\n            if (next_x, next_y) in impassable_coords or next_tile_type not in traversable_types:\n                continue\n            \n            # Prevent moving from land to water or water to land\n            is_current_walk = current_tile_type in walk_types\n            is_next_walk = next_tile_type in walk_types\n            is_current_surf = current_tile_type in surf_types\n            is_next_surf = next_tile_type in surf_types\n\n            if (is_current_walk and is_next_surf) or (is_current_surf and is_next_walk):\n                continue\n\n            visited.add((next_x, next_y))\n            new_path = path + [(next_x, next_y)]\n            queue.append(((next_x, next_y), new_path))\n            \n    return []\n\nfound_path = find_path_bfs()\n\nif found_path:\n    path_plan = [{'x': x + 1, 'y': y + 1} for x, y in found_path]\n    target_x, target_y = path_plan[-1]['x'], path_plan[-1]['y']\n    reasoning = f'Path found to target at ({target_x}, {target_y}).'\n    print(json.dumps({'path': path_plan, 'reasoning': reasoning}))\nelse:\n    print(json.dumps({'path': [], 'reasoning': 'Could not find a path to any reachable targets.'}))"
  },
  "get_impassable_tiles": {
    "description": "Extracts and returns a JSON list of all impassable tile coordinates from the current map XML.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET; import json; root = ET.fromstring(map_xml_string); impassable_tiles = []; for row_elem in root.findall('Row'): y = int(row_elem.get('id')); for tile_elem in row_elem.findall('Tile'): x = int(tile_elem.get('id')); if tile_elem.get('type') == 'impassable' or tile_elem.find('Object') is not None: impassable_tiles.append({'x': x, 'y': y}); print(json.dumps(impassable_tiles))"
  }
}