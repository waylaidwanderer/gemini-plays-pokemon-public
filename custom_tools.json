{
  "advanced_pathfinder": {
    "description": "An advanced pathfinder that ignores most tile types to find hidden passages, but respects truly impassable tiles, objects, and closed gates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\ngrid = [['' for _ in range(width)] for _ in range(height)]\nimpassable_coords = set()\n\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.get('id')) - 1\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.get('id')) - 1\n        grid[y][x] = tile_elem.get('type')\n        obj = tile_elem.find('Object')\n        if obj is not None and obj.get('id-name') != 'Pikachu':\n            impassable_coords.add((x, y))\n\nstart_x = int(input_data['start_x']) - 1\nstart_y = int(input_data['start_y']) - 1\nend_x = int(input_data['end_x']) - 1\nend_y = int(input_data['end_y']) - 1\n\nstart_node = (start_x, start_y)\nend_node = (end_x, end_y)\n\nqueue = deque([(start_node, [start_node])])\nvisited = {start_node}\n\npath_found = False\nwhile queue:\n    (current_x, current_y), path = queue.popleft()\n\n    if (current_x, current_y) == end_node:\n        path_plan = [{'x': x + 1, 'y': y + 1} for x, y in path]\n        print(json.dumps(path_plan))\n        path_found = True\n        break\n\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        next_x, next_y = current_x + dx, current_y + dy\n\n        if 0 <= next_x < width and 0 <= next_y < height:\n            neighbor = (next_x, next_y)\n            if neighbor not in visited:\n                tile_type = grid[next_y][next_x]\n                if tile_type not in ['impassable', 'closed_gate'] and neighbor not in impassable_coords:\n                    visited.add(neighbor)\n                    new_path = path + [neighbor]\n                    queue.append((neighbor, new_path))\n\nif not path_found:\n    print(json.dumps([]))"
  },
  "find_path": {
    "description": "A consolidated pathfinding tool. Finds a path to specified X, Y coordinates. If no coordinates are provided, it finds a path to the nearest reachable unseen tile. It automatically paths to an adjacent tile if the target is impassable. It can now handle mixed traversal types (walking and surfing).",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string",
          "nullable": true
        },
        "end_y": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\ngrid = [['' for _ in range(width)] for _ in range(height)]\nimpassable_coords = set()\nunseen_tiles = []\n\nwalk_types = ['ground', 'grass', 'open_gate', 'cleared_boulder_barrier', 'boulder_switch', 'teleport', 'hole', 'spinner_stop', 'ladder_up', 'ladder_down', 'steps', 'cuttable']\nsurf_types = ['water']\ntraversable_tiles = set(walk_types + surf_types)\ntraversable_tiles.add('ledge')\n\nfor r_idx, row_elem in enumerate(root.findall('Row')):\n    y = int(row_elem.get('id')) - 1\n    for c_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n        x = int(tile_elem.get('id')) - 1\n        tile_type = tile_elem.get('type')\n        grid[y][x] = tile_type\n        if tile_elem.get('seen') == 'false':\n            unseen_tiles.append((x, y))\n        if tile_elem.find('Object') is not None and (tile_elem.find('Object').get('id-name') != 'Pikachu'):\n            impassable_coords.add((x, y))\n\nstart_x, start_y = int(input_data['start_x']) - 1, int(input_data['start_y']) - 1\nend_x = int(input_data.get('end_x', None)) - 1 if input_data.get('end_x') else None\nend_y = int(input_data.get('end_y', None)) - 1 if input_data.get('end_y') else None\n\ndef find_path_bfs():\n    start_tile_type = grid[start_y][start_x]\n    if start_tile_type not in traversable_tiles:\n        return []\n\n    queue = deque([((start_x, start_y), [(start_x, start_y)])])\n    visited = {(start_x, start_y)}\n\n    while queue:\n        (current_x, current_y), path = queue.popleft()\n\n        if end_x is not None and end_y is not None:\n            if grid[end_y][end_x] in traversable_tiles and (end_x, end_y) not in impassable_coords:\n                if current_x == end_x and current_y == end_y:\n                    return path\n            else:\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    if current_x == end_x + dx and current_y == end_y + dy:\n                        return path\n        else:\n            if not unseen_tiles:\n                return []\n            for ux, uy in unseen_tiles:\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    if current_x == ux + dx and current_y == uy + dy:\n                        return path\n\n        for move in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = current_x + move[0], current_y + move[1]\n\n            if not (0 <= next_x < width and 0 <= next_y < height):\n                continue\n\n            if (next_x, next_y) in visited or (next_x, next_y) in impassable_coords:\n                continue\n\n            next_tile_type = grid[next_y][next_x]\n            \n            if next_tile_type not in traversable_tiles:\n                continue\n\n            if next_tile_type == 'ledge':\n                if next_y > current_y:\n                    ledge_jump_y = next_y + 1\n                    if 0 <= ledge_jump_y < height and (next_x, ledge_jump_y) not in visited:\n                        if grid[ledge_jump_y][next_x] in traversable_tiles and (next_x, ledge_jump_y) not in impassable_coords:\n                            new_path = path + [(next_x, next_y), (next_x, ledge_jump_y)]\n                            visited.add((next_x, next_y))\n                            visited.add((next_x, ledge_jump_y))\n                            queue.append(((next_x, ledge_jump_y), new_path))\n                continue\n            \n            visited.add((next_x, next_y))\n            new_path = path + [(next_x, next_y)]\n            queue.append(((next_x, next_y), new_path))\n            \n    return []\n\nfound_path = find_path_bfs()\n\nif found_path:\n    path_plan = [{'x': x + 1, 'y': y + 1} for x, y in found_path]\n    target_x, target_y = path_plan[-1]['x'], path_plan[-1]['y']\n    reasoning = f'Path found to target at ({target_x}, {target_y}).'\n    print(json.dumps({'path': path_plan, 'reasoning': reasoning}))\nelse:\n    print(json.dumps({'path': [], 'reasoning': 'Could not find a path to any reachable targets.'}))"
  },
  "get_unseen_tiles": {
    "description": "Parses the map XML to find all unseen tiles and returns them as a JSON list. This helps identify new areas for exploration.",
    "input_schema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "python_script": "import xml.etree.ElementTree as ET; import json; root = ET.fromstring(map_xml_string); unseen_tiles = []; for row_elem in root.findall('Row'): y = int(row_elem.get('id')); for tile_elem in row_elem.findall('Tile'): if tile_elem.get('seen') == 'false': x = int(tile_elem.get('id')); unseen_tiles.append({'x': x, 'y': y}); print(json.dumps(unseen_tiles))"
  },
  "find_hm_spot_tool": {
    "description": "Scans tiles adjacent to the player to find a valid location to initiate an HM field move like SURF or CUT. This prevents wasting time on repeated failed attempts.",
    "input_schema": {
      "type": "object",
      "properties": {
        "hm_type": {
          "type": "string",
          "enum": [
            "cut",
            "surf"
          ]
        },
        "player_x": {
          "type": "string"
        },
        "player_y": {
          "type": "string"
        }
      },
      "required": [
        "hm_type",
        "player_x",
        "player_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\n\nplayer_x = int(input_data['player_x'])\nplayer_y = int(input_data['player_y'])\nhm_type = input_data['hm_type']\n\ntarget_tile_type = 'cuttable' if hm_type == 'cut' else 'water'\n\nfor move in [('Up', 0, -1), ('Down', 0, 1), ('Left', -1, 0), ('Right', 1, 0)]:\n    direction, dx, dy = move\n    check_x, check_y = player_x + dx, player_y + dy\n\n    if not (1 <= check_x <= width and 1 <= check_y <= height):\n        continue\n\n    tile_xpath = f\".//Row[@id='{check_y}']/Tile[@id='{check_x}']\"\n    tile_elem = root.find(tile_xpath)\n    if tile_elem is not None and tile_elem.get('type') == target_tile_type:\n        print(json.dumps({'status': 'found', 'direction_to_face': direction, 'x': check_x, 'y': check_y}))\n        exit()\n\nprint(json.dumps({'status': 'not_found', 'reasoning': f'No adjacent {target_tile_type} tile found.'}))"
  },
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "import json\nattacker = input_data['attacker_type']\ndefender1 = input_data['defender_type1']\ndefender2 = input_data.get('defender_type2')\neffectiveness = input_data['effectiveness']\n\ndefender_str = defender1\nif defender2 and defender2 != 'null':\n    defender_str += f'/{defender2}'\n\nif effectiveness == 'super effective':\n    log_string = f'- {attacker} > {defender_str}'\nelif effectiveness == 'not very effective':\n    log_string = f'- {attacker} !> {defender_str}'\nelse:\n    log_string = f'- {defender_str} immune to {attacker}'\n\nprint(json.dumps({'formatted_log': log_string}))"
  }
}