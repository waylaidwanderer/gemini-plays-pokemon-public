{
  "patrol_grass": {
    "description": "Generates a path for patrolling tall grass. It performs a random walk on connected TALL_GRASS tiles starting from the player's current position and returns a list of button presses.",
    "input_schema": {
      "type": "object",
      "properties": {
        "steps": {
          "type": "integer",
          "description": "Number of steps to take.",
          "default": 20
        },
        "current_x": {
          "type": "integer",
          "description": "Current X coordinate"
        },
        "current_y": {
          "type": "integer",
          "description": "Current Y coordinate"
        }
      },
      "required": [
        "current_x",
        "current_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport random\nimport json\n\n# map_xml_string is automatically provided\n\nroot = ET.fromstring(map_xml_string)\ngrid = {}\nfor row in root.findall('Row'):\n    y = int(row.get('id'))\n    for tile in row.findall('Tile'):\n        x = int(tile.get('id'))\n        tile_type = tile.get('type')\n        has_object = tile.get('has-object') == 'true'\n        grid[(x, y)] = {'type': tile_type, 'blocked': has_object}\n\n# Simple random walk on grass\nbuttons = []\ncurr_x, curr_y = current_x, current_y\n\n# Direction vectors mapped to buttons\ndirs = {\n    (0, -1): \"Up\",\n    (0, 1): \"Down\",\n    (-1, 0): \"Left\",\n    (1, 0): \"Right\"\n}\n\ndef is_valid(x, y):\n    if (x, y) not in grid: return False\n    # Only TALL_GRASS\n    if grid[(x, y)]['type'] == 'TALL_GRASS' and not grid[(x, y)]['blocked']:\n        return True\n    return False\n\n# Avoid backtracking immediately if possible\nlast_move = None\n\nfor _ in range(steps):\n    valid_moves = []\n    for (dx, dy), btn in dirs.items():\n        nx, ny = curr_x + dx, curr_y + dy\n        if is_valid(nx, ny):\n            # Prefer not to reverse immediately\n            if last_move:\n                reverse_map = {\"Up\": \"Down\", \"Down\": \"Up\", \"Left\": \"Right\", \"Right\": \"Left\"}\n                if btn == reverse_map.get(last_move):\n                    valid_moves.append((nx, ny, btn))\n                else:\n                    # Weight forward/turn moves higher (3x)\n                    valid_moves.append((nx, ny, btn))\n                    valid_moves.append((nx, ny, btn))\n                    valid_moves.append((nx, ny, btn))\n            else:\n                valid_moves.append((nx, ny, btn))\n    \n    if valid_moves:\n        nx, ny, btn = random.choice(valid_moves)\n        buttons.append(btn)\n        curr_x, curr_y = nx, ny\n        last_move = btn\n    else:\n        break\n\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-15T20:31:56.421Z",
        "action_counter": 40981
      },
      {
        "commit_message": "Updated to return button presses for autopress_buttons compatibility.",
        "timestamp": "2026-01-15T20:33:57.961Z",
        "action_counter": 40983
      }
    ]
  }
}