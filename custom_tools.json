{
  "wkg_updater": {
    "description": "Streamlined tool to manage the World Knowledge Graph. It verifies if a node or edge already exists and, if not, directly calls `manage_world_knowledge` to add it. This is a single-step action to prevent manual errors.",
    "input_schema": {
      "type": "object",
      "properties": {
        "operation": {
          "type": "string",
          "enum": [
            "add_node",
            "add_edge"
          ]
        },
        "map_id": {
          "type": "string"
        },
        "x": {
          "type": "string"
        },
        "y": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "type": {
          "type": "string"
        },
        "tags": {
          "type": "string"
        },
        "source_map_id": {
          "type": "string"
        },
        "source_x": {
          "type": "string"
        },
        "source_y": {
          "type": "string"
        },
        "dest_map_id": {
          "type": "string"
        },
        "dest_x": {
          "type": "string"
        },
        "dest_y": {
          "type": "string"
        },
        "connection_type": {
          "type": "string"
        },
        "is_one_way": {
          "type": "string"
        },
        "destination_entry_point": {
          "type": "string"
        }
      },
      "required": [
        "operation"
      ]
    },
    "python_script": "import json\nimport subprocess\n\ndef run_tool(tool_name, payload):\n    command = f'{{ \"tool_name\": \"{tool_name}\", \"payload\": {json.dumps(payload)} }}'\n    # This is a placeholder for the actual tool execution environment\n    # In a real scenario, this would interact with the game's tool-running API\n    # For this script, we'll simulate by printing the command\n    print(f'Executing: {command}')\n    # In a real implementation, you would need to capture the output of the tool call\n    # to get the new node/edge ID for subsequent operations.\n    # For now, we assume a successful call.\n\ndef wkg_updater():\n    wkg = json.loads(world_knowledge_graph_json_string)\n    operation = input_data.get('operation')\n\n    if operation == 'add_node':\n        map_id = input_data.get('map_id')\n        x = int(input_data.get('x'))\n        y = int(input_data.get('y'))\n        name = input_data.get('name')\n        node_type = input_data.get('type')\n        tags_str = input_data.get('tags', '[]')\n        tags = json.loads(tags_str)\n\n        for node in wkg['nodes']:\n            if node['map_id'] == map_id and node['coordinates']['x'] == x and node['coordinates']['y'] == y:\n                print(f\"Node already exists at ({x},{y}) on map {map_id}. Skipping.\")\n                return\n\n        node_payload = {\n            'map_id': map_id,\n            'name': name,\n            'coordinates': {'x': x, 'y': y},\n            'type': node_type,\n            'tags': tags\n        }\n        run_tool('manage_world_knowledge', {'action': 'add_node', 'payload': json.dumps(node_payload)})\n        print(f'SUCCESS: Node added for {name} at ({x},{y}) on map {map_id}.')\n\n    elif operation == 'add_edge':\n        source_map_id = input_data.get('source_map_id')\n        source_x = int(input_data.get('source_x'))\n        source_y = int(input_data.get('source_y'))\n        dest_map_id = input_data.get('dest_map_id')\n        dest_x = int(input_data.get('dest_x'))\n        dest_y = int(input_data.get('dest_y'))\n        connection_type = input_data.get('connection_type')\n        is_one_way = input_data.get('is_one_way', 'false').lower() == 'true'\n        dest_entry_point = input_data.get('destination_entry_point')\n\n        source_node_id = None\n        dest_node_id = None\n\n        for node in wkg['nodes']:\n            if node['map_id'] == source_map_id and node['coordinates']['x'] == source_x and node['coordinates']['y'] == source_y:\n                source_node_id = node['id']\n            if node['map_id'] == dest_map_id and node['coordinates']['x'] == dest_x and node['coordinates']['y'] == dest_y:\n                dest_node_id = node['id']\n\n        if not source_node_id or not dest_node_id:\n            print('Error: Source or destination node not found. Please add nodes first.')\n            return\n\n        for edge in wkg['edges']:\n            if edge['source_node_id'] == source_node_id and edge['destination_node_id'] == dest_node_id:\n                print('Edge already exists. Skipping.')\n                return\n            if not is_one_way and edge['source_node_id'] == dest_node_id and edge['destination_node_id'] == source_node_id:\n                 print('Bidirectional edge already exists. Skipping.')\n                 return\n\n        edge_payload = {\n            'source_node_id': source_node_id,\n            'destination_node_id': dest_node_id,\n            'connection_type': connection_type,\n            'source_coordinates': {'x': source_x, 'y': source_y, 'map_id': source_map_id},\n            'destination_coordinates': {'x': dest_x, 'y': dest_y, 'map_id': dest_map_id},\n            'is_one_way': is_one_way\n        }\n        if dest_entry_point:\n            edge_payload['destination_entry_point'] = int(dest_entry_point)\n\n        run_tool('manage_world_knowledge', {'action': 'add_edge', 'payload': json.dumps(edge_payload)})\n        print(f'SUCCESS: Edge added from {source_map_id} ({source_x},{source_y}) to {dest_map_id} ({dest_x},{dest_y}).')\n\nwkg_updater()"
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map using the Breadth-First Search (BFS) algorithm. It considers tile types (including elevation, water), impassable objects (excluding Pikachu), and special ledge traversal rules. The output is a JSON string containing the list of coordinates for the path or debug info if no path is found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\nimport json\n\ndef find_path():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        start = (int(input_data['start_x']), int(input_data['start_y']))\n        end = (int(input_data['end_x']), int(input_data['end_y']))\n\n        grid = {}\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                object_name = None\n                if has_object:\n                    obj_elem = tile_elem.find('Object')\n                    if obj_elem is not None:\n                        object_name = obj_elem.get('id-name')\n                grid[(x, y)] = {'type': tile_type, 'has_object': has_object, 'object_name': object_name}\n\n        queue = collections.deque([[start]])\n        seen = {start}\n\n        while queue:\n            path = queue.popleft()\n            x, y = path[-1]\n\n            if (x, y) == end:\n                print(json.dumps({\"status\": \"success\", \"path\": path}))\n                return\n\n            for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                next_x, next_y = x + move_x, y + move_y\n                next_pos = (next_x, next_y)\n\n                if not (1 <= next_x <= width and 1 <= next_y <= height):\n                    continue\n\n                if next_pos in seen:\n                    continue\n\n                current_tile_info = grid.get((x,y), {})\n                next_tile_info = grid.get(next_pos, {})\n                next_tile_type = next_tile_info.get('type')\n\n                # Ledge Rule\n                if move_y == 1 and current_tile_info.get('type') != 'ledge' and next_tile_type == 'ledge':\n                    ledge_jump_pos = (next_x, next_y + 1)\n                    if ledge_jump_pos in seen:\n                        continue\n                    ledge_jump_tile_info = grid.get(ledge_jump_pos, {})\n                    if ledge_jump_tile_info.get('type') not in ['impassable', 'unknown']:\n                        new_path = list(path)\n                        new_path.append(ledge_jump_pos)\n                        queue.append(new_path)\n                        seen.add(next_pos) # Mark the ledge itself as seen to prevent re-evaluation\n                        seen.add(ledge_jump_pos)\n                    continue # Skip normal processing for this move\n                \n                # Standard impassable checks\n                impassable_types = ['impassable', 'unknown', 'ledge', 'water'] # Added 'water' here\n                if next_tile_type in impassable_types:\n                    continue\n\n                if next_tile_info.get('has_object') and next_tile_info.get('object_name') != 'Pikachu':\n                    continue\n                \n                # Elevation check\n                current_elevation = 'elevated' if current_tile_info.get('type') == 'elevated_ground' else 'ground'\n                next_elevation = 'elevated' if next_tile_type == 'elevated_ground' else 'ground'\n                if current_elevation != next_elevation and current_tile_info.get('type') != 'steps' and next_tile_type != 'steps':\n                    continue\n\n                seen.add(next_pos)\n                new_path = list(path)\n                new_path.append(next_pos)\n                queue.append(new_path)\n\n        print(json.dumps({\"status\": \"error\", \"message\": \"No path found\"}))\n    except Exception as e:\n        print(json.dumps({\"status\": \"error\", \"message\": str(e)}))\n\nfind_path()\n"
  },
  "wkg_pathfinder": {
    "description": "Calculates the shortest path between two maps in the World Knowledge Graph, returning a sequence of map IDs and warp coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_map_id": {
          "type": "string"
        },
        "end_map_id": {
          "type": "string"
        }
      },
      "required": [
        "start_map_id",
        "end_map_id"
      ]
    },
    "python_script": "import json\nfrom collections import deque\n\ndef find_wkg_path(start_map_id, end_map_id, wkg_json_string):\n    wkg = json.loads(wkg_json_string)\n    nodes = {node['id']: node for node in wkg['nodes']}\n    adj = {node_id: [] for node_id in nodes}\n    for edge in wkg['edges']:\n        adj[edge['source_node_id']].append(edge['destination_node_id'])\n        if not edge.get('is_one_way', False):\n            adj[edge['destination_node_id']].append(edge['source_node_id'])\n\n    start_nodes = [node_id for node_id, node in nodes.items() if node['map_id'] == start_map_id]\n    if not start_nodes:\n        print(json.dumps({'error': 'Start map not in WKG'}))\n        return\n\n    queue = deque([(node, [node]) for node in start_nodes])\n    visited = set(start_nodes)\n    \n    while queue:\n        current_node_id, path = queue.popleft()\n        current_map_id = nodes[current_node_id]['map_id']\n\n        if current_map_id == end_map_id:\n            result_path = []\n            for node_id in path:\n                node = nodes[node_id]\n                result_path.append({'map_id': node['map_id'], 'coordinates': node['coordinates']})\n            print(json.dumps({'path': result_path}))\n            return\n\n        for neighbor_id in adj.get(current_node_id, []):\n            if neighbor_id not in visited:\n                visited.add(neighbor_id)\n                new_path = list(path)\n                new_path.append(neighbor_id)\n                queue.append((neighbor_id, new_path))\n\n    print(json.dumps({'path': []}))\n\nfind_wkg_path(input_data['start_map_id'], input_data['end_map_id'], world_knowledge_graph_json_string)"
  },
  "wkg_edge_payload_generator": {
    "description": "A helper tool that generates the correct JSON payload for adding an edge to the World Knowledge Graph. It finds the required node IDs based on map and coordinate inputs.",
    "input_schema": {
      "type": "object",
      "properties": {
        "source_map_id": {
          "type": "string"
        },
        "source_x": {
          "type": "string"
        },
        "source_y": {
          "type": "string"
        },
        "dest_map_id": {
          "type": "string"
        },
        "dest_x": {
          "type": "string"
        },
        "dest_y": {
          "type": "string"
        },
        "connection_type": {
          "type": "string"
        },
        "is_one_way": {
          "type": "string"
        },
        "destination_entry_point": {
          "type": "string"
        }
      },
      "required": [
        "source_map_id",
        "source_x",
        "source_y",
        "dest_map_id",
        "dest_x",
        "dest_y"
      ]
    },
    "python_script": "import json\n\ndef find_node_id(nodes, map_id, x, y):\n    for node in nodes:\n        if node['map_id'] == map_id and node['coordinates']['x'] == x and node['coordinates']['y'] == y:\n            return node['id']\n    return None\n\ntry:\n    wkg = json.loads(world_knowledge_graph_json_string)\n    nodes = wkg.get('nodes', [])\n\n    source_map_id = input_data['source_map_id']\n    source_x = int(input_data['source_x'])\n    source_y = int(input_data['source_y'])\n    dest_map_id = input_data['dest_map_id']\n    dest_x = int(input_data['dest_x'])\n    dest_y = int(input_data['dest_y'])\n    \n    source_node_id = find_node_id(nodes, source_map_id, source_x, source_y)\n    dest_node_id = find_node_id(nodes, dest_map_id, dest_x, dest_y)\n\n    if source_node_id and dest_node_id:\n        payload = {\n            \"source_node_id\": source_node_id,\n            \"destination_node_id\": dest_node_id,\n            \"connection_type\": input_data.get('connection_type', 'map_edge'),\n            \"source_coordinates\": {\"x\": source_x, \"y\": source_y, \"map_id\": source_map_id},\n            \"destination_coordinates\": {\"x\": dest_x, \"y\": dest_y, \"map_id\": dest_map_id},\n            \"is_one_way\": input_data.get('is_one_way', 'false').lower() == 'true'\n        }\n        if 'destination_entry_point' in input_data and input_data['destination_entry_point']:\n            payload['destination_entry_point'] = int(input_data['destination_entry_point'])\n\n        print(json.dumps(payload))\n    else:\n        missing = []\n        if not source_node_id:\n            missing.append(f\"Source node ({source_map_id} at {source_x},{source_y})\")\n        if not dest_node_id:\n            missing.append(f\"Destination node ({dest_map_id} at {dest_x},{dest_y})\")\n        print(json.dumps({\"status\": \"error\", \"message\": f\"Could not find nodes: {', '.join(missing)}\"}))\n\nexcept Exception as e:\n    print(json.dumps({\"status\": \"error\", \"message\": str(e)}))"
  }
}