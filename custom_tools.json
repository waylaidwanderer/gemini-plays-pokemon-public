{
  "calculate_xp_requirements": {
    "description": "Calculates the experience points required for the next level for a given Pokémon species and its current level and experience. Supports the four standard experience curves found in Pokémon Crystal (Fast, Medium Fast, Medium Slow, Slow).",
    "input_schema": {
      "type": "object",
      "properties": {
        "current_exp": {
          "type": "integer"
        },
        "current_level": {
          "type": "integer"
        },
        "growth_rate": {
          "type": "string",
          "enum": [
            "Fast",
            "Medium Fast",
            "Medium Slow",
            "Slow"
          ]
        }
      },
      "required": [
        "current_exp",
        "current_level",
        "growth_rate"
      ]
    },
    "python_script": "import json\nimport sys\n\ndef calculate_xp_needed(growth_rate, current_level, current_exp):\n    next_level = current_level + 1\n    if growth_rate == \"Fast\":\n        next_exp = int(0.8 * (next_level**3))\n    elif growth_rate == \"Medium Fast\":\n        next_exp = int(next_level**3)\n    elif growth_rate == \"Medium Slow\":\n        next_exp = int(1.2 * (next_level**3) - 15 * (next_level**2) + 100 * next_level - 140)\n    elif growth_rate == \"Slow\":\n        next_exp = int(1.25 * (next_level**3))\n    else:\n        return \"Unknown growth rate\"\n    \n    xp_needed = max(0, next_exp - current_exp)\n    return xp_needed\n\nif __name__ == \"__main__\":\n    # In a real environment, input_data would be passed in.\n    # For this example, we'll simulate the input parsing.\n    # Since this is a script to be defined, we use a placeholder for input_data.\n    try:\n        # The system will provide input_data as a global or via some mechanism.\n        # Here we expect it to be available.\n        # For the purpose of definition, we just write the logic.\n        res = calculate_xp_needed(input_data[\"growth_rate\"], int(input_data[\"current_level\"]), int(input_data[\"current_exp\"]))\n        print(json.dumps({\"xp_needed\": res}))\n    except NameError:\n        # Fallback for testing if input_data isn't defined\n        pass\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T04:58:09.193Z",
        "action_counter": 817
      }
    ]
  },
  "find_path_v3": {
    "description": "Finds a shortest path to a target coordinate, correctly handling ledges as one-way traversal and objects as walls. Returns a list of button strings.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import collections\nimport json\nimport xml.etree.ElementTree as ET\n\ndef solve():\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    player_pos = None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib.get('type', 'unseen')\n            seen = tile.attrib.get('seen') == 'true'\n            is_wall = t_type in ['WALL', 'WATER', 'BLOCK', 'HEADBUTT_TREE', 'CUT_TREE', 'VOID'] or tile.find('Object') is not None\n            if not seen and t_type == 'unseen':\n                is_wall = True\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n            grid[(x, y)] = {'type': t_type, 'wall': is_wall, 'seen': seen}\n\n    if player_pos is None:\n        print(json.dumps([]))\n        return\n    \n    target = (int(input_data['target_x']), int(input_data['target_y']))\n    if player_pos == target:\n        print(json.dumps([]))\n        return\n\n    queue = collections.deque([(player_pos, [])])\n    visited = {player_pos}\n\n    while queue:\n        (cx, cy), path = queue.popleft()\n        curr_tile = grid.get((cx, cy), {'type': 'FLOOR', 'wall': False})\n        \n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            if curr_tile['type'] == 'LEDGE_HOP_DOWN' and btn != 'Down': continue\n            if curr_tile['type'] == 'LEDGE_HOP_UP' and btn != 'Up': continue\n            if curr_tile['type'] == 'LEDGE_HOP_LEFT' and btn != 'Left': continue\n            if curr_tile['type'] == 'LEDGE_HOP_RIGHT' and btn != 'Right': continue\n            \n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) not in grid: continue\n            next_tile = grid[(nx, ny)]\n            \n            if next_tile['type'] == 'LEDGE_HOP_DOWN':\n                if btn != 'Down': continue\n                nx, ny = nx + dx, ny + dy\n                if (nx, ny) not in grid: continue\n                next_tile = grid[(nx, ny)]\n            elif next_tile['type'] == 'LEDGE_HOP_UP':\n                if btn != 'Up': continue\n                nx, ny = nx + dx, ny + dy\n                if (nx, ny) not in grid: continue\n                next_tile = grid[(nx, ny)]\n            elif next_tile['type'] == 'LEDGE_HOP_LEFT':\n                if btn != 'Left': continue\n                nx, ny = nx + dx, ny + dy\n                if (nx, ny) not in grid: continue\n                next_tile = grid[(nx, ny)]\n            elif next_tile['type'] == 'LEDGE_HOP_RIGHT':\n                if btn != 'Right': continue\n                nx, ny = nx + dx, ny + dy\n                if (nx, ny) not in grid: continue\n                next_tile = grid[(nx, ny)]\n            \n            if next_tile['wall'] and (nx, ny) != target: continue\n            \n            if (nx, ny) == target:\n                print(json.dumps(path + [btn]))\n                return\n            \n            if (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [btn]))\n    \n    print(json.dumps([]))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T05:31:42.338Z",
        "action_counter": 871
      },
      {
        "commit_message": "Removing catch-all exception and refining wall logic for target tile.",
        "timestamp": "2025-12-18T05:35:51.251Z",
        "action_counter": 881
      },
      {
        "commit_message": "Refined pathfinding logic to correctly handle ledges as one-way jumps and treat unseen tiles as obstacles.",
        "timestamp": "2025-12-18T06:35:14.636Z",
        "action_counter": 995
      }
    ]
  },
  "list_reachable_unseen_v3": {
    "description": "Finds all 'unseen' tiles that are currently reachable from the player's position, correctly handling ledges and objects. Returns a list of (x, y) coordinates.",
    "input_schema": {},
    "python_script": "import collections\nimport json\nimport xml.etree.ElementTree as ET\n\ndef solve():\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    player_pos = None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib.get('type', 'unseen')\n            is_wall = t_type in ['WALL', 'WATER', 'BLOCK', 'HEADBUTT_TREE', 'CUT_TREE', 'VOID'] or tile.find('Object') is not None\n            if tile.find('Player') is not None: player_pos = (x, y)\n            grid[(x, y)] = {'type': t_type, 'wall': is_wall, 'seen': tile.attrib.get('seen') == 'true'}\n    \n    if player_pos is None:\n        print(json.dumps([]))\n        return\n\n    reachable_unseen = []\n    queue = collections.deque([player_pos])\n    visited = {player_pos}\n    \n    while queue:\n        cx, cy = queue.popleft()\n        \n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) in grid:\n                curr = grid[(cx, cy)]\n                next_tile = grid[(nx, ny)]\n                \n                # Check if next tile is unseen\n                if not next_tile['seen']:\n                    if (nx, ny) not in reachable_unseen:\n                        reachable_unseen.append((nx, ny))\n                    continue # Cannot walk into unseen tile\n                \n                # Ledge logic\n                if curr['type'] == 'LEDGE_HOP_DOWN' and btn != 'Down': continue\n                if next_tile['type'] == 'LEDGE_HOP_DOWN' and btn != 'Down': continue\n                \n                if next_tile['wall']: continue\n                \n                if (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n                    \n    print(json.dumps(reachable_unseen))\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T06:06:05.223Z",
        "action_counter": 935
      }
    ]
  },
  "press_sequence": {
    "description": "Executes a specific sequence of button presses, allowing for mixed directional and action inputs. Useful for complex menu navigation.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nprint(json.dumps(input_data['buttons']))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T06:11:16.135Z",
        "action_counter": 948
      }
    ]
  }
}