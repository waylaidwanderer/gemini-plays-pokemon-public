{
  "wkg_updater": {
    "description": "Prepares the JSON payload for `manage_world_knowledge`. It verifies if a node or edge already exists and, if not, prints the exact JSON string needed to call the `manage_world_knowledge` tool. Now supports adding `tags` to nodes and `destination_entry_point` for warp edges, preventing duplicates and ensuring graph integrity. It also provides existing node IDs if found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "operation": {
          "type": "string",
          "enum": [
            "prepare_add_node",
            "prepare_add_edge"
          ]
        },
        "map_id": {
          "type": "string"
        },
        "x": {
          "type": "string"
        },
        "y": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "type": {
          "type": "string"
        },
        "tags": {
          "type": "string"
        },
        "source_map_id": {
          "type": "string"
        },
        "source_x": {
          "type": "string"
        },
        "source_y": {
          "type": "string"
        },
        "dest_map_id": {
          "type": "string"
        },
        "dest_x": {
          "type": "string"
        },
        "dest_y": {
          "type": "string"
        },
        "connection_type": {
          "type": "string"
        },
        "is_one_way": {
          "type": "string"
        },
        "destination_entry_point": {
          "type": "string"
        }
      },
      "required": [
        "operation"
      ]
    },
    "python_script": "import json\n\ndef find_node_by_coords(graph, map_id, x, y):\n    for node in graph.get('nodes', []):\n        if str(node.get('map_id')) == str(map_id) and node['coordinates']['x'] == x and node['coordinates']['y'] == y:\n            return node\n    return None\n\ndef find_edge(graph, source_id, dest_id):\n    for edge in graph.get('edges', []):\n        if (edge['source_node_id'] == source_id and edge['destination_node_id'] == dest_id) or \\\n           (edge['source_node_id'] == dest_id and edge['destination_node_id'] == source_id and not edge.get('is_one_way')):\n            return edge\n    return None\n\noperation = input_data['operation']\ngraph = json.loads(world_knowledge_graph_json_string)\n\nif operation == 'prepare_add_node':\n    map_id = input_data['map_id']\n    x = int(input_data['x'])\n    y = int(input_data['y'])\n    name = input_data['name']\n    node_type = input_data.get('type', '')\n    tags_str = input_data.get('tags', '[]')\n    tags = json.loads(tags_str) if isinstance(tags_str, str) else tags_str\n\n    existing_node = find_node_by_coords(graph, map_id, x, y)\n    if existing_node:\n        print(json.dumps({'action': 'do_nothing', 'reason': 'Node already exists.', 'node_id': existing_node['id']}))\n    else:\n        payload = {'map_id': map_id, 'name': name, 'coordinates': {'x': x, 'y': y}, 'type': node_type, 'tags': tags}\n        print(json.dumps({'action': 'call_tool', 'tool_name': 'manage_world_knowledge', 'tool_action': 'add_node', 'payload': json.dumps(payload)}))\n\nelif operation == 'prepare_add_edge':\n    source_map_id = input_data['source_map_id']\n    source_x = int(input_data['source_x'])\n    source_y = int(input_data['source_y'])\n    dest_map_id = input_data['dest_map_id']\n    dest_x = int(input_data['dest_x'])\n    dest_y = int(input_data['dest_y'])\n    connection_type = input_data['connection_type']\n    is_one_way = input_data.get('is_one_way', 'false').lower() == 'true'\n    dest_entry_point = input_data.get('destination_entry_point')\n    \n    source_node = find_node_by_coords(graph, source_map_id, source_x, source_y)\n    dest_node = find_node_by_coords(graph, dest_map_id, dest_x, dest_y)\n\n    if not source_node:\n        print(json.dumps({'action': 'error', 'reason': f'Source node at ({source_x},{source_y}) on map {source_map_id} not found.'}))\n    elif not dest_node:\n        print(json.dumps({'action': 'error', 'reason': f'Destination node at ({dest_x},{dest_y}) on map {dest_map_id} not found.'}))\n    else:\n        existing_edge = find_edge(graph, source_node['id'], dest_node['id'])\n        if existing_edge:\n            print(json.dumps({'action': 'do_nothing', 'reason': 'Edge already exists.', 'edge_id': existing_edge['id']}))\n        else:\n            payload = {\n                'source_node_id': source_node['id'],\n                'destination_node_id': dest_node['id'],\n                'connection_type': connection_type,\n                'source_coordinates': {'x': source_x, 'y': source_y, 'map_id': source_map_id},\n                'destination_coordinates': {'x': dest_x, 'y': dest_y, 'map_id': dest_map_id},\n                'is_one_way': is_one_way\n            }\n            if dest_entry_point is not None and connection_type == 'warp':\n                payload['destination_entry_point'] = int(dest_entry_point)\n\n            print(json.dumps({'action': 'call_tool', 'tool_name': 'manage_world_knowledge', 'tool_action': 'add_edge', 'payload': json.dumps(payload)}))\nelse:\n    print(json.dumps({'action': 'error', 'reason': 'Invalid operation.'}))"
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map, now with support for steps and elevated ground. This is the correct tool for overworld navigation planning.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef parse_map_data(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    tile_data = {}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tile_type = tile.attrib.get('type', 'impassable')\n            has_object = tile.attrib.get('has-object') == 'true'\n            is_pikachu = False\n            if has_object:\n                object_element = tile.find('Object')\n                if object_element is not None and object_element.attrib.get('id-name') == 'Pikachu':\n                    is_pikachu = True\n            tile_data[(x, y)] = {'type': tile_type, 'has_object': has_object and not is_pikachu}\n    return tile_data, width, height\n\ndef is_move_valid(current_pos, next_pos, tile_data, move_direction):\n    if next_pos not in tile_data: return False\n    current_tile = tile_data.get(current_pos, {})\n    next_tile = tile_data.get(next_pos, {})\n\n    if next_tile.get('has_object'): return False\n\n    current_type = current_tile.get('type')\n    next_type = next_tile.get('type')\n\n    traversable_types = {'ground', 'grass', 'elevated_ground', 'steps'}\n    if next_type not in traversable_types and next_type != 'ledge': return False\n    \n    if next_type == 'ledge': return move_direction == 'Down'\n    if current_type == 'ledge': return False\n\n    ground_types = {'ground', 'grass'}\n    \n    if current_type == 'elevated_ground':\n        if next_type == 'elevated_ground': return True\n        if next_type == 'steps' and move_direction in ['Up', 'Down']: return True\n        return False\n\n    if current_type in ground_types:\n        if next_type in ground_types: return True\n        if next_type == 'steps' and move_direction in ['Up', 'Down']: return True\n        return False\n\n    if current_type == 'steps':\n        if (next_type in ground_types or next_type == 'elevated_ground') and move_direction in ['Up', 'Down']: return True\n        return False\n\n    return False\n\ndef bfs_path(tile_data, start, end, width, height):\n    if start not in tile_data or end not in tile_data: return None\n    queue = deque([(start, [])])\n    visited = {start}\n\n    while queue:\n        current_pos, path = queue.popleft()\n        if current_pos == end: return path\n\n        for dx, dy, direction in [(-1, 0, 'Left'), (0, -1, 'Up'), (1, 0, 'Right'), (0, 1, 'Down')]:\n            next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n            if not (1 <= next_pos[0] <= width and 1 <= next_pos[1] <= height): continue\n            if next_pos in visited: continue\n\n            if tile_data.get(next_pos, {}).get('type') == 'ledge' and direction == 'Down':\n                jump_pos = (next_pos[0], next_pos[1] + 1)\n                if jump_pos not in visited and tile_data.get(jump_pos, {}).get('type') not in ['impassable', 'unknown']:\n                    visited.add(next_pos); visited.add(jump_pos)\n                    queue.append((jump_pos, path + [direction]))\n                continue\n\n            if is_move_valid(current_pos, next_pos, tile_data, direction):\n                visited.add(next_pos)\n                queue.append((next_pos, path + [direction]))\n    return None\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\ntile_data, width, height = parse_map_data(map_xml_string)\npath = bfs_path(tile_data, (start_x, start_y), (end_x, end_y), width, height)\n\nif path is not None:\n    print(f'{path}')\nelse:\n    print('No path found.')"
  }
}