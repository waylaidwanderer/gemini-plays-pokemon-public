{
  "assess_reachability": {
    "description": "Performs a flood-fill BFS starting from a given coordinate to determine all reachable tiles of a specific type (e.g., WATER). Returns the bounds of the reachable area, accessible warps, and adjacent unseen tiles. Useful for determining if a path exists through a maze.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "tile_type": {
          "type": "string",
          "default": "WATER"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef assess_reachability(map_xml_string, start_x, start_y, tile_type=\"WATER\"):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = {}\n    warps = {}\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib.get('type', 'unseen')\n            is_warp = tile.attrib.get('is-warp') == 'true'\n            \n            grid[(x, y)] = t_type\n            if is_warp:\n                # Check for warp details in children\n                warp_node = tile.find('Warp')\n                entry_point = warp_node.attrib.get('entry_point') if warp_node is not None else \"?\"\n                warps[(x, y)] = entry_point\n\n    if grid.get((start_x, start_y)) != tile_type and grid.get((start_x, start_y)) != \"WHIRLPOOL\":\n        print(f\"Error: Start position ({start_x}, {start_y}) is {grid.get((start_x, start_y))}, not {tile_type}.\")\n        return\n\n    queue = deque([(start_x, start_y)])\n    visited = set([(start_x, start_y)])\n    reachable_warps = []\n    reachable_unseen_adjacents = []\n    min_x, max_x, min_y, max_y = start_x, start_x, start_y, start_y\n    \n    # Allow WHIRLPOOL as traversable for surfing if tile_type is WATER\n    traversable_types = {tile_type}\n    if tile_type == \"WATER\":\n        traversable_types.add(\"WHIRLPOOL\")\n\n    while queue:\n        cx, cy = queue.popleft()\n        \n        min_x = min(min_x, cx)\n        max_x = max(max_x, cx)\n        min_y = min(min_y, cy)\n        max_y = max(max_y, cy)\n        \n        if (cx, cy) in warps:\n            reachable_warps.append({'x': cx, 'y': cy, 'entry': warps[(cx, cy)]})\n            \n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < width and 0 <= ny < height:\n                if (nx, ny) in visited:\n                    continue\n                \n                n_type = grid.get((nx, ny), 'unseen')\n                \n                if n_type in traversable_types:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n                elif n_type == 'unseen':\n                    reachable_unseen_adjacents.append({'x': nx, 'y': ny})\n                    # Don't traverse into unseen, just mark it as a frontier\n    \n    print(f\"Reachability Analysis from ({start_x}, {start_y}) for {tile_type}:\")\n    print(f\"  Bounds: X[{min_x}-{max_x}], Y[{min_y}-{max_y}]\")\n    print(f\"  Reachable Tiles Count: {len(visited)}\")\n    print(f\"  Reachable Warps: {reachable_warps}\")\n    print(f\"  Adjacent Unseen Tiles: {len(reachable_unseen_adjacents)} (First 5: {reachable_unseen_adjacents[:5]})\")\n\nassess_reachability(map_xml_string, input_data['start_x'], input_data['start_y'], input_data.get('tile_type', 'WATER'))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-08T11:22:54.983Z",
        "action_counter": 27988
      }
    ]
  },
  "find_path_bfs": {
    "description": "Finds the shortest path from the player's current position to a target coordinate using Breadth-First Search (BFS). Parses map XML to identify walkable tiles, avoiding Walls, Water (if walking), On-screen Objects, and Off-screen Objects marked with markers. Returns a list of button presses.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "movement_mode": {
          "type": "string",
          "enum": [
            "walking",
            "surfing"
          ],
          "default": "walking"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef bfs_path(xml_string, target_x, target_y, movement_mode=\"walking\"):\n    try:\n        root = ET.fromstring(xml_string)\n    except Exception as e:\n        print(f\"Error parsing XML: {e}\")\n        return []\n\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = {}\n    start_pos = None\n    \n    # Allowed tile types\n    walkable_types = {\"FLOOR\", \"GRASS\", \"TALL_GRASS\", \"SAND\", \"CARPET\", \"DOOR\", \n                      \"WARP_CARPET_LEFT\", \"WARP_CARPET_RIGHT\", \"WARP_CARPET_UP\", \"WARP_CARPET_DOWN\",\n                      \"STAIRS\", \"CAVE\"}\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib.get('type', 'WALL')\n            \n            is_blocked = False\n            \n            # Check basic tile type\n            if t_type not in walkable_types:\n                if movement_mode == \"walking\":\n                    is_blocked = True\n                elif movement_mode == \"surfing\":\n                    if t_type != \"WATER\":\n                        is_blocked = True\n            elif movement_mode == \"surfing\":\n                # If surfing, can only move on WATER (usually)\n                if t_type != \"WATER\":\n                    is_blocked = True\n            \n            # Check Objects (On-screen sprites)\n            if not is_blocked:\n                for child in tile:\n                    if child.tag == 'Object':\n                        is_blocked = True\n                        break\n            \n            # Check Markers with object_id (Off-screen known sprites)\n            if not is_blocked:\n                for child in tile:\n                    if child.tag == 'Marker' and child.attrib.get('object_id'):\n                        is_blocked = True\n                        break\n\n            # Check has-object attribute\n            if not is_blocked and tile.attrib.get('has-object') == 'true':\n                 is_blocked = True\n\n            grid[(x, y)] = not is_blocked\n            \n            # Locate Player\n            if tile.find('Player') is not None or tile.attrib.get('has-player') == 'true':\n                start_pos = (x, y)\n                # Player tile is always walkable to start\n                grid[(x, y)] = True\n                \n    if not start_pos:\n        print(\"Error: Player not found on map.\")\n        return []\n        \n    if not grid.get((target_x, target_y), False):\n        print(f\"Error: Target {(target_x, target_y)} is blocked or invalid.\")\n        return []\n        \n    # BFS\n    queue = deque([(start_pos, [])])\n    visited = {start_pos}\n    \n    while queue:\n        current, path = queue.popleft()\n        if current == (target_x, target_y):\n            # Convert path to buttons\n            buttons = []\n            cx, cy = start_pos\n            for nx, ny in path:\n                if nx > cx: buttons.append(\"Right\")\n                elif nx < cx: buttons.append(\"Left\")\n                elif ny > cy: buttons.append(\"Down\")\n                elif ny < cy: buttons.append(\"Up\")\n                cx, cy = nx, ny\n            print(json.dumps(buttons))\n            return buttons\n            \n        cx, cy = current\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) in grid and grid[(nx, ny)] and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [(nx, ny)]))\n                \n    print(f\"Error: No path found to {(target_x, target_y)}.\")\n    return []\n\nif __name__ == \"__main__\":\n    bfs_path(map_xml_string, input_data['target_x'], input_data['target_y'], input_data.get('movement_mode', 'walking'))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-08T13:38:17.154Z",
        "action_counter": 28141
      },
      {
        "commit_message": "Fixed variable access by using `input_data` dictionary instead of assuming global variables.",
        "timestamp": "2026-01-08T13:40:06.080Z",
        "action_counter": 28143
      },
      {
        "commit_message": "Fixing JSON output error when no path is found. Now returns an empty list [] on failure instead of a plain string.",
        "timestamp": "2026-01-08T16:53:53.077Z",
        "action_counter": 28353
      },
      {
        "commit_message": "Fixed missing commit message error and refined BFS logic to handle surfing and landing correctly.",
        "timestamp": "2026-01-08T18:06:59.771Z",
        "action_counter": 28443
      },
      {
        "commit_message": "Fixed JSON output error by removing plain text error messages. Now returns an empty list [] on failure.",
        "timestamp": "2026-01-08T18:13:10.805Z",
        "action_counter": 28451
      },
      {
        "commit_message": "Refined obstacle detection to include <Object> tags and <Marker> tags with object_id, preventing pathing through NPCs.",
        "timestamp": "2026-01-08T21:34:10.018Z",
        "action_counter": 28681
      }
    ]
  },
  "roamer_hunt_cycle": {
    "description": "Automates the roamer hunt loop. If in Ecruteak, moves to Route 37. If in Route 37, hunts and returns.",
    "input_schema": {
      "type": "object",
      "properties": {
        "steps": {
          "type": "integer",
          "default": 10
        },
        "current_map_id": {
          "type": "string"
        },
        "player_x": {
          "type": "integer"
        },
        "player_y": {
          "type": "integer"
        }
      },
      "required": [
        "current_map_id",
        "player_x",
        "player_y"
      ]
    },
    "python_script": "import json\n\nsteps = 10\ncurrent_map_id = \"\"\nplayer_x = 0\nplayer_y = 0\n\nif 'steps' in input_data:\n    steps = int(input_data['steps'])\nif 'current_map_id' in input_data:\n    current_map_id = input_data['current_map_id']\nif 'player_x' in input_data:\n    player_x = int(input_data['player_x'])\nif 'player_y' in input_data:\n    player_y = int(input_data['player_y'])\n\nbuttons = []\n\nif current_map_id == \"4_9\": # Ecruteak\n    # Send Down twice to handle \"Turn then Move\" if facing Up.\n    # If already facing Down, the extra Down might be eaten during transition or move us on next map, which is fine.\n    buttons.append(\"Down\")\n    buttons.append(\"Down\")\n\nelif current_map_id == \"10_4\": # Route 37\n    # Calculate path to grass (Row 2)\n    # Usually we enter at (7,0) or (8,0).\n    # Grass starts at Y=2.\n    \n    # Move Down to Y=2\n    if player_y < 2:\n        for _ in range(2 - player_y):\n            buttons.append(\"Down\")\n    \n    # Wiggle\n    for i in range(steps):\n        if i % 2 == 0:\n            buttons.append(\"Left\")\n        else:\n            buttons.append(\"Right\")\n    \n    # Realign if odd steps\n    if steps % 2 != 0:\n        buttons.append(\"Right\")\n        \n    # Return to Ecruteak (Move Up to Y=-1)\n    # We are at Y=2. Needs 3 Ups to exit (2 to 1, 1 to 0, 0 to -1).\n    buttons.append(\"Up\")\n    buttons.append(\"Up\")\n    buttons.append(\"Up\")\n\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-10T19:20:59.721Z",
        "action_counter": 32161
      },
      {
        "commit_message": "Updated to be context-aware. Checks current_map_id to determine whether to transition maps or hunt in grass.",
        "timestamp": "2026-01-10T19:25:02.533Z",
        "action_counter": 32166
      },
      {
        "commit_message": "Updated to perform full hunt cycle from Ecruteak City (enter map -> hunt -> return).",
        "timestamp": "2026-01-10T19:28:39.979Z",
        "action_counter": 32169
      },
      {
        "commit_message": "Refined to handle map transitions better. If in Ecruteak, only sends one 'Down' to transition, preventing input loss. If in Route 37, performs the hunt and returns.",
        "timestamp": "2026-01-10T19:55:25.798Z",
        "action_counter": 32208
      },
      {
        "commit_message": "Updated Ecruteak logic to send 'Down' twice. This ensures that if the player is facing Up, the first 'Down' turns them and the second initiates movement/transition.",
        "timestamp": "2026-01-10T19:59:43.592Z",
        "action_counter": 32213
      }
    ]
  }
}