{
  "find_path_v5": {
    "description": "Standardized A* pathfinding tool for navigating the current map. Returns an array of button strings (\"Up\", \"Down\", \"Left\", \"Right\") to reach the destination from the current position. Can handle ledges (LEDGE_HOP_DOWN) as one-way traversable tiles. Returns an empty array if no path is found. Treats 'unseen' tiles and all WARP_CARPET types as walkable.",
    "input_schema": {
      "properties": {
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ],
      "type": "object"
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef solve():\n    try:\n        tree = ET.fromstring(map_xml_string)\n    except Exception:\n        print(json.dumps([]))\n        return\n\n    width = int(tree.get('width'))\n    height = int(tree.get('height'))\n    start = (int(input_data['start_x']), int(input_data['start_y']))\n    end = (int(input_data['end_x']), int(input_data['end_y']))\n\n    grid = {}\n    for row in tree.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            t_type = tile.get('type')\n            seen = tile.get('seen') == 'true'\n            has_obj = tile.get('has-object') == 'true'\n            grid[(x, y)] = {'type': t_type, 'seen': seen, 'has_obj': has_obj}\n\n    def is_walkable(pos, from_pos=None):\n        if pos not in grid: return False\n        tile = grid[pos]\n        if tile['has_obj'] and pos != start and pos != end: return False\n        if not tile['seen']: return True\n        \n        walkable_types = [\"FLOOR\", \"TALL_GRASS\", \"LONG_GRASS\", \"LADDER\", \"PIER\", \"grass\", \"DOOR\", \"STAIRCASE\", \"CAVE\", \"WARP_CARPET_DOWN\", \"WARP_CARPET_UP\", \"WARP_CARPET_LEFT\", \"WARP_CARPET_RIGHT\"]\n        if tile['type'] in walkable_types or \"WARP_CARPET\" in tile['type']:\n            return True\n        if tile['type'] == \"LEDGE_HOP_DOWN\":\n            if from_pos and from_pos[0] == pos[0] and from_pos[1] == pos[1] - 1:\n                return True\n        return False\n\n    queue = [(0, start, [])]\n    visited = set()\n    \n    while queue:\n        (cost, current, path) = heapq.heappop(queue)\n        if current in visited: continue\n        visited.add(current)\n        if current == end:\n            print(json.dumps(path))\n            return\n        \n        x, y = current\n        for dx, dy, btn in [(0, -1, \"Up\"), (0, 1, \"Down\"), (-1, 0, \"Left\"), (1, 0, \"Right\")]:\n            neighbor = (x + dx, y + dy)\n            if is_walkable(neighbor, current):\n                new_path = path + [btn]\n                priority = len(new_path) + abs(neighbor[0] - end[0]) + abs(neighbor[1] - end[1])\n                heapq.heappush(queue, (priority, neighbor, new_path))\n    \n    print(json.dumps([]))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T12:40:56.986Z",
        "action_counter": 40831
      },
      {
        "commit_message": "Allow exploration by treating 'unseen' tiles as walkable.",
        "timestamp": "2026-01-11T13:12:47.713Z",
        "action_counter": 40891
      },
      {
        "commit_message": "Correctly handle FLOOR_UP_WALL blocking Down movement.",
        "timestamp": "2026-01-11T13:16:31.532Z",
        "action_counter": 40897
      },
      {
        "commit_message": "Refined find_path_v5 to include LADDER tiles and correctly handle one-way LEDGE_HOP_DOWN tiles.",
        "timestamp": "2026-01-11T15:23:05.121Z",
        "action_counter": 41101
      },
      {
        "commit_message": "Added support for WARP_CARPET_LEFT and WARP_CARPET_RIGHT to the walkable tile list.",
        "timestamp": "2026-01-11T18:11:19.132Z",
        "action_counter": 41393
      },
      {
        "commit_message": "Added STAIRCASE and DOOR to the walkable tile list in find_path_v5.",
        "timestamp": "2026-01-11T19:20:58.657Z",
        "action_counter": 41474
      },
      {
        "commit_message": "Initial definition of find_path_v5 for standardized A* pathfinding.",
        "timestamp": "2026-01-11T20:50:03.487Z",
        "action_counter": 41642
      },
      {
        "commit_message": "Refining find_path_v5 to include DOOR, STAIRCASE, CAVE, and specific WARP_CARPET types in walkable list.",
        "timestamp": "2026-01-11T21:41:37.784Z",
        "action_counter": 41724
      },
      {
        "commit_message": "Fixing ' grass' typo and ensuring all traversable types are included in find_path_v5.",
        "timestamp": "2026-01-11T21:44:10.617Z",
        "action_counter": 41726
      }
    ]
  },
  "press_menu_buttons_v3": {
    "description": "Presses a sequence of buttons for menu navigation. Returns the sequence.",
    "input_schema": {
      "properties": {
        "buttons": {
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "buttons"
      ],
      "type": "object"
    },
    "python_script": "import json\n\ndef solve():\n    buttons = input_data.get('buttons', [])\n    print(json.dumps(buttons))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T12:40:56.987Z",
        "action_counter": 40831
      },
      {
        "commit_message": "Initial definition of press_menu_buttons_v3 for menu navigation with sleep support.",
        "timestamp": "2026-01-11T21:46:51.136Z",
        "action_counter": 41731
      }
    ]
  },
  "find_reachable_unseen_tiles": {
    "description": "Identifies all unseen tiles on the current map that are adjacent to reachable walkable tiles. If autopress_buttons is true, returns a path to the nearest one.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "description": "If true, returns a path to the nearest one.",
          "type": "boolean"
        },
        "current_x": {
          "type": "integer"
        },
        "current_y": {
          "type": "integer"
        }
      },
      "required": [
        "current_x",
        "current_y"
      ],
      "type": "object"
    },
    "python_script": "import json\nfrom xml.etree import ElementTree as ET\n\ndef find_path(grid, start, end):\n    queue = [(start, [])]\n    visited = {start}\n    while queue:\n        (x, y), path = queue.pop(0)\n        if (x, y) == end:\n            return path\n        for dx, dy, btn in [(0, -1, \"Up\"), (0, 1, \"Down\"), (-1, 0, \"Left\"), (1, 0, \"Right\")]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) in grid and grid[(nx, ny)] != 'WALL' and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [btn]))\n    return None\n\ndef solve():\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    unseen = []\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            seen = tile.attrib['seen'] == 'true'\n            grid[(x, y)] = t_type\n            if not seen:\n                unseen.append((x, y))\n                \n    start = (input_data['current_x'], input_data['current_y'])\n    \n    reachable_unseen = []\n    for ux, uy in unseen:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = ux + dx, uy + dy\n            if (nx, ny) in grid and grid[(nx, ny)] != 'WALL':\n                path = find_path(grid, start, (nx, ny))\n                if path is not None:\n                    reachable_unseen.append({\"x\": ux, \"y\": uy})\n                    break\n                    \n    if input_data.get('autopress_buttons', False):\n        if not reachable_unseen:\n            print(json.dumps([]))\n            return\n        reachable_unseen.sort(key=lambda p: abs(p['x']-start[0]) + abs(p['y']-start[1]))\n        target_coords = (reachable_unseen[0]['x'], reachable_unseen[0]['y'])\n        \n        best_path = None\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = target_coords[0] + dx, target_coords[1] + dy\n            if (nx, ny) in grid and grid[(nx, ny)] != 'WALL':\n                path = find_path(grid, start, (nx, ny))\n                if path is not None:\n                    if best_path is None or len(path) < len(best_path):\n                        best_path = path\n        print(json.dumps(best_path if best_path else []))\n    else:\n        print(json.dumps(reachable_unseen))\n\nsolve()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T18:35:24.812Z",
        "action_counter": 41414
      },
      {
        "commit_message": "Refined logic to correctly identify unseen tiles adjacent to reachable walkable tiles. Removed 'unseen' from walkable types to ensure search only passes through confirmed traversable areas.",
        "timestamp": "2026-01-11T22:25:41.646Z",
        "action_counter": 41821
      },
      {
        "commit_message": "Fix find_reachable_unseen_tiles to return button strings when autopress_buttons is true.",
        "timestamp": "2026-01-12T01:57:28.881Z",
        "action_counter": 42305
      }
    ]
  },
  "find_isolated_tile_clusters": {
    "description": "Identifies groups of reachable tiles that are separated from each other by impassable tiles (WALLs, Objects, etc.). Useful for finding isolated sections of a map.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport collections\n\ndef solve():\n    try:\n        tree = ET.fromstring(map_xml_string)\n    except:\n        print(json.dumps([]))\n        return\n        \n    width = int(tree.get('width'))\n    height = int(tree.get('height'))\n    \n    walkable_tiles = set()\n    walkable_types = [\n        \"FLOOR\", \"TALL_GRASS\", \"LONG_GRASS\", \"LADDER\", \"PIER\", \n        \"WARP_CARPET\", \"WARP_CARPET_DOWN\", \"WARP_CARPET_LEFT\", \n        \"WARP_CARPET_RIGHT\", \"WARP_CARPET_UP\", \"LEDGE_HOP_DOWN\", \n        \"grass\", \"STAIRCASE\", \"DOOR\"\n    ]\n    \n    for row in tree.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            t_type = tile.get('type')\n            seen = tile.get('seen') == 'true'\n            has_object = tile.get('has-object') == 'true'\n            \n            if has_object:\n                continue\n            \n            if t_type in walkable_types or not seen:\n                walkable_tiles.add((x, y))\n                \n    clusters = []\n    visited = set()\n    \n    for tile in walkable_tiles:\n        if tile not in visited:\n            cluster = []\n            queue = collections.deque([tile])\n            visited.add(tile)\n            while queue:\n                curr = queue.popleft()\n                cluster.append(curr)\n                cx, cy = curr\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nx, ny = cx + dx, cy + dy\n                    if (nx, ny) in walkable_tiles and (nx, ny) not in visited:\n                        visited.add((nx, ny))\n                        queue.append((nx, ny))\n            clusters.append(cluster)\n            \n    output = []\n    for i, cluster in enumerate(clusters):\n        output.append({\n            \"cluster_id\": i,\n            \"tiles\": [{\"x\": x, \"y\": y} for x, y in cluster]\n        })\n    print(json.dumps(output))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T19:40:21.735Z",
        "action_counter": 41523
      }
    ]
  }
}