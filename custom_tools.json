{
  "find_path_v3": {
    "description": "Calculates a path between two coordinates on the current map using BFS, accounting for walls, objects, and avoiding unintentional warps. Returns a list of button strings. Updated to include more traversable tile types (including WARP_CARPET and STAIRS) and robust player position detection from the Mental Map.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer",
          "nullable": true
        },
        "start_y": {
          "type": "integer",
          "nullable": true
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "can_surf": {
          "type": "boolean",
          "default": false
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "end_x",
        "end_y",
        "autopress_buttons"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef solve():\n    root = ET.fromstring(map_xml_string)\n    \n    # Get current position from XML if not provided\n    start_x = input_data.get('start_x')\n    start_y = input_data.get('start_y')\n    \n    if start_x is None or start_y is None:\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                if tile.find('Player') is not None:\n                    start_x = int(tile.attrib['id'])\n                    start_y = y\n                    break\n            if start_x is not None: break\n\n    if start_x is None:\n        print(json.dumps([]))\n        return\n\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    can_surf = input_data.get('can_surf', False)\n\n    # Build grid\n    grid = {}\n    objects = set()\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            grid[(x, y)] = t_type\n            if tile.find('Object') is not None or tile.attrib.get('has-object') == 'true':\n                objects.add((x, y))\n\n    def is_traversable(x, y):\n        if (x, y) not in grid: return False\n        # Allow walking onto the target even if it has an object (e.g. interacting with an item)\n        if (x, y) in objects and (x, y) != (end_x, end_y): return False\n        \n        t_type = grid[(x, y)]\n        traversable_types = [\n            'FLOOR', 'TALL_GRASS', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', \n            'WARP_CARPET_UP', 'WARP_CARPET_DOWN', 'CAVE', 'FLOOR_UP_WALL', \n            'STAIRS', 'WARP_CARPET'\n        ]\n        if t_type in traversable_types:\n            return True\n        if can_surf and t_type == 'WATER':\n            return True\n        return False\n\n    queue = deque([(start_x, start_y, [])])\n    visited = {(start_x, start_y)}\n    \n    while queue:\n        cx, cy, path = queue.popleft()\n        if (cx, cy) == (end_x, end_y):\n            print(json.dumps(path))\n            return\n\n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) not in visited and is_traversable(nx, ny):\n                visited.add((nx, ny))\n                queue.append((nx, ny, path + [btn]))\n\n    print(json.dumps([]))\n\nsolve()",
    "history": [
      {
        "commit_message": "Refined pathfinding with more robust tile type handling and improved BFS for overworld navigation.",
        "timestamp": "2025-12-26T16:54:12.345Z",
        "action_counter": 23112
      },
      {
        "commit_message": "Refined pathfinding with robust position detection and improved traversability checks for overworld navigation.",
        "timestamp": "2025-12-26T16:56:20.298Z",
        "action_counter": 23116
      }
    ]
  },
  "navigate_fly_map_v2": {
    "description": "Navigates the Johto FLY map from a known starting city to a target city. City names: 'New Bark Town', 'Cherrygrove City', 'Violet City', 'Azalea Town', 'Goldenrod City', 'Ecruteak City', 'Olivine City', 'Cianwood City', 'Mahogany Town', 'Lake of Rage', 'Blackthorn City', 'Mt. Silver', 'Indigo Plateau'. Assumes the FLY map is already open.",
    "input_schema": {
      "properties": {
        "start_city": {
          "default": "New Bark Town",
          "type": "string"
        },
        "target_city": {
          "type": "string"
        }
      },
      "required": [
        "target_city"
      ],
      "type": "object"
    },
    "python_script": "import json\n\ndef navigate_fly_map(target_city, start_city=\"New Bark Town\"):\n    cities = [\n        \"New Bark Town\", \"Cherrygrove City\", \"Violet City\", \"Azalea Town\",\n        \"Goldenrod City\", \"Ecruteak City\", \"Olivine City\", \"Cianwood City\",\n        \"Mahogany Town\", \"Lake of Rage\", \"Blackthorn City\", \"Mt. Silver\", \"Indigo Plateau\"\n    ]\n    \n    if target_city not in cities or start_city not in cities:\n        print(json.dumps([]))\n        return\n\n    start_idx = cities.index(start_city)\n    target_idx = cities.index(target_city)\n    diff = target_idx - start_idx\n    \n    buttons = []\n    # In Crystal Johto FLY map:\n    # 'Up' moves forward in the sequence (index increases).\n    if diff > 0:\n        buttons = [\"Up\"] * diff\n    elif diff < 0:\n        buttons = [\"Down\"] * abs(diff)\n    \n    buttons.append(\"A\")\n    print(json.dumps(buttons))\n\n# The variable 'input_data' is automatically available.\nnavigate_fly_map(input_data['target_city'], input_data.get('start_city', 'New Bark Town'))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-27T03:08:24.414Z",
        "action_counter": 24583
      }
    ]
  },
  "sweep_area_v2": {
    "description": "Iteratively walks all floor tiles within a specified bounding box on the current map to trigger events or find objects. Uses BFS for robust movement between points and handles obstacles. Returns a list of button strings for the path.",
    "input_schema": {
      "properties": {
        "bottom_y": {
          "type": "integer"
        },
        "left_x": {
          "type": "integer"
        },
        "right_x": {
          "type": "integer"
        },
        "top_y": {
          "type": "integer"
        }
      },
      "required": [
        "left_x",
        "top_y",
        "right_x",
        "bottom_y"
      ],
      "type": "object"
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef find_player(root):\n    for row in root.findall('Row'):\n        row_id = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            if tile.find('Player') is not None:\n                return int(tile.get('id')), row_id\n    return None\n\ndef bfs(start, end, root):\n    if start == end: return []\n    q = deque([(start, [])])\n    visited = {start}\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    while q:\n        (cx, cy), path = q.popleft()\n        for dx, dy, btn in [(0, -1, \"Up\"), (0, 1, \"Down\"), (-1, 0, \"Left\"), (1, 0, \"Right\")]:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:\n                tile = root.find(f\".//Row[@id='{ny}']/Tile[@id='{nx}']\")\n                if tile is not None and tile.get('type') in ['FLOOR', 'WARP_CARPET', 'STAIRS', 'CAVE', 'WATER']:\n                    # Note: Simplified collision. Objects are walls.\n                    if tile.find('Object') is not None:\n                        continue\n                    if (nx, ny) == end:\n                        return path + [btn]\n                    visited.add((nx, ny))\n                    q.append(((nx, ny), path + [btn]))\n    return None\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    left = int(input_data['left_x'])\n    top = int(input_data['top_y'])\n    right = int(input_data['right_x'])\n    bottom = int(input_data['bottom_y'])\n    \n    player_pos = find_player(root)\n    if not player_pos: \n        print(json.dumps([\"Error: Player not found\"]))\n    else:\n        # Generate target floor tiles in a snake pattern for efficiency\n        targets = []\n        for y in range(top, bottom + 1):\n            x_range = range(left, right + 1) if (y - top) % 2 == 0 else range(right, left - 1, -1)\n            for x in x_range:\n                tile = root.find(f\".//Row[@id='{y}']/Tile[@id='{x}']\")\n                if tile is not None and tile.get('type') == 'FLOOR':\n                    targets.append((x, y))\n        \n        full_path = []\n        curr_pos = player_pos\n        for target in targets:\n            sub_path = bfs(curr_pos, target, root)\n            if sub_path is not None:\n                full_path.extend(sub_path)\n                curr_pos = target\n        \n        print(json.dumps(full_path))\nexcept Exception as e:\n    print(json.dumps([f\"Error: {str(e)}\"]))\n",
    "history": [
      {
        "commit_message": "Initial version of a robust area sweep tool using BFS for navigation between floor tiles.",
        "timestamp": "2025-12-27T05:49:48.091Z",
        "action_counter": 24932
      }
    ]
  },
  "find_path_bfs": {
    "description": "Calculates a path between two coordinates on the current map using BFS. Returns a list of button strings.",
    "input_schema": {
      "type": "object",
      "properties": {
        "can_surf": {
          "default": false,
          "type": "boolean"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef run(input_data):\n    xml_str = map_xml_string\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    can_surf = input_data.get('can_surf', False)\n\n    root = ET.fromstring(xml_str)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tile_type = tile.attrib['type']\n            has_object = tile.attrib.get('has-object') == 'true'\n            is_warp = tile.attrib.get('is-warp') == 'true'\n            \n            impassable_types = ['WALL', 'HEADBUTT_TREE', 'CUT_TREE', 'VOID']\n            if not can_surf:\n                impassable_types.append('WATER')\n                \n            passable = tile_type not in impassable_types and not has_object\n            if tile_type in ['WARP_CARPET_DOWN', 'WARP_CARPET_UP', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'STAIRS', 'LADDER'] or is_warp:\n                passable = True\n                \n            grid[(x, y)] = passable\n\n    start = (start_x, start_y)\n    end = (end_x, end_y)\n    \n    if start not in grid:\n        print(json.dumps([]))\n        return\n    grid[start] = True\n\n    queue = deque([(start, [])])\n    visited = {start}\n    \n    while queue:\n        (curr_x, curr_y), path = queue.popleft()\n        if (curr_x, curr_y) == end:\n            print(json.dumps(path))\n            return\n            \n        for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = curr_x + dx, curr_y + dy\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) in grid and grid[(nx, ny)] and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [move]))\n    print(json.dumps([]))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-27T07:56:41.439Z",
        "action_counter": 25202
      }
    ]
  },
  "open_fly_map_v2": {
    "description": "Opens the FLY map from the main menu by selecting a Pokemon in the party. Assumes the main menu is already open with the cursor on POKEMON.",
    "input_schema": {
      "type": "object",
      "properties": {
        "party_index": {
          "type": "integer",
          "description": "The 1-indexed position of the Pokemon with FLY in the party."
        }
      },
      "required": [
        "party_index"
      ]
    },
    "python_script": "import json\ndef main(input_data):\n    index = int(input_data.get('party_index', 2))\n    buttons = [\"A\", \"sleep 500\"]\n    for _ in range(index - 1):\n        buttons.append(\"Down\")\n        buttons.append(\"sleep 500\")\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    buttons.append(\"A\")\n    print(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-27T09:07:23.644Z",
        "action_counter": 25369
      }
    ]
  }
}