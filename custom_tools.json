{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "inventory_navigator_tool": {
    "description": "Calculates the optimal number of button presses (Up/Down) to navigate from a current selection to a target item in a list-based menu. This version correctly handles non-wrapping menus and provides a warning for long scrolls.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory_list": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "current_selection": {
          "type": "string"
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "inventory_list",
        "current_selection",
        "target_item"
      ]
    },
    "python_script": "import json\ntry:\n    inventory = input_data['inventory_list']\n    current_item = input_data['current_selection']\n    target_item = input_data['target_item']\n\n    if current_item not in inventory or target_item not in inventory:\n        print(json.dumps({'error': 'Item not found in inventory list.'}))\n    else:\n        current_idx = inventory.index(current_item)\n        target_idx = inventory.index(target_item)\n        \n        response = {}\n        if current_idx == target_idx:\n            response = {'direction': 'NONE', 'presses': 0}\n        elif target_idx > current_idx:\n            presses = target_idx - current_idx\n            response = {'direction': 'DOWN', 'presses': presses}\n        else: # target_idx < current_idx\n            presses = current_idx - target_idx\n            response = {'direction': 'UP', 'presses': presses}\n\n        if response.get('presses', 0) > 4:\n            response['note'] = 'Warning: This is a long scroll. Press Down in increments of 4 to navigate pages more effectively.'\n        \n        print(json.dumps(response))\nexcept Exception as e:\n    print(json.dumps({'error': str(e), 'type': type(e).__name__}))"
  },
  "path_planner": {
    "description": "A combined pathfinding and path conversion tool. Takes start and target coordinates and directly outputs a JSON-formatted path plan. This improved version avoids pathing through warp tiles. Now with enhanced debugging.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef find_and_convert_path(start_x_str, start_y_str, target_x_str, target_y_str, map_xml_string):\n    debug_log = []\n    try:\n        start_x, start_y, target_x, target_y = int(start_x_str), int(start_y_str), int(target_x_str), int(target_y_str)\n        root = ET.fromstring(map_xml_string)\n        grid = {}\n        objects = set()\n        warps = set()\n\n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                x = int(tile.get('id'))\n                grid[(x, y)] = tile.get('type')\n                if tile.find('Object') is not None and tile.find('Object').get('id-name') != 'Pikachu':\n                    objects.add((x, y))\n                if tile.find('Warp') is not None:\n                    warps.add((x, y))\n        debug_log.append(f\"Grid built. Size: {len(grid)}\")\n        debug_log.append(f\"Objects found: {sorted(list(objects))}\")\n        debug_log.append(f\"Warps found: {sorted(list(warps))}\")\n\n        def is_walkable(x, y):\n            walkable = True\n            reason = []\n            if (x, y) not in grid:\n                walkable = False\n                reason.append('not in grid')\n            if (x, y) in objects:\n                walkable = False\n                reason.append('is object')\n            if (x, y) in warps:\n                walkable = False\n                reason.append('is warp')\n            \n            if walkable:\n                tile_type = grid.get((x,y))\n                walkable_types = ['ground', 'grass', 'steps', 'elevated_ground', 'cleared_boulder_barrier', 'open_gate', 'spinner_stop']\n                if not (tile_type in walkable_types or 'spinner' in tile_type):\n                    walkable = False\n                    reason.append(f'bad type: {tile_type}')\n            debug_log.append(f\"is_walkable({x},{y}) -> {walkable}. Reason: {', '.join(reason) if reason else 'OK'}\")\n            return walkable\n\n        def get_neighbors(x, y):\n            neighbors = []\n            for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n                nx, ny = x + dx, y + dy\n                if (nx, ny) not in grid:\n                    continue\n                \n                if grid.get((nx, ny)) == 'ledge' and dy == 1 and grid.get((x,y)) != 'ledge':\n                    if is_walkable(nx, ny + 1):\n                        neighbors.append((nx, ny + 1, 'Down'))\n                    continue\n\n                is_target_warp = (nx, ny) in warps and nx == target_x and ny == target_y\n                if is_walkable(nx, ny) or is_target_warp:\n                    neighbors.append((nx, ny, move))\n            return neighbors\n\n        start_node = (start_x, start_y)\n        pathfinding_target_nodes = set()\n        if is_walkable(target_x, target_y) or ((target_x, target_y) in warps):\n            pathfinding_target_nodes.add((target_x, target_y))\n        else:\n            for dx, dy, _ in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n                adj_x, adj_y = target_x + dx, target_y + dy\n                if is_walkable(adj_x, adj_y):\n                    pathfinding_target_nodes.add((adj_x, adj_y))\n\n        if not pathfinding_target_nodes:\n            debug_log.append(\"No valid pathfinding target nodes found.\")\n            print(json.dumps({'path': [], 'debug_log': debug_log}))\n            return\n\n        open_set = []\n        heapq.heappush(open_set, (0, start_node))\n        came_from = {}\n        g_score = {start_node: 0}\n        f_score = {start_node: min(abs(start_node[0] - t[0]) + abs(start_node[1] - t[1]) for t in pathfinding_target_nodes)}\n        path_found = False\n\n        while open_set:\n            _, current = heapq.heappop(open_set)\n\n            if current in pathfinding_target_nodes:\n                path_moves = []\n                temp = current\n                while temp in came_from:\n                    prev, move = came_from[temp]\n                    path_moves.append(move)\n                    temp = prev\n                moves = path_moves[::-1]\n                x, y = start_x, start_y\n                coordinates = [{'x': x, 'y': y}]\n                move_map = {'Up': (0, -1), 'Down': (0, 1), 'Left': (-1, 0), 'Right': (1, 0)}\n                for move in moves:\n                    if move in move_map:\n                        dx, dy = move_map[move]\n                        x += dx\n                        y += dy\n                        coordinates.append({'x': x, 'y': y})\n                print(json.dumps({'path': coordinates, 'debug_log': debug_log}))\n                path_found = True\n                break\n\n            for neighbor_x, neighbor_y, move in get_neighbors(current[0], current[1]):\n                neighbor = (neighbor_x, neighbor_y)\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = (current, move)\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = tentative_g_score + min(abs(neighbor[0] - t[0]) + abs(neighbor[1] - t[1]) for t in pathfinding_target_nodes)\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n        if not path_found:\n            debug_log.append(\"A* search completed without finding a path.\")\n            print(json.dumps({'path': [], 'debug_log': debug_log}))\n\n    except Exception as e:\n        print(json.dumps({'path': [], 'debug_log': debug_log, 'error': str(e)}))\n\ntry:\n    find_and_convert_path(input_data['start_x'], input_data['start_y'], input_data['target_x'], input_data['target_y'], map_xml_string)\nexcept KeyError as e:\n    print(json.dumps({'path': [], 'debug_log': [], 'error': f'Missing input key: {e}'}))"
  }
}