{
  "get_type_effectiveness_gen2": {
    "description": "Returns the type effectiveness multiplier for an attack in Gen 2 Pokemon Crystal.",
    "input_schema": {
      "properties": {
        "attacking_type": {
          "description": "The type of the move being used.",
          "type": "string"
        },
        "defending_type1": {
          "description": "The first type of the defending Pokemon.",
          "type": "string"
        },
        "defending_type2": {
          "description": "The second type of the defending Pokemon (optional).",
          "nullable": true,
          "type": "string"
        }
      },
      "required": [
        "attacking_type",
        "defending_type1"
      ],
      "type": "object"
    },
    "python_script": "import json\n\ndef get_effectiveness():\n    attacking_type = input_data.get('attacking_type').upper()\n    def1 = input_data.get('defending_type1').upper()\n    def2 = input_data.get('defending_type2')\n    if def2: def2 = def2.upper()\n    \n    chart = {\n        \"NORMAL\": {\"ROCK\": 0.5, \"GHOST\": 0, \"STEEL\": 0.5},\n        \"FIRE\": {\"FIRE\": 0.5, \"WATER\": 0.5, \"GRASS\": 2, \"ICE\": 2, \"BUG\": 2, \"ROCK\": 0.5, \"DRAGON\": 0.5, \"STEEL\": 2},\n        \"WATER\": {\"FIRE\": 2, \"WATER\": 0.5, \"GRASS\": 0.5, \"GROUND\": 2, \"ROCK\": 2, \"DRAGON\": 0.5},\n        \"ELECTRIC\": {\"WATER\": 2, \"ELECTRIC\": 0.5, \"GRASS\": 0.5, \"GROUND\": 0, \"FLYING\": 2, \"DRAGON\": 0.5},\n        \"GRASS\": {\"FIRE\": 0.5, \"WATER\": 2, \"GRASS\": 0.5, \"POISON\": 0.5, \"GROUND\": 2, \"FLYING\": 0.5, \"BUG\": 0.5, \"ROCK\": 2, \"DRAGON\": 0.5, \"STEEL\": 0.5},\n        \"ICE\": {\"FIRE\": 0.5, \"WATER\": 0.5, \"GRASS\": 2, \"ICE\": 0.5, \"GROUND\": 2, \"FLYING\": 2, \"DRAGON\": 2, \"STEEL\": 0.5},\n        \"FIGHTING\": {\"NORMAL\": 2, \"ICE\": 2, \"POISON\": 0.5, \"FLYING\": 0.5, \"PSYCHIC\": 0.5, \"BUG\": 0.5, \"ROCK\": 2, \"GHOST\": 0, \"DARK\": 2, \"STEEL\": 2},\n        \"POISON\": {\"GRASS\": 2, \"POISON\": 0.5, \"GROUND\": 0.5, \"ROCK\": 0.5, \"GHOST\": 0.5, \"STEEL\": 0},\n        \"GROUND\": {\"FIRE\": 2, \"ELECTRIC\": 2, \"GRASS\": 0.5, \"POISON\": 2, \"FLYING\": 0, \"BUG\": 0.5, \"ROCK\": 2, \"STEEL\": 2},\n        \"FLYING\": {\"ELECTRIC\": 0.5, \"GRASS\": 2, \"FIGHTING\": 2, \"BUG\": 2, \"ROCK\": 0.5, \"STEEL\": 0.5},\n        \"PSYCHIC\": {\"FIGHTING\": 2, \"POISON\": 2, \"PSYCHIC\": 0.5, \"DARK\": 0, \"STEEL\": 0.5},\n        \"BUG\": {\"FIRE\": 0.5, \"GRASS\": 2, \"POISON\": 0.5, \"FIGHTING\": 0.5, \"FLYING\": 0.5, \"PSYCHIC\": 2, \"GHOST\": 0.5, \"DARK\": 2, \"STEEL\": 0.5},\n        \"ROCK\": {\"FIRE\": 2, \"ICE\": 2, \"FIGHTING\": 0.5, \"GROUND\": 0.5, \"FLYING\": 2, \"BUG\": 2, \"STEEL\": 0.5},\n        \"GHOST\": {\"NORMAL\": 0, \"PSYCHIC\": 2, \"GHOST\": 2, \"DARK\": 0.5, \"STEEL\": 0.5},\n        \"DRAGON\": {\"DRAGON\": 2, \"STEEL\": 0.5},\n        \"DARK\": {\"FIGHTING\": 0.5, \"PSYCHIC\": 2, \"GHOST\": 2, \"DARK\": 0.5, \"STEEL\": 0.5},\n        \"STEEL\": {\"FIRE\": 0.5, \"WATER\": 0.5, \"ELECTRIC\": 0.5, \"ICE\": 2, \"ROCK\": 2, \"STEEL\": 0.5}\n    }\n    \n    eff = chart.get(attacking_type, {}).get(def1, 1.0)\n    if def2:\n        eff *= chart.get(attacking_type, {}).get(def2, 1.0)\n    \n    print(json.dumps({\"multiplier\": eff}))\n\nif __name__ == \"__main__\":\n    get_effectiveness()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-23T09:05:37.668Z",
        "action_counter": 14041
      },
      {
        "commit_message": "Fixed the tool to actually print the result using input_data.",
        "timestamp": "2025-12-23T09:26:49.920Z",
        "action_counter": 14085
      },
      {
        "commit_message": "Defining the missing type effectiveness tool for Gen 2.",
        "timestamp": "2025-12-23T12:40:44.706Z",
        "action_counter": 14405
      }
    ]
  },
  "select_battle_move_refined": {
    "description": "Selects a move from the battle move menu. Automatically detects the current cursor position from screen text. Takes the 1-based index of the move to select (1-4). Accounts for menu wrapping. Navigation is restricted to Up/Down buttons only.",
    "input_schema": {
      "properties": {
        "move_index": {
          "maximum": 4,
          "minimum": 1,
          "type": "integer"
        },
        "screen_text": {
          "type": "string"
        }
      },
      "required": [
        "move_index",
        "screen_text"
      ],
      "type": "object"
    },
    "python_script": "import json\nimport sys\n\ndef run():\n    buttons = [\"A\"]\n    try:\n        if len(sys.argv) > 1:\n            input_data = json.loads(sys.argv[1])\n            move_target = int(input_data.get('move_index', 1))\n            text = input_data.get('screen_text', \"\")\n            \n            lines = text.split('\\n')\n            cursor_chars = ['▶', '▷', '>']\n            \n            move_line_indices = []\n            cursor_line_index = -1\n            \n            # List of strings to exclude when looking for move names\n            exclusions = [\n                'LV', 'HP', 'EXP', 'TYPE', \n                'NORMAL', 'FIRE', 'WATER', 'GRASS', 'ELECTRIC', 'ICE', \n                'FIGHTING', 'POISON', 'GROUND', 'FLYING', 'PSYCHIC', \n                'BUG', 'ROCK', 'GHOST', 'DRAGON', 'STEEL', 'DARK',\n                'CANCEL'\n            ]\n            \n            for i, line in enumerate(lines):\n                # Detect cursor\n                if any(c in line for c in cursor_chars):\n                    cursor_line_index = i\n                \n                # Detect move lines\n                if line.count('│') >= 2:\n                    parts = line.split('│')\n                    for part in parts:\n                        clean_part = part\n                        for c in cursor_chars:\n                            clean_part = clean_part.replace(c, '')\n                        clean_part = clean_part.strip()\n                        \n                        # Pokemon Crystal move names are max 12 chars\n                        if 1 <= len(clean_part) <= 12 and any(c.isalnum() for c in clean_part) and '/' not in clean_part:\n                            # Filter out stat/info labels and type names\n                            if not any(keyword in clean_part.upper() for keyword in exclusions):\n                                move_line_indices.append(i)\n                                break\n            \n            if cursor_line_index != -1 and move_line_indices:\n                # Find the contiguous block of moves containing the cursor\n                # This handles cases where the menu is split or has headers\n                start = cursor_line_index\n                while start > 0 and start - 1 in move_line_indices:\n                    start -= 1\n                end = cursor_line_index\n                while end < len(lines) - 1 and end + 1 in move_line_indices:\n                    end += 1\n                    \n                move_block = [idx for idx in move_line_indices if start <= idx <= end]\n                num_moves = len(move_block)\n                \n                if num_moves > 0:\n                    try:\n                        current_move_pos = move_block.index(cursor_line_index) + 1\n                        diff = move_target - current_move_pos\n                        \n                        # Account for wrapping in the menu\n                        if diff > (num_moves // 2):\n                            diff -= num_moves\n                        elif diff < -(num_moves // 2):\n                            diff += num_moves\n                            \n                        buttons = []\n                        if diff > 0:\n                            buttons = [\"Down\"] * diff\n                        elif diff < 0:\n                            buttons = [\"Up\"] * abs(diff)\n                        \n                        buttons.append(\"A\")\n                    except ValueError:\n                        pass\n    except:\n        pass\n    print(json.dumps(buttons))\n\nif __name__ == \"__main__\":\n    run()",
    "history": [
      {
        "commit_message": "Refine move selection logic to use print() for JSON output and improve move line filtering. Navigation restricted to Up/Down.",
        "timestamp": "2025-12-23T13:30:50.096Z",
        "action_counter": 14481
      },
      {
        "commit_message": "Refine cursor detection and move slot filtering for battle menu. Ensure robust JSON output. Use regex for cursor detection.",
        "timestamp": "2025-12-23T13:33:42.607Z",
        "action_counter": 14486
      },
      {
        "commit_message": "Refine move selection logic to filter for '│   │' pattern, ensuring box-type displays don't interfere. Added sys.stdout robustness.",
        "timestamp": "2025-12-23T13:48:54.766Z",
        "action_counter": 14506
      },
      {
        "commit_message": "Refine move selection logic with more robust cursor detection and move slot filtering. Navigation restricted to Up/Down.",
        "timestamp": "2025-12-23T14:07:01.779Z",
        "action_counter": 14526
      },
      {
        "commit_message": "Refined move detection logic to better handle screen text formatting and contiguous move blocks. Consolidated logic into a single reliable tool.",
        "timestamp": "2025-12-23T15:55:14.197Z",
        "action_counter": 14701
      },
      {
        "commit_message": "Refined error handling and default output to ensure the tool always returns a valid JSON array, even if input parsing fails.",
        "timestamp": "2025-12-23T16:04:23.036Z",
        "action_counter": 14718
      },
      {
        "commit_message": "Refined move detection logic to exclude type labels and other non-move text, ensuring more robust move selection in battle.",
        "timestamp": "2025-12-23T16:17:09.785Z",
        "action_counter": 14744
      },
      {
        "commit_message": "Refined move detection logic with more robust cursor and move name detection. Added support for multiple cursor characters and improved contiguous block identification. Added debug logging for internal state.",
        "timestamp": "2025-12-23T16:20:28.116Z",
        "action_counter": 14748
      }
    ]
  },
  "find_path_v2": {
    "description": "Calculates a path between two coordinates on the current map using BFS, accounting for walls, objects, and one-way tiles (ledges, floor-up-walls). Treats HEADBUTT_TREE as impassable. Does not support surfing navigation. Automatically detects start position from the player's location in the map XML if not provided. Returns a list of coordinate objects.",
    "input_schema": {
      "type": "object",
      "properties": {
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "nullable": true,
          "type": "integer"
        },
        "start_y": {
          "nullable": true,
          "type": "integer"
        }
      },
      "required": [
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef run(input_data):\n    root = ET.fromstring(map_xml_string)\n    \n    start_x = input_data.get('start_x')\n    start_y = input_data.get('start_y')\n    \n    if start_x is None or start_y is None:\n        found = False\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                if tile.find('Player') is not None:\n                    start_x = int(tile.attrib['id'])\n                    start_y = y\n                    found = True\n                    break\n            if found: break\n            \n    if start_x is None or start_y is None:\n        return {\"error\": \"Player position not found\"}\n\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n\n    grid = {}\n    impassable_types = {'WALL', 'HEADBUTT_TREE', 'WATER', 'unseen'}\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            grid[(x, y)] = t_type\n            if tile.find('Object') is not None:\n                grid[(x, y)] = 'WALL'\n\n    queue = deque([(start_x, start_y)])\n    visited = {(start_x, start_y): None}\n    \n    while queue:\n        curr_x, curr_y = queue.popleft()\n        if (curr_x, curr_y) == (end_x, end_y):\n            path = []\n            temp_x, temp_y = curr_x, curr_y\n            while temp_x is not None and temp_y is not None:\n                path.append({\"x\": temp_x, \"y\": temp_y})\n                parent = visited[(temp_x, temp_y)]\n                if parent:\n                    temp_x, temp_y = parent\n                else:\n                    temp_x, temp_y = None, None\n            return path[::-1]\n            \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = curr_x + dx, curr_y + dy\n            if (nx, ny) in grid:\n                t_type = grid[(nx, ny)]\n                if t_type in impassable_types and (nx, ny) != (end_x, end_y):\n                    continue\n                \n                # One-way logic\n                if dy == 1: # South\n                    if grid.get((curr_x, curr_y)) == 'FLOOR_UP_WALL' or t_type == 'FLOOR_UP_WALL': continue\n                    if t_type == 'LEDGE_HOP_DOWN':\n                        ny = ny + 1\n                        if (nx, ny) not in grid or grid[(nx, ny)] in impassable_types: continue\n                elif dy == -1: # North\n                    if t_type == 'LEDGE_HOP_DOWN': continue\n                elif dx == 1: # East\n                    if t_type == 'LEDGE_HOP_RIGHT':\n                        nx = nx + 1\n                        if (nx, ny) not in grid or grid[(nx, ny)] in impassable_types: continue\n                elif dx == -1: # West\n                    if t_type == 'LEDGE_HOP_RIGHT': continue\n                \n                if (nx, ny) not in visited:\n                    visited[(nx, ny)] = (curr_x, curr_y)\n                    queue.append((nx, ny))\n    return []\n\nprint(json.dumps(run(input_data)))",
    "history": [
      {
        "commit_message": "Refined find_path to use the globally available map_xml_string and removed it from input_schema. Fixed one-way logic and impassable types.",
        "timestamp": "2025-12-23T14:36:16.850Z",
        "action_counter": 14568
      },
      {
        "commit_message": "Updated find_path_v2 to automatically detect player position from map_xml_string if start_x/y are not provided. Added start_x/y to input_schema as optional properties.",
        "timestamp": "2025-12-23T14:37:43.655Z",
        "action_counter": 14570
      },
      {
        "commit_message": "Fixed a bug in find_path_v2 where the path reconstruction loop would never terminate if the start position was found, leading to a KeyError: (None, None). Also fixed start_x/y handling to properly detect player position from XML if not provided as arguments.",
        "timestamp": "2025-12-23T14:38:20.004Z",
        "action_counter": 14571
      },
      {
        "commit_message": "Corrected output format of find_path_v2 to return a flat list of coordinates, matching the expected input for the navigate tool.",
        "timestamp": "2025-12-23T14:41:01.719Z",
        "action_counter": 14573
      },
      {
        "commit_message": "Fixed a bug in path reconstruction where (None, None) was not correctly identified as the termination condition, causing a KeyError. Also improved player position detection.",
        "timestamp": "2025-12-23T14:54:49.565Z",
        "action_counter": 14596
      },
      {
        "commit_message": "Refined find_path_v2 to handle pathfinding more robustly, correctly detecting the player's position from the XML if not provided, and returning a list of coordinate objects suitable for the navigate tool's path_plan. Added checks for impassable tiles including HEADBUTT_TREE and WATER.",
        "timestamp": "2025-12-23T14:56:11.952Z",
        "action_counter": 14599
      }
    ]
  },
  "get_reachable_unseen_tiles_v2": {
    "description": "Analyzes the current map XML to identify unseen tiles that are directly adjacent to tiles reachable from the player's current position. Handles ledges and one-way tiles. Returns a list of coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef run(input_data):\n    if not map_xml_string or \"<Map\" not in map_xml_string:\n        return {\"error\": \"Mental Map unavailable.\"}\n    \n    root = ET.fromstring(map_xml_string)\n    \n    start_x, start_y = None, None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            if tile.find('Player') is not None:\n                start_x, start_y = int(tile.attrib['id']), y\n                break\n        if start_x is not None: break\n            \n    if start_x is None: return {\"reachable_unseen\": []}\n\n    grid = {}\n    impassable_types = {'WALL', 'HEADBUTT_TREE', 'WATER', 'unseen'}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            grid[(x, y)] = t_type\n            if tile.find('Object') is not None: grid[(x, y)] = 'WALL'\n\n    queue = deque([(start_x, start_y)])\n    visited = {(start_x, start_y)}\n    reachable_tiles = {(start_x, start_y)}\n    \n    while queue:\n        curr_x, curr_y = queue.popleft()\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = curr_x + dx, curr_y + dy\n            if (nx, ny) in grid:\n                t_type = grid[(nx, ny)]\n                \n                # Relational movement logic (one-way tiles)\n                if dy == 1: # South\n                    if grid.get((curr_x, curr_y)) == 'FLOOR_UP_WALL' or t_type == 'FLOOR_UP_WALL': continue\n                    if t_type == 'LEDGE_HOP_DOWN':\n                        ny += 1\n                        if (nx, ny) in grid: t_type = grid[(nx, ny)]\n                        else: continue\n                elif dy == -1: # North\n                    if t_type == 'LEDGE_HOP_DOWN': continue\n                elif dx == 1: # East\n                    if t_type == 'LEDGE_HOP_RIGHT':\n                        nx += 1\n                        if (nx, ny) in grid: t_type = grid[(nx, ny)]\n                        else: continue\n                elif dx == -1: # West\n                    if t_type == 'LEDGE_HOP_RIGHT': continue\n                \n                if t_type not in impassable_types:\n                    if (nx, ny) not in visited:\n                        visited.add((nx, ny))\n                        reachable_tiles.add((nx, ny))\n                        queue.append((nx, ny))\n\n    reachable_unseen = set()\n    for rx, ry in reachable_tiles:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ux, uy = rx + dx, ry + dy\n            if (ux, uy) in grid and grid[(ux, uy)] == 'unseen':\n                reachable_unseen.add((ux, uy))\n                \n    return {\"reachable_unseen\": sorted(list(reachable_unseen))}\n\nprint(json.dumps(run(input_data)))",
    "history": [
      {
        "commit_message": "Refined get_reachable_unseen_tiles to use the BFS logic from find_path_v2, correctly handling ledges and one-way movement. Added Mental Map availability check.",
        "timestamp": "2025-12-23T15:43:54.280Z",
        "action_counter": 14678
      }
    ]
  }
}