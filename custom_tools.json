{
  "pathfinder": {
    "description": "Calculates the shortest path from a start to an end coordinate on the current map using the A* algorithm. It parses the map_xml_string to identify traversable tiles ('ground', 'grass') and obstacles, correctly handling Pikachu as a traversable object. Returns a list of directional button presses.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\n\ndef parse_map(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    grid = [[0 for _ in range(width + 1)] for _ in range(height + 1)]\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tile_type = tile.attrib.get('type', 'impassable')\n            has_object = tile.attrib.get('has-object') == 'true'\n            is_pikachu = False\n            if has_object:\n                object_element = tile.find('Object')\n                if object_element is not None and object_element.attrib.get('id-name') == 'Pikachu':\n                    is_pikachu = True\n            if tile_type in ['ground', 'grass'] and (not has_object or is_pikachu):\n                grid[y][x] = 1\n            else:\n                grid[y][x] = 0\n    return grid, width, height\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(grid, start, end):\n    start_x, start_y = start\n    end_x, end_y = end\n\n    if not (1 <= start_x < len(grid[0]) and 1 <= start_y < len(grid)):\n        print(f'Error: Start {start} is out of bounds.')\n        return None\n    if not (1 <= end_x < len(grid[0]) and 1 <= end_y < len(grid)):\n        print(f'Error: End {end} is out of bounds.')\n        return None\n\n    if grid[start_y][start_x] == 0:\n        print('Error: Start position is on an impassable tile.')\n        return None\n    if grid[end_y][end_x] == 0:\n        print('Error: End position is on an impassable tile.')\n        return None\n\n    neighbors = [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]\n    close_set = set()\n    came_from = {}\n    gscore = {start: 0}\n    fscore = {start: heuristic(start, end)}\n    oheap = []\n\n    heapq.heappush(oheap, (fscore[start], start))\n\n    while oheap:\n        current = heapq.heappop(oheap)[1]\n\n        if current == end:\n            path = []\n            while current in came_from:\n                prev, direction = came_from[current]\n                path.append(direction)\n                current = prev\n            return path[::-1]\n\n        close_set.add(current)\n        for i, j, direction in neighbors:\n            neighbor = current[0] + i, current[1] + j\n            if not (1 <= neighbor[1] < len(grid) and 1 <= neighbor[0] < len(grid[0])):\n                continue\n            if grid[neighbor[1]][neighbor[0]] == 0:\n                continue\n\n            tentative_g_score = gscore[current] + 1\n\n            if neighbor in close_set and tentative_g_score >= gscore.get(neighbor, float('inf')):\n                continue\n\n            if tentative_g_score < gscore.get(neighbor, float('inf')):\n                came_from[neighbor] = (current, direction)\n                gscore[neighbor] = tentative_g_score\n                fscore[neighbor] = tentative_g_score + heuristic(neighbor, end)\n                heapq.heappush(oheap, (fscore[neighbor], neighbor))\n\n    return None\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\ngrid, width, height = parse_map(map_xml_string)\npath = a_star_search(grid, (start_x, start_y), (end_x, end_y))\n\nif path:\n    print(f'Path found: {path}')\nelse:\n    print('No path found.')"
  }
}