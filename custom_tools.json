{
  "landmass_analyzer": {
    "description": "Analyzes the map to identify all disconnected, traversable landmasses. Helps diagnose navigation puzzles and prevent getting stuck in isolated areas.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ndef get_neighbors(x, y, width, height):\n    neighbors = []\n    if x > 1: neighbors.append((x - 1, y))\n    if x < width: neighbors.append((x + 1, y))\n    if y > 1: neighbors.append((x, y - 1))\n    if y < height: neighbors.append((x, y + 1))\n    return neighbors\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\n\ntile_data = {}\nfor row in root.findall('Row'):\n    y = int(row.get('id'))\n    for tile in row.findall('Tile'):\n        x = int(tile.get('id'))\n        tile_data[(x, y)] = tile\n\nplayer_pos = None\nfor (x, y), tile in tile_data.items():\n    if tile.find('Player') is not None:\n        player_pos = (x, y)\n        break\n\ntraversable_types = {'ground', 'grass', 'elevated_ground', 'steps', 'cleared_boulder_barrier', 'boulder_switch', 'ladder_up', 'ladder_down'}\ntraversable_nodes = set()\nfor (x, y), tile in tile_data.items():\n    if tile.get('type') in traversable_types and tile.find('Object[@id!=\\\"15\\\"]') is None and tile.find('Boulder') is None:\n        traversable_nodes.add((x, y))\n\nlandmasses = []\nvisited = set()\n\nfor node in traversable_nodes:\n    if node not in visited:\n        current_landmass = set()\n        q = [node]\n        visited.add(node)\n        while q:\n            curr_x, curr_y = q.pop(0)\n            current_landmass.add((curr_x, curr_y))\n            for nx, ny in get_neighbors(curr_x, curr_y, width, height):\n                if (nx, ny) in traversable_nodes and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    q.append((nx, ny))\n        landmasses.append(sorted(list(current_landmass)))\n\nplayer_landmass_id = -1\nif player_pos:\n    for i, mass in enumerate(landmasses):\n        if player_pos in mass:\n            player_landmass_id = i\n            break\n\nresult = {\n    'player_landmass_id': player_landmass_id,\n    'total_landmasses': len(landmasses),\n    'landmasses': landmasses\n}\n\nprint(json.dumps(result))",
    "history": [
      {
        "commit_message": "feat: Create landmass_analyzer tool. This tool identifies disconnected traversable areas on a map, which will prevent getting stuck in navigational loops like the one experienced on Victory Road 2F. This directly addresses an Overwatch critique and improves long-term strategic navigation.",
        "timestamp": "2025-08-06T05:09:44.480Z",
        "action_counter": 123572
      }
    ]
  },
  "puzzle_input_generator": {
    "description": "Parses the current map's XML to generate the correct JSON input for the puzzle_strategist_agent, targeting a specific switch.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntarget_x = int(input_data['target_x'])\ntarget_y = int(input_data['target_y'])\n\nroot = ET.fromstring(map_xml_string)\n\nplayer_pos = None\nboulders = []\nswitches = []\nbarriers = []\nimpassable_tiles = []\n\nfor row in root.findall('Row'):\n    y = int(row.get('id'))\n    for tile in row.findall('Tile'):\n        x = int(tile.get('id'))\n        coord = {'x': x, 'y': y}\n\n        if tile.find('Player') is not None:\n            player_pos = coord\n        if tile.find('Boulder') is not None:\n            boulders.append(coord)\n        if tile.get('type') == 'boulder_switch':\n            switches.append(coord)\n        if tile.get('type') == 'boulder_barrier':\n            barriers.append(coord)\n        if tile.get('type') == 'impassable':\n            impassable_tiles.append(coord)\n\nagent_call = {\n    'tool_name': 'puzzle_strategist_agent',\n    'tool_args': [\n        {'name': 'player_pos', 'value': json.dumps(player_pos)},\n        {'name': 'boulders', 'value': json.dumps(boulders)},\n        {'name': 'switches', 'value': json.dumps(switches)},\n        {'name': 'barriers', 'value': json.dumps(barriers)},\n        {'name': 'impassable_tiles', 'value': json.dumps(impassable_tiles)},\n        {'name': 'target_switch', 'value': json.dumps({'x': target_x, 'y': target_y})},\n        {'name': 'solved_switches', 'value': '[]'},\n        {'name': 'system_directive', 'value': json.dumps('You are on a map with a boulder puzzle. Your progress is likely blocked by a boulder barrier elsewhere. To proceed, you MUST attempt to solve the puzzle.')},\n        {'name': 'notepad_content', 'value': json.dumps(\"\")} # Placeholder, user should provide this\n    ]\n}\n\nprint(json.dumps(agent_call, indent=2))",
    "history": [
      {
        "commit_message": "feat: Create puzzle_input_generator tool. This tool automates the repetitive task of parsing the map XML to gather all necessary data (player position, boulders, switches, etc.) and formats it into the correct JSON structure required to call the `puzzle_strategist_agent`. This was identified as a key process improvement during self-reflection, as it streamlines puzzle-solving and reduces the chance of manual error.",
        "timestamp": "2025-08-06T07:21:26.855Z",
        "action_counter": 123715
      },
      {
        "commit_message": "fix: Correct a syntax error in the agent_call dictionary. The `notepad_content` value was an unterminated string, causing a Python `SyntaxError`. This has been corrected to use `json.dumps(\"\")` for a valid empty string placeholder.",
        "timestamp": "2025-08-06T07:23:13.766Z",
        "action_counter": 123717
      }
    ]
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map using the A* search algorithm. It avoids impassable tiles and objects. If the destination is impassable, it finds a path to an adjacent traversable tile.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "extra_impassable": {
          "type": "string",
          "description": "A JSON string of a list of extra impassable coordinates, e.g., '[{\"x\": 10, \"y\": 5}]'"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import heapq\nimport json\nimport xml.etree.ElementTree as ET\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\nextra_impassable_str = input_data.get('extra_impassable', '[]')\nextra_impassable = json.loads(extra_impassable_str)\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(grid, start, goal, impassable_types, extra_impassable_coords):\n    neighbors = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    close_set = set()\n    came_from = {}\n    gscore = {start: 0}\n    fscore = {start: heuristic(start, goal)}\n    oheap = []\n\n    heapq.heappush(oheap, (fscore[start], start))\n\n    while oheap:\n        current = heapq.heappop(oheap)[1]\n\n        if current == goal:\n            data = []\n            while current in came_from:\n                data.append(current)\n                current = came_from[current]\n            data.append(start)\n            return [{'x': x, 'y': y} for x, y in reversed(data)]\n\n        close_set.add(current)\n        for i, j in neighbors:\n            neighbor = current[0] + i, current[1] + j\n            \n            if neighbor not in grid:\n                continue\n\n            tentative_g_score = gscore[current] + 1\n\n            if neighbor in close_set and tentative_g_score >= gscore.get(neighbor, float('inf')):\n                continue\n\n            tile_type = grid[neighbor]['type']\n            has_object = grid[neighbor]['has_object']\n            is_impassable_object = has_object and grid[neighbor].get('object_name') not in ['Pikachu']\n\n            if tile_type in impassable_types or (neighbor[0], neighbor[1]) in extra_impassable_coords or is_impassable_object:\n                 if neighbor != goal:\n                    continue\n\n            if tentative_g_score < gscore.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                gscore[neighbor] = tentative_g_score\n                fscore[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(oheap, (fscore[neighbor], neighbor))\n\n    return None\n\nroot = ET.fromstring(map_xml_string)\ngrid = {}\n\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.get('id'))\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.get('id'))\n        tile_type = tile_elem.get('type')\n        obj_node = tile_elem.find('Object')\n        has_object = obj_node is not None\n        object_name = obj_node.get('id-name') if has_object else None\n\n        grid[(x, y)] = {'type': tile_type, 'has_object': has_object, 'object_name': object_name}\n\nstart_node = (start_x, start_y)\ngoal_node = (end_x, end_y)\n\nimpassable_types = ['impassable', 'boulder_barrier']\ntraversable_types = ['ground', 'elevated_ground', 'steps', 'grass', 'cleared_boulder_barrier', 'boulder_switch', 'ladder_up', 'ladder_down']\n\nextra_impassable_coords = {(d['x'], d['y']) for d in extra_impassable}\n\ngoal_is_impassable = False\nif goal_node in grid:\n    tile_type = grid[goal_node]['type']\n    has_object = grid[goal_node]['has_object']\n    is_impassable_object = has_object and grid[goal_node].get('object_name') not in ['Pikachu']\n\n    if tile_type in impassable_types or (goal_node[0], goal_node[1]) in extra_impassable_coords or is_impassable_object:\n        goal_is_impassable = True\n\nif goal_is_impassable:\n    possible_goals = []\n    for i, j in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        adj_node = (goal_node[0] + i, goal_node[1] + j)\n        if adj_node in grid:\n            adj_tile_type = grid[adj_node]['type']\n            adj_has_object = grid[adj_node]['has_object']\n            adj_is_impassable_object = adj_has_object and grid[adj_node].get('object_name') not in ['Pikachu']\n\n            if adj_tile_type in traversable_types and not adj_is_impassable_object and (adj_node[0], adj_node[1]) not in extra_impassable_coords:\n                possible_goals.append(adj_node)\n    \n    if not possible_goals:\n        print(json.dumps({\"error\": \"No reachable tile adjacent to the impassable destination.\"}))\n    else:\n        possible_goals.sort(key=lambda p: heuristic(start_node, p))\n        path = None\n        for new_goal in possible_goals:\n            path = a_star_search(grid, start_node, new_goal, impassable_types, extra_impassable_coords)\n            if path:\n                break\n        if path:\n            print(json.dumps(path))\n        else:\n            print(json.dumps({\"error\": f\"No path found to any tile adjacent to {goal_node}.\"}))\nelse:\n    path = a_star_search(grid, start_node, goal_node, impassable_types, extra_impassable_coords)\n    if path:\n        print(json.dumps(path))\n    else:\n        print(json.dumps({\"error\": f\"No path found to {goal_node}.\"}))",
    "history": [
      {
        "commit_message": "fix: Correct JSON syntax in input_schema. Removed the unsupported 'default' property from the 'extra_impassable' field to resolve the tool definition error. This will allow the pathfinder tool to be created successfully.",
        "timestamp": "2025-08-06T12:43:06.780Z",
        "action_counter": 123976
      },
      {
        "commit_message": "fix: Boulders are now correctly treated as impassable objects. The previous version of the script incorrectly allowed pathing through boulders, causing it to generate invalid routes. This has been corrected by removing 'Boulder' from the list of exceptions for impassable objects.",
        "timestamp": "2025-08-06T12:45:32.003Z",
        "action_counter": 123980
      }
    ]
  }
}