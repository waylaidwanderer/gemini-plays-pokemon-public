{
  "find_path": {
    "description": "Finds the shortest path on the current map using BFS. Avoids impassable tiles, objects, and unseen areas.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef find_path_logic(map_xml_string, start_x, start_y, end_x, end_y):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = [['' for _ in range(width + 1)] for _ in range(height + 1)]\n    \n    impassable_tiles = {'WALL', 'HEADBUTT_TREE', 'CUT_TREE', 'WATER', 'COUNTER', 'MART_SHELF', 'BUOY', 'TOWN_MAP', 'WINDOW', 'BOOKSHELF', 'TV', 'RADIO', 'VOID'}\n    \n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id'])\n            tile_type = tile_elem.attrib['type']\n            seen = tile_elem.attrib['seen']\n            \n            if seen == 'false' or tile_elem.find('Object') is not None or tile_type in impassable_tiles:\n                grid[y][x] = 'WALL'\n            else:\n                grid[y][x] = tile_type\n\n    start = (start_x, start_y)\n    end = (end_x, end_y)\n    \n    if not (1 <= start[0] <= width and 1 <= start[1] <= height and 1 <= end[0] <= width and 1 <= end[1] <= height):\n        return json.dumps({\"error\": \"Start or end coordinates are out of bounds.\"})\n\n    if grid[start[1]][start[0]] == 'WALL' or grid[end[1]][end[0]] == 'WALL':\n        return json.dumps({\"error\": \"Start or end tile is impassable.\"})\n\n    queue = deque([(start, [start])])\n    visited = {start}\n    \n    while queue:\n        (current_x, current_y), path = queue.popleft()\n        \n        if (current_x, current_y) == end:\n            return json.dumps([{'x': p[0], 'y': p[1]} for p in path])\n            \n        moves = [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]\n        \n        for dx, dy, move_dir in moves:\n            next_x, next_y = current_x + dx, current_y + dy\n            \n            if not (1 <= next_x <= width and 1 <= next_y <= height):\n                continue\n\n            if (next_x, next_y) in visited:\n                continue\n\n            next_tile_type = grid[next_y][next_x]\n            if next_tile_type == 'WALL':\n                continue\n            \n            current_tile_type = grid[current_y][current_x]\n            if dy == 1 and 'LEDGE' in current_tile_type: \n                pass\n            elif dy == -1 and 'LEDGE' in grid[next_y][next_x]:\n                continue\n\n            visited.add((next_x, next_y))\n            new_path = list(path)\n            new_path.append((next_x, next_y))\n            queue.append(((next_x, next_y), new_path))\n            \n    return json.dumps({\"error\": \"No path found.\"})\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nresult = find_path_logic(map_xml_string, start_x, start_y, end_x, end_y)\nprint(result)"
  },
  "path_master": {
    "description": "Finds the shortest path on the current map using A*. Avoids impassable static tiles, objects, and unseen areas. **Warning: Does not account for moving NPCs and may fail.**",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\ndef find_path_astar(map_xml_string, start_x, start_y, end_x, end_y):\n    root = ET.fromstring(map_xml_string)\n    impassable_types = {'WALL', 'COUNTER', 'MART_SHELF', 'BOOKSHELF', 'TV', 'RADIO', 'VOID', 'BUOY', 'TOWN_MAP', 'WINDOW', 'PC', 'TRADE_MACHINE', 'HEADBUTT_TREE', 'CUT_TREE', 'WATER'}\n    grid = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id'])\n            tile_type = tile_elem.attrib.get('type')\n            seen = tile_elem.attrib['seen']\n            has_object = tile_elem.find('Object') is not None\n            is_impassable = tile_type in impassable_types or has_object or seen == 'false'\n            grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n\n    if start_node not in grid or grid[start_node]['impassable']:\n        return f'Error: Start point ({start_x},{start_y}) is invalid or blocked.'\n    if end_node not in grid or grid[end_node]['impassable']:\n        return f'Error: End point ({end_x},{end_y}) is invalid or blocked.'\n\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    open_set = []\n    heapq.heappush(open_set, (0, start_node))\n    came_from = {}\n    g_score = {start_node: 0}\n    f_score = {start_node: heuristic(start_node, end_node)}\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == end_node:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start_node)\n            return path[::-1]\n\n        x, y = current\n        potential_moves = []\n        current_tile_type = grid.get(current, {}).get('type', '')\n        \n        # Correctly handle one-way ledges\n        if 'LEDGE' in current_tile_type:\n            if 'RIGHT' in current_tile_type: potential_moves.append((x + 1, y))\n            elif 'LEFT' in current_tile_type: potential_moves.append((x - 1, y))\n            else: potential_moves.append((x, y + 1))\n        else:\n            potential_moves = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n\n        for neighbor in potential_moves:\n            if neighbor not in grid or grid[neighbor]['impassable']:\n                continue\n\n            nx, ny = neighbor\n            target_tile_type = grid.get(neighbor, {}).get('type', '')\n            # Prevent moving UP a ledge\n            if ny < y and 'LEDGE' in target_tile_type:\n                continue\n            # Prevent moving DOWN onto a ledge from above\n            if ny > y and 'LEDGE' in current_tile_type and 'HOP' not in current_tile_type:\n                continue\n            \n            tentative_g_score = g_score[current] + 1\n            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + heuristic(neighbor, end_node)\n                if neighbor not in [i[1] for i in open_set]:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    \n    return 'Error: No path found.'\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nresult_path = find_path_astar(map_xml_string, start_x, start_y, end_x, end_y)\n\nif isinstance(result_path, list):\n    moves = []\n    for i in range(len(result_path) - 1):\n        x1, y1 = result_path[i]\n        x2, y2 = result_path[i+1]\n        if x2 > x1: moves.append('Right')\n        elif x2 < x1: moves.append('Left')\n        elif y2 > y1: moves.append('Down')\n        elif y2 < y1: moves.append('Up')\n    print(moves)\n    print('Warning: This path does not account for moving NPCs and may fail.')\nelse:\n    print(result_path)"
  },
  "unstick_me_tool": {
    "description": "Analyzes the map XML to find the nearest cluster of 'unseen' tiles when stuck. Returns coordinates for a new navigation goal. Can also check for softlock conditions (e.g., no path to any warp/exit).",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef find_unseen_logic(map_xml_string, start_x, start_y):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = [['' for _ in range(width + 1)] for _ in range(height + 1)]\n    unseen_coords = set()\n    impassable_tiles = {'WALL', 'HEADBUTT_TREE', 'CUT_TREE', 'WATER', 'COUNTER', 'MART_SHELF', 'BUOY', 'TOWN_MAP', 'WINDOW', 'BOOKSHELF', 'TV', 'RADIO', 'VOID'}\n    \n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id'])\n            tile_type = tile_elem.attrib['type']\n            seen = tile_elem.attrib['seen']\n            \n            if seen == 'false':\n                unseen_coords.add((x, y))\n                grid[y][x] = 'UNSEEN'\n            elif tile_elem.find('Object') is not None or tile_type in impassable_tiles:\n                grid[y][x] = 'WALL'\n            else:\n                grid[y][x] = tile_type\n\n    start = (start_x, start_y)\n    if not (1 <= start[0] <= width and 1 <= start[1] <= height):\n        return json.dumps({\"error\": \"Start coordinates are out of bounds.\"})\n\n    if not unseen_coords:\n        return json.dumps({\"error\": \"No unseen tiles on the map.\"})\n\n    queue = deque([start])\n    visited = {start}\n    \n    while queue:\n        (current_x, current_y) = queue.popleft()\n        \n        moves = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n        \n        for dx, dy in moves:\n            next_x, next_y = current_x + dx, current_y + dy\n            \n            if not (1 <= next_x <= width and 1 <= next_y <= height):\n                continue\n\n            if (next_x, next_y) in unseen_coords:\n                return json.dumps({\"goal_x\": current_x, \"goal_y\": current_y})\n\n            next_tile_type = grid[next_y][next_x]\n            if (next_x, next_y) not in visited and next_tile_type != 'WALL' and next_tile_type != 'UNSEEN':\n                # Add ledge check\n                current_tile_type = grid[current_y][current_x]\n                if dy == -1 and 'LEDGE' in next_tile_type: # Trying to move up a ledge\n                    continue\n\n                visited.add((next_x, next_y))\n                queue.append((next_x, next_y))\n            \n    return json.dumps({\"error\": \"No path to any unseen tile found.\"})\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\n\nresult = find_unseen_logic(map_xml_string, start_x, start_y)\nprint(result)"
  }
}