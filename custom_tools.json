{
  "explore_unseen_v1": {
    "description": "Finds the nearest reachable 'unseen' tile and returns a list of button presses to reach it. Handles ledges, objects, and impassable tiles like WATER and HEADBUTT_TREE correctly. Treats 'unseen' tiles as impassable for traversal unless they are the target.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve(input_data):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = {}\n    objects = set()\n    start_pos = None\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            grid[(x, y)] = t_type\n            if tile.find('Player') is not None:\n                start_pos = (x, y)\n            if tile.find('Object') is not None:\n                objects.add((x, y))\n\n    if not start_pos:\n        print(\"[]\")\n        return\n\n    queue = deque([(start_pos[0], start_pos[1], [])])\n    visited = {start_pos}\n    impassable = {'WALL', 'WATER', 'HEADBUTT_TREE', 'FLOOR_UP_WALL', 'CUT_TREE', 'unseen'}\n\n    while queue:\n        x, y, path = queue.popleft()\n        \n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx < width and 0 <= ny < height:\n                if (nx, ny) not in grid or grid[(nx, ny)] == 'unseen':\n                    print(json.dumps(path + [btn]))\n                    return\n\n                if (nx, ny) not in visited:\n                    tile_type = grid[(nx, ny)]\n                    if tile_type in impassable:\n                        continue\n                    if (nx, ny) in objects:\n                        continue\n                    \n                    current_type = grid[(x, y)]\n                    if current_type == 'LEDGE_HOP_DOWN' and btn != 'Down': continue\n                    if current_type == 'LEDGE_HOP_LEFT' and btn != 'Left': continue\n                    if current_type == 'LEDGE_HOP_RIGHT' and btn != 'Right': continue\n                    if current_type == 'LEDGE_HOP_UP' and btn != 'Up': continue\n                        \n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [btn]))\n    print(\"[]\")\n\nsolve(input_data)",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T21:53:44.618Z",
        "action_counter": 2565
      },
      {
        "commit_message": "Included HEADBUTT_TREE, WATER, and CUT_TREE in impassable tiles list. Added check for unseen tiles.",
        "timestamp": "2025-12-19T04:48:43.614Z",
        "action_counter": 3272
      },
      {
        "commit_message": "Added missing solve(input_data) call to execute the script.",
        "timestamp": "2025-12-19T04:49:48.769Z",
        "action_counter": 3274
      },
      {
        "commit_message": "Refined find_path_v4 and explore_unseen_v1 to treat 'unseen' tiles as impassable for traversal. This prevents the tools from planning paths through areas that haven't been visually confirmed, avoiding collisions with unseen objects or walls. Added 'unseen' to the impassable set for both tools.",
        "timestamp": "2025-12-19T04:58:58.879Z",
        "action_counter": 3290
      },
      {
        "commit_message": "Added map boundary check to prevent walking off-map. (Turn 3292)",
        "timestamp": "2025-12-19T05:01:44.664Z",
        "action_counter": 3292
      }
    ]
  },
  "press_sequence": {
    "description": "Executes a specific sequence of button presses, allowing for mixed directional and action inputs. Useful for complex menu navigation.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nprint(json.dumps(input_data['buttons']))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T06:11:16.135Z",
        "action_counter": 948
      }
    ]
  },
  "find_path_v5_unseen_traversable": {
    "description": "Finds the shortest path to a target coordinate, correctly handling all collision types and treating 'unseen' tiles as traversable. Returns a list of button strings.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "description": "If true, the buttons will be pressed automatically.",
          "type": "boolean"
        },
        "target_x": {
          "description": "The x-coordinate of the target tile.",
          "type": "integer"
        },
        "target_y": {
          "description": "The y-coordinate of the target tile.",
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ],
      "type": "object"
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        print(f\"Error parsing map_xml_string: {e}\")\n        return\n\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    player_x, player_y = -1, -1\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            if tile.find('Player') is not None:\n                player_x = int(tile.attrib['id'])\n                player_y = y\n                break\n        if player_x != -1:\n            break\n            \n    if player_x == -1:\n        print(\"Player position not found.\")\n        return\n\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n\n    # Collision types that block movement\n    impassable_types = {\"WALL\", \"WATER\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"BOOKSHELF\", \"PC\", \"TOWN_MAP\", \"WINDOW\"}\n\n    # Map layout\n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            has_object = tile.attrib.get('has-object') == 'true'\n            \n            # Treat unseen as traversable for exploration\n            is_passable = t_type not in impassable_types and not has_object or t_type == \"unseen\"\n            grid[(x, y)] = is_passable\n\n    # BFS for shortest path\n    queue = deque([(player_x, player_y, [])])\n    visited = {(player_x, player_y)}\n    \n    while queue:\n        x, y, path = queue.popleft()\n        \n        if x == target_x and y == target_y:\n            print(json.dumps(path))\n            return\n            \n        for dx, dy, btn in [(0, -1, \"Up\"), (0, 1, \"Down\"), (-1, 0, \"Left\"), (1, 0, \"Right\")]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:\n                if grid.get((nx, ny), False) or (nx == target_x and ny == target_y):\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [btn]))\n\n    print(\"No path found.\")\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-19T06:27:37.692Z",
        "action_counter": 3482
      },
      {
        "commit_message": "Fix player position detection by avoiding parent navigation in XML.",
        "timestamp": "2025-12-19T06:28:11.213Z",
        "action_counter": 3484
      }
    ]
  },
  "use_tm_v2_refined": {
    "description": "Uses a TM or HM from the PACK on a Pokémon. Assumes overworld and that the Pokémon has fewer than 4 moves. Parameters: tm_index (0-indexed position in the TM/HM pocket), pokemon_index (1-indexed position in the party), current_menu_index (0-indexed position of the menu cursor, POKEDEX=0, EXIT=7).",
    "input_schema": {
      "type": "object",
      "properties": {
        "tm_index": {
          "type": "integer",
          "description": "0-indexed position of the TM/HM in the pocket"
        },
        "pokemon_index": {
          "type": "integer",
          "description": "1-indexed position of the Pokémon in the party"
        },
        "current_menu_index": {
          "type": "integer",
          "description": "0-indexed position of the current menu cursor (POKEDEX=0, EXIT=7)"
        }
      },
      "required": [
        "tm_index",
        "pokemon_index",
        "current_menu_index"
      ]
    },
    "python_script": "\nimport json\n\ndef main():\n    tm_index = int(input_data['tm_index'])\n    pokemon_index = int(input_data['pokemon_index'])\n    current_menu_index = int(input_data['current_menu_index'])\n    \n    buttons = [\"Start\", \"sleep 500\"]\n    \n    # Navigate to Pack (index 2)\n    # Menu: 0:Pokedex, 1:Pokemon, 2:Pack, 3:Pokegear, 4:Player, 5:Save, 6:Option, 7:Exit\n    diff = 2 - current_menu_index\n    if diff > 0:\n        for _ in range(diff):\n            buttons.append(\"Down\")\n    elif diff < 0:\n        for _ in range(abs(diff)):\n            buttons.append(\"Up\")\n            \n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # Change pocket to TM/HM (Left from Items).\n    buttons.append(\"Left\")\n    buttons.append(\"sleep 500\")\n    \n    # Navigate to TM\n    for _ in range(tm_index):\n        buttons.append(\"Down\")\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # Select USE (top option)\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # Select Pokemon\n    for _ in range(pokemon_index - 1):\n        buttons.append(\"Down\")\n    buttons.append(\"A\")\n    buttons.append(\"sleep 1000\")\n    \n    # Clear dialogue (assuming <4 moves)\n    for _ in range(5):\n        buttons.append(\"A\")\n        buttons.append(\"sleep 500\")\n    \n    print(json.dumps(buttons))\n\nif __name__ == \"__main__\":\n    main()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-19T10:55:52.584Z",
        "action_counter": 3933
      }
    ]
  },
  "give_item_v1_refined": {
    "description": "Gives an item from the PACK to a Pokémon. Assumes overworld. Parameters: item_index (0-indexed position in the current pocket), pokemon_index (1-indexed position in the party), current_menu_index (0-indexed position of the menu cursor, POKEDEX=0, EXIT=7).",
    "input_schema": {
      "type": "object",
      "properties": {
        "item_index": {
          "type": "integer",
          "description": "0-indexed position of the item in the current pocket"
        },
        "pokemon_index": {
          "type": "integer",
          "description": "1-indexed position of the Pokémon in the party"
        },
        "current_menu_index": {
          "type": "integer",
          "description": "0-indexed position of the current menu cursor (POKEDEX=0, EXIT=7)"
        }
      },
      "required": [
        "item_index",
        "pokemon_index",
        "current_menu_index"
      ]
    },
    "python_script": "\nimport json\n\ndef main():\n    item_index = int(input_data['item_index'])\n    pokemon_index = int(input_data['pokemon_index'])\n    current_menu_index = int(input_data['current_menu_index'])\n    \n    buttons = [\"Start\", \"sleep 500\"]\n    \n    # Navigate to Pack (index 2)\n    diff = 2 - current_menu_index\n    if diff > 0:\n        for _ in range(diff):\n            buttons.append(\"Down\")\n    elif diff < 0:\n        for _ in range(abs(diff)):\n            buttons.append(\"Up\")\n            \n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # Navigate to Item\n    for _ in range(item_index):\n        buttons.append(\"Down\")\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # Select GIVE (2nd option)\n    buttons.append(\"Down\")\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # Select Pokemon\n    for _ in range(pokemon_index - 1):\n        buttons.append(\"Down\")\n    buttons.append(\"A\")\n    buttons.append(\"sleep 1000\")\n    \n    # Clear text\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    buttons.append(\"A\")\n    \n    print(json.dumps(buttons))\n\nif __name__ == \"__main__\":\n    main()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-19T10:55:52.584Z",
        "action_counter": 3933
      }
    ]
  }
}