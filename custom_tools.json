{
  "find_path_to_target": {
    "description": "Calculates the shortest path from a start to an end coordinate on the current map using the A* algorithm. It considers tile traversability and objects as obstacles. If the target tile is impassable, it finds a path to an adjacent traversable tile. Returns a JSON string of the coordinate path or an empty list if no path is found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef find_path(start_x, start_y, end_x, end_y, map_xml_string):\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.attrib['width'])\n    map_height = int(root.attrib['height'])\n\n    traversable_tiles = {'FLOOR', 'WARP_CARPET_DOWN', 'DOOR', 'STAIRCASE', 'TALL_GRASS'}\n    ledge_tiles = {'LEDGE_HOP_DOWN', 'LEDGE_HOP_RIGHT'}\n    \n    grid = [[{'type': 'unseen', 'traversable': 0} for _ in range(map_width)] for _ in range(map_height)]\n    \n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id'])\n            tile_type = tile_elem.attrib.get('type', 'unseen')\n            grid[y][x]['type'] = tile_type\n            \n            if tile_type in traversable_tiles or tile_type in ledge_tiles:\n                grid[y][x]['traversable'] = 1\n            \n            if tile_elem.find('Object') is not None:\n                grid[y][x]['traversable'] = 0\n\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n\n    if grid[start_y][start_x]['traversable'] == 0:\n        return []\n\n    if grid[end_y][end_x]['traversable'] == 0:\n        found_new_target = False\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor_x, neighbor_y = end_x + dx, end_y + dy\n            if 0 <= neighbor_x < map_width and 0 <= neighbor_y < map_height and grid[neighbor_y][neighbor_x]['traversable'] == 1:\n                end_node = (neighbor_x, neighbor_y)\n                found_new_target = True\n                break\n        if not found_new_target:\n            return []\n\n    open_set = []\n    heapq.heappush(open_set, (0, start_node))\n    came_from = {}\n    g_score = { (c_x, c_y): float('inf') for c_x in range(map_width) for c_y in range(map_height) }\n    g_score[start_node] = 0\n    f_score = { (c_x, c_y): float('inf') for c_x in range(map_width) for c_y in range(map_height) }\n    f_score[start_node] = abs(start_node[0] - end_node[0]) + abs(start_node[1] - end_node[1])\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == end_node:\n            path = []\n            while current in came_from:\n                path.append({'x': current[0], 'y': current[1]})\n                current = came_from[current]\n            path.append({'x': start_node[0], 'y': start_node[1]})\n            return path[::-1]\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            nx, ny = neighbor\n\n            if not (0 <= nx < map_width and 0 <= ny < map_height) or grid[ny][nx]['traversable'] == 0:\n                continue\n\n            # Ledge logic\n            neighbor_type = grid[ny][nx]['type']\n            if neighbor_type == 'LEDGE_HOP_RIGHT' and dx != 1:\n                continue # Can only move right onto this tile\n            if neighbor_type == 'LEDGE_HOP_DOWN' and dy != 1:\n                continue # Can only move down onto this tile\n\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = g_score[neighbor] + abs(neighbor[0] - end_node[0]) + abs(neighbor[1] - end_node[1])\n                if neighbor not in [i[1] for i in open_set]:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    return []\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\npath = find_path(start_x, start_y, end_x, end_y, map_xml_string)\nprint(json.dumps(path))",
    "history": [
      {
        "commit_message": "feat: Create A* pathfinding tool. This tool, `find_path_to_target`, provides essential navigation capabilities, allowing for automated and optimal path calculation. It parses the map XML, identifies walkable tiles, and avoids obstacles like walls and NPCs. This is a foundational tool to improve exploration efficiency and solve reachability problems.",
        "timestamp": "2025-10-27T01:14:44.384Z",
        "action_counter": 156
      },
      {
        "commit_message": "fix: Add debug prints to diagnose pathing failures. The tool is incorrectly reporting no path in some situations. These prints will help visualize the grid and the A* algorithm's state to identify the bug.",
        "timestamp": "2025-10-27T01:32:49.803Z",
        "action_counter": 198
      },
      {
        "commit_message": "fix: Correct boundary checks and grid initialization for 0-indexed coordinates. The previous implementation used 1-based logic (`0 < nx`), preventing pathing into the 0th row or column. The grid was also incorrectly sized. This change aligns the tool with the game's 0-indexed coordinate system, enabling correct pathfinding across the entire map.",
        "timestamp": "2025-10-27T01:33:43.716Z",
        "action_counter": 200
      },
      {
        "commit_message": "feat: Add adjacent tile pathing for impassable targets. The A* algorithm will now check if the destination tile is blocked (e.g., by an object or wall). If it is, the tool will automatically search for a valid, traversable adjacent tile to use as the new destination. This prevents pathing failures when trying to approach NPCs or objects and makes the tool more robust and user-friendly.",
        "timestamp": "2025-10-27T04:36:36.648Z",
        "action_counter": 572
      },
      {
        "commit_message": "feat: Add TALL_GRASS and ledge tiles to traversable set. The pathfinder was unable to navigate through tall grass or over ledges, blocking progress on Route 29. This update adds 'TALL_GRASS', 'LEDGE_HOP_DOWN', and 'LEDGE_HOP_RIGHT' to the list of walkable tiles, enabling the tool to find paths through these areas.",
        "timestamp": "2025-10-27T05:18:36.345Z",
        "action_counter": 653
      },
      {
        "commit_message": "fix: Implement directional traversal for ledge tiles. The pathfinder was treating ledges as regular walkable tiles, causing it to generate invalid paths. This update adds logic to ensure that ledge tiles can only be traversed in the correct direction (e.g., right for 'LEDGE_HOP_RIGHT'), fixing pathing failures on routes like Route 29.",
        "timestamp": "2025-10-27T05:20:02.532Z",
        "action_counter": 656
      }
    ]
  },
  "generate_nickname_inputs": {
    "description": "Calculates the optimal sequence of button presses to enter a given nickname on the Pokémon naming screen. It handles both uppercase and lowercase letters and minimizes cursor movement.",
    "input_schema": {
      "type": "object",
      "properties": {
        "nickname": {
          "type": "string",
          "description": "The desired nickname, up to 10 characters."
        }
      },
      "required": [
        "nickname"
      ]
    },
    "python_script": "import json\n\ninput_nickname = input_data['nickname']\n\nkeyboards = {\n    'UPPER': [\n        ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'],\n        ['J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R'],\n        ['S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '-'],\n        ['?', '!', '/', '.', ',', 'lower', 'DEL', 'END']\n    ],\n    'lower': [\n        ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'],\n        ['j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r'],\n        ['s', 't', 'u', 'v', 'w', 'x', 'y', 'z', ' '],\n        ['(', ')', ':', ';', '[', ']', 'UPPER', 'DEL', 'END']\n    ]\n}\n\ndef find_char_pos(char, keyboard_layout):\n    for r, row in enumerate(keyboard_layout):\n        if char in row:\n            return (r, row.index(char))\n    return None\n\npresses = []\ncurrent_pos = (0, 0) # Start on 'A'\ncurrent_keyboard = 'UPPER'\n\nfor i, char in enumerate(input_nickname):\n    target_keyboard = 'UPPER' if 'A' <= char <= 'Z' or i == 0 else 'lower'\n    if char.islower():\n        target_keyboard = 'lower'\n\n    if current_keyboard != target_keyboard:\n        switch_key = 'lower' if target_keyboard == 'lower' else 'UPPER'\n        target_pos = find_char_pos(switch_key, keyboards[current_keyboard])\n        dr, dc = target_pos[0] - current_pos[0], target_pos[1] - current_pos[1]\n        presses.extend(['Down'] * dr if dr > 0 else ['Up'] * abs(dr))\n        presses.extend(['Right'] * dc if dc > 0 else ['Left'] * abs(dc))\n        presses.append('A')\n        current_keyboard = target_keyboard\n        current_pos = find_char_pos('a' if current_keyboard == 'lower' else 'A', keyboards[current_keyboard])\n\n    target_pos = find_char_pos(char, keyboards[current_keyboard])\n    dr, dc = target_pos[0] - current_pos[0], target_pos[1] - current_pos[1]\n    presses.extend(['Down'] * dr if dr > 0 else ['Up'] * abs(dr))\n    presses.extend(['Right'] * dc if dc > 0 else ['Left'] * abs(dc))\n    presses.append('A')\n    current_pos = target_pos\n\nend_pos = find_char_pos('END', keyboards[current_keyboard])\ndr, dc = end_pos[0] - current_pos[0], end_pos[1] - current_pos[1]\npresses.extend(['Down'] * dr if dr > 0 else ['Up'] * abs(dr))\npresses.extend(['Right'] * dc if dc > 0 else ['Left'] * abs(dc))\npresses.append('A')\n\nprint(json.dumps(presses))",
    "history": [
      {
        "commit_message": "feat: Create nicknaming automation tool. This tool, `generate_nickname_inputs`, automates the tedious and error-prone process of entering a Pokémon's nickname. It calculates the optimal button presses to navigate the on-screen keyboard for any given name, saving significant time and preventing manual input errors. This is a major quality-of-life improvement.",
        "timestamp": "2025-10-27T05:03:16.685Z",
        "action_counter": 623
      }
    ]
  }
}