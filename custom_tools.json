{
  "explore_unseen_v1": {
    "description": "Finds the nearest reachable 'unseen' tile and returns a list of button presses to reach it. Handles ledges, objects, and impassable tiles like WATER and HEADBUTT_TREE correctly.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve(input_data):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = {}\n    objects = set()\n    start_pos = None\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            grid[(x, y)] = t_type\n            if tile.find('Player') is not None:\n                start_pos = (x, y)\n            if tile.find('Object') is not None:\n                objects.add((x, y))\n\n    if not start_pos:\n        print(\"[]\")\n        return\n\n    queue = deque([(start_pos[0], start_pos[1], [])])\n    visited = {start_pos}\n    impassable = {'WALL', 'WATER', 'HEADBUTT_TREE', 'FLOOR_UP_WALL', 'CUT_TREE'}\n\n    while queue:\n        x, y, path = queue.popleft()\n        \n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) not in grid:\n                # Target is unseen or off-map\n                print(json.dumps(path + [btn]))\n                return\n            \n            if grid[(nx, ny)] == 'unseen':\n                print(json.dumps(path + [btn]))\n                return\n\n            if (nx, ny) not in visited:\n                tile_type = grid[(nx, ny)]\n                if tile_type in impassable:\n                    continue\n                if (nx, ny) in objects:\n                    continue\n                \n                # Check ledges\n                current_type = grid[(x, y)]\n                if current_type == 'LEDGE_HOP_DOWN' and btn != 'Down':\n                    continue\n                if current_type == 'LEDGE_HOP_LEFT' and btn != 'Left':\n                    continue\n                if current_type == 'LEDGE_HOP_RIGHT' and btn != 'Right':\n                    continue\n                if current_type == 'LEDGE_HOP_UP' and btn != 'Up':\n                    continue\n                    \n                visited.add((nx, ny))\n                queue.append((nx, ny, path + [btn]))\n    print(\"[]\")\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T21:53:44.618Z",
        "action_counter": 2565
      },
      {
        "commit_message": "Included HEADBUTT_TREE, WATER, and CUT_TREE in impassable tiles list. Added check for unseen tiles.",
        "timestamp": "2025-12-19T04:48:43.614Z",
        "action_counter": 3272
      }
    ]
  },
  "find_path_v4": {
    "description": "Finds a shortest path to a target coordinate, correctly handling ledges as one-way traversal, objects as walls, and specific impassable tile types like FLOOR_UP_WALL, WATER, and HEADBUTT_TREE. Returns a list of button strings.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve(input_data):\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    \n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = {}\n    objects = set()\n    start_pos = None\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            grid[(x, y)] = t_type\n            if tile.find('Player') is not None:\n                start_pos = (x, y)\n            if tile.find('Object') is not None:\n                objects.add((x, y))\n\n    if not start_pos:\n        print(\"[]\")\n        return\n\n    queue = deque([(start_pos[0], start_pos[1], [])])\n    visited = {start_pos}\n    # Impassable tile types\n    impassable = {'WALL', 'WATER', 'HEADBUTT_TREE', 'FLOOR_UP_WALL', 'CUT_TREE'}\n\n    while queue:\n        x, y, path = queue.popleft()\n        if x == target_x and y == target_y:\n            print(json.dumps(path))\n            return\n            \n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) in grid and (nx, ny) not in visited:\n                tile_type = grid[(nx, ny)]\n                \n                # Check collision\n                if tile_type in impassable:\n                    continue\n                if (nx, ny) in objects:\n                    # Exception: target can be an object\n                    if not (nx == target_x and ny == target_y):\n                        continue\n                \n                # Check ledges\n                current_type = grid[(x, y)]\n                if current_type == 'LEDGE_HOP_DOWN' and btn != 'Down':\n                    continue\n                if current_type == 'LEDGE_HOP_LEFT' and btn != 'Left':\n                    continue\n                if current_type == 'LEDGE_HOP_RIGHT' and btn != 'Right':\n                    continue\n                if current_type == 'LEDGE_HOP_UP' and btn != 'Up':\n                    continue\n                    \n                visited.add((nx, ny))\n                queue.append((nx, ny, path + [btn]))\n    print(\"[]\")\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T16:21:03.281Z",
        "action_counter": 2012
      },
      {
        "commit_message": "Added Marker support to find_path_v4 to account for off-screen obstacles.",
        "timestamp": "2025-12-18T16:23:18.646Z",
        "action_counter": 2014
      },
      {
        "commit_message": "Refined ledge logic to correctly handle entry/exit restrictions and fixed the 5-tool limit issue by ensuring only necessary tools are kept.",
        "timestamp": "2025-12-18T16:48:29.278Z",
        "action_counter": 2057
      },
      {
        "commit_message": "Added MART_SHELF to impassable types and ensured target coordinate is treated as passable.",
        "timestamp": "2025-12-18T17:25:09.644Z",
        "action_counter": 2106
      },
      {
        "commit_message": "Removed Marker-as-wall logic to prevent pathfinding issues with non-blocking markers.",
        "timestamp": "2025-12-18T17:27:39.883Z",
        "action_counter": 2108
      },
      {
        "commit_message": "Included HEADBUTT_TREE, WATER, and CUT_TREE in impassable tiles list. Added check for target being an object.",
        "timestamp": "2025-12-19T04:48:43.612Z",
        "action_counter": 3272
      }
    ]
  },
  "press_sequence": {
    "description": "Executes a specific sequence of button presses, allowing for mixed directional and action inputs. Useful for complex menu navigation.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nprint(json.dumps(input_data['buttons']))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T06:11:16.135Z",
        "action_counter": 948
      }
    ]
  },
  "use_item_v4": {
    "description": "Uses an item from the PACK on a Pokémon. Assumes overworld. Parameters: item_index (0-indexed), pokemon_index (1-indexed), current_menu_index (0-indexed, POKEDEX=0, EXIT=7).",
    "input_schema": {
      "properties": {
        "current_menu_index": {
          "description": "0-indexed position of the current menu cursor",
          "type": "integer"
        },
        "item_index": {
          "description": "0-indexed position of the item in the current pocket",
          "type": "integer"
        },
        "pokemon_index": {
          "description": "1-indexed position of the Pokémon in the party",
          "type": "integer"
        }
      },
      "required": [
        "item_index",
        "pokemon_index",
        "current_menu_index"
      ],
      "type": "object"
    },
    "python_script": "import json\ndef get_btns(item_idx, pkmn_idx, cur_idx):\n    btns = [\"Start\", \"sleep 500\"]\n    # Target PACK is Index 2\n    diff = 2 - cur_idx\n    if diff > 0:\n        for _ in range(diff): btns.append(\"Down\")\n    elif diff < 0:\n        for _ in range(abs(diff)): btns.append(\"Up\")\n    btns.append(\"A\")\n    btns.append(\"sleep 500\")\n    # In Bag. Assumes Items pocket.\n    for _ in range(item_idx): btns.append(\"Down\")\n    btns.append(\"A\")\n    btns.extend([\"sleep 300\", \"A\", \"sleep 500\"])\n    # In Party menu. Cursor on Slot 1.\n    for _ in range(pkmn_idx - 1): btns.append(\"Down\")\n    btns.append(\"A\")\n    # Success text and close\n    btns.extend([\"sleep 1000\", \"B\", \"B\", \"B\"])\n    return btns\nprint(json.dumps(get_btns(int(input_data['item_index']), int(input_data['pokemon_index']), int(input_data['current_menu_index']))))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T20:55:45.730Z",
        "action_counter": 2433
      }
    ]
  },
  "find_silent_path_v1": {
    "description": "Finds a shortest path to a target coordinate while avoiding a list of 'noisy' tiles that would cause the runaway Farfetch'd to turn. Handles ledges and objects correctly.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "noisy_tiles": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "x": {
                "type": "integer"
              },
              "y": {
                "type": "integer"
              }
            },
            "required": [
              "x",
              "y"
            ]
          }
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "target_x",
        "target_y",
        "noisy_tiles"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    noisy = {(t['x'], t['y']) for t in input_data.get('noisy_tiles', [])}\n    \n    # Find player\n    player_tile = root.find(\".//Tile[Player]\")\n    if player_tile is None:\n        print(json.dumps([]))\n        return\n    start_x = int(player_tile.get('id'))\n    start_y = int(player_tile.get('coordinate').split(',')[1].strip(' )'))\n\n    # Map collision and objects\n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            t_type = tile.get('type')\n            has_obj = tile.get('has-object') == 'true'\n            # Treat all objects as walls (including the bird)\n            grid[(x, y)] = {'type': t_type, 'blocked': has_obj or t_type in ['WALL', 'DENSE_TREES', 'HEADBUTT_TREE', 'CUT_TREE', 'WATER', 'VOID']}\n\n    # BFS\n    queue = deque([(start_x, start_y, [])])\n    visited = {(start_x, start_y)}\n    \n    while queue:\n        curr_x, curr_y, path = queue.popleft()\n        \n        if curr_x == target_x and curr_y == target_y:\n            print(json.dumps(path))\n            return\n            \n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = curr_x + dx, curr_y + dy\n            \n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:\n                if (nx, ny) in noisy:\n                    continue # Avoid noisy tiles\n                \n                tile = grid.get((nx, ny))\n                if tile and not tile['blocked']:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [btn]))\n                elif tile and tile['type'].startswith('LEDGE_HOP'):\n                    # Simple ledge handling for now\n                    pass\n\n    print(json.dumps([]))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-19T03:26:02.320Z",
        "action_counter": 3115
      }
    ]
  }
}