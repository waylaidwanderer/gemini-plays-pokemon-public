{
  "find_next_exploration_target": {
    "description": "Analyzes unseen tiles and reachable barriers to suggest the most logical next exploration target. Prioritizes the closest unseen tile. If none exist, it finds the closest reachable barrier based on Manhattan distance from the player's current coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "unseen_tiles_json": {
          "type": "string"
        },
        "reachable_barriers_json": {
          "type": "string"
        },
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "unseen_tiles_json",
        "reachable_barriers_json",
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import json\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nunseen_tiles = json.loads(input_data['unseen_tiles_json'])\nreachable_barriers = json.loads(input_data['reachable_barriers_json'])\n\nstart_pos = (start_x, start_y)\nnext_target = None\nmin_dist = float('inf')\nreasoning = ''\n\nif unseen_tiles:\n    for tile in unseen_tiles:\n        dist = heuristic(start_pos, (tile['x'], tile['y']))\n        if dist < min_dist:\n            min_dist = dist\n            next_target = tile\n    if next_target:\n        reasoning = f'The closest unseen tile is at ({next_target[\"x\"]}, {next_target[\"y\"]}) with a distance of {min_dist}.'\n    else:\n        reasoning = 'No unseen tiles found.'\nelif reachable_barriers:\n    for barrier in reachable_barriers:\n        dist = heuristic(start_pos, (barrier['x'], barrier['y']))\n        if dist < min_dist:\n            min_dist = dist\n            next_target = barrier\n    if next_target:\n        reasoning = f'No unseen tiles. The closest reachable barrier is at ({next_target[\"x\"]}, {next_target[\"y\"]}) with a distance of {min_dist}.'\n    else:\n        reasoning = 'No reachable barriers found.'\nelse:\n    reasoning = 'No unseen tiles or reachable barriers to suggest.'\n\nif next_target:\n    print(json.dumps({'next_target_x': next_target['x'], 'next_target_y': next_target['y'], 'reasoning': reasoning}))\nelse:\n    print(json.dumps({'next_target_x': None, 'next_target_y': None, 'reasoning': reasoning}))"
  },
  "find_path": {
    "description": "Calculates the shortest path between two points on the current map using BFS. Supports 'walk' and 'surf' traversal types.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "traversal_type": {
          "type": "string",
          "enum": [
            "walk",
            "surf"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "traversal_type"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef find_path_tool():\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    grid = [['' for _ in range(width)] for _ in range(height)]\n    impassable_coords = set()\n\n    traversal_type = input_data['traversal_type']\n    if traversal_type == 'walk':\n        walkable_types = ['ground', 'grass', 'open_gate', 'cleared_boulder_barrier', 'boulder_switch', 'teleport', 'hole', 'spinner_stop', 'ladder_up', 'ladder_down', 'steps']\n    elif traversal_type == 'surf':\n        walkable_types = ['water']\n    else:\n        print(json.dumps([]))\n        return\n\n    for r_idx, row_elem in enumerate(root.findall('Row')):\n        y = int(row_elem.get('id')) - 1\n        for c_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n            x = int(tile_elem.get('id')) - 1\n            tile_type = tile_elem.get('type')\n            grid[y][x] = tile_type\n            obj = tile_elem.find('Object')\n            if obj is not None and obj.get('id-name') != 'Pikachu':\n                impassable_coords.add((x, y))\n\n    start_x = int(input_data['start_x']) - 1\n    start_y = int(input_data['start_y']) - 1\n    end_x = int(input_data['end_x']) - 1\n    end_y = int(input_data['end_y']) - 1\n\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n\n    queue = deque([(start_node, [start_node])])\n    visited = {start_node}\n\n    while queue:\n        (current_x, current_y), path = queue.popleft()\n\n        if (current_x, current_y) == end_node:\n            path_plan = [{'x': x + 1, 'y': y + 1} for x, y in path]\n            print(json.dumps(path_plan))\n            return\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = current_x + dx, current_y + dy\n            \n            if traversal_type == 'walk' and grid[current_y][current_x] == 'ledge' and dy == 1:\n                next_y = current_y + 2\n\n            if 0 <= next_x < width and 0 <= next_y < height:\n                neighbor = (next_x, next_y)\n                if neighbor not in visited:\n                    tile_type = grid[next_y][next_x]\n                    is_walkable = tile_type in walkable_types or (traversal_type == 'walk' and tile_type == 'ledge' and next_y > current_y)\n                    is_object_blocked = neighbor in impassable_coords\n                    if is_walkable and not is_object_blocked:\n                        visited.add(neighbor)\n                        new_path = path + [neighbor]\n                        queue.append((neighbor, new_path))\n\n    print(json.dumps([]))\n\nfind_path_tool()\n"
  },
  "gate_scanner": {
    "description": "Scans the current map XML for all tiles of type 'closed_gate', 'open_gate', or 'gate_offscreen' and returns their coordinates and current state.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\nroot = ET.fromstring(map_xml_string)\ngates = []\nfor row_elem in root.findall('Row'):\n    for tile_elem in row_elem.findall('Tile'):\n        tile_type = tile_elem.get('type')\n        if 'gate' in tile_type:\n            gates.append({\n                \"coordinate\": tile_elem.get('coordinate'),\n                \"state\": tile_type\n            })\nprint(json.dumps(gates))"
  },
  "marker_compliance_tool": {
    "description": "Parses map markers and checks for compliance with protocols defined in the notepad. Identifies markers with non-standard emojis or incorrect label formats.",
    "input_schema": {
      "type": "object",
      "properties": {
        "notepad_contents": {
          "type": "string"
        }
      },
      "required": [
        "notepad_contents"
      ]
    },
    "python_script": "import json\nimport re\n\ndef check_marker_compliance():\n    notepad_content = input_data['notepad_contents']\n    \n    protocol_emojis = []\n    teleporter_format_regex_str = ''\n\n    try:\n        protocol_line = \"\"\n        for line in notepad_content.splitlines():\n            if \"CRITICAL: Map Marker Protocol\" in line:\n                protocol_line = line\n                break\n        \n        if not protocol_line:\n            print(json.dumps({'error': 'Map Marker Protocol line not found in notepad.'}))\n            return\n\n        teleporter_format_regex_str = r\"ðŸšª Warp to/from \\(\\d+, \\d+\\) \\[(?:Bi-directional|One-way)\\]\"\n        teleporter_format_regex = re.compile(teleporter_format_regex_str)\n        protocol_emojis = re.findall(r\"'([^']*)'\", protocol_line)\n\n    except Exception as e:\n        print(json.dumps({'error': f'Failed to parse protocols from notepad: {e}'}))\n        return\n\n    non_compliant_markers = []\n    try:\n        tiles = map_xml_string.split('</Tile>')\n        for tile_str in tiles:\n            if '<Marker' in tile_str:\n                try:\n                    coord_match = re.search(r'coordinate=\"\\((\\d+), (\\d+)\\)\"', tile_str)\n                    if not coord_match: continue\n                    x, y = int(coord_match.group(1)), int(coord_match.group(2))\n                except (ValueError, IndexError):\n                    continue\n\n                marker_parts = tile_str.split('<Marker emoji=\"')\n                for part in marker_parts[1:]:\n                    try:\n                        emoji = part.split('\"')[0]\n                        label = part.split('>')[1].split('</Marker>')[0]\n                        \n                        is_compliant = False\n                        if emoji in protocol_emojis:\n                            if emoji == 'ðŸšª':\n                                if teleporter_format_regex.fullmatch(f\"{emoji} {label}\"):\n                                    is_compliant = True\n                            else:\n                                is_compliant = True\n                        \n                        if not is_compliant:\n                            non_compliant_markers.append({\n                                \"x\": x,\n                                \"y\": y,\n                                \"emoji\": emoji,\n                                \"label\": label,\n                                \"reason\": f\"Emoji '{emoji}' not in protocol or label format for 'ðŸšª' is incorrect.\"\n                            })\n                    except IndexError:\n                        continue\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': f'Error during XML parsing: {str(e)}', 'traceback': traceback.format_exc()}))\n        return\n        \n    print(json.dumps(non_compliant_markers))\n\ncheck_marker_compliance()"
  },
  "systematic_searcher": {
    "description": "Calculates the next reachable, untested tile to check in a systematic sweep. It parses the map XML to find all walkable tiles and uses BFS to find the nearest target.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "tested_coords_json": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "tested_coords_json"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef parse_map(xml_str):\n    walkable = set()\n    impassable = set()\n    root = ET.fromstring(xml_str)\n    for row in root.findall('Row'):\n        for tile in row.findall('Tile'):\n            coord_str = tile.get('coordinate')\n            x_str, y_str = coord_str.strip('()').split(',')\n            x, y = int(x_str), int(y_str)\n            tile_type = tile.get('type')\n            has_obj = tile.find('Object') is not None and tile.find('Object').get('id-name') != 'Pikachu'\n            if tile_type in ['impassable', 'unknown', 'closed_gate'] or has_obj:\n                impassable.add((x, y))\n            else:\n                walkable.add((x, y))\n    return walkable, impassable\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\ntested_coords = set(tuple(c) for c in json.loads(input_data['tested_coords_json']))\n\nwalkable, impassable = parse_map(map_xml_string)\n\nqueue = deque([((start_x, start_y), [])])\nvisited = set([(start_x, start_y)])\n\nwhile queue:\n    (x, y), path = queue.popleft()\n\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n        adj_x, adj_y = x + dx, y + dy\n        if (adj_x, adj_y) in impassable and (adj_x, adj_y) not in tested_coords:\n            print(json.dumps({'target_x': x, 'target_y': y, 'wall_x': adj_x, 'wall_y': adj_y}))\n            exit()\n\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n        next_x, next_y = x + dx, y + dy\n        if (next_x, next_y) in walkable and (next_x, next_y) not in visited:\n            visited.add((next_x, next_y))\n            new_path = list(path)\n            new_path.append((next_x, next_y))\n            queue.append(((next_x, next_y), new_path))\n\nprint(json.dumps({'error': 'No new adjacent walls to test.'}))"
  }
}