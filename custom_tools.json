{
  "find_path_v2": {
    "description": "Finds the shortest path between two coordinates on the current map using BFS, considering walls, objects, and hazardous tiles (pits/ladders) as obstacles. Returns a JSON array of buttons.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "description": "If true and the tool returns a list of buttons, they will be pressed automatically.",
          "type": "boolean"
        },
        "avoid_warps": {
          "default": true,
          "description": "If true, treats CAVE and WARP tiles as obstacles unless they are the destination.",
          "type": "boolean"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "autopress_buttons"
      ],
      "type": "object"
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef solve():\n    root = ET.fromstring(map_xml_string)\n    \n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    avoid_warps = input_data.get('avoid_warps', True)\n    \n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            grid[(x, y)] = {\n                'type': tile.attrib['type'],\n                'has_object': tile.attrib.get('has-object') == 'true'\n            }\n            \n    # 'unseen' is NOT impassable to allow exploration.\n    impassable_base = {'WALL', 'FLOOR_UP_WALL', 'WATER', 'PIT', 'VOID'}\n    if avoid_warps:\n        impassable_base.add('CAVE')\n        impassable_base.add('WARP')\n    \n    queue = deque([(start_x, start_y, [])])\n    visited = {(start_x, start_y)}\n    \n    while queue:\n        x, y, path = queue.popleft()\n        \n        if x == end_x and y == end_y:\n            print(json.dumps(path))\n            return\n\n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = x + dx, y + dy\n            \n            if (nx, ny) in grid and (nx, ny) not in visited:\n                tile_info = grid[(nx, ny)]\n                tile_type = tile_info['type']\n                has_object = tile_info['has_object']\n                \n                can_pass = True\n                if nx == end_x and ny == end_y:\n                    can_pass = True\n                elif tile_type in impassable_base or has_object:\n                    can_pass = False\n                \n                # Ledge Logic: A ledge tile can only be entered from the direction it hops from.\n                if tile_type == 'LEDGE_HOP_DOWN' and dy != 1:\n                    can_pass = False\n                if tile_type == 'LEDGE_HOP_UP' and dy != -1:\n                    can_pass = False\n                if tile_type == 'LEDGE_HOP_LEFT' and dx != -1:\n                    can_pass = False\n                if tile_type == 'LEDGE_HOP_RIGHT' and dx != 1:\n                    can_pass = False\n                \n                if can_pass:\n                    if tile_type.startswith('LEDGE_HOP_'):\n                        nnx, nny = nx + dx, ny + dy\n                        if (nnx, nny) in grid and (nnx, nny) not in visited:\n                            nn_info = grid[(nnx, nny)]\n                            nn_type = nn_info['type']\n                            nn_has_obj = nn_info['has_object']\n                            if (nn_type not in impassable_base and not nn_has_obj) or (nnx == end_x and nny == end_y):\n                                visited.add((nnx, nny))\n                                queue.append((nnx, nny, path + [btn]))\n                    else:\n                        visited.add((nx, ny))\n                        queue.append((nx, ny, path + [btn]))\n\n    print(json.dumps([]))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T20:27:16.465Z",
        "action_counter": 29425
      },
      {
        "commit_message": "Refined to correctly identify objects using 'has-object' attribute and added logic for boulder bridges in pits.",
        "timestamp": "2025-12-28T20:30:14.390Z",
        "action_counter": 29431
      },
      {
        "commit_message": "Refined to correctly handle autopress_buttons by outputting button strings and fixed pathfinding logic for boulder bridges.",
        "timestamp": "2025-12-28T20:30:50.776Z",
        "action_counter": 29432
      },
      {
        "commit_message": "Refined to handle boulder bridges in Blackthorn Gym 1F and improved object detection.",
        "timestamp": "2025-12-28T20:47:40.334Z",
        "action_counter": 29458
      },
      {
        "commit_message": "Fixing missing commit message and improving tile passability logic.",
        "timestamp": "2025-12-28T22:59:48.479Z",
        "action_counter": 29673
      },
      {
        "commit_message": "Fix find_path_v2 by providing a commit message and using input_data correctly.",
        "timestamp": "2025-12-29T03:29:03.821Z",
        "action_counter": 30041
      },
      {
        "commit_message": "Refine find_path_v2 to treat PIT and LADDER tiles as obstacles by default to prevent accidental warps, unless they are the intended destination.",
        "timestamp": "2025-12-29T04:09:14.393Z",
        "action_counter": 30092
      },
      {
        "commit_message": "Refine find_path_v2 to treat all warp tiles (PIT, LADDER) as obstacles unless they are the specific destination, and correctly identify objects using 'has-object'.",
        "timestamp": "2025-12-29T04:10:34.909Z",
        "action_counter": 30094
      },
      {
        "commit_message": "Initial definition with ledge handling.",
        "timestamp": "2026-01-06T20:56:57.721Z",
        "action_counter": 30778
      },
      {
        "commit_message": "Added commit message to update tool.",
        "timestamp": "2026-01-06T21:16:09.438Z",
        "action_counter": 30812
      },
      {
        "commit_message": "Refined ledge handling: ledges are now impassable from all directions except the jump direction. Added more impassable tile types.",
        "timestamp": "2026-01-06T21:17:48.184Z",
        "action_counter": 30816
      },
      {
        "commit_message": "Added CAVE and WARP to impassable tiles to prevent accidental map transitions.",
        "timestamp": "2026-01-06T21:27:34.747Z",
        "action_counter": 30833
      },
      {
        "commit_message": "Added avoid_warps parameter and object detection logic. Refined ledge and warp handling.",
        "timestamp": "2026-01-06T21:37:49.308Z",
        "action_counter": 30841
      },
      {
        "commit_message": "Removed 'unseen' from impassable_base to allow exploration pathing.",
        "timestamp": "2026-01-06T21:53:26.245Z",
        "action_counter": 30871
      },
      {
        "commit_message": "Removed 'unseen' from impassable tiles to allow exploration pathing. Added avoid_warps parameter. Refined ledge and object handling.",
        "timestamp": "2026-01-06T21:58:47.153Z",
        "action_counter": 30880
      }
    ]
  },
  "press_menu_buttons": {
    "description": "Presses a sequence of buttons to navigate menus, bypassing the directional/action mixing restriction. Use for menu navigation ONLY. Returns the sequence of buttons as a JSON array.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nprint(json.dumps(input_data['buttons']))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-29T01:56:30.654Z",
        "action_counter": 29934
      }
    ]
  },
  "use_item_from_bag_v2": {
    "description": "Calculates the button sequence to use an item from a specific bag pocket on a Pokémon. Includes menu navigation to the Pack. Pockets: Items, Balls, Key Items, TM/HM.",
    "input_schema": {
      "properties": {
        "inventory": {
          "description": "The current items list from Game State for the target pocket.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "pokemon_index": {
          "description": "The 1-indexed position of the Pokémon in the party.",
          "type": "integer"
        },
        "target_item": {
          "description": "The name of the item to use (e.g., 'HYPER POTION').",
          "type": "string"
        },
        "target_pocket": {
          "description": "The pocket where the item is located.",
          "enum": [
            "Items",
            "Balls",
            "Key Items",
            "TM/HM"
          ],
          "type": "string"
        }
      },
      "required": [
        "inventory",
        "target_item",
        "pokemon_index",
        "target_pocket"
      ],
      "type": "object"
    },
    "python_script": "import json\n\ndef solve():\n    inventory = input_data['inventory']\n    target_item = input_data['target_item']\n    pokemon_index = int(input_data['pokemon_index'])\n    target_pocket = input_data['target_pocket']\n    \n    buttons = [\"Start\"]\n    # Navigate to Pack from Start Menu\n    # 1. Pokedex, 2. Pokemon, 3. Pack\n    # Ensure cursor is at top, then go to 3rd item\n    buttons.extend([\"Up\", \"Up\", \"Up\", \"Up\", \"Up\", \"Down\", \"Down\", \"A\"])\n    \n    if target_pocket == \"Items\":\n        pass\n    elif target_pocket == \"Balls\":\n        buttons.append(\"Right\")\n    elif target_pocket == \"Key Items\":\n        buttons.extend([\"Right\", \"Right\"])\n    elif target_pocket == \"TM/HM\":\n        buttons.append(\"Left\")\n        \n    try:\n        item_index = inventory.index(target_item)\n        for _ in range(item_index):\n            buttons.append(\"Down\")\n    except ValueError:\n        print(json.dumps([]))\n        return\n\n    buttons.extend([\"A\", \"A\"])\n    \n    for _ in range(pokemon_index - 1):\n        buttons.append(\"Down\")\n    buttons.append(\"A\")\n    \n    print(json.dumps(buttons))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-06T19:29:13.516Z",
        "action_counter": 30642
      },
      {
        "commit_message": "Refined to include menu navigation from overworld and improved cursor stability.",
        "timestamp": "2026-01-06T22:14:34.854Z",
        "action_counter": 30907
      },
      {
        "commit_message": "Refined to include menu navigation from overworld and improved cursor stability.",
        "timestamp": "2026-01-06T22:16:04.023Z",
        "action_counter": 30908
      },
      {
        "commit_message": "Fixed typo in button sequence and ensured it starts from the overworld by navigating to PACK from the Start menu.",
        "timestamp": "2026-01-06T22:18:45.349Z",
        "action_counter": 30915
      }
    ]
  },
  "get_reachable_unseen_tiles": {
    "description": "Analyzes the current mental map and returns a list of unseen tiles that are adjacent to reachable walkable tiles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "player_x": {
          "type": "integer"
        },
        "player_y": {
          "type": "integer"
        }
      },
      "required": [
        "player_x",
        "player_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef find_reachable_unseen(map_xml, start_x, start_y):\n    root = ET.fromstring(map_xml)\n    grid = {}\n    unseen_tiles = []\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tile_type = tile.attrib['type']\n            seen = tile.attrib.get('seen') == 'true'\n            has_object = tile.attrib.get('has-object') == 'true'\n            \n            # Basic collision check - objects and walls are obstacles\n            is_walkable = tile_type not in ['WALL', 'FLOOR_UP_WALL'] and not has_object\n            \n            grid[(x, y)] = {\n                'walkable': is_walkable,\n                'seen': seen\n            }\n            \n            if not seen:\n                unseen_tiles.append((x, y))\n\n    # BFS to find all reachable walkable seen tiles\n    queue = deque([(start_x, start_y)])\n    visited = set([(start_x, start_y)])\n    reachable_walkable = set()\n    \n    while queue:\n        cx, cy = queue.popleft()\n        reachable_walkable.add((cx, cy))\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) in grid and (nx, ny) not in visited:\n                if grid[(nx, ny)]['walkable'] and grid[(nx, ny)]['seen']:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n\n    # Find unseen tiles adjacent to reachable walkable tiles\n    results = []\n    for ux, uy in unseen_tiles:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            if (ux + dx, uy + dy) in reachable_walkable:\n                results.append((ux, uy))\n                break\n            \n    return sorted(results)\n\nprint(find_reachable_unseen(map_xml_string, int(input_data['player_x']), int(input_data['player_y'])))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-07T04:05:36.113Z",
        "action_counter": 31572
      }
    ]
  },
  "fly_to_blackthorn": {
    "description": "Automates the sequence to use Fly from the overworld. Destination must be provided as a list of buttons to navigate the Fly map. Assumes Icarus (Pidgey) is in the 2nd party slot and Fly is the first field move.",
    "input_schema": {
      "properties": {
        "fly_map_navigation": {
          "description": "An array of directional buttons to reach the destination on the Fly map.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "fly_map_navigation"
      ],
      "type": "object"
    },
    "python_script": "import json\n\ndef main(input_data):\n    navigation = input_data.get('fly_map_navigation', [])\n    buttons = [\n        \"B\", \"B\", \"B\", \"B\", # Clear any open menus (Bag, etc.)\n        \"Start\", \"sleep 500\",\n        \"Up\", \"Up\", \"Up\", \"Up\", \"Up\", \"Up\", \"Up\", # Ensure cursor is on POKEDEX\n        \"Down\", \"A\", \"sleep 500\", # Select POKEMON\n        \"Up\", \"Up\", \"Up\", \"Up\", \"Up\", \"Up\", # Ensure cursor is on KIMCHI\n        \"Down\", \"A\", \"sleep 500\", # Select ICARUS (2nd slot)\n        \"A\", \"sleep 500\", # Select FLY (assumed first field move)\n        \"sleep 2000\"\n    ]\n    buttons.extend(navigation)\n    buttons.append(\"A\") # Confirm destination\n    print(json.dumps(buttons))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-07T05:56:00.798Z",
        "action_counter": 31766
      },
      {
        "commit_message": "Refined fly_to_blackthorn to be more robust by clearing the UI and ensuring correct menu selection.",
        "timestamp": "2026-01-07T06:00:27.598Z",
        "action_counter": 31773
      }
    ]
  }
}