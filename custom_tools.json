{
  "check_reachable_unseen": {
    "description": "Finds all unseen tiles adjacent to reachable walkable tiles. Relies on verified traversable tile types from the notepad. Useful for clearing the exploration alert. Returns a list of coordinate dictionaries, or buttons if autopress_buttons is true.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "description": "If true and the tool returns a list of buttons, they will be pressed automatically.",
          "type": "boolean"
        },
        "player_x": {
          "type": "integer"
        },
        "player_y": {
          "type": "integer"
        }
      },
      "required": [
        "player_x",
        "player_y",
        "autopress_buttons"
      ],
      "type": "object"
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport collections\n\ndef solve():\n    try:\n        # input_data is a global dictionary provided by the harness\n        auto = input_data.get('autopress_buttons', False)\n        px = int(input_data.get('player_x', 0))\n        py = int(input_data.get('player_y', 0))\n    except:\n        auto = False\n        px, py = 0, 0\n\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    # If px, py are 0, try to find player in XML\n    if px == 0 and py == 0:\n        found_player = False\n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                if tile.find('Player') is not None:\n                    px, py = int(tile.get('id')), y\n                    found_player = True\n                    break\n            if found_player: break\n\n    # Map tile types and seen status\n    tiles = {}\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tiles[(x, y)] = {\n                'type': tile.get('type'),\n                'seen': tile.get('seen') == 'true',\n                'has_obj': tile.get('has-object') == 'true'\n            }\n\n    # Define traversable tiles based on notepad verification\n    traversable = {'FLOOR', 'WARP_CARPET_DOWN', 'WARP_CARPET', 'LADDER', 'STAIRS', 'DOOR', 'FLOOR_UP_WALL', 'GRASS', 'TALL_GRASS'}\n    \n    # BFS to find reachable tiles\n    reachable = set()\n    queue = collections.deque([(px, py)])\n    reachable.add((px, py))\n    parent = {}\n\n    while queue:\n        cx, cy = queue.popleft()\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) in tiles and (nx, ny) not in reachable:\n                tile = tiles[(nx, ny)]\n                if tile['type'] in traversable and not tile['has_obj']:\n                    reachable.add((nx, ny))\n                    parent[(nx, ny)] = (cx, cy)\n                    queue.append((nx, ny))\n    \n    # Identify unseen tiles adjacent to reachable tiles\n    unseen_targets = []\n    for rx, ry in reachable:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = rx + dx, ry + dy\n            if (nx, ny) in tiles:\n                if not tiles[(nx, ny)]['seen']:\n                    unseen_targets.append((nx, ny, rx, ry))\n            elif 0 <= nx < width and 0 <= ny < height:\n                # Boundary tile not in 'tiles' dict implies unseen\n                unseen_targets.append((nx, ny, rx, ry))\n\n    if not auto:\n        # Return coordinates of unseen tiles\n        unique_unseen = []\n        seen_coords = set()\n        for ux, uy, rx, ry in unseen_targets:\n            if (ux, uy) not in seen_coords:\n                unique_unseen.append({\"x\": ux, \"y\": uy})\n                seen_coords.add((ux, uy))\n        print(json.dumps(unique_unseen))\n    else:\n        # Return buttons to reach the closest reachable tile adjacent to an unseen one\n        if not unseen_targets:\n            print(\"[]\")\n            return\n            \n        # Dijkstra-like BFS for distance\n        dist = {(px, py): 0}\n        q = collections.deque([(px, py)])\n        while q:\n            cx, cy = q.popleft()\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = cx + dx, cy + dy\n                if (nx, ny) in reachable and (nx, ny) not in dist:\n                    dist[(nx, ny)] = dist[(cx, cy)] + 1\n                    q.append((nx, ny))\n                    \n        # Find best target (closest reachable tile with unseen neighbor)\n        best_target = None\n        min_dist = float('inf')\n        for ux, uy, rx, ry in unseen_targets:\n            if (rx, ry) in dist and dist[(rx, ry)] < min_dist:\n                min_dist = dist[(rx, ry)]\n                best_target = (rx, ry)\n                \n        if best_target:\n            # Reconstruct path\n            path = []\n            curr = best_target\n            while curr != (px, py):\n                path.append(curr)\n                curr = parent[curr]\n            path.reverse()\n            \n            # Convert to buttons\n            buttons = []\n            cx, cy = px, py\n            for nx, ny in path:\n                if nx > cx: buttons.append(\"Right\")\n                elif nx < cx: buttons.append(\"Left\")\n                elif ny > cy: buttons.append(\"Down\")\n                elif ny < cy: buttons.append(\"Up\")\n                cx, cy = nx, ny\n            print(json.dumps(buttons))\n        else:\n            print(\"[]\")\n\nif __name__ == \"__main__\":\n    solve()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-21T01:42:51.206Z",
        "action_counter": 7635
      },
      {
        "commit_message": "Refined traversable tiles to match verified mechanics in notepad and added object collision check.",
        "timestamp": "2025-12-21T01:51:20.552Z",
        "action_counter": 7655
      },
      {
        "commit_message": "Added FLOOR_UP_WALL to traversable tiles and updated description to clarify output.",
        "timestamp": "2025-12-21T02:16:24.728Z",
        "action_counter": 7707
      },
      {
        "commit_message": "Added WATER to traversable tiles to support exploration while surfing.",
        "timestamp": "2025-12-21T02:28:00.542Z",
        "action_counter": 7736
      },
      {
        "commit_message": "Fixing autopress_buttons logic to return a button array instead of coordinates when enabled.",
        "timestamp": "2025-12-21T04:13:20.660Z",
        "action_counter": 7952
      }
    ]
  },
  "find_path_v4": {
    "description": "Finds the shortest path to a target coordinate. Correctly handles walls, NPCs, and items. Returns an empty list if no path is found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef solve():\n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n        \n        root = ET.fromstring(map_xml_string)\n        \n        start_x, start_y = -1, -1\n        for row in root.findall('Row'):\n            curr_y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                if tile.find('Player') is not None:\n                    start_x = int(tile.attrib['id'])\n                    start_y = curr_y\n                    break\n            if start_x != -1: break\n            \n        if start_x == -1: return []\n\n        grid = {}\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                t_type = tile.attrib['type']\n                is_wall = t_type in ['WALL', 'COUNTER', 'BOOKSHELF', 'TABLE', 'MART_SHELF']\n                obj = tile.find('Object')\n                if obj is not None:\n                    # NPCs and items are walls unless they are the target (for interaction)\n                    if not (x == start_x and y == start_y) and not (x == target_x and y == target_y):\n                        is_wall = True\n                grid[(x, y)] = not is_wall\n\n        queue = deque([(start_x, start_y, [])])\n        visited = {(start_x, start_y)}\n        while queue:\n            x, y, path = queue.popleft()\n            if x == target_x and y == target_y:\n                return path\n            for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n                nx, ny = x + dx, y + dy\n                if (nx, ny) in grid and grid[(nx, ny)] and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [btn]))\n        return []\n    except Exception:\n        return []\n\nprint(json.dumps(solve()))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-21T06:11:17.104Z",
        "action_counter": 8161
      },
      {
        "commit_message": "Fixed find_path_v4: removed non-standard getparent() call and improved player position detection. Consolidated grid construction and BFS.",
        "timestamp": "2025-12-21T06:23:10.110Z",
        "action_counter": 8180
      }
    ]
  },
  "battle_move_selector_v2": {
    "description": "Selects a move from the move selection menu in battle. Assumes the menu is open and the cursor is at the first move (index 0). Optimized for Gen 2 vertical move lists.",
    "input_schema": {
      "type": "object",
      "properties": {
        "move_index": {
          "type": "integer",
          "description": "The 0-indexed position of the move to select (0-3)."
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false,
          "description": "If true and the tool returns a list of buttons, they will be pressed automatically."
        }
      },
      "required": [
        "move_index",
        "autopress_buttons"
      ]
    },
    "python_script": "import json\n# The harness provides input arguments in the 'input_data' dictionary.\nmove_index = int(input_data.get('move_index', 0))\nbuttons = []\nfor _ in range(move_index):\n    buttons.append(\"Down\")\nbuttons.append(\"A\")\nprint(json.dumps(buttons))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-21T11:41:54.981Z",
        "action_counter": 8762
      },
      {
        "commit_message": "Corrected tool to use the 'input_data' variable for arguments instead of reading from stdin.",
        "timestamp": "2025-12-21T11:46:11.447Z",
        "action_counter": 8774
      }
    ]
  },
  "get_map_warps_v1": {
    "description": "Extracts warp information (coordinates and entry points) for a list of map IDs from the mental map XML.",
    "input_schema": {
      "type": "object",
      "properties": {
        "map_ids": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "map_ids"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ndef run(input_data):\n    try:\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        print(f\"Error parsing XML: {e}\")\n        return\n\n    results = {}\n    for mid in input_data.get('map_ids', []):\n        map_node = root.find(f\".//Map[@id='{mid}']\")\n        if map_node is not None:\n            name = map_node.get('name')\n            warps = []\n            for row in map_node.findall('Row'):\n                y = row.get('id')\n                for tile in row.findall('Tile'):\n                    x = tile.get('id')\n                    warp = tile.find('Warp')\n                    if warp is not None:\n                        warps.append({\n                            'x': int(x),\n                            'y': int(y),\n                            'entry': int(warp.get('entry_point'))\n                        })\n            results[mid] = {'name': name, 'warps': warps}\n    print(json.dumps(results, indent=2))\n\nrun(input_data)",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-21T12:56:21.285Z",
        "action_counter": 8882
      }
    ]
  }
}