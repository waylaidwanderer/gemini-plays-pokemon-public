{
  "assess_reachability": {
    "description": "Performs a flood-fill BFS starting from a given coordinate to determine all reachable tiles of a specific type (e.g., WATER). Returns the bounds of the reachable area, accessible warps, and adjacent unseen tiles. Useful for determining if a path exists through a maze.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "tile_type": {
          "type": "string",
          "default": "WATER"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef assess_reachability(map_xml_string, start_x, start_y, tile_type=\"WATER\"):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = {}\n    warps = {}\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib.get('type', 'unseen')\n            is_warp = tile.attrib.get('is-warp') == 'true'\n            \n            grid[(x, y)] = t_type\n            if is_warp:\n                # Check for warp details in children\n                warp_node = tile.find('Warp')\n                entry_point = warp_node.attrib.get('entry_point') if warp_node is not None else \"?\"\n                warps[(x, y)] = entry_point\n\n    if grid.get((start_x, start_y)) != tile_type and grid.get((start_x, start_y)) != \"WHIRLPOOL\":\n        print(f\"Error: Start position ({start_x}, {start_y}) is {grid.get((start_x, start_y))}, not {tile_type}.\")\n        return\n\n    queue = deque([(start_x, start_y)])\n    visited = set([(start_x, start_y)])\n    reachable_warps = []\n    reachable_unseen_adjacents = []\n    min_x, max_x, min_y, max_y = start_x, start_x, start_y, start_y\n    \n    # Allow WHIRLPOOL as traversable for surfing if tile_type is WATER\n    traversable_types = {tile_type}\n    if tile_type == \"WATER\":\n        traversable_types.add(\"WHIRLPOOL\")\n\n    while queue:\n        cx, cy = queue.popleft()\n        \n        min_x = min(min_x, cx)\n        max_x = max(max_x, cx)\n        min_y = min(min_y, cy)\n        max_y = max(max_y, cy)\n        \n        if (cx, cy) in warps:\n            reachable_warps.append({'x': cx, 'y': cy, 'entry': warps[(cx, cy)]})\n            \n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < width and 0 <= ny < height:\n                if (nx, ny) in visited:\n                    continue\n                \n                n_type = grid.get((nx, ny), 'unseen')\n                \n                if n_type in traversable_types:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n                elif n_type == 'unseen':\n                    reachable_unseen_adjacents.append({'x': nx, 'y': ny})\n                    # Don't traverse into unseen, just mark it as a frontier\n    \n    print(f\"Reachability Analysis from ({start_x}, {start_y}) for {tile_type}:\")\n    print(f\"  Bounds: X[{min_x}-{max_x}], Y[{min_y}-{max_y}]\")\n    print(f\"  Reachable Tiles Count: {len(visited)}\")\n    print(f\"  Reachable Warps: {reachable_warps}\")\n    print(f\"  Adjacent Unseen Tiles: {len(reachable_unseen_adjacents)} (First 5: {reachable_unseen_adjacents[:5]})\")\n\nassess_reachability(map_xml_string, input_data['start_x'], input_data['start_y'], input_data.get('tile_type', 'WATER'))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-08T11:22:54.983Z",
        "action_counter": 27988
      }
    ]
  },
  "sequence_press": {
    "description": "Executes a sequence of button presses to navigate menus or perform actions. Allows mixing directional and action buttons.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T08:10:06.907Z",
        "action_counter": 33328
      },
      {
        "commit_message": "Initial definition of sequence_press tool",
        "timestamp": "2026-01-11T10:39:20.952Z",
        "action_counter": 33514
      }
    ]
  },
  "pathfind": {
    "description": "Finds a path from the player's current position to a target coordinate using BFS. Returns a list of coordinates. Requires `map_xml_string` to be available in the environment.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef pathfind(target_x, target_y):\n    # map_xml_string is injected by the system\n    root = ET.fromstring(map_xml_string)\n    \n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    # 1 = blocked, 0 = walkable\n    grid = [[1 for _ in range(height)] for _ in range(width)] \n    start_pos = None\n    \n    # Allowed tile types\n    walkable_types = [\n        'FLOOR', 'GRASS', 'TALL_GRASS', \n        'WARP_CARPET_DOWN', 'WARP_CARPET_UP', \n        'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT'\n    ]\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            \n            # Find player\n            if tile.find('Player') is not None:\n                start_pos = (x, y)\n            \n            t_type = tile.attrib.get('type', 'WALL')\n            has_object = tile.attrib.get('has-object', 'false') == 'true'\n            \n            # Check traversability\n            # Note: We consider objects as blocking unless it's the target itself\n            if t_type in walkable_types:\n                if not has_object or (x == target_x and y == target_y):\n                    grid[x][y] = 0\n            \n            # Explicitly allow LADDER if it's the target\n            if t_type == 'LADDER' and x == target_x and y == target_y:\n                grid[x][y] = 0\n\n    if not start_pos:\n        print(f\"Error: Player not found on map.\")\n        return []\n\n    # BFS\n    queue = deque([(start_pos, [])])\n    visited = set([start_pos])\n    \n    while queue:\n        (cx, cy), path = queue.popleft()\n        \n        if (cx, cy) == (target_x, target_y):\n            # Return path including start (or not? navigate tool expects start)\n            # navigate tool expects: [current_pos, next, next...]\n            # My logic builds path of *steps*. \n            # Let's return full coordinate list including start.\n            return [{\"x\": start_pos[0], \"y\": start_pos[1]}] + path\n            \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < width and 0 <= ny < height and grid[nx][ny] == 0 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                new_path = path + [{\"x\": nx, \"y\": ny}]\n                queue.append(((nx, ny), new_path))\n                \n    print(f\"No path found from {start_pos} to ({target_x}, {target_y})\")\n    return []\n\nprint(pathfind(target_x, target_y))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T09:01:19.563Z",
        "action_counter": 33384
      }
    ]
  }
}