{
  "menu_navigator_v2_fixed": {
    "description": "Executes a sequence of button presses to navigate menus. Returns a JSON array of buttons. Use this to bypass the restriction on mixing directional and action inputs. Automatically handles autopress_buttons.",
    "input_schema": {
      "properties": {
        "sequence": {
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "sequence"
      ],
      "type": "object"
    },
    "python_script": "import json\nprint(json.dumps(input_data.get('sequence', [])))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-14T06:16:48.631Z",
        "action_counter": 47221
      }
    ]
  },
  "fly_list_navigator_v3_fixed": {
    "description": "Calculates the shortest button sequence to navigate the Fly map list. Supports 'Johto' and 'Kanto' regions. Returns a JSON array of buttons. Validates input cities against known lists. Up increases index, Down decreases. Starting position: New Bark Town (Johto) or Pallet Town (Kanto).",
    "input_schema": {
      "type": "object",
      "properties": {
        "region": {
          "type": "string",
          "enum": [
            "Johto",
            "Kanto"
          ]
        },
        "current_city": {
          "type": "string"
        },
        "target_city": {
          "type": "string"
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "region",
        "current_city",
        "target_city",
        "autopress_buttons"
      ]
    },
    "python_script": "import json\n\ndef solve():\n    region = input_data.get('region')\n    current = input_data.get('current_city')\n    target = input_data.get('target_city')\n    \n    kanto_cities = [\n        \"Pallet Town\", \"Viridian City\", \"Pewter City\", \"Cerulean City\", \n        \"Vermilion City\", \"Lavender Town\", \"Celadon City\", \"Saffron City\", \n        \"Fuchsia City\", \"Cinnabar Island\", \"Indigo Plateau\"\n    ]\n    johto_cities = [\n        \"New Bark Town\", \"Cherrygrove City\", \"Violet City\", \"Azalea Town\", \n        \"Goldenrod City\", \"Ecruteak City\", \"Olivine City\", \"Cianwood City\", \n        \"Mahogany Town\", \"Lake of Rage\", \"Blackthorn City\", \"Silver Cave\", \"Indigo Plateau\"\n    ]\n    \n    cities = kanto_cities if region == \"Kanto\" else johto_cities\n    \n    if current not in cities or target not in cities:\n        print(json.dumps([]))\n        return\n\n    start_idx = cities.index(current)\n    end_idx = cities.index(target)\n    n = len(cities)\n    \n    # Observed behavior (Crystal): \n    # Up increases index (+1)\n    # Down decreases index (-1)\n    diff = (end_idx - start_idx) % n\n    if diff <= n // 2:\n        buttons = [\"Up\"] * diff\n    else:\n        buttons = [\"Down\"] * (n - diff)\n        \n    print(json.dumps(buttons))\n\nsolve()\n",
    "history": [
      {
        "commit_message": "Swapped Up and Down buttons to match observed Fly menu behavior (Up moves forward, Down moves backward).",
        "timestamp": "2026-01-14T06:20:55.460Z",
        "action_counter": 47231
      },
      {
        "commit_message": "Update fly_list_navigator_v3_fixed with correct button mappings for Johto (Up increases index, Down decreases).",
        "timestamp": "2026-01-14T07:47:22.439Z",
        "action_counter": 47376
      }
    ]
  },
  "find_path_crystal": {
    "description": "Calculates a path between two coordinates on the current map, accounting for Pokemon Crystal collision types like one-way walls (FLOOR_UP_WALL) and ledges (LEDGE_HOP_DOWN). Returns a JSON array of coordinates. Supports 'allow_water' for surfing.",
    "input_schema": {
      "type": "object",
      "properties": {
        "allow_water": {
          "default": false,
          "type": "boolean"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\nimport sys\n\ndef solve():\n    try:\n        if len(sys.argv) < 2:\n            print(json.dumps({\"error\": \"No arguments provided\"}))\n            return\n        input_data = json.loads(sys.argv[1])\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n        allow_water = input_data.get('allow_water', False)\n        \n        root = ET.fromstring(map_xml_string)\n        grid = {}\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                t_type = tile.attrib['type']\n                has_obj = tile.attrib.get('has-object') == 'true'\n                if t_type in ['WALL', 'BUOY', 'HEADBUTT_TREE', 'CUT_TREE', 'FRUIT_TREE', 'COUNTER'] or has_obj:\n                    grid[(x, y)] = False\n                elif t_type == 'WATER':\n                    grid[(x, y)] = 'WATER'\n                elif t_type == 'FLOOR_UP_WALL':\n                    grid[(x, y)] = 'UP_WALL'\n                elif t_type == 'LEDGE_HOP_DOWN':\n                    grid[(x, y)] = 'LEDGE'\n                else:\n                    grid[(x, y)] = True\n        \n        start_pos = (start_x, start_y)\n        target_pos = (target_x, target_y)\n        queue = deque([(start_pos, [])])\n        visited = {start_pos}\n        while queue: \n            (curr_x, curr_y), path = queue.popleft()\n            if (curr_x, curr_y) == target_pos:\n                full_path = path + [(curr_x, curr_y)]\n                print(json.dumps(full_path))\n                return\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = curr_x + dx, curr_y + dy\n                if (nx, ny) in grid:\n                    val = grid[(nx, ny)]\n                    if val is False: continue\n                    if not allow_water and val == 'WATER': continue\n                    if dy == 1 and val == 'UP_WALL': continue\n                    if dy == -1 and grid[(curr_x, curr_y)] == 'UP_WALL': continue\n                    if dy == -1 and val == 'LEDGE': continue\n                    if (nx, ny) not in visited:\n                        visited.add((nx, ny))\n                        queue.append(((nx, ny), path + [(curr_x, curr_y)]))\n        print('[]')\n    except Exception as e:\n        import traceback\n        print(json.dumps({\"error\": str(e), \"traceback\": traceback.format_exc()}))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-14T08:58:48.612Z",
        "action_counter": 47481
      },
      {
        "commit_message": "Added allow_water parameter and fixed water collision logic.",
        "timestamp": "2026-01-14T09:02:38.713Z",
        "action_counter": 47485
      }
    ]
  },
  "find_path_crystal_v2": {
    "description": "Calculates a path between two coordinates on the current map, accounting for Pokemon Crystal collision types like one-way walls (FLOOR_UP_WALL) and ledges (LEDGE_HOP_DOWN). Returns a JSON array of coordinates. Supports 'allow_water' for surfing.",
    "input_schema": {
      "type": "object",
      "properties": {
        "allow_water": {
          "default": false,
          "type": "boolean"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\nimport sys\n\ndef solve():\n    try:\n        if len(sys.argv) < 2:\n            print(json.dumps([]))\n            return\n            \n        input_data = json.loads(sys.argv[1])\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n        allow_water = input_data.get('allow_water', False)\n        \n        root = ET.fromstring(map_xml_string)\n        grid = {}\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                t_type = tile.attrib['type']\n                has_obj = tile.attrib.get('has-object') == 'true'\n                \n                if t_type in ['WALL', 'BUOY', 'HEADBUTT_TREE', 'CUT_TREE', 'FRUIT_TREE', 'COUNTER']:\n                    grid[(x, y)] = False\n                elif t_type == 'WATER':\n                    grid[(x, y)] = 'WATER'\n                elif t_type == 'FLOOR_UP_WALL':\n                    grid[(x, y)] = 'UP_WALL'\n                elif t_type == 'LEDGE_HOP_DOWN':\n                    grid[(x, y)] = 'LEDGE'\n                else:\n                    grid[(x, y)] = True\n                    \n                if has_obj:\n                    grid[(x, y)] = False\n\n        queue = deque([((start_x, start_y), [])])\n        visited = {(start_x, start_y)}\n        \n        while queue:\n            (cx, cy), path = queue.popleft()\n            \n            if (cx, cy) == (target_x, target_y):\n                res = path + [{\"x\": cx, \"y\": cy}]\n                print(json.dumps(res))\n                return\n                \n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = cx + dx, cy + dy\n                \n                if (nx, ny) in grid:\n                    val = grid[(nx, ny)]\n                    if val is False: continue\n                    if not allow_water and val == 'WATER': continue\n                    \n                    if dy == 1 and val == 'UP_WALL': continue\n                    if dy == -1 and grid[(cx, cy)] == 'UP_WALL': continue\n                    if dy == -1 and val == 'LEDGE': continue\n                    \n                    if (nx, ny) not in visited:\n                        visited.add((nx, ny))\n                        queue.append(((nx, ny), path + [{\"x\": cx, \"y\": cy}]))\n        \n        print(json.dumps([]))\n    except Exception as e:\n        print(json.dumps({\"error\": str(e)}))\n\nsolve()",
    "history": [
      {
        "commit_message": "Refined argument handling and coordinate output format.",
        "timestamp": "2026-01-14T09:09:05.241Z",
        "action_counter": 47492
      }
    ]
  },
  "find_path_crystal_v2_fixed": {
    "description": "Calculates a path between two coordinates on the current map, accounting for Pokemon Crystal collision types like one-way walls (FLOOR_UP_WALL) and ledges (LEDGE_HOP_DOWN). Returns a JSON array of coordinates. Supports 'allow_water' for surfing.",
    "input_schema": {
      "type": "object",
      "properties": {
        "allow_water": {
          "default": false,
          "type": "boolean"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\nimport sys\n\ndef solve():\n    try:\n        # Robustly handle input arguments\n        if len(sys.argv) < 2:\n            print(json.dumps({\"error\": \"No input provided\"}))\n            return\n            \n        try:\n            input_data = json.loads(sys.argv[1])\n        except json.JSONDecodeError:\n            print(json.dumps({\"error\": \"Invalid JSON input\"}))\n            return\n            \n        start_x = int(input_data.get('start_x', 0))\n        start_y = int(input_data.get('start_y', 0))\n        target_x = int(input_data.get('target_x', 0))\n        target_y = int(input_data.get('target_y', 0))\n        allow_water = input_data.get('allow_water', False)\n        \n        # Parse Mental Map\n        try:\n            root = ET.fromstring(map_xml_string)\n        except Exception as e:\n            print(json.dumps({\"error\": f\"Failed to parse map XML: {str(e)}\"}))\n            return\n            \n        grid = {}\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                t_type = tile.attrib['type']\n                has_obj = tile.attrib.get('has-object') == 'true'\n                \n                # Collision Logic\n                if t_type in ['WALL', 'BUOY', 'HEADBUTT_TREE', 'CUT_TREE', 'FRUIT_TREE', 'COUNTER']:\n                    grid[(x, y)] = False\n                elif t_type == 'WATER':\n                    grid[(x, y)] = 'WATER'\n                elif t_type == 'FLOOR_UP_WALL':\n                    grid[(x, y)] = 'UP_WALL'\n                elif t_type == 'LEDGE_HOP_DOWN':\n                    grid[(x, y)] = 'LEDGE'\n                else:\n                    grid[(x, y)] = True\n                    \n                if has_obj:\n                    grid[(x, y)] = False\n\n        # BFS for shortest path\n        queue = deque([((start_x, start_y), [])])\n        visited = {(start_x, start_y)}\n        \n        while queue:\n            (cx, cy), path = queue.popleft()\n            \n            if (cx, cy) == (target_x, target_y):\n                # Success! Construct the full path including the current position\n                res = path + [{\"x\": cx, \"y\": cy}]\n                print(json.dumps(res))\n                return\n                \n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = cx + dx, cy + dy\n                \n                if (nx, ny) in grid:\n                    val = grid[(nx, ny)]\n                    if val is False: continue\n                    if not allow_water and val == 'WATER': continue\n                    \n                    # Directional Collision Rules\n                    # 1. FLOOR_UP_WALL: Impassable from the North\n                    if dy == 1 and val == 'UP_WALL': continue # Moving SOUTH into UP_WALL\n                    if dy == -1 and grid.get((cx, cy)) == 'UP_WALL': continue # Moving NORTH out of UP_WALL\n                    \n                    # 2. LEDGE_HOP_DOWN: One-way jump from North to South\n                    if dy == -1 and val == 'LEDGE': continue # Moving NORTH into LEDGE\n                    \n                    if (nx, ny) not in visited:\n                        visited.add((nx, ny))\n                        # Append current node to path and move to next\n                        queue.append(((nx, ny), path + [{\"x\": cx, \"y\": cy}]))\n        \n        # No path found\n        print(json.dumps([]))\n        \n    except Exception as e:\n        import traceback\n        print(json.dumps({\"error\": str(e), \"traceback\": traceback.format_exc()}))\n\nif __name__ == \"__main__\":\n    solve()",
    "history": [
      {
        "commit_message": "Fixed sys.argv handling and robust error reporting.",
        "timestamp": "2026-01-14T09:12:03.581Z",
        "action_counter": 47495
      }
    ]
  }
}