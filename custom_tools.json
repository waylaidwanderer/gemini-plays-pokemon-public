{
  "navigate_fly_map_v2": {
    "description": "Navigates the Johto FLY map from a known starting city to a target city. City names: 'New Bark Town', 'Cherrygrove City', 'Violet City', 'Azalea Town', 'Goldenrod City', 'Ecruteak City', 'Olivine City', 'Cianwood City', 'Mahogany Town', 'Lake of Rage', 'Blackthorn City', 'Mt. Silver', 'Indigo Plateau'. Assumes the FLY map is already open.",
    "input_schema": {
      "properties": {
        "start_city": {
          "default": "New Bark Town",
          "type": "string"
        },
        "target_city": {
          "type": "string"
        }
      },
      "required": [
        "target_city"
      ],
      "type": "object"
    },
    "python_script": "import json\n\ndef navigate_fly_map(target_city, start_city=\"New Bark Town\"):\n    cities = [\n        \"New Bark Town\", \"Cherrygrove City\", \"Violet City\", \"Azalea Town\",\n        \"Goldenrod City\", \"Ecruteak City\", \"Olivine City\", \"Cianwood City\",\n        \"Mahogany Town\", \"Lake of Rage\", \"Blackthorn City\", \"Mt. Silver\", \"Indigo Plateau\"\n    ]\n    \n    if target_city not in cities or start_city not in cities:\n        print(json.dumps([]))\n        return\n\n    start_idx = cities.index(start_city)\n    target_idx = cities.index(target_city)\n    diff = target_idx - start_idx\n    \n    buttons = []\n    # In Crystal Johto FLY map:\n    # 'Up' moves forward in the sequence (index increases).\n    if diff > 0:\n        buttons = [\"Up\"] * diff\n    elif diff < 0:\n        buttons = [\"Down\"] * abs(diff)\n    \n    buttons.append(\"A\")\n    print(json.dumps(buttons))\n\n# The variable 'input_data' is automatically available.\nnavigate_fly_map(input_data['target_city'], input_data.get('start_city', 'New Bark Town'))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-27T03:08:24.414Z",
        "action_counter": 24583
      }
    ]
  },
  "sweep_area_v2": {
    "description": "Iteratively walks all floor tiles within a specified bounding box on the current map to trigger events or find objects. Uses BFS for robust movement between points and handles obstacles. Returns a list of button strings for the path.",
    "input_schema": {
      "type": "object",
      "properties": {
        "bottom_y": {
          "type": "integer"
        },
        "left_x": {
          "type": "integer"
        },
        "right_x": {
          "type": "integer"
        },
        "top_y": {
          "type": "integer"
        }
      },
      "required": [
        "left_x",
        "top_y",
        "right_x",
        "bottom_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        print(json.dumps([]))\n        return\n\n    # Build adjacency and walkable map\n    walkable = {}\n    start_x, start_y = -1, -1\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            t_type = tile.get('type')\n            has_obj = tile.get('has-object') == 'true'\n            \n            # Floor, grass, dirt, sand, and cut trees are generally walkable.\n            # Walls, water (without surf), and objects are not.\n            walkable_types = [\n                'FLOOR', 'TALL_GRASS', 'LONG_GRASS', 'GRASS', 'DIRT', 'SAND',\n                'CUT_TREE', 'CUT_08', 'CUT_28_GARBAGE'\n            ]\n            \n            is_walkable = t_type in walkable_types and not has_obj\n            walkable[(x, y)] = is_walkable\n            \n            if tile.find('Player') is not None:\n                start_x, start_y = x, y\n\n    if start_x == -1:\n        print(json.dumps([]))\n        return\n\n    left_x = int(input_data['left_x'])\n    top_y = int(input_data['top_y'])\n    right_x = int(input_data['right_x'])\n    bottom_y = int(input_data['bottom_y'])\n\n    # Determine targets within the bounding box\n    targets = []\n    for y in range(top_y, bottom_y + 1):\n        # Use a snake pattern for efficiency\n        if (y - top_y) % 2 == 0:\n            x_range = range(left_x, right_x + 1)\n        else:\n            x_range = range(right_x, left_x - 1, -1)\n        \n        for x in x_range:\n            if walkable.get((x, y)):\n                targets.append((x, y))\n\n    if not targets:\n        print(json.dumps([]))\n        return\n\n    def get_path(s_x, s_y, e_x, e_y):\n        if s_x == e_x and s_y == e_y:\n            return []\n            \n        q = deque([(s_x, s_y, [])])\n        visited = set([(s_x, s_y)])\n        while q:\n            cx, cy, path = q.popleft()\n            if cx == e_x and cy == e_y:\n                return path\n            for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n                nx, ny = cx + dx, cy + dy\n                if (nx, ny) in walkable and walkable[(nx, ny)] and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    q.append((nx, ny, path + [btn]))\n        return None\n\n    full_path = []\n    curr_x, curr_y = start_x, start_y\n    \n    # We want to visit EVERY target. If a target is unreachable from the current\n    # position, we skip it and move to the next.\n    for tx, ty in targets:\n        p = get_path(curr_x, curr_y, tx, ty)\n        if p:\n            full_path.extend(p)\n            curr_x, curr_y = tx, ty\n        elif curr_x == tx and curr_y == ty:\n            continue\n            \n    print(json.dumps(full_path))\n\nsolve()\n",
    "history": [
      {
        "commit_message": "Initial version of a robust area sweep tool using BFS for navigation between floor tiles.",
        "timestamp": "2025-12-27T05:49:48.091Z",
        "action_counter": 24932
      },
      {
        "commit_message": "Fixing typo 'intelligence' to 'in' and improving logic.",
        "timestamp": "2025-12-27T14:27:39.597Z",
        "action_counter": 26009
      },
      {
        "commit_message": "Fixing 'is_walkable' logic to include more tile types and cleaning up start position detection.",
        "timestamp": "2025-12-27T14:28:45.750Z",
        "action_counter": 26011
      },
      {
        "commit_message": "Adding more walkable tile types (CUT_TREE, etc.) and improving error handling.",
        "timestamp": "2025-12-27T14:30:38.821Z",
        "action_counter": 26014
      }
    ]
  },
  "get_exploration_targets": {
    "description": "Analyzes the current map XML and identifies unseen tiles that are adjacent to known walkable tiles, helping prioritize exploration.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ndef run():\n    root = ET.fromstring(map_xml_string)\n    walkable_types = ['FLOOR', 'GRASS', 'TALL_GRASS', 'LONG_GRASS', 'FLOOR_UP_WALL', 'WARP_CARPET_DOWN', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'WARP_CARPET_UP', 'DOOR', 'CAVE']\n    \n    walkable_tiles = set()\n    unseen_tiles = []\n    \n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            t_type = tile.get('type')\n            seen = tile.get('seen') == 'true'\n            \n            if seen and t_type in walkable_types:\n                walkable_tiles.add((x, y))\n            elif not seen:\n                unseen_tiles.append({'x': x, 'y': y})\n                \n    exploration_targets = []\n    for target in unseen_tiles:\n        tx, ty = target['x'], target['y']\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            if (tx + dx, ty + dy) in walkable_tiles:\n                exploration_targets.append(target)\n                break\n    \n    print(json.dumps(exploration_targets))\n\nrun()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-27T12:45:15.743Z",
        "action_counter": 25794
      }
    ]
  },
  "find_path_v5": {
    "description": "Calculates a path between two coordinates on the current map using BFS, accounting for walls, objects, and avoiding unintentional warps. Returns a JSON array of button strings. Handles landing from water, cutting trees, and one-way ledges. Uses global map_xml_string and input_data.",
    "input_schema": {
      "type": "object",
      "properties": {
        "autopress_buttons": {
          "default": false,
          "type": "boolean"
        },
        "can_cut": {
          "default": false,
          "type": "boolean"
        },
        "can_surf": {
          "default": false,
          "type": "boolean"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "nullable": true,
          "type": "integer"
        },
        "start_y": {
          "nullable": true,
          "type": "integer"
        }
      },
      "required": [
        "end_x",
        "end_y",
        "autopress_buttons"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    try:\n        # map_xml_string and input_data are global\n        start_x = input_data.get('start_x')\n        start_y = input_data.get('start_y')\n        end_x = int(input_data.get('end_x'))\n        end_y = int(input_data.get('end_y'))\n        can_surf = input_data.get('can_surf', False)\n        can_cut = input_data.get('can_cut', False)\n        \n        if not map_xml_string:\n            print(json.dumps({\"error\": \"Map XML is empty\"}))\n            return\n\n        root = ET.fromstring(map_xml_string)\n        width = int(root.attrib['width'])\n        height = int(root.attrib['height'])\n        \n        if start_x is None or start_y is None:\n            found = False\n            for row in root.findall('Row'):\n                for tile in row.findall('Tile'):\n                    if tile.find('Player') is not None:\n                        start_x = int(tile.attrib['id'])\n                        start_y = int(row.attrib['id'])\n                        found = True\n                        break\n                if found:\n                    break\n            \n            if not found:\n                print(json.dumps({\"error\": \"Start position not found\"}))\n                return\n\n        grid = {}\n        types = {}\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                t_type = tile.attrib['type']\n                is_warp = tile.attrib.get('is-warp') == 'true'\n                has_obj = tile.attrib.get('has-object') == 'true'\n                \n                types[(x, y)] = t_type\n                passable = True\n                if t_type in ['WALL', 'unseen', 'HEADBUTT_TREE']:\n                    passable = False\n                elif t_type == 'WATER' and not can_surf:\n                    passable = False\n                elif t_type == 'CUT_TREE' and not can_cut:\n                    passable = False\n                elif has_obj:\n                    if x != end_x or y != end_y:\n                        passable = False\n                \n                if is_warp and (x != end_x or y != end_y):\n                    passable = False\n                \n                if x == end_x and y == end_y:\n                    passable = True\n                \n                grid[(x, y)] = passable\n\n        queue = deque([(start_x, start_y, [])])\n        visited = {(start_x, start_y)}\n        \n        while queue:\n            curr_x, curr_y, path = queue.popleft()\n            if curr_x == end_x and curr_y == end_y:\n                print(json.dumps(path))\n                return\n                \n            for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n                nx, ny = curr_x + dx, curr_y + dy\n                if 0 <= nx < width and 0 <= ny < height and grid.get((nx, ny)) and (nx, ny) not in visited:\n                    # Ledge check\n                    curr_type = types.get((curr_x, curr_y))\n                    next_type = types.get((nx, ny))\n                    \n                    if curr_type == 'LEDGE_HOP_DOWN' and btn != 'Down': continue\n                    if curr_type == 'LEDGE_HOP_UP' and btn != 'Up': continue\n                    if curr_type == 'LEDGE_HOP_LEFT' and btn != 'Left': continue\n                    if curr_type == 'LEDGE_HOP_RIGHT' and btn != 'Right': continue\n                    \n                    if next_type == 'LEDGE_HOP_DOWN' and btn != 'Down': continue\n                    if next_type == 'LEDGE_HOP_UP' and btn != 'Up': continue\n                    if next_type == 'LEDGE_HOP_LEFT' and btn != 'Left': continue\n                    if next_type == 'LEDGE_HOP_RIGHT' and btn != 'Right': continue\n\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [btn]))\n        \n        print(json.dumps({\"error\": \"Path not found\"}))\n    except Exception as e:\n        print(json.dumps({\"error\": str(e)}))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-27T18:00:32.003Z",
        "action_counter": 26449
      },
      {
        "commit_message": "Fixing player position detection logic in find_path_v5. Removed use of '..' in find() as it is not supported for finding parents in this context. Logic now iterates through rows and tiles to find the Player element.",
        "timestamp": "2025-12-27T18:03:53.736Z",
        "action_counter": 26457
      },
      {
        "commit_message": "Refining find_path_v5 to handle LEDGE_HOP_DOWN tiles as one-way (North to South) movement only. Added logic to ensure ledges can only be entered and exited by moving Down.",
        "timestamp": "2025-12-27T18:07:04.333Z",
        "action_counter": 26461
      },
      {
        "commit_message": "Refining find_path_v5 to handle all ledge types (LEDGE_HOP_DOWN, LEDGE_HOP_UP, LEDGE_HOP_LEFT, LEDGE_HOP_RIGHT) as one-way movement. A ledge tile can only be entered and exited by moving in its designated direction.",
        "timestamp": "2025-12-27T18:12:41.748Z",
        "action_counter": 26471
      }
    ]
  },
  "set_lead_pokemon_v1": {
    "description": "Swaps the current lead Pokémon with a Pokémon at a specified index in the party. Assumes starting from the overworld.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_index": {
          "type": "integer",
          "description": "The 1-based index of the Pokémon to move to the lead position (2-6)."
        },
        "num_field_moves": {
          "type": "integer",
          "description": "The number of field moves the current lead Pokémon has (0-4)."
        }
      },
      "required": [
        "target_index",
        "num_field_moves"
      ]
    },
    "python_script": "import json\n\ndef run(input_data):\n    target_index = int(input_data['target_index'])\n    num_field_moves = int(input_data['num_field_moves'])\n    if not (2 <= target_index <= 6):\n        return json.dumps([])\n    \n    buttons = [\"Start\", \"Down\", \"A\"] # Open menu, go to POKEMON, select it\n    \n    # We are now in the party menu, cursor on index 1\n    buttons.append(\"A\") # Select index 1 (the current lead)\n    \n    # Now in sub-menu for index 1.\n    # 1..n [Field Moves], n+1. STATS, n+2. SWITCH\n    for _ in range(num_field_moves + 1):\n        buttons.append(\"Down\")\n    buttons.append(\"A\")\n    \n    # Now in \"Move to where?\" mode, cursor on index 1.\n    for _ in range(target_index - 1):\n        buttons.append(\"Down\")\n    \n    buttons.append(\"A\") # Select target and swap\n    buttons.extend([\"B\", \"B\", \"B\"]) # Exit menus\n    \n    return json.dumps(buttons)\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-27T18:52:58.051Z",
        "action_counter": 26551
      },
      {
        "commit_message": "Added num_field_moves parameter to handle variable menu structures.",
        "timestamp": "2025-12-27T19:09:03.419Z",
        "action_counter": 26581
      }
    ]
  }
}