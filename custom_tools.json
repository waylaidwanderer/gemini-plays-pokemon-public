{
  "path_finder": {
    "description": "A* pathfinding algorithm to find a path between two points on the current map, avoiding obstacles and impassable terrain.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\nimport json\n\nclass Node:\n    def __init__(self, parent=None, position=None):\n        self.parent = parent\n        self.position = position\n        self.g = 0\n        self.h = 0\n        self.f = 0\n\n    def __eq__(self, other):\n        return self.position == other.position\n\n    def __lt__(self, other):\n        return self.f < other.f\n\n    def __hash__(self):\n        return hash(self.position)\n\ndef get_path(grid_data, start, end):\n    impassable_tiles = {'WALL', 'VOID', 'WATER', 'CUT_TREE', 'unseen', 'COUNTER', 'LADDER', 'BUOY'}\n    one_way_down = {'LEDGE', 'FLOOR_ALLOW_HOP_DOWN'}\n    one_way_up = {'FLOOR_UP_WALL'}\n    one_way_left = {'FLOOR_ALLOW_HOP_LEFT'}\n    one_way_right = {'FLOOR_ALLOW_HOP_RIGHT'}\n    one_way_down_or_right = {'FLOOR_ALLOW_HOP_DOWN_OR_RIGHT'}\n\n    start_node = Node(None, start)\n    end_node = Node(None, end)\n\n    open_list = []\n    closed_set = set()\n\n    heapq.heappush(open_list, (start_node.f, start_node))\n\n    while open_list:\n        current_f, current_node = heapq.heappop(open_list)\n\n        if current_node.position in closed_set:\n            continue\n        closed_set.add(current_node.position)\n\n        if current_node == end_node:\n            path = []\n            current = current_node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            return path[::-1]\n\n        children = []\n        for move_offset in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            node_position = (current_node.position[0] + move_offset[0], current_node.position[1] + move_offset[1])\n            \n            if node_position not in grid_data:\n                continue\n\n            tile_info = grid_data[node_position]\n            current_tile_info = grid_data[current_node.position]\n            \n            if tile_info['type'] in impassable_tiles or tile_info['has_object']:\n                continue\n            \n            is_move_allowed = True\n            if not grid_data[node_position]['is_warp']:\n                current_type = current_tile_info['type']\n                next_type = tile_info['type']\n                if current_type in one_way_down and move_offset != (0, 1): is_move_allowed = False\n                if current_type in one_way_left and move_offset != (-1, 0): is_move_allowed = False\n                if current_type in one_way_right and move_offset != (1, 0): is_move_allowed = False\n                if current_type in one_way_down_or_right and move_offset not in [(0, 1), (1, 0)]: is_move_allowed = False\n                if next_type in one_way_up and move_offset == (0, 1): is_move_allowed = False\n            \n            if not is_move_allowed:\n                continue\n\n            new_node = Node(current_node, node_position)\n            children.append(new_node)\n\n        for child in children:\n            if child.position in closed_set:\n                continue\n\n            child.g = current_node.g + 1\n            child.h = abs(child.position[0] - end_node.position[0]) + abs(child.position[1] - end_node.position[1])\n            child.f = child.g + child.h\n\n            if any(item for item in open_list if child == item[1] and child.g >= item[1].g):\n                continue\n\n            heapq.heappush(open_list, (child.f, child))\n\n    return None\n\ndef path_to_buttons(path):\n    buttons = []\n    for i in range(1, len(path)):\n        x1, y1 = path[i-1]\n        x2, y2 = path[i]\n        if y2 < y1: buttons.append('Up')\n        elif y2 > y1: buttons.append('Down')\n        elif x2 < x1: buttons.append('Left')\n        elif x2 > x1: buttons.append('Right')\n    return buttons\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n\n    root = ET.fromstring(map_xml_string)\n    grid_data = {}\n    for row in root.findall('Row'):\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            y = int(row.get('id'))\n            tile_type = tile.get('type')\n            has_object = tile.get('has-object') == 'true'\n            is_warp = tile.get('is-warp') == 'true'\n            grid_data[(x, y)] = {'type': tile_type, 'has_object': has_object, 'is_warp': is_warp}\n\n    path = get_path(grid_data, (start_x, start_y), (end_x, end_y))\n\n    if path:\n        buttons = path_to_buttons(path)\n        print(json.dumps(buttons))\n    else:\n        print(json.dumps([]))\nexcept Exception as e:\n    print(json.dumps([f'Error: {str(e)}']))"
  },
  "route_finder": {
    "description": "Finds a path between two maps using the World Knowledge Graph.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_map_id": {
          "type": "string"
        },
        "end_map_id": {
          "type": "string"
        }
      },
      "required": [
        "start_map_id",
        "end_map_id"
      ]
    },
    "python_script": "import json\nimport heapq\nfrom collections import defaultdict\nimport itertools\n\nworld_knowledge = json.loads(world_knowledge_graph_json_string)\nnodes = world_knowledge['nodes']\nedges = world_knowledge['edges']\n\nstart_map = input_data['start_map_id']\nend_map = input_data['end_map_id']\n\ngraph = defaultdict(list)\n\n# Add explicit edges from the knowledge graph\nfor edge in edges:\n    if edge['source_node_id'] and edge['destination_node_id']:\n        graph[edge['source_node_id']].append(edge['destination_node_id'])\n        if not edge.get('is_one_way', False):\n            graph[edge['destination_node_id']].append(edge['source_node_id'])\n\n# Group nodes by map_id\nnodes_by_map = defaultdict(list)\nfor node in nodes:\n    nodes_by_map[node['map_id']].append(node['id'])\n\n# Add implicit intra-map edges\nfor map_id, map_nodes in nodes_by_map.items():\n    if len(map_nodes) > 1:\n        for u, v in itertools.combinations(map_nodes, 2):\n            graph[u].append(v)\n            graph[v].append(u)\n\nstart_node_ids = nodes_by_map.get(start_map, [])\n\nif not start_node_ids:\n    print(f'Start node for map {start_map} not found in World Knowledge Graph.')\n    exit()\n\n# Dijkstra's algorithm to find the shortest path\nqueue = [(0, start_node_id, [start_node_id]) for start_node_id in start_node_ids]\nvisited = set()\n\nwhile queue:\n    cost, current_node_id, path = heapq.heappop(queue)\n\n    if current_node_id in visited:\n        continue\n    visited.add(current_node_id)\n\n    current_map_id = next((n['map_id'] for n in nodes if n['id'] == current_node_id), None)\n    if current_map_id == end_map:\n        path_details = []\n        for node_id in path:\n            node_info = next((n for n in nodes if n['id'] == node_id), None)\n            if node_info:\n                path_details.append(f\"{node_info['name']} ({node_info['map_id']})\")\n        print(' -> '.join(path_details))\n        exit()\n\n    for neighbor_id in graph[current_node_id]:\n        if neighbor_id not in visited:\n            new_path = path + [neighbor_id]\n            heapq.heappush(queue, (cost + 1, neighbor_id, new_path))\n\nprint(f'No path found from map {start_map} to {end_map}.')"
  }
}