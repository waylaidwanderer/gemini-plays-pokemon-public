{
  "slow_press": {
    "description": "Presses a sequence of buttons with a configurable delay between each press. Input 'buttons' should be a list of button names (e.g., 'A', 'B', 'Up'). 'sleep' commands in the input list are ignored to prevent errors; use the 'delay' parameter instead.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "A",
              "B",
              "Select",
              "Start",
              "Right",
              "Left",
              "Up",
              "Down",
              "R",
              "L"
            ]
          }
        },
        "delay": {
          "type": "integer",
          "default": 500,
          "description": "Delay in milliseconds between presses."
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "buttons = input_data.get('buttons', [])\ndelay = input_data.get('delay', 500)\n\nsequence = []\nfor btn in buttons:\n    # Filter out any accidentally passed sleep commands or invalid strings\n    if btn in [\"A\", \"B\", \"Select\", \"Start\", \"Right\", \"Left\", \"Up\", \"Down\", \"R\", \"L\"]:\n        sequence.append(btn)\n        sequence.append(f\"sleep {delay}\")\n\n# Remove the trailing sleep if it exists\nif sequence and sequence[-1].startswith(\"sleep\"):\n    sequence.pop()\n\nprint(json.dumps(sequence))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-20T10:42:11.488Z",
        "action_counter": 8108
      },
      {
        "commit_message": "Refined slow_press to prevent consecutive sleep errors by sanitizing input and ensuring correct interleaving of delays.",
        "timestamp": "2025-12-26T10:25:26.235Z",
        "action_counter": 19531
      }
    ]
  },
  "try_cut_tree": {
    "description": "Checks the tile in front of the player for a cuttable tree and attempts to cut it. Returns true if a tree was cut, false otherwise.",
    "input_schema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "python_script": "# This script would ideally inspect the map data for a tree object.\n# Since we can't directly inspect live RAM, we'll try to press the button sequence for CUT.\n# \"Start\" -> \"Pokemon\" -> Select Oddish -> \"Cut\"\n# Or interacting with the tree \"A\".\n# In Gen 2, you can just press A on the tree.\n# So we will return the button \"A\".\nimport json\nprint(json.dumps([\"A\"]))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T17:46:48.214Z",
        "action_counter": 23754
      }
    ]
  },
  "navigate_menu": {
    "description": "Navigates menus by holding direction buttons for a specified duration to ensure registration, with delays between inputs. Useful for the Fly map and other sticky menus.",
    "input_schema": {
      "type": "object",
      "properties": {
        "directions": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "Up",
              "Down",
              "Left",
              "Right",
              "A",
              "B",
              "Start",
              "Select"
            ]
          }
        },
        "hold_ms": {
          "type": "integer",
          "default": 150
        },
        "interval_ms": {
          "type": "integer",
          "default": 300
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": true
        }
      },
      "required": [
        "directions",
        "autopress_buttons"
      ]
    },
    "python_script": "import json\n\n# Extract arguments from input_data\ndirections = input_data.get('directions', [])\nhold_ms = input_data.get('hold_ms', 150)\ninterval_ms = input_data.get('interval_ms', 300)\nautopress_buttons = input_data.get('autopress_buttons', True)\n\n# Frame duration is approx 16ms\nframes_to_hold = max(1, int(hold_ms / 16))\n\noutput_sequence = []\n\nfor btn in directions:\n    # Hold the button\n    for _ in range(frames_to_hold):\n        output_sequence.append(btn)\n    \n    # Release/Wait\n    if interval_ms > 0:\n        output_sequence.append(f\"sleep {interval_ms}\")\n        \nprint(json.dumps(output_sequence))",
    "history": [
      {
        "commit_message": "Defined a new tool 'navigate_menu' to reliably navigate menus by holding buttons for a specific duration, addressing input registration issues in emulated menus.",
        "timestamp": "2026-01-08T03:01:39.002Z",
        "action_counter": 27437
      },
      {
        "commit_message": "Fixed `navigate_menu` to correctly extract arguments from `input_data` and execute the logic, preventing 'Unexpected end of JSON input' errors.",
        "timestamp": "2026-01-08T03:03:15.631Z",
        "action_counter": 27439
      }
    ]
  },
  "assess_reachability": {
    "description": "Performs a flood-fill BFS starting from a given coordinate to determine all reachable tiles of a specific type (e.g., WATER). Returns the bounds of the reachable area, accessible warps, and adjacent unseen tiles. Useful for determining if a path exists through a maze.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "tile_type": {
          "type": "string",
          "default": "WATER"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef assess_reachability(map_xml_string, start_x, start_y, tile_type=\"WATER\"):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = {}\n    warps = {}\n    \n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib.get('type', 'unseen')\n            is_warp = tile.attrib.get('is-warp') == 'true'\n            \n            grid[(x, y)] = t_type\n            if is_warp:\n                # Check for warp details in children\n                warp_node = tile.find('Warp')\n                entry_point = warp_node.attrib.get('entry_point') if warp_node is not None else \"?\"\n                warps[(x, y)] = entry_point\n\n    if grid.get((start_x, start_y)) != tile_type and grid.get((start_x, start_y)) != \"WHIRLPOOL\":\n        print(f\"Error: Start position ({start_x}, {start_y}) is {grid.get((start_x, start_y))}, not {tile_type}.\")\n        return\n\n    queue = deque([(start_x, start_y)])\n    visited = set([(start_x, start_y)])\n    reachable_warps = []\n    reachable_unseen_adjacents = []\n    min_x, max_x, min_y, max_y = start_x, start_x, start_y, start_y\n    \n    # Allow WHIRLPOOL as traversable for surfing if tile_type is WATER\n    traversable_types = {tile_type}\n    if tile_type == \"WATER\":\n        traversable_types.add(\"WHIRLPOOL\")\n\n    while queue:\n        cx, cy = queue.popleft()\n        \n        min_x = min(min_x, cx)\n        max_x = max(max_x, cx)\n        min_y = min(min_y, cy)\n        max_y = max(max_y, cy)\n        \n        if (cx, cy) in warps:\n            reachable_warps.append({'x': cx, 'y': cy, 'entry': warps[(cx, cy)]})\n            \n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < width and 0 <= ny < height:\n                if (nx, ny) in visited:\n                    continue\n                \n                n_type = grid.get((nx, ny), 'unseen')\n                \n                if n_type in traversable_types:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n                elif n_type == 'unseen':\n                    reachable_unseen_adjacents.append({'x': nx, 'y': ny})\n                    # Don't traverse into unseen, just mark it as a frontier\n    \n    print(f\"Reachability Analysis from ({start_x}, {start_y}) for {tile_type}:\")\n    print(f\"  Bounds: X[{min_x}-{max_x}], Y[{min_y}-{max_y}]\")\n    print(f\"  Reachable Tiles Count: {len(visited)}\")\n    print(f\"  Reachable Warps: {reachable_warps}\")\n    print(f\"  Adjacent Unseen Tiles: {len(reachable_unseen_adjacents)} (First 5: {reachable_unseen_adjacents[:5]})\")\n\nassess_reachability(map_xml_string, input_data['start_x'], input_data['start_y'], input_data.get('tile_type', 'WATER'))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-08T11:22:54.983Z",
        "action_counter": 27988
      }
    ]
  },
  "find_path_bfs": {
    "description": "Finds the shortest path from the player's current position to a target coordinate using Breadth-First Search (BFS). It parses the game's map XML to identify walkable tiles and obstacles (walls, objects, etc.) based on the specified movement mode (walking or surfing). Returns a list of button presses to navigate the path.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer",
          "description": "The target X coordinate."
        },
        "target_y": {
          "type": "integer",
          "description": "The target Y coordinate."
        },
        "movement_mode": {
          "type": "string",
          "enum": [
            "walking",
            "surfing"
          ],
          "default": "walking",
          "description": "The current movement mode. Determines which tiles are passable (e.g., WATER is passable only when surfing)."
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": true,
          "description": "If true, automatically presses the calculated buttons."
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef get_player_pos(root):\n    for row in root.findall('Row'):\n        for tile in row.findall('Tile'):\n            if tile.attrib.get('has-player') == 'true':\n                return int(tile.attrib['id']), int(row.attrib['id'])\n    return None\n\ndef solve_path(xml_data, target_x, target_y, movement_mode='walking'):\n    try:\n        root = ET.fromstring(xml_data)\n        width = int(root.attrib['width'])\n        height = int(root.attrib['height'])\n        \n        start_pos = get_player_pos(root)\n        if not start_pos:\n            return \"Error: Player position not found in map data.\"\n        \n        start_x, start_y = start_pos\n        \n        # Build grid\n        # 0: Walkable, 1: Blocked\n        grid = [[0 for _ in range(width)] for _ in range(height)]\n        \n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                t_type = tile.attrib.get('type', 'unseen')\n                \n                is_blocked = False\n                \n                # Collision Logic\n                if t_type in ['WALL', 'BUOY', 'CUT_TREE', 'HEADBUTT_TREE']:\n                    is_blocked = True\n                elif t_type == 'WATER':\n                    if movement_mode == 'walking':\n                        is_blocked = True\n                elif t_type == 'unseen':\n                     is_blocked = True\n                elif movement_mode == 'surfing' and t_type not in ['WATER', 'WARP_CARPET_DOWN', 'WARP_CARPET_UP', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT']:\n                    is_blocked = True\n                \n                if tile.attrib.get('has-object') == 'true':\n                    if tile.attrib.get('has-player') != 'true':\n                        is_blocked = True\n                \n                if is_blocked:\n                    grid[y][x] = 1\n        \n        # Check if start or end are blocked (allow start to be blocked by player/object logic above)\n        # BFS\n        queue = deque([(start_x, start_y, [])])\n        visited = set([(start_x, start_y)])\n        \n        found_path = None\n        \n        while queue:\n            curr_x, curr_y, path = queue.popleft()\n            \n            if curr_x == target_x and curr_y == target_y:\n                found_path = path\n                break\n            \n            moves = [\n                (0, -1, \"Up\"),\n                (0, 1, \"Down\"),\n                (-1, 0, \"Left\"),\n                (1, 0, \"Right\")\n            ]\n            \n            for dx, dy, btn in moves:\n                nx, ny = curr_x + dx, curr_y + dy\n                \n                if 0 <= nx < width and 0 <= ny < height:\n                    if grid[ny][nx] == 0 and (nx, ny) not in visited:\n                        visited.add((nx, ny))\n                        queue.append((nx, ny, path + [btn]))\n                        \n        if found_path is not None:\n            print(json.dumps(found_path))\n        else:\n            print(\"Error: No path found.\")\n            \n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# Use input_data dictionary\nt_x = int(input_data['target_x'])\nt_y = int(input_data['target_y'])\nm_mode = input_data.get('movement_mode', 'walking')\n\nsolve_path(map_xml_string, t_x, t_y, m_mode)",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-08T13:38:17.154Z",
        "action_counter": 28141
      },
      {
        "commit_message": "Fixed variable access by using `input_data` dictionary instead of assuming global variables.",
        "timestamp": "2026-01-08T13:40:06.080Z",
        "action_counter": 28143
      }
    ]
  }
}