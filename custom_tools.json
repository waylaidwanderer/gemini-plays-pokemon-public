{
  "object_finder": {
    "description": "Finds a specific map object by its ID and returns its coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "object_id": {
          "type": "string"
        }
      },
      "required": [
        "object_id"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntarget_id = input_data['object_id']\nroot = ET.fromstring(map_xml_string)\nfound = False\nfor row in root.findall('Row'):\n    y = row.get('id')\n    for tile in row.findall('Tile'):\n        x = tile.get('id')\n        for obj in tile.findall('Object'):\n            if obj.get('id') == target_id:\n                print(json.dumps({'x': x, 'y': y}))\n                found = True\n                break\n        if found:\n            break\n    if found:\n        break\n\nif not found:\n    print(json.dumps({'error': 'Object not found on screen.'}))"
  },
  "warp_scanner": {
    "description": "Scans the current map XML and returns the coordinates of all warp tiles that do not have a map marker.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    unmarked_warps = []\n    for row_elem in root.findall('Row'):\n        for tile_elem in row_elem.findall('Tile'):\n            is_warp = tile_elem.find('Warp') is not None\n            has_marker = tile_elem.find('Marker') is not None\n            \n            if is_warp and not has_marker:\n                x = int(tile_elem.get('id'))\n                y = int(row_elem.get('id'))\n                unmarked_warps.append([x, y])\n                \n    print(json.dumps({\"unmarked_warps\": unmarked_warps, \"error\": None}))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({\"unmarked_warps\": [], \"error\": f\"An exception occurred: {str(e)}\\n{traceback.format_exc()}\"}))"
  },
  "pathfinder_v15": {
    "description": "A pathfinding tool that can avoid a specified list of coordinates. Now correctly treats unseen tiles as traversable and PIT tiles as impassable.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string",
          "nullable": true
        },
        "end_y": {
          "type": "string",
          "nullable": true
        },
        "explore_unseen": {
          "type": "boolean",
          "default": false
        },
        "avoid_coords": {
          "type": "array",
          "items": {
            "type": "array",
            "items": {
              "type": "integer"
            }
          },
          "nullable": true
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\nimport heapq\n\ndef parse_map(map_xml_string):\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    unseen_tiles = set()\n    all_impassable = set()\n    impassable_marker_emojis = {'ðŸ“', 'ðŸš€', 'ðŸ‘¦', 'ðŸ‘©â€ðŸ«', 'ðŸ‘´', 'âš”ï¸', 'ðŸ’°', 'ðŸŽ£', 'ðŸ˜Ž', 'ðŸŽ', 'â“', 'ðŸ¤“'}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            grid[(x, y)] = {'type': tile_type}\n            if tile_elem.get('seen') == 'false':\n                unseen_tiles.add((x, y))\n            if tile_elem.find('Object') is not None:\n                all_impassable.add((x, y))\n            for marker_elem in tile_elem.findall('Marker'):\n                if marker_elem.get('emoji') in impassable_marker_emojis:\n                    all_impassable.add((x, y))\n    return grid, unseen_tiles, all_impassable\n\ndef is_traversable(grid, pos, all_impassable, avoid_coords_set):\n    if pos in avoid_coords_set:\n        return False\n    if pos not in grid:\n        return False\n    impassable_types = {\n        'WALL', 'HEADBUTT_TREE', 'PILLAR', 'BOOKSHELF', 'TV', 'RADIO', 'TOWN_MAP', 'WINDOW', 'STATUE', 'TABLE', 'CHAIR', 'BIRD', \n        'MART_SHELF', 'BUOY', 'PC', 'LINK_CABLE', 'TRADE_MACHINE', 'INCENSE_BURNER', 'COUNTER', 'ROOF', 'CHIMNEY', 'SIGN', \n        'FLOWER', 'TREE_TOP', 'WATER_EDGE_UP', 'WATER_EDGE_DOWN', 'WATER_EDGE_LEFT', 'WATER_EDGE_RIGHT', 'VOID', 'PIT'\n    }\n    tile_info = grid.get(pos)\n    if not tile_info or tile_info['type'] in impassable_types or pos in all_impassable:\n        return False\n    return True\n\ndef get_neighbors(grid, pos):\n    neighbors = []\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n        next_pos = (pos[0] + dx, pos[1] + dy)\n        if next_pos in grid:\n            current_type = grid[pos]['type']\n            next_type = grid[next_pos]['type']\n            if current_type == 'LEDGE_HOP_DOWN' and dy != 1: continue\n            if current_type == 'LEDGE_HOP_LEFT' and dx != -1: continue\n            if current_type == 'LEDGE_HOP_RIGHT' and dx != 1: continue\n            if next_type == 'LEDGE_HOP_DOWN' and dy == -1: continue\n            if next_type == 'LEDGE_HOP_LEFT' and dx == 1: continue\n            if next_type == 'LEDGE_HOP_RIGHT' and dx == -1: continue\n            if next_type == 'FLOOR_UP_WALL' and dy != -1: continue\n            neighbors.append(next_pos)\n    return neighbors\n\ndef find_path_astar(grid, start, end, all_impassable, avoid_coords_set):\n    if not is_traversable(grid, start, all_impassable, avoid_coords_set):\n        return None, f'Start {start} is impassable.'\n    if start not in grid or end not in grid:\n        return None, 'Start or end coordinates are outside the map boundaries.'\n    if not is_traversable(grid, end, all_impassable, avoid_coords_set):\n        found_adjacent = False\n        for neighbor in get_neighbors(grid, end):\n            if is_traversable(grid, neighbor, all_impassable, avoid_coords_set):\n                end = neighbor\n                found_adjacent = True\n                break\n        if not found_adjacent:\n            return None, f'End {end} and all its neighbors are impassable.'\n    open_set = [(0, start)]; came_from = {}; g_score = {start: 0}\n    iteration = 0\n    while open_set:\n        iteration += 1\n        if iteration > 10000: return None, 'Max iterations exceeded.'\n        _, current = heapq.heappop(open_set)\n        if current == end:\n            path = []\n            while current in came_from: path.append(current); current = came_from[current]\n            path.append(start)\n            return path[::-1], None\n        for neighbor in get_neighbors(grid, current):\n            if not is_traversable(grid, neighbor, all_impassable, avoid_coords_set):\n                continue\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current; g_score[neighbor] = tentative_g_score\n                f_score = tentative_g_score + abs(neighbor[0] - end[0]) + abs(neighbor[1] - end[1])\n                heapq.heappush(open_set, (f_score, neighbor))\n    return None, f'No path found from {start} to {end}.'\n\ndef find_all_unseen_areas(grid, unseen_tiles):\n    visited = set()\n    all_areas = []\n    for tile in unseen_tiles:\n        if tile not in visited:\n            current_area = []\n            q = deque([tile])\n            visited.add(tile)\n            while q:\n                node = q.popleft()\n                current_area.append(node)\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    neighbor = (node[0] + dx, node[1] + dy)\n                    if neighbor in unseen_tiles and neighbor not in visited:\n                        visited.add(neighbor); q.append(neighbor)\n            all_areas.append(current_area)\n    return all_areas\n\ntry:\n    start_x = int(input_data['start_x']); start_y = int(input_data['start_y'])\n    explore_unseen = input_data.get('explore_unseen', 'false').lower() == 'true'\n    avoid_coords_raw = json.loads(input_data.get('avoid_coords', '[]'))\n    avoid_coords_set = set(tuple(c) for c in avoid_coords_raw) if avoid_coords_raw else set()\n    grid, unseen_tiles, all_impassable = parse_map(map_xml_string)\n    start_pos = (start_x, start_y)\n    path, error = None, None\n    if explore_unseen:\n        if not unseen_tiles:\n            error = 'No unseen areas to explore.'\n        else:\n            all_unseen_blobs = find_all_unseen_areas(grid, unseen_tiles)\n            all_entry_points = set()\n            for blob in all_unseen_blobs:\n                for unseen_tile in blob:\n                    for neighbor in get_neighbors(grid, unseen_tile):\n                        if is_traversable(grid, neighbor, all_impassable, avoid_coords_set):\n                            all_entry_points.add(neighbor)\n            if not all_entry_points:\n                error = 'No traversable entry points found for any unseen area.'\n            else:\n                shortest_path = None\n                for entry in all_entry_points:\n                    p, e = find_path_astar(grid, start_pos, entry, all_impassable, avoid_coords_set)\n                    if p and (shortest_path is None or len(p) < len(shortest_path)):\n                        shortest_path = p\n                if shortest_path:\n                    path = shortest_path\n                else:\n                    error = 'No reachable entry points to any unseen area found.'\n    else:\n        end_x = int(input_data.get('end_x')) if input_data.get('end_x') is not None else None\n        end_y = int(input_data.get('end_y')) if input_data.get('end_y') is not None else None\n        if end_x is None or end_y is None:\n            error = 'No target specified. Provide end coordinates or set explore_unseen to true.'\n        else:\n            path, error = find_path_astar(grid, start_pos, (end_x, end_y), all_impassable, avoid_coords_set)\n    path_coords = [[p[0], p[1]] for p in path] if path else []\n    print(json.dumps({'path': path_coords, 'error': error}))\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'path': [], 'error': f'An exception occurred: {str(e)}\\n{traceback.format_exc()}'}))"
  },
  "pathfinder_v1": {
    "description": "A simple pathfinding tool using A* to find a path between two points on the current map.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\ndef parse_map_xml(xml_string):\n    root = ET.fromstring(xml_string)\n    grid = {}\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tile_type = tile.attrib['type']\n            is_warp = tile.attrib.get('is-warp') == 'true'\n            has_object = tile.find('Object') is not None\n            grid[(x, y)] = {'type': tile_type, 'is_warp': is_warp, 'has_object': has_object}\n    return grid, width, height\n\ndef is_traversable(grid, x, y):\n    impassable_types = ['WALL', 'HEADBUTT_TREE', 'PILLAR', 'BOOKSHELF', 'TV', 'RADIO', 'TOWN_MAP', 'STATUE', 'TABLE', 'CHAIR', 'BIRD', 'MART_SHELF', 'BUOY', 'PC', 'LINK_CABLE', 'TRADE_MACHINE', 'INCENSE_BURNER', 'ROOF', 'CHIMNEY', 'SIGN', 'FLOWER', 'TREE_TOP', 'WATER_EDGE_UP', 'WATER_EDGE_DOWN', 'WATER_EDGE_LEFT', 'WATER_EDGE_RIGHT', 'VOID', 'COUNTER', 'FENCE', 'LINK_RECEPTIONIST', 'WINDOW', 'PIT']\n    tile = grid.get((x, y))\n    if not tile or tile['type'] in impassable_types or tile['has_object']:\n        return False\n    return True\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(grid, start, end):\n    neighbors = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    close_set = set()\n    came_from = {}\n    gscore = {start: 0}\n    fscore = {start: heuristic(start, end)}\n    oheap = []\n\n    heapq.heappush(oheap, (fscore[start], start))\n\n    while oheap:\n        current = heapq.heappop(oheap)[1]\n\n        if current == end:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            return path[::-1]\n\n        close_set.add(current)\n        for i, j in neighbors:\n            neighbor = current[0] + i, current[1] + j\n            tentative_g_score = gscore[current] + 1\n\n            if not is_traversable(grid, neighbor[0], neighbor[1]):\n                continue\n            \n            if neighbor in close_set and tentative_g_score >= gscore.get(neighbor, 0):\n                continue\n\n            if tentative_g_score < gscore.get(neighbor, 0) or neighbor not in [i[1] for i in oheap]:\n                came_from[neighbor] = current\n                gscore[neighbor] = tentative_g_score\n                fscore[neighbor] = tentative_g_score + heuristic(neighbor, end)\n                heapq.heappush(oheap, (fscore[neighbor], neighbor))\n\n    return None # No path found\n\ndef coords_to_moves(path):\n    moves = []\n    for i in range(len(path) - 1):\n        x1, y1 = path[i]\n        x2, y2 = path[i+1]\n        if x2 > x1: moves.append('Right')\n        elif x2 < x1: moves.append('Left')\n        elif y2 > y1: moves.append('Down')\n        elif y2 < y1: moves.append('Up')\n    return moves\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nstart_node = (start_x, start_y)\nend_node = (end_x, end_y)\n\ngrid, width, height = parse_map_xml(map_xml_string)\n\npath_coords = a_star_search(grid, start_node, end_node)\n\nif path_coords:\n    moves = coords_to_moves(path_coords)\n    print(f'Path found: {moves}')\nelse:\n    print('No path found.')\n"
  }
}