{
  "find_path_v3": {
    "description": "Calculates a path between two coordinates on the current map using BFS, accounting for walls, objects, and avoiding unintentional warps. Returns a list of button strings. Updated to include more traversable tile types (including WARP_CARPET and STAIRS) and robust player position detection from the Mental Map.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer",
          "nullable": true
        },
        "start_y": {
          "type": "integer",
          "nullable": true
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "can_surf": {
          "type": "boolean",
          "default": false
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "end_x",
        "end_y",
        "autopress_buttons"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef solve():\n    root = ET.fromstring(map_xml_string)\n    \n    # Get current position from XML if not provided\n    start_x = input_data.get('start_x')\n    start_y = input_data.get('start_y')\n    \n    if start_x is None or start_y is None:\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                if tile.find('Player') is not None:\n                    start_x = int(tile.attrib['id'])\n                    start_y = y\n                    break\n            if start_x is not None: break\n\n    if start_x is None:\n        print(json.dumps([]))\n        return\n\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    can_surf = input_data.get('can_surf', False)\n\n    # Build grid\n    grid = {}\n    objects = set()\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            grid[(x, y)] = t_type\n            if tile.find('Object') is not None or tile.attrib.get('has-object') == 'true':\n                objects.add((x, y))\n\n    def is_traversable(x, y):\n        if (x, y) not in grid: return False\n        # Allow walking onto the target even if it has an object (e.g. interacting with an item)\n        if (x, y) in objects and (x, y) != (end_x, end_y): return False\n        \n        t_type = grid[(x, y)]\n        traversable_types = [\n            'FLOOR', 'TALL_GRASS', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', \n            'WARP_CARPET_UP', 'WARP_CARPET_DOWN', 'CAVE', 'FLOOR_UP_WALL', \n            'STAIRS', 'WARP_CARPET'\n        ]\n        if t_type in traversable_types:\n            return True\n        if can_surf and t_type == 'WATER':\n            return True\n        return False\n\n    queue = deque([(start_x, start_y, [])])\n    visited = {(start_x, start_y)}\n    \n    while queue:\n        cx, cy, path = queue.popleft()\n        if (cx, cy) == (end_x, end_y):\n            print(json.dumps(path))\n            return\n\n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) not in visited and is_traversable(nx, ny):\n                visited.add((nx, ny))\n                queue.append((nx, ny, path + [btn]))\n\n    print(json.dumps([]))\n\nsolve()",
    "history": [
      {
        "commit_message": "Refined pathfinding with more robust tile type handling and improved BFS for overworld navigation.",
        "timestamp": "2025-12-26T16:54:12.345Z",
        "action_counter": 23112
      },
      {
        "commit_message": "Refined pathfinding with robust position detection and improved traversability checks for overworld navigation.",
        "timestamp": "2025-12-26T16:56:20.298Z",
        "action_counter": 23116
      }
    ]
  },
  "menu_navigator_v4_robust": {
    "description": "Navigates a vertical list (Bag, Pokedex, etc.) to a target string and selects it. Accounts for cursor position and scrolls if necessary. Supports menu borders. Optimized for the Johto main menu.",
    "input_schema": {
      "type": "object",
      "properties": {
        "screen_text": {
          "type": "string"
        },
        "target": {
          "type": "string"
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "screen_text",
        "target",
        "autopress_buttons"
      ]
    },
    "python_script": "import json\n\ndef solve():\n    text = input_data['screen_text']\n    target = input_data['target'].upper()\n    \n    lines = [line.strip() for line in text.split('\\n') if line.strip() and not all(c in '┌┐└┘─│' for c in line.strip())]\n    \n    # Identify options and current cursor position\n    options = []\n    cursor_idx = -1\n    for i, line in enumerate(lines):\n        clean_line = line.replace('▶', '').replace('▷', '').strip()\n        if '▶' in line or '▷' in line:\n            cursor_idx = len(options)\n        if clean_line:\n            options.append(clean_line)\n\n    if target not in options:\n        # Fallback for partial matches or common misspellings\n        for i, opt in enumerate(options):\n            if target in opt or opt in target:\n                target = opt\n                break\n        else:\n            print(json.dumps([]))\n            return\n\n    target_idx = options.index(target)\n    diff = target_idx - cursor_idx\n    \n    buttons = []\n    if diff > 0:\n        buttons.extend(['Down'] * diff)\n    elif diff < 0:\n        buttons.extend(['Up'] * abs(diff))\n    \n    buttons.append('A')\n    print(json.dumps(buttons))\n\nsolve()",
    "history": [
      {
        "commit_message": "Improved menu navigation with better target matching and border handling.",
        "timestamp": "2025-12-26T16:54:12.346Z",
        "action_counter": 23112
      }
    ]
  },
  "navigate_fly_map_v2": {
    "description": "Navigates the Johto FLY map from a known starting city to a target city. City names: 'New Bark Town', 'Cherrygrove City', 'Violet City', 'Azalea Town', 'Goldenrod City', 'Ecruteak City', 'Olivine City', 'Cianwood City', 'Mahogany Town', 'Lake of Rage', 'Blackthorn City', 'Mt. Silver', 'Indigo Plateau'. Assumes the FLY map is already open.",
    "input_schema": {
      "properties": {
        "start_city": {
          "default": "New Bark Town",
          "type": "string"
        },
        "target_city": {
          "type": "string"
        }
      },
      "required": [
        "target_city"
      ],
      "type": "object"
    },
    "python_script": "import json\n\ndef navigate_fly_map(target_city, start_city=\"New Bark Town\"):\n    cities = [\n        \"New Bark Town\", \"Cherrygrove City\", \"Violet City\", \"Azalea Town\",\n        \"Goldenrod City\", \"Ecruteak City\", \"Olivine City\", \"Cianwood City\",\n        \"Mahogany Town\", \"Lake of Rage\", \"Blackthorn City\", \"Mt. Silver\", \"Indigo Plateau\"\n    ]\n    \n    if target_city not in cities or start_city not in cities:\n        print(json.dumps([]))\n        return\n\n    start_idx = cities.index(start_city)\n    target_idx = cities.index(target_city)\n    diff = target_idx - start_idx\n    \n    buttons = []\n    # In Crystal Johto FLY map:\n    # 'Up' moves forward in the sequence (index increases).\n    if diff > 0:\n        buttons = [\"Up\"] * diff\n    elif diff < 0:\n        buttons = [\"Down\"] * abs(diff)\n    \n    buttons.append(\"A\")\n    print(json.dumps(buttons))\n\n# The variable 'input_data' is automatically available.\nnavigate_fly_map(input_data['target_city'], input_data.get('start_city', 'New Bark Town'))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-27T03:08:24.414Z",
        "action_counter": 24583
      }
    ]
  },
  "sweep_area_v2": {
    "description": "Iteratively walks all floor tiles within a specified bounding box on the current map to trigger events or find objects. Uses BFS for robust movement between points and handles obstacles. Returns a list of button strings for the path.",
    "input_schema": {
      "properties": {
        "bottom_y": {
          "type": "integer"
        },
        "left_x": {
          "type": "integer"
        },
        "right_x": {
          "type": "integer"
        },
        "top_y": {
          "type": "integer"
        }
      },
      "required": [
        "left_x",
        "top_y",
        "right_x",
        "bottom_y"
      ],
      "type": "object"
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef find_player(root):\n    for row in root.findall('Row'):\n        row_id = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            if tile.find('Player') is not None:\n                return int(tile.get('id')), row_id\n    return None\n\ndef bfs(start, end, root):\n    if start == end: return []\n    q = deque([(start, [])])\n    visited = {start}\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    while q:\n        (cx, cy), path = q.popleft()\n        for dx, dy, btn in [(0, -1, \"Up\"), (0, 1, \"Down\"), (-1, 0, \"Left\"), (1, 0, \"Right\")]:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:\n                tile = root.find(f\".//Row[@id='{ny}']/Tile[@id='{nx}']\")\n                if tile is not None and tile.get('type') in ['FLOOR', 'WARP_CARPET', 'STAIRS', 'CAVE', 'WATER']:\n                    # Note: Simplified collision. Objects are walls.\n                    if tile.find('Object') is not None:\n                        continue\n                    if (nx, ny) == end:\n                        return path + [btn]\n                    visited.add((nx, ny))\n                    q.append(((nx, ny), path + [btn]))\n    return None\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    left = int(input_data['left_x'])\n    top = int(input_data['top_y'])\n    right = int(input_data['right_x'])\n    bottom = int(input_data['bottom_y'])\n    \n    player_pos = find_player(root)\n    if not player_pos: \n        print(json.dumps([\"Error: Player not found\"]))\n    else:\n        # Generate target floor tiles in a snake pattern for efficiency\n        targets = []\n        for y in range(top, bottom + 1):\n            x_range = range(left, right + 1) if (y - top) % 2 == 0 else range(right, left - 1, -1)\n            for x in x_range:\n                tile = root.find(f\".//Row[@id='{y}']/Tile[@id='{x}']\")\n                if tile is not None and tile.get('type') == 'FLOOR':\n                    targets.append((x, y))\n        \n        full_path = []\n        curr_pos = player_pos\n        for target in targets:\n            sub_path = bfs(curr_pos, target, root)\n            if sub_path is not None:\n                full_path.extend(sub_path)\n                curr_pos = target\n        \n        print(json.dumps(full_path))\nexcept Exception as e:\n    print(json.dumps([f\"Error: {str(e)}\"]))\n",
    "history": [
      {
        "commit_message": "Initial version of a robust area sweep tool using BFS for navigation between floor tiles.",
        "timestamp": "2025-12-27T05:49:48.091Z",
        "action_counter": 24932
      }
    ]
  },
  "menu_navigator_crystal_v2": {
    "description": "Navigates the Crystal main menu. Handles the vertical layout including OPTION and EXIT. Robust against special characters like 'é'.",
    "input_schema": {
      "properties": {
        "screen_text": {
          "type": "string"
        },
        "target": {
          "enum": [
            "POKEDEX",
            "POKEMON",
            "PACK",
            "GEAR",
            "GEM",
            "SAVE",
            "OPTION",
            "EXIT"
          ],
          "type": "string"
        }
      },
      "required": [
        "screen_text",
        "target"
      ],
      "type": "object"
    },
    "python_script": "import json\nimport re\n\ndef navigate_menu(screen_text, target):\n    def normalize(s):\n        return re.sub(r'[^a-z]', '', s.lower())\n\n    order = [\"POKEDEX\", \"POKEMON\", \"PACK\", \"GEAR\", \"GEM\", \"SAVE\", \"OPTION\", \"EXIT\"]\n    norm_order = [normalize(n) for n in order]\n    norm_target = normalize(target)\n    \n    if norm_target not in norm_order:\n        return [f\"Error: Target '{target}' not in menu order\"]\n    \n    target_idx = norm_order.index(norm_target)\n    \n    curr_idx = -1\n    lines = screen_text.split('\\n')\n    for i, line in enumerate(lines):\n        if \"▶\" in line or \"▷\" in line:\n            line_norm = normalize(line)\n            for j, n_name in enumerate(norm_order):\n                if n_name in line_norm:\n                    curr_idx = j\n                    break\n            if curr_idx != -1: break\n    \n    if curr_idx == -1:\n        return [\"Error: Cursor not found\"]\n        \n    target_idx = norm_order.index(norm_target)\n    diff = target_idx - curr_idx\n    buttons = []\n    if diff > 0:\n        buttons = [\"Down\"] * diff\n    elif diff < 0:\n        buttons = [\"Up\"] * abs(diff)\n    buttons.append(\"A\")\n    return buttons\n\ntry:\n    print(json.dumps(navigate_menu(input_data['screen_text'], input_data['target'])))\nexcept Exception as e:\n    print(json.dumps([f\"Error: {str(e)}\"]))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-27T05:50:42.249Z",
        "action_counter": 24933
      },
      {
        "commit_message": "Refined menu_navigator_crystal_v2 to handle special characters like 'é' by normalizing strings (removing non-alpha characters) before matching. Also added support for the '▷' cursor.",
        "timestamp": "2025-12-27T05:53:07.908Z",
        "action_counter": 24940
      }
    ]
  }
}