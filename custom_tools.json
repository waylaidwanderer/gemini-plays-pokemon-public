{
  "object_finder": {
    "description": "Finds a specific map object by its ID and returns its coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "object_id": {
          "type": "string"
        }
      },
      "required": [
        "object_id"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntarget_id = input_data['object_id']\nroot = ET.fromstring(map_xml_string)\nfound = False\nfor row in root.findall('Row'):\n    y = row.get('id')\n    for tile in row.findall('Tile'):\n        x = tile.get('id')\n        for obj in tile.findall('Object'):\n            if obj.get('id') == target_id:\n                print(json.dumps({'x': x, 'y': y}))\n                found = True\n                break\n        if found:\n            break\n    if found:\n        break\n\nif not found:\n    print(json.dumps({'error': 'Object not found on screen.'}))"
  },
  "maze_solver_v1": {
    "description": "A robust pathfinding tool using the A* search algorithm, designed to navigate complex maze-like environments efficiently. Includes extensive debugging.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "extra_impassable_coordinates": {
          "type": "string",
          "description": "A JSON string of a list of additional [x, y] coordinates to treat as impassable."
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport heapq\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(grid, start, end, all_impassable):\n    impassable_types = {\n        'WALL', 'VOID', 'WATER', 'CUT_TREE', 'COUNTER', 'BUOY', 'HEADBUTT_TREE',\n        'MART_SHELF', 'BOOKSHELF', 'TV', 'RADIO', 'PC', 'TOWN_MAP', 'WINDOW', 'PAINTING', 'STATUE', 'PILLAR',\n        'BED', 'TABLE', 'CHAIR', 'unseen'\n    }\n\n    print(f'Starting A* from {start} to {end}')\n    if start not in grid or end not in grid:\n        return [], f'Start {start} or end {end} position not in grid.'\n\n    if grid.get(start, {}).get('type') in impassable_types or start in all_impassable:\n        return [], f'Start position {start} is impassable.'\n\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {pos: float('inf') for pos in grid}\n    g_score[start] = 0\n    f_score = {pos: float('inf') for pos in grid}\n    f_score[start] = heuristic(start, end)\n\n    visited_in_loop = set()\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current in visited_in_loop:\n            continue\n        visited_in_loop.add(current)\n\n        if current == end:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            print('Path found!')\n            return path[::-1], None\n\n        for move_x, move_y in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            neighbor = (current[0] + move_x, current[1] + move_y)\n\n            if neighbor not in grid:\n                continue\n\n            neighbor_type = grid.get(neighbor, {}).get('type')\n            if neighbor_type in impassable_types or neighbor in all_impassable:\n                continue\n\n            tentative_g_score = g_score[current] + 1\n\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, end)\n                heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    print('No path found. Open set exhausted.')\n    return [], 'No path found to destination.'\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    \n    extra_impassable_str = input_data.get('extra_impassable_coordinates')\n    loaded_extra = json.loads(extra_impassable_str) if extra_impassable_str else []\n    extra_impassable = {tuple(map(int, coord)) for coord in loaded_extra} if loaded_extra else set()\n\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    map_objects_impassable = set()\n\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            grid[(x, y)] = {'type': tile.get('type')}\n            if tile.find('Object') is not None:\n                map_objects_impassable.add((x,y))\n\n    all_impassable = map_objects_impassable.union(extra_impassable)\n\n    path, error = a_star_search(grid, (start_x, start_y), (end_x, end_y), all_impassable)\n    path_coords = [[p[0], p[1]] for p in path]\n    \n    print(json.dumps({'path': path_coords, 'error': error}))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'path': [], 'error': f'An exception occurred: {str(e)}\\n{traceback.format_exc()}'}))"
  },
  "pathfinder_v1": {
    "description": "A consolidated pathfinding tool using A* for targeted paths and BFS to find the largest contiguous unseen area for exploration. Replaces path_master_v24 and maze_explorer_v8.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string",
          "nullable": true
        },
        "end_y": {
          "type": "string",
          "nullable": true
        },
        "explore_unseen": {
          "type": "boolean",
          "default": false
        },
        "extra_impassable_coordinates": {
          "type": "string",
          "description": "A JSON string of a list of additional [x, y] coordinates to treat as impassable."
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\nimport heapq\n\ndef parse_map(map_xml_string, extra_impassable_coordinates_str):\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    unseen_tiles = []\n    map_objects_impassable = set()\n    extra_impassable = {tuple(map(int, coord)) for coord in json.loads(extra_impassable_coordinates_str)} if extra_impassable_coordinates_str else set()\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            grid[(x, y)] = {'type': tile_type}\n            if tile_type == 'unseen':\n                unseen_tiles.append((x, y))\n            if tile_elem.find('Object') is not None:\n                map_objects_impassable.add((x, y))\n    \n    all_impassable = map_objects_impassable.union(extra_impassable)\n    return grid, unseen_tiles, all_impassable\n\ndef is_traversable(grid, pos, all_impassable):\n    impassable_types = {\n        'WALL', 'VOID', 'WATER', 'CUT_TREE', 'COUNTER', 'BUOY', 'HEADBUTT_TREE',\n        'MART_SHELF', 'BOOKSHELF', 'TV', 'RADIO', 'PC', 'TOWN_MAP', 'WINDOW', 'PAINTING', 'STATUE', 'PILLAR',\n        'BED', 'TABLE', 'CHAIR', 'unseen'\n    }\n    tile_info = grid.get(pos)\n    if not tile_info or tile_info['type'] in impassable_types or pos in all_impassable:\n        return False\n    return True\n\ndef get_neighbors(grid, pos):\n    neighbors = []\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n        next_pos = (pos[0] + dx, pos[1] + dy)\n        if next_pos in grid:\n            # Handle one-way ledges\n            current_type = grid[pos]['type']\n            next_type = grid[next_pos]['type']\n            if current_type == 'LEDGE_HOP_DOWN' and dy != 1: continue\n            if current_type == 'LEDGE_HOP_LEFT' and dx != -1: continue\n            if current_type == 'LEDGE_HOP_RIGHT' and dx != 1: continue\n            if next_type == 'LEDGE_HOP_DOWN' and dy == -1: continue\n            if next_type == 'LEDGE_HOP_LEFT' and dx == 1: continue\n            if next_type == 'LEDGE_HOP_RIGHT' and dx == -1: continue\n            neighbors.append(next_pos)\n    return neighbors\n\ndef find_path_astar(grid, start, end, all_impassable):\n    if not is_traversable(grid, start, all_impassable) or not is_traversable(grid, end, all_impassable):\n        return None, 'Start or end is impassable.'\n\n    open_set = [(0, start)]\n    came_from = {}\n    g_score = {start: 0}\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == end:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            return path[::-1], None\n\n        for neighbor in get_neighbors(grid, current):\n            if not is_traversable(grid, neighbor, all_impassable) and neighbor != end:\n                continue\n            \n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score = tentative_g_score + abs(neighbor[0] - end[0]) + abs(neighbor[1] - end[1])\n                heapq.heappush(open_set, (f_score, neighbor))\n    \n    return None, 'No path found.'\n\ndef find_largest_unseen_area(grid, unseen_tiles):\n    visited = set()\n    largest_area = []\n    for tile in unseen_tiles:\n        if tile not in visited:\n            current_area = []\n            q = deque([tile])\n            visited.add(tile)\n            while q:\n                node = q.popleft()\n                current_area.append(node)\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    neighbor = (node[0] + dx, node[1] + dy)\n                    if neighbor in grid and grid[neighbor]['type'] == 'unseen' and neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n            if len(current_area) > len(largest_area):\n                largest_area = current_area\n    return largest_area\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x']) if input_data.get('end_x') else None\n    end_y = int(input_data['end_y']) if input_data.get('end_y') else None\n    explore_unseen = input_data.get('explore_unseen', 'false').lower() == 'true'\n    extra_impassable_str = input_data.get('extra_impassable_coordinates')\n\n    grid, unseen_tiles, all_impassable = parse_map(map_xml_string, extra_impassable_str)\n    start_pos = (start_x, start_y)\n    path, error = None, None\n\n    if explore_unseen:\n        if not unseen_tiles:\n            error = 'No unseen areas to explore.'\n        else:\n            largest_area = find_largest_unseen_area(grid, unseen_tiles)\n            if not largest_area:\n                error = 'Could not identify unseen areas.'\n            else:\n                shortest_path = None\n                for unseen_tile in largest_area:\n                    for neighbor in get_neighbors(grid, unseen_tile):\n                        if is_traversable(grid, neighbor, all_impassable):\n                            p, e = find_path_astar(grid, start_pos, neighbor, all_impassable)\n                            if p and (shortest_path is None or len(p) < len(shortest_path)):\n                                shortest_path = p\n                if shortest_path:\n                    path = shortest_path\n                else:\n                    error = 'No reachable entry point to the largest unseen area found.'\n    elif end_x is not None and end_y is not None:\n        end_pos = (end_x, end_y)\n        path, error = find_path_astar(grid, start_pos, end_pos, all_impassable)\n    else:\n        error = 'No target specified. Provide end coordinates or set explore_unseen to true.'\n\n    path_coords = [[p[0], p[1]] for p in path] if path else []\n    print(json.dumps({'path': path_coords, 'error': error}))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'path': [], 'error': f'An exception occurred: {str(e)}\\n{traceback.format_exc()}'}))"
  }
}