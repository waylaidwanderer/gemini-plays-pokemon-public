{
  "unseen_tile_checker": {
    "description": "Analyzes the list of unseen tiles from a system alert and uses pathfinding logic to determine which are actually reachable from the player's current position.",
    "input_schema": {
      "type": "object",
      "properties": {
        "coordinates": {
          "type": "string",
          "description": "A stringified JSON array of coordinate objects, e.g., '[{\"x\":1,\"y\":2}]'"
        }
      },
      "required": [
        "coordinates"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET; from collections import deque; import json\n\ndef parse_map_xml(xml_string):\n    root = ET.fromstring(xml_string)\n    map_data = {}\n    map_data['width'] = int(root.attrib['width'])\n    map_data['height'] = int(root.attrib['height'])\n    map_data['tiles'] = {}\n    player_pos = None\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id'])\n            tile_type = tile_elem.attrib.get('type', 'unseen')\n            has_object = tile_elem.attrib.get('has-object') == 'true'\n            map_data['tiles'][(x, y)] = {'type': tile_type, 'has_object': has_object}\n            if tile_elem.find('Player') is not None:\n                player_pos = (x, y)\n    map_data['player_pos'] = player_pos\n    return map_data\n\ndef is_passable(x, y, dx, dy, map_data):\n    target_x, target_y = x + dx, y + dy\n    if not (1 <= target_x <= map_data['width'] and 1 <= target_y <= map_data['height']):\n        return False\n    target_tile = map_data['tiles'].get((target_x, target_y))\n    if not target_tile:\n        return False\n    current_tile = map_data['tiles'].get((x, y))\n    current_tile_type = current_tile.get('type') if current_tile else 'None'\n    target_tile_type = target_tile.get('type')\n    impassable_types = ['unseen', 'WALL', 'WINDOW', 'VOID', 'CUT_TREE', 'SIGN', 'BOOKSHELF', 'BLACKBOARD', 'MART_SHELF', 'BUOY', 'TV', 'TOWN_MAP', 'RADIO', 'INCENSE_BURNER', 'BIRD', 'HEADBUTT_TREE', 'FRUIT_TREE', 'COMPUTER', 'PRINTER', 'COUNTER', 'PC', 'WATER']\n    if target_tile_type in impassable_types:\n        return False\n    if target_tile.get('has_object'):\n        return False\n    if target_tile_type == 'LEDGE_HOP_DOWN' and dy != 1:\n        return False\n    if target_tile_type == 'LEDGE_HOP_RIGHT' and dx != 1:\n        return False\n    if target_tile_type == 'LEDGE_HOP_LEFT' and dx != -1:\n        return False\n    if current_tile_type == 'FLOOR' and target_tile_type == 'FLOOR_UP_WALL':\n        return False\n    if target_tile_type == 'FLOOR_UP_WALL' and dy == -1:\n        return False\n    return True\n\ndef find_path_bfs(start_pos, end_pos, map_data):\n    if not start_pos or not end_pos:\n        return None\n    queue = deque([[start_pos]])\n    visited = {start_pos}\n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n        if (x, y) == end_pos:\n            return path\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = x + dx, y + dy\n            if (next_x, next_y) not in visited and is_passable(x, y, dx, dy, map_data):\n                visited.add((next_x, next_y))\n                new_path = list(path)\n                new_path.append((next_x, next_y))\n                queue.append(new_path)\n    return None\n\nmap_data = parse_map_xml(map_xml_string)\nstart_pos = map_data.get('player_pos')\ncoordinates_to_check_str = input_data.get('coordinates')\nreachable_tiles = []\nif start_pos and coordinates_to_check_str:\n    try:\n        coordinates_to_check = json.loads(coordinates_to_check_str)\n        for coord in coordinates_to_check:\n            target_x = int(coord['x'])\n            target_y = int(coord['y'])\n            if find_path_bfs(start_pos, (target_x, target_y), map_data):\n                reachable_tiles.append(coord)\n    except (json.JSONDecodeError, TypeError):\n        pass # Ignore errors in parsing\nprint(json.dumps(reachable_tiles))",
    "history": [
      {
        "commit_message": "feat: Create unseen_tile_checker tool. This tool automates the process of checking which unseen tiles from a system alert are actually reachable, streamlining exploration and preventing wasted turns trying to path to disconnected areas.",
        "timestamp": "2025-07-29T03:31:55.070Z",
        "action_counter": 15144
      }
    ]
  },
  "pathfinder": {
    "description": "A consolidated pathfinding tool. Finds the shortest path to a single target coordinate OR checks the reachability of a list of coordinates. Returns a path for a single target, or a list of reachable coordinates for a list.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string",
          "nullable": true
        },
        "target_y": {
          "type": "string",
          "nullable": true
        },
        "coordinates": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "x": {
                "type": "string"
              },
              "y": {
                "type": "string"
              }
            },
            "required": [
              "x",
              "y"
            ]
          },
          "nullable": true
        }
      }
    },
    "python_script": "import xml.et.ree.ElementTree as ET\nimport heapq\nimport json\n\ndef find_path(input_data, map_xml_string):\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.attrib['width'])\n        height = int(root.attrib['height'])\n        \n        player_pos = None\n        for r_idx, row_elem in enumerate(root.findall('Row')):\n            for c_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n                if tile_elem.find('Player') is not None:\n                    player_pos = (int(tile_elem.attrib['id']), int(row_elem.attrib['id']))\n                    break\n            if player_pos:\n                break\n        \n        if not player_pos:\n            return json.dumps({\"error\": \"Player position not found on the map.\"})\n\n        start_x, start_y = player_pos\n        \n        traversable_tiles = {\n            \"FLOOR\", \"TALL_GRASS\", \"LONG_GRASS\", \"DOOR\", \n            \"WARP_CARPET_DOWN\", \"LADDER\", \"CAVE\",\n            \"WARP_CARPET_RIGHT\", \"WARP_CARPET_LEFT\"\n        }\n        \n        one_way_down = {\"LEDGE_HOP_DOWN\"}\n        one_way_left = {\"LEDGE_HOP_LEFT\"}\n        one_way_right = {\"LEDGE_HOP_RIGHT\"}\n\n        grid = [[None for _ in range(width + 1)] for _ in range(height + 1)]\n        for r_idx, row_elem in enumerate(root.findall('Row')):\n            y = int(row_elem.attrib['id'])\n            for c_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n                x = int(tile_elem.attrib['id'])\n                tile_type = tile_elem.attrib.get('type')\n                has_object = tile_elem.attrib.get('has-object') == 'true'\n                \n                is_impassable = has_object and not (x == start_x and y == start_y)\n\n                if tile_type in traversable_tiles and not is_impassable:\n                    grid[y][x] = 1 # Traversable\n                elif tile_type in one_way_down and not is_impassable:\n                    grid[y][x] = 2 # One-way down\n                elif tile_type in one_way_left and not is_impassable:\n                    grid[y][x] = 3 # One-way left\n                elif tile_type in one_way_right and not is_impassable:\n                    grid[y][x] = 4 # One-way right\n                else:\n                    grid[y][x] = 0 # Wall or other impassable\n\n    except Exception as e:\n        return json.dumps({\"error\": f\"XML parsing failed: {str(e)}\"})\n\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def a_star(start, goal):\n        if not (1 <= goal[0] <= width and 1 <= goal[1] <= height):\n            return None\n        if grid[goal[1]][goal[0]] == 0:\n            neighbors_to_check = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n            found_adjacent = False\n            for dx, dy in neighbors_to_check:\n                nx, ny = goal[0] + dx, goal[1] + dy\n                if 1 <= nx <= width and 1 <= ny <= height and grid[ny][nx] != 0:\n                    found_adjacent = True\n                    break\n            if not found_adjacent:\n                return None\n        \n        frontier = [(0, start)]\n        came_from = {start: None}\n        cost_so_far = {start: 0}\n\n        while frontier:\n            _, current = heapq.heappop(frontier)\n\n            if heuristic(current, goal) <= 1:\n                path = []\n                temp = current\n                while temp is not None:\n                    path.append({\"x\": temp[0], \"y\": temp[1]})\n                    temp = came_from.get(temp)\n                path.reverse()\n                if current != goal:\n                    path.append({\"x\": goal[0], \"y\": goal[1]})\n                return path\n\n            for dx, dy, move_dir in [(0, 1, 'down'), (0, -1, 'up'), (1, 0, 'right'), (-1, 0, 'left')]:\n                next_node = (current[0] + dx, current[1] + dy)\n                if not (1 <= next_node[0] <= width and 1 <= next_node[1] <= height):\n                    continue\n\n                current_tile_type = grid[current[1]][current[0]]\n                next_tile_type = grid[next_node[1]][next_node[0]]\n                \n                can_move = False\n                if next_tile_type == 1:\n                    can_move = True\n                elif next_tile_type == 2 and move_dir == 'down':\n                    can_move = True\n                elif next_tile_type == 3 and move_dir == 'left':\n                    can_move = True\n                elif next_tile_type == 4 and move_dir == 'right':\n                    can_move = True\n\n                if can_move:\n                    new_cost = cost_so_far[current] + 1\n                    if next_node not in cost_so_far or new_cost < cost_so_far[next_node]:\n                        cost_so_far[next_node] = new_cost\n                        priority = new_cost + heuristic(goal, next_node)\n                        heapq.heappush(frontier, (priority, next_node))\n                        came_from[next_node] = current\n        return None\n\n    def check_reachability(start, coordinates):\n        reachable_coords = []\n        for coord in coordinates:\n            target_x = int(coord['x'])\n            target_y = int(coord['y'])\n            if a_star(start, (target_x, target_y)) is not None:\n                reachable_coords.append(coord)\n        return reachable_coords\n\n    target_x_str = input_data.get('target_x')\n    target_y_str = input_data.get('target_y')\n    coordinates_list = input_data.get('coordinates')\n\n    if target_x_str and target_y_str:\n        target_x = int(target_x_str)\n        target_y = int(target_y_str)\n        path = a_star((start_x, start_y), (target_x, target_y))\n        if path:\n            return json.dumps({\"status\": \"success\", \"path\": path})\n        else:\n            return json.dumps({\"status\": \"failure\", \"reason\": \"No path found to target.\"})\n    elif coordinates_list:\n        reachable = check_reachability((start_x, start_y), coordinates_list)\n        return json.dumps({\"status\": \"success\", \"reachable_coordinates\": reachable})\n    else:\n        return json.dumps({\"error\": \"Invalid input. Provide target_x/y or a list of coordinates.\"})\n\nprint(find_path(input_data, map_xml_string))",
    "history": [
      {
        "commit_message": "fix: Recreate tool to fix Python sandbox error. Previous attempts to redefine the tool failed. This action deletes and then re-defines the tool with the same proven script, hypothesizing that this will force a full reset of the sandbox environment and resolve the persistent system-level error.",
        "timestamp": "2025-07-29T05:50:04.418Z",
        "action_counter": 15184
      },
      {
        "commit_message": "fix: Recreate tool to fix Python sandbox error. Previous attempts to redefine the tool failed. This action deletes and then re-defines the tool with the same proven script, hypothesizing that this will force a full reset of the sandbox environment and resolve the persistent system-level error.",
        "timestamp": "2025-07-29T06:29:11.854Z",
        "action_counter": 15241
      }
    ]
  }
}