{
  "automated_explorer": {
    "description": "Finds the nearest reachable unseen tile and generates a path to an adjacent traversable tile. Now correctly handles water traversal with SURF, defeated trainers, and uses robust pathfinding logic.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\nimport json\n\ndef find_all_reachable_and_paths(start, grid, width, height, can_surf):\n    queue = collections.deque([start])\n    came_from = {start: None}\n    \n    while queue:\n        current = queue.popleft()\n        \n        for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = current[0] + move_x, current[1] + move_y\n            next_pos = (next_x, next_y)\n            \n            if not (1 <= next_x <= width and 1 <= next_y <= height):\n                continue\n            \n            if next_pos in came_from:\n                continue\n                \n            current_tile_info = grid.get(current, {})\n            next_tile_info = grid.get(next_pos, {})\n            next_tile_type = next_tile_info.get('type')\n            \n            if move_y == 1 and current_tile_info.get('type') != 'ledge' and next_tile_type == 'ledge':\n                ledge_jump_pos = (next_x, next_y + 1)\n                if ledge_jump_pos in came_from: continue\n                \n                ledge_jump_tile_info = grid.get(ledge_jump_pos, {})\n                if ledge_jump_tile_info.get('type') not in ['impassable', 'unknown']:\n                    came_from[next_pos] = current\n                    came_from[ledge_jump_pos] = next_pos\n                    queue.append(ledge_jump_pos)\n                continue\n\n            impassable_types = ['impassable', 'unknown']\n            if current_tile_info.get('type') != 'water':\n                 impassable_types.append('ledge')\n            \n            if next_tile_type in impassable_types:\n                continue\n\n            if next_tile_type == 'water' and not can_surf:\n                continue\n            \n            if next_tile_info.get('has_object') and next_tile_info.get('object_name') != 'Pikachu' and not next_tile_info.get('is_defeated_trainer', False):\n                continue\n\n            current_elevation = 'elevated' if current_tile_info.get('type') == 'elevated_ground' else 'ground'\n            next_elevation = 'elevated' if next_tile_type == 'elevated_ground' else 'ground'\n            if current_elevation != next_elevation and current_tile_info.get('type') not in ['steps', 'ladder_up', 'ladder_down'] and next_tile_type not in ['steps', 'ladder_up', 'ladder_down']:\n                continue\n            \n            came_from[next_pos] = current\n            queue.append(next_pos)\n            \n    return came_from\n\ndef reconstruct_path(came_from, end):\n    if end not in came_from:\n        return None\n    path = []\n    current = end\n    while current is not None:\n        path.append(list(current))\n        current = came_from.get(current)\n    return path[::-1]\n\ndef main():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        start_node = (start_x, start_y)\n        \n        party_info = root.find(\"Party\")\n        can_surf = False\n        if party_info is not None:\n            for pokemon in party_info.findall(\"Pokemon\"):\n                moves = pokemon.find(\"Moves\")\n                if moves is not None:\n                    for move in moves.findall(\"Move\"):\n                        if move.get(\"name\") == \"SURF\":\n                            can_surf = True\n                            break\n                if can_surf:\n                    break\n\n        grid = {}\n        unseen_tiles = []\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                \n                is_defeated = False\n                for marker in tile_elem.findall('Marker'):\n                    if marker.get('emoji') == '☠️':\n                        is_defeated = True\n                        break\n\n                grid[(x, y)] = {\n                    'type': tile_elem.get('type'),\n                    'has_object': tile_elem.get('has-object') == 'true',\n                    'object_name': tile_elem.find('Object').get('id-name') if tile_elem.find('Object') is not None else None,\n                    'is_defeated_trainer': is_defeated\n                }\n                if tile_elem.get('seen') == 'false':\n                    unseen_tiles.append((x, y))\n\n        if not unseen_tiles:\n            print(json.dumps({'status': 'success', 'message': 'No unseen tiles found.'}))\n            return\n\n        came_from = find_all_reachable_and_paths(start_node, grid, width, height, can_surf)\n        reachable_nodes = set(came_from.keys())\n        \n        targetable_unseen_tiles = []\n        for unseen_tile in unseen_tiles:\n            is_targetable = False\n            for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adj_x, adj_y = unseen_tile[0] + move_x, unseen_tile[1] + move_y\n                adj_pos = (adj_x, adj_y)\n                if adj_pos in reachable_nodes:\n                    is_targetable = True\n                    break\n            if is_targetable:\n                targetable_unseen_tiles.append(unseen_tile)\n\n        if not targetable_unseen_tiles:\n            print(json.dumps({'status': 'error', 'message': 'No unseen tiles are adjacent to reachable areas.', 'reachable_nodes_count': len(reachable_nodes)}))\n            return\n\n        shortest_path = None\n        target_unseen = None\n        \n        sorted_targets = sorted(targetable_unseen_tiles, key=lambda t: (abs(t[0] - start_x) + abs(t[1] - start_y)))\n\n        for tile in sorted_targets:\n            best_adj_path = None\n            for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adj_x, adj_y = tile[0] + move_x, tile[1] + move_y\n                adj_pos = (adj_x, adj_y)\n                if adj_pos in reachable_nodes:\n                    path = reconstruct_path(came_from, adj_pos)\n                    if path and (best_adj_path is None or len(path) < len(best_adj_path)):\n                        best_adj_path = path\n            \n            if best_adj_path:\n                shortest_path = best_adj_path\n                target_unseen = tile\n                break\n        \n        if shortest_path:\n            print(json.dumps({'status': 'success', 'path': shortest_path, 'target_unseen_tile': target_unseen}))\n        else:\n            print(json.dumps({'status': 'error', 'message': 'Could not find a path to any adjacent tile of any reachable unseen tiles.'}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'status': 'error', 'message': f'An exception occurred: {traceback.format_exc()}'}))\n\nmain()"
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map using the Breadth-First Search (BFS) algorithm. It considers tile types (including elevation, water), impassable objects (excluding Pikachu), and special ledge traversal rules. It now detects and reports if a destination is on an unreachable map segment. The output is a JSON string containing the path or debug info.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\nimport json\n\ndef find_path():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        start = (int(input_data['start_x']), int(input_data['start_y']))\n        end = (int(input_data['end_x']), int(input_data['end_y']))\n\n        grid = {}\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                object_name = None\n                if has_object:\n                    obj_elem = tile_elem.find('Object')\n                    if obj_elem is not None:\n                        object_name = obj_elem.get('id-name')\n                grid[(x, y)] = {'type': tile_type, 'has_object': has_object, 'object_name': object_name}\n\n        queue = collections.deque([[start]])\n        seen = {start}\n\n        while queue:\n            path = queue.popleft()\n            x, y = path[-1]\n\n            if (x, y) == end:\n                print(json.dumps({\"status\": \"success\", \"path\": path}))\n                return\n\n            for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                next_x, next_y = x + move_x, y + move_y\n                next_pos = (next_x, next_y)\n\n                if not (1 <= next_x <= width and 1 <= next_y <= height):\n                    continue\n\n                if next_pos in seen:\n                    continue\n\n                current_tile_info = grid.get((x,y), {})\n                next_tile_info = grid.get(next_pos, {})\n                next_tile_type = next_tile_info.get('type')\n\n                if move_y == 1 and current_tile_info.get('type') != 'ledge' and next_tile_type == 'ledge':\n                    ledge_jump_pos = (next_x, next_y + 1)\n                    if ledge_jump_pos in seen:\n                        continue\n                    ledge_jump_tile_info = grid.get(ledge_jump_pos, {})\n                    if ledge_jump_tile_info.get('type') not in ['impassable', 'unknown']:\n                        new_path = list(path)\n                        new_path.append(ledge_jump_pos)\n                        queue.append(new_path)\n                        seen.add(next_pos)\n                        seen.add(ledge_jump_pos)\n                    continue\n                \n                impassable_types = ['impassable', 'unknown', 'ledge']\n                if next_tile_type in impassable_types:\n                    continue\n\n                if next_pos != end and next_tile_info.get('has_object') and next_tile_info.get('object_name') != 'Pikachu':\n                    continue\n                \n                current_elevation = 'elevated' if current_tile_info.get('type') == 'elevated_ground' else 'ground'\n                next_elevation = 'elevated' if next_tile_type == 'elevated_ground' else 'ground'\n                if current_elevation != next_elevation and current_tile_info.get('type') != 'steps' and next_tile_type != 'steps':\n                    continue\n\n                seen.add(next_pos)\n                new_path = list(path)\n                new_path.append(next_pos)\n                queue.append(new_path)\n\n        if end in grid and end not in seen:\n            print(json.dumps({\"status\": \"error\", \"message\": \"No path found. The destination is on an unreachable segment of the map.\"}))\n        else:\n            print(json.dumps({\"status\": \"error\", \"message\": \"No path found. The destination may be invalid or blocked.\"}))\n    except Exception as e:\n        print(json.dumps({\"status\": \"error\", \"message\": str(e)}))\n\nfind_path()"
  },
  "wkg_edge_payload_generator": {
    "description": "A helper tool that generates the correct JSON payload for adding an edge to the World Knowledge Graph. It finds the required node IDs based on map and coordinate inputs, and correctly includes source/destination coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "source_map_id": {
          "type": "string"
        },
        "source_x": {
          "type": "string"
        },
        "source_y": {
          "type": "string"
        },
        "dest_map_id": {
          "type": "string"
        },
        "dest_x": {
          "type": "string"
        },
        "dest_y": {
          "type": "string"
        },
        "connection_type": {
          "type": "string"
        },
        "is_one_way": {
          "type": "string"
        },
        "destination_entry_point": {
          "type": "string"
        }
      },
      "required": [
        "source_map_id",
        "source_x",
        "source_y",
        "dest_map_id",
        "dest_x",
        "dest_y"
      ]
    },
    "python_script": "import json\n\ndef main():\n    try:\n        wkg = json.loads(world_knowledge_graph_json_string)\n        nodes = wkg.get('nodes', [])\n\n        source_map_id = input_data['source_map_id']\n        source_x = int(input_data['source_x'])\n        source_y = int(input_data['source_y'])\n        dest_map_id = input_data['dest_map_id']\n        dest_x = int(input_data['dest_x'])\n        dest_y = int(input_data['dest_y'])\n        connection_type = input_data.get('connection_type', 'map_edge')\n        is_one_way_str = input_data.get('is_one_way', 'false').lower()\n        is_one_way = is_one_way_str == 'true'\n        dest_entry_point_str = input_data.get('destination_entry_point')\n\n        source_node_id = None\n        dest_node_id = None\n\n        for node in nodes:\n            if node['map_id'] == source_map_id and node['coordinates']['x'] == source_x and node['coordinates']['y'] == source_y:\n                source_node_id = node['id']\n            if node['map_id'] == dest_map_id and node['coordinates']['x'] == dest_x and node['coordinates']['y'] == dest_y:\n                dest_node_id = node['id']\n            if source_node_id and dest_node_id:\n                break\n\n        if not source_node_id or not dest_node_id:\n            print(json.dumps({\"status\": \"error\", \"message\": \"One or both nodes not found in World Knowledge Graph.\"}))\n            return\n\n        payload = {\n            \"source_node_id\": source_node_id,\n            \"destination_node_id\": dest_node_id,\n            \"connection_type\": connection_type,\n            \"source_coordinates\": {\"map_id\": source_map_id, \"x\": source_x, \"y\": source_y},\n            \"destination_coordinates\": {\"map_id\": dest_map_id, \"x\": dest_x, \"y\": dest_y},\n            \"is_one_way\": is_one_way\n        }\n\n        if dest_entry_point_str and dest_entry_point_str.isdigit():\n            payload[\"destination_entry_point\"] = int(dest_entry_point_str)\n\n        print(json.dumps(payload))\n    except Exception as e:\n        print(json.dumps({\"status\": \"error\", \"message\": f\"An error occurred: {str(e)}\"}))\n\nmain()\n"
  },
  "wkg_pathfinder": {
    "description": "Calculates the shortest path between two maps in the World Knowledge Graph, returning a sequence of map IDs and warp coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_map_id": {
          "type": "string"
        },
        "end_map_id": {
          "type": "string"
        }
      },
      "required": [
        "start_map_id",
        "end_map_id"
      ]
    },
    "python_script": "import json\nfrom collections import deque\n\ndef find_wkg_path(start_map_id, end_map_id, wkg_json_string):\n    wkg = json.loads(wkg_json_string)\n    nodes = {node['id']: node for node in wkg['nodes']}\n    adj = {node_id: [] for node_id in nodes}\n    for edge in wkg['edges']:\n        adj[edge['source_node_id']].append(edge['destination_node_id'])\n        if not edge.get('is_one_way', False):\n            adj[edge['destination_node_id']].append(edge['source_node_id'])\n\n    start_nodes = [node_id for node_id, node in nodes.items() if node['map_id'] == start_map_id]\n    if not start_nodes:\n        print(json.dumps({'error': 'Start map not in WKG'}))\n        return\n\n    queue = deque([(node, [node]) for node in start_nodes])\n    visited = set(start_nodes)\n    \n    while queue:\n        current_node_id, path = queue.popleft()\n        current_map_id = nodes[current_node_id]['map_id']\n\n        if current_map_id == end_map_id:\n            result_path = []\n            for node_id in path:\n                node = nodes[node_id]\n                result_path.append({'map_id': node['map_id'], 'coordinates': node['coordinates']})\n            print(json.dumps({'path': result_path}))\n            return\n\n        for neighbor_id in adj.get(current_node_id, []):\n            if neighbor_id not in visited:\n                visited.add(neighbor_id)\n                new_path = list(path)\n                new_path.append(neighbor_id)\n                queue.append((neighbor_id, new_path))\n\n    print(json.dumps({'path': []}))\n\nfind_wkg_path(input_data['start_map_id'], input_data['end_map_id'], world_knowledge_graph_json_string)"
  }
}