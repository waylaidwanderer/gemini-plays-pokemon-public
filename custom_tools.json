{
  "unseen_tile_checker": {
    "description": "Analyzes the list of unseen tiles from a system alert and uses pathfinding logic to determine which are actually reachable from the player's current position.",
    "input_schema": {
      "type": "object",
      "properties": {
        "coordinates": {
          "type": "string",
          "description": "A stringified JSON array of coordinate objects, e.g., '[{\"x\":1,\"y\":2}]'"
        }
      },
      "required": [
        "coordinates"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\nimport json\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(start, goal, traversable, one_way_rules):\n    open_set = [(0 + heuristic(start, goal), 0, start)]\n    came_from = {}\n    g_score = {start: 0}\n\n    while open_set:\n        _, current_g, current_node = heapq.heappop(open_set)\n\n        if current_node == goal:\n            return True # Path found\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current_node[0] + dx, current_node[1] + dy)\n\n            if neighbor not in traversable and neighbor != goal: # Allow pathing to the goal even if it's not in the initial traversable set (e.g., unseen)\n                continue\n\n            if neighbor in one_way_rules:\n                allowed_from = one_way_rules[neighbor]\n                if (current_node[0] - neighbor[0], current_node[1] - neighbor[1]) != allowed_from:\n                    continue\n\n            tentative_g_score = current_g + 1\n\n            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                g_score[neighbor] = tentative_g_score\n                f_score = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_score, tentative_g_score, neighbor))\n                came_from[neighbor] = current_node\n\n    return False # No path found\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    player_x, player_y = -1, -1\n    traversable = set()\n    one_way_rules = {}\n\n    impassable_types = ['WALL', 'WINDOW', 'VOID', 'CUT_TREE', 'SIGN', 'BOOKSHELF', 'BLACKBOARD', 'MART_SHELF', 'BUOY', 'TV', 'TOWN_MAP', 'RADIO', 'INCENSE_BURNER', 'BIRD', 'HEADBUTT_TREE', 'FRUIT_TREE', 'COMPUTER', 'PRINTER', 'PC', 'COUNTER', 'CAVE']\n    one_way_types = {\n        'LEDGE_HOP_DOWN': (0, -1),\n        'LEDGE_HOP_LEFT': (1, 0),\n        'LEDGE_HOP_RIGHT': (-1, 0)\n    }\n\n    for row in root.findall('Row'):\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            y = int(row.get('id'))\n            tile_type = tile.get('type')\n\n            if tile.find('Player') is not None:\n                player_x, player_y = x, y\n\n            if tile_type not in impassable_types and tile.find('Object') is None:\n                traversable.add((x, y))\n                if tile_type in one_way_types:\n                    one_way_rules[(x, y)] = one_way_types[tile_type]\n\n    start_node = (player_x, player_y)\n    target_coordinates = json.loads(input_data['coordinates'])\n    reachable_tiles = []\n\n    if start_node == (-1, -1):\n        print('{\"error\": \"Player not found on the map.\"}')\n    else:\n        for coord in target_coordinates:\n            goal_node = (int(coord['x']), int(coord['y']))\n            if a_star_search(start_node, goal_node, traversable, one_way_rules):\n                reachable_tiles.append(coord)\n        print(json.dumps(reachable_tiles))\n\nexcept Exception as e:\n    print(f'{{\"error\": \"An unexpected error occurred in unseen_tile_checker: {str(e)}\"}}')\n",
    "history": [
      {
        "commit_message": "feat: Create unseen_tile_checker tool. This tool automates the process of checking which unseen tiles from a system alert are actually reachable, streamlining exploration and preventing wasted turns trying to path to disconnected areas.",
        "timestamp": "2025-07-29T03:31:55.070Z",
        "action_counter": 15144
      },
      {
        "commit_message": "feat: Create unseen_tile_checker tool. This tool automates the process of checking which unseen tiles from a system alert are actually reachable, streamlining exploration and preventing wasted turns trying to path to disconnected areas.",
        "timestamp": "2025-07-29T06:52:53.467Z",
        "action_counter": 15273
      }
    ]
  },
  "pathfinder": {
    "description": "Finds the shortest path from the player's current position to a target coordinate on the current map using the A* algorithm. It avoids impassable tiles and respects one-way traversal rules.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\n\ndef pathfinder(input_data):\n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n\n        root = ET.fromstring(map_xml_string)\n        player_pos = None\n        for tile in root.iter('Tile'):\n            if tile.find('Player') is not None:\n                player_pos = (int(tile.get('id')), int(tile.getparent().get('id')))\n                break\n        \n        if not player_pos:\n            print(\"Error: Player position not found.\")\n            return\n\n        start_node = (player_pos[0], player_pos[1])\n        target_node = (target_x, target_y)\n\n        def get_tile(x, y):\n            for row in root.findall('Row'):\n                if int(row.get('id')) == y:\n                    for tile in row.findall('Tile'):\n                        if int(tile.get('id')) == x:\n                            return tile\n            return None\n\n        traversable_tiles = ['FLOOR', 'TALL_GRASS', 'DOOR', 'WARP_CARPET_DOWN', 'LADDER', 'LEDGE_HOP_DOWN', 'LEDGE_HOP_RIGHT', 'LEDGE_HOP_LEFT', 'WARP_CARPET_RIGHT', 'WARP_CARPET_LEFT']\n\n        def is_traversable(x, y, from_x, from_y):\n            tile = get_tile(x, y)\n            if not tile or tile.get('type') == 'unseen': return False\n            if tile.find('Object') is not None: return False\n            \n            tile_type = tile.get('type')\n            if tile_type in ['WALL', 'WINDOW', 'VOID', 'CUT_TREE', 'SIGN', 'BOOKSHELF', 'BLACKBOARD', 'MART_SHELF', 'BUOY', 'TV', 'TOWN_MAP', 'RADIO', 'INCENSE_BURNER', 'BIRD', 'HEADBUTT_TREE', 'FRUIT_TREE', 'COMPUTER', 'PRINTER', 'COUNTER', 'CAVE']:\n                 return False\n\n            if tile_type == 'LEDGE_HOP_DOWN' and y < from_y: return False\n            if tile_type == 'LEDGE_HOP_RIGHT' and x < from_x: return False\n            if tile_type == 'LEDGE_HOP_LEFT' and x > from_x: return False\n            if tile_type == 'FLOOR_UP_WALL' and y > from_y: return False\n\n            return True\n\n        open_set = []\n        heapq.heappush(open_set, (0, start_node))\n        came_from = {}\n        g_score = {start_node: 0}\n        f_score = {start_node: abs(start_node[0] - target_node[0]) + abs(start_node[1] - target_node[1])}\n\n        while open_set:\n            _, current = heapq.heappop(open_set)\n\n            if current == target_node:\n                path = []\n                while current in came_from:\n                    path.append({'x': current[0], 'y': current[1]})\n                    current = came_from[current]\n                path.append({'x': start_node[0], 'y': start_node[1]})\n                print(path[::-1])\n                return\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                neighbor = (current[0] + dx, current[1] + dy)\n                if is_traversable(neighbor[0], neighbor[1], current[0], current[1]):\n                    tentative_g_score = g_score[current] + 1\n                    if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                        came_from[neighbor] = current\n                        g_score[neighbor] = tentative_g_score\n                        f_score[neighbor] = tentative_g_score + abs(neighbor[0] - target_node[0]) + abs(neighbor[1] - target_node[1])\n                        if neighbor not in [i[1] for i in open_set]:\n                            heapq.heappush(open_set, (f_score[neighbor], neighbor))\n        print('No path found')\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\npathfinder(input_data)",
    "history": [
      {
        "commit_message": "feat: Recreate pathfinder tool after deletion. This is an attempt to resolve the persistent sandbox error by forcing a complete reset of the tool's environment. The script itself remains unchanged as it was previously functional.",
        "timestamp": "2025-07-29T06:31:10.732Z",
        "action_counter": 15245
      },
      {
        "commit_message": "fix: Overhaul pathfinder script for robustness. The previous 'sandbox not running' error was likely a red herring for a script that was crashing silently. This revision adds comprehensive error handling with a try-except block, explicit type casting for input data, and refined logic for parsing the map XML and identifying traversable tiles. This should resolve the persistent failures and restore pathfinding functionality.",
        "timestamp": "2025-07-29T06:51:09.535Z",
        "action_counter": 15271
      },
      {
        "commit_message": "fix: Overhaul pathfinder script for robustness. The previous 'sandbox not running' error was likely a red herring for a script that was crashing silently. This revision adds comprehensive error handling with a try-except block, explicit type casting for input data, and refined logic for parsing the map XML and identifying traversable tiles. This should resolve the persistent failures and restore pathfinding functionality.",
        "timestamp": "2025-07-29T07:16:36.610Z",
        "action_counter": 15305
      }
    ]
  }
}