{
  "find_path_v2": {
    "description": "Calculates a path between two coordinates on the current map using BFS, accounting for walls, objects, and one-way tiles (ledges, floor-up-walls). Returns a list of button strings.",
    "input_schema": {
      "type": "object",
      "properties": {
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "type": "integer",
          "nullable": true
        },
        "start_y": {
          "type": "integer",
          "nullable": true
        },
        "can_surf": {
          "type": "boolean"
        }
      },
      "required": [
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef solve():\n    try:\n        # Use injected input_data dictionary\n        if 'input_data' not in globals():\n            print(json.dumps([\"Error: input_data not found\"]))\n            return\n            \n        data = input_data\n        end_x = int(data['end_x'])\n        end_y = int(data['end_y'])\n        start_x = data.get('start_x')\n        start_y = data.get('start_y')\n        can_surf = data.get('can_surf', False)\n        \n        root = ET.fromstring(map_xml_string)\n        map_width = int(root.get('width'))\n        map_height = int(root.get('height'))\n        \n        tiles = {}\n        player_coords = None\n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                x = int(tile.get('id'))\n                t_type = tile.get('type')\n                has_obj = tile.get('has-object') == 'true'\n                tiles[(x, y)] = {'type': t_type, 'has_obj': has_obj}\n                if tile.find('Player') is not None:\n                    player_coords = (x, y)\n\n        if start_x is None or start_y is None:\n            if player_coords:\n                start_x, start_y = player_coords\n            else:\n                print(json.dumps([\"Error: Player position not found\"]))\n                return\n\n        start = (int(start_x), int(start_y))\n        end = (end_x, end_y)\n        \n        if start == end:\n            print(json.dumps([]))\n            return\n\n        queue = deque([(start, [])])\n        visited = {start}\n        \n        while queue:\n            (curr_x, curr_y), path = queue.popleft()\n            \n            for dx, dy, btn in [(0, -1, \"Up\"), (0, 1, \"Down\"), (-1, 0, \"Left\"), (1, 0, \"Right\")]:\n                nx, ny = curr_x + dx, curr_y + dy\n                \n                if 0 <= nx < map_width and 0 <= ny < map_height:\n                    target_tile = tiles.get((nx, ny))\n                    if not target_tile: continue\n                    \n                    t_type = target_tile['type']\n                    has_obj = target_tile['has_obj']\n                    \n                    if (nx, ny) == end:\n                        print(json.dumps(path + [btn]))\n                        return\n\n                    impassable = [\"WALL\", \"MOUNTAIN\", \"HEADBUTT_TREE\", \"TREE\"]\n                    if t_type in impassable: continue\n                    if has_obj: continue \n                    if t_type == \"WATER\" and not can_surf: continue\n                    \n                    curr_tile_info = tiles.get((curr_x, curr_y))\n                    if not curr_tile_info: continue\n                    curr_tile_type = curr_tile_info['type']\n                    \n                    if curr_tile_type == \"LEDGE_HOP_DOWN\" and btn != \"Down\": continue\n                    if curr_tile_type == \"LEDGE_HOP_UP\" and btn != \"Up\": continue\n                    if curr_tile_type == \"LEDGE_HOP_LEFT\" and btn != \"Left\": continue\n                    if curr_tile_type == \"LEDGE_HOP_RIGHT\" and btn != \"Right\": continue\n                    \n                    if btn == \"Down\" and t_type == \"FLOOR_UP_WALL\": continue\n                    \n                    if (nx, ny) not in visited:\n                        visited.add((nx, ny))\n                        queue.append(((nx, ny), path + [btn]))\n                        \n        print(json.dumps([\"Error: No path found\"]))\n    except Exception as e:\n        print(json.dumps([f\"Error: {str(e)}\"]))\n\nsolve()",
    "history": [
      {
        "commit_message": "Refined find_path to use the globally available map_xml_string and removed it from input_schema. Fixed one-way logic and impassable types.",
        "timestamp": "2025-12-23T14:36:16.850Z",
        "action_counter": 14568
      },
      {
        "commit_message": "Updated find_path_v2 to automatically detect player position from map_xml_string if start_x/y are not provided. Added start_x/y to input_schema as optional properties.",
        "timestamp": "2025-12-23T14:37:43.655Z",
        "action_counter": 14570
      },
      {
        "commit_message": "Fixed a bug in find_path_v2 where the path reconstruction loop would never terminate if the start position was found, leading to a KeyError: (None, None). Also fixed start_x/y handling to properly detect player position from XML if not provided as arguments.",
        "timestamp": "2025-12-23T14:38:20.004Z",
        "action_counter": 14571
      },
      {
        "commit_message": "Corrected output format of find_path_v2 to return a flat list of coordinates, matching the expected input for the navigate tool.",
        "timestamp": "2025-12-23T14:41:01.719Z",
        "action_counter": 14573
      },
      {
        "commit_message": "Fixed a bug in path reconstruction where (None, None) was not correctly identified as the termination condition, causing a KeyError. Also improved player position detection.",
        "timestamp": "2025-12-23T14:54:49.565Z",
        "action_counter": 14596
      },
      {
        "commit_message": "Refined find_path_v2 to handle pathfinding more robustly, correctly detecting the player's position from the XML if not provided, and returning a list of coordinate objects suitable for the navigate tool's path_plan. Added checks for impassable tiles including HEADBUTT_TREE and WATER.",
        "timestamp": "2025-12-23T14:56:11.952Z",
        "action_counter": 14599
      },
      {
        "commit_message": "Fixing find_path_v2 to correctly return a JSON array of button strings when autopress_buttons is true, and ensuring it handles the end tile correctly even if it's marked as impassable (like an NPC).",
        "timestamp": "2025-12-23T17:23:41.688Z",
        "action_counter": 14852
      },
      {
        "commit_message": "Updating find_path_v2 to support an optional 'can_surf' parameter. When true, WATER tiles are treated as traversable. This allows for pathfinding across ponds and oceans when the player has a Pokemon with Surf.",
        "timestamp": "2025-12-23T18:04:50.520Z",
        "action_counter": 14936
      },
      {
        "commit_message": "Refined passable types and added better error handling for unreachable destinations.",
        "timestamp": "2025-12-23T20:52:10.769Z",
        "action_counter": 15273
      },
      {
        "commit_message": "Refined passable types, added better error handling, and fixed button output for overworld/menu navigation.",
        "timestamp": "2025-12-23T20:52:38.251Z",
        "action_counter": 15274
      },
      {
        "commit_message": "Reverted to returning coordinates for 'navigate' tool and added specific logic for FLOOR_UP_WALL one-way tiles.",
        "timestamp": "2025-12-23T20:54:14.377Z",
        "action_counter": 15278
      },
      {
        "commit_message": "Fix find_path_v2 to handle autopress_buttons correctly by returning a JSON array of button strings when enabled, and account for one-way tiles like LEDGE and FLOOR_UP_WALL.",
        "timestamp": "2025-12-23T21:48:39.009Z",
        "action_counter": 15375
      },
      {
        "commit_message": "Fix find_path_v2 to handle autopress_buttons correctly and add one-way tile logic for LEDGE and FLOOR_UP_WALL.",
        "timestamp": "2025-12-23T21:49:12.615Z",
        "action_counter": 15376
      },
      {
        "commit_message": "Fix find_path_v2 by removing the function wrapper and ensuring it prints the result directly to stdout, and refine traversable types to include CAVE and warps.",
        "timestamp": "2025-12-23T21:51:09.492Z",
        "action_counter": 15382
      },
      {
        "commit_message": "Refine find_path_v2 to handle traversable types more robustly (including LONG_GRASS), fix button output logic, and improve error reporting when no path is found.",
        "timestamp": "2025-12-23T21:52:41.372Z",
        "action_counter": 15383
      },
      {
        "commit_message": "Ensure all outputs of find_path_v2 are JSON-encoded arrays of strings to prevent parsing errors in the harness, and include WARP in the passable list.",
        "timestamp": "2025-12-23T21:55:48.757Z",
        "action_counter": 15387
      },
      {
        "commit_message": "Added can_surf parameter and updated pathfinding logic for ledges and one-way walls.",
        "timestamp": "2025-12-24T02:44:55.343Z",
        "action_counter": 16074
      },
      {
        "commit_message": "Fixed FLOOR_UP_WALL logic and improved ledge hopping.",
        "timestamp": "2025-12-24T02:48:02.495Z",
        "action_counter": 16081
      },
      {
        "commit_message": "Fixed FLOOR_UP_WALL logic to block Southward movement as verified on Route 42.",
        "timestamp": "2025-12-24T02:53:18.188Z",
        "action_counter": 16094
      },
      {
        "commit_message": "Fixed FLOOR_UP_WALL logic to block Northward entry.",
        "timestamp": "2025-12-24T02:56:43.743Z",
        "action_counter": 16101
      },
      {
        "commit_message": "Corrected FLOOR_UP_WALL logic to block Southward movement.",
        "timestamp": "2025-12-24T03:01:54.819Z",
        "action_counter": 16109
      },
      {
        "commit_message": "Finalized ledge and FLOOR_UP_WALL (Southward block) logic for accurate pathfinding.",
        "timestamp": "2025-12-24T03:26:52.936Z",
        "action_counter": 16154
      },
      {
        "commit_message": "Implement robust BFS pathfinding for overworld navigation, accounting for ledge directions and hypothetical floor-up-wall behavior.",
        "timestamp": "2025-12-24T04:03:42.841Z",
        "action_counter": 16231
      },
      {
        "commit_message": "Refine pathfinding logic: allow destination to be an object-occupied tile and ensure the start tile's object/impassable status doesn't block the initial step.",
        "timestamp": "2025-12-24T04:09:54.304Z",
        "action_counter": 16244
      },
      {
        "commit_message": "Fix IndexError by checking sys.argv length and improve player position detection.",
        "timestamp": "2025-12-24T04:16:01.527Z",
        "action_counter": 16258
      },
      {
        "commit_message": "Refine find_path_v2 to use the injected input_data dictionary instead of sys.argv, and improve error handling.",
        "timestamp": "2025-12-24T04:18:55.006Z",
        "action_counter": 16263
      }
    ]
  },
  "navigate_menu_v2": {
    "description": "Executes a sequence of button presses for menu navigation, allowing mixing of directional and action buttons. Includes support for pauses between presses.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The sequence of buttons and/or 'sleep <ms>' commands to execute."
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nprint(json.dumps(input_data.get(\"buttons\", [])))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-24T11:42:51.849Z",
        "action_counter": 17071
      }
    ]
  },
  "list_reachable_unseen_tiles": {
    "description": "Analyzes the mental map to find all unseen tiles that are directly adjacent to currently reachable walkable tiles.",
    "input_schema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ndef find_reachable_unseen(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    # Map coordinates to tile data\n    tiles = {}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tiles[(x, y)] = {\n                'type': tile.attrib['type'],\n                'seen': tile.attrib.get('seen') == 'true',\n                'is_warp': tile.attrib.get('is-warp') == 'true',\n                'has_player': tile.find('Player') is not None,\n                'has_object': tile.find('Object') is not None\n            }\n            \n    # Standard walkability\n    impassable = {'WALL', 'VOID', 'WATER_ROCKS', 'ROCK', 'HEADBUTT_TREE', 'CUT_TREE'}\n    \n    player_pos = next((pos for pos, data in tiles.items() if data['has_player']), None)\n    if not player_pos:\n        return []\n\n    # BFS to find reachable tiles\n    reachable = set()\n    queue = [player_pos]\n    reachable.add(player_pos)\n    \n    while queue:\n        cx, cy = queue.pop(0)\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) in tiles and (nx, ny) not in reachable:\n                tile_data = tiles[(nx, ny)]\n                # Check for walls, objects, and ledges\n                if tile_data['type'] not in impassable and not tile_data['has_object']:\n                    # Simplified ledge logic: cannot jump UP a ledge\n                    if tile_data['type'] == 'LEDGE_HOP_RIGHT' and dx != 1: continue\n                    if tile_data['type'] == 'LEDGE_HOP_LEFT' and dx != -1: continue\n                    if tile_data['type'] == 'LEDGE_HOP_DOWN' and dy != 1: continue\n                    if tile_data['type'] == 'LEDGE_HOP_UP' and dy != -1: continue\n                    \n                    reachable.add((nx, ny))\n                    queue.append((nx, ny))\n\n    # Find unseen tiles adjacent to reachable tiles\n    unseen_reachable = []\n    for rx, ry in reachable:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ux, uy = rx + dx, ry + dy\n            if (ux, uy) in tiles and not tiles[(ux, uy)]['seen']:\n                if (ux, uy) not in unseen_reachable:\n                    unseen_reachable.append((ux, uy))\n                    \n    return unseen_reachable\n\nreachable_unseen = find_reachable_unseen(map_xml_string)\nprint(json.dumps(reachable_unseen))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-24T12:31:03.855Z",
        "action_counter": 17141
      },
      {
        "commit_message": "Fixed typo in is_passable function (nx, ny -> x, y).",
        "timestamp": "2025-12-24T12:32:15.871Z",
        "action_counter": 17142
      },
      {
        "commit_message": "Fixed AttributeError by using a more robust method to find player position and row ID. Removed reliance on '..' which is not supported in ET.",
        "timestamp": "2025-12-24T12:33:34.492Z",
        "action_counter": 17144
      },
      {
        "commit_message": "Refined ledge logic and added comments.",
        "timestamp": "2025-12-24T19:15:11.477Z",
        "action_counter": 17891
      }
    ]
  },
  "navigate_fly_map": {
    "description": "Calculates the button sequence to move the cursor on the Johto FLY map between cities using the vertical cycling logic (Up/Down).",
    "input_schema": {
      "type": "object",
      "properties": {
        "current_city": {
          "type": "string",
          "description": "The city currently selected on the FLY map."
        },
        "target_city": {
          "type": "string",
          "description": "The city you want to fly to."
        }
      },
      "required": [
        "current_city",
        "target_city"
      ]
    },
    "python_script": "import json\n\ndef solve():\n    cities = [\n        \"New Bark Town\",\n        \"Cherrygrove City\",\n        \"Violet City\",\n        \"Azalea Town\",\n        \"Goldenrod City\",\n        \"Ecruteak City\",\n        \"Olivine City\",\n        \"Cianwood City\",\n        \"Mahogany Town\",\n        \"Lake of Rage\",\n        \"Blackthorn City\"\n    ]\n    start = input_data.get(\"current_city\")\n    target = input_data.get(\"target_city\")\n    if start not in cities or target not in cities or start == target:\n        print(json.dumps([]))\n        return\n    start_idx = cities.index(start)\n    target_idx = cities.index(target)\n    if target_idx > start_idx:\n        path = [\"Up\"] * (target_idx - start_idx)\n    else:\n        path = [\"Down\"] * (start_idx - target_idx)\n    print(json.dumps(path))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-24T14:06:36.256Z",
        "action_counter": 17301
      },
      {
        "commit_message": "Fixed IndexError by using a dictionary-based adjacency map and safer enumeration. Updated Johto FLY map connections based on observed cursor behavior.",
        "timestamp": "2025-12-24T14:21:17.157Z",
        "action_counter": 17342
      },
      {
        "commit_message": "Refined FLY map navigation to use the linear vertical cycle (Up/Down) based on observed behavior (New Bark -> Cherrygrove -> Violet -> Azalea -> Goldenrod -> Ecruteak).",
        "timestamp": "2025-12-24T14:48:39.533Z",
        "action_counter": 17401
      }
    ]
  },
  "pace_area": {
    "description": "Generates a sequence of button presses to move back and forth between two coordinates to trigger encounters or events.",
    "input_schema": {
      "properties": {
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "num_paces": {
          "description": "How many times to move back and forth",
          "type": "integer"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "num_paces"
      ],
      "type": "object"
    },
    "python_script": "import json\nimport sys\n\ndef pace():\n    try:\n        # The harness passes tool_args as a JSON string in the first argument\n        if len(sys.argv) < 2:\n            print(json.dumps([]))\n            return\n            \n        input_data = json.loads(sys.argv[1])\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        end_x = int(input_data.get('end_x', start_x))\n        end_y = int(input_data.get('end_y', start_y))\n        num_paces = int(input_data['num_paces'])\n        \n        buttons = []\n        \n        # Calculate steps to get from start to end\n        dx = end_x - start_x\n        dy = end_y - start_y\n        \n        move_to_end = []\n        if dx > 0: move_to_end += ['Right'] * dx\n        elif dx < 0: move_to_end += ['Left'] * abs(dx)\n        if dy > 0: move_to_end += ['Down'] * dy\n        elif dy < 0: move_to_end += ['Up'] * abs(dy)\n        \n        move_to_start = []\n        if dx > 0: move_to_start += ['Left'] * dx\n        elif dx < 0: move_to_start += ['Right'] * abs(dx)\n        if dy > 0: move_to_start += ['Up'] * dy\n        elif dy < 0: move_to_start += ['Down'] * abs(dy)\n        \n        # If no movement is specified, just alternate direction to look around\n        if not move_to_end:\n            move_to_end = ['Left']\n            move_to_start = ['Right']\n            \n        for _ in range(num_paces):\n            buttons += move_to_end\n            buttons += move_to_start\n            \n        print(json.dumps(buttons))\n    except Exception as e:\n        # Fallback or error reporting\n        print(json.dumps([]))\n\npace()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-24T17:52:55.120Z",
        "action_counter": 17762
      },
      {
        "commit_message": "Make pace_area more robust and actually move between two points.",
        "timestamp": "2025-12-24T18:17:17.205Z",
        "action_counter": 17800
      }
    ]
  }
}