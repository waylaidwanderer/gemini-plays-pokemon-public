{
  "find_path": {
    "description": "A consolidated pathfinding tool. Finds a path to specified X, Y coordinates. If no coordinates are provided, it finds a path to the nearest reachable unseen tile. It automatically paths to an adjacent tile if the target is impassable. It can now handle mixed traversal types (walking and surfing).",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string",
          "nullable": true
        },
        "end_y": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\ngrid = [['' for _ in range(width)] for _ in range(height)]\nimpassable_coords = set()\nunseen_tiles = []\n\nwalk_types = ['ground', 'grass', 'open_gate', 'cleared_boulder_barrier', 'boulder_switch', 'teleport', 'hole', 'spinner_stop', 'ladder_up', 'ladder_down', 'steps', 'cuttable']\nsurf_types = ['water']\ntraversable_tiles = set(walk_types + surf_types)\ntraversable_tiles.add('ledge')\n\nfor r_idx, row_elem in enumerate(root.findall('Row')):\n    y = int(row_elem.get('id')) - 1\n    for c_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n        x = int(tile_elem.get('id')) - 1\n        tile_type = tile_elem.get('type')\n        grid[y][x] = tile_type\n        if tile_elem.get('seen') == 'false':\n            unseen_tiles.append((x, y))\n        if tile_elem.find('Object') is not None and (tile_elem.find('Object').get('id-name') != 'Pikachu'):\n            impassable_coords.add((x, y))\n\nstart_x, start_y = int(input_data['start_x']) - 1, int(input_data['start_y']) - 1\nend_x = int(input_data.get('end_x', None)) - 1 if input_data.get('end_x') else None\nend_y = int(input_data.get('end_y', None)) - 1 if input_data.get('end_y') else None\n\ndef find_path_bfs():\n    start_tile_type = grid[start_y][start_x]\n    if start_tile_type not in traversable_tiles:\n        return []\n\n    queue = deque([((start_x, start_y), [(start_x, start_y)])])\n    visited = {(start_x, start_y)}\n\n    while queue:\n        (current_x, current_y), path = queue.popleft()\n\n        if end_x is not None and end_y is not None:\n            if grid[end_y][end_x] in traversable_tiles and (end_x, end_y) not in impassable_coords:\n                if current_x == end_x and current_y == end_y:\n                    return path\n            else:\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    if current_x == end_x + dx and current_y == end_y + dy:\n                        return path\n        else:\n            if not unseen_tiles:\n                return []\n            for ux, uy in unseen_tiles:\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    if current_x == ux + dx and current_y == uy + dy:\n                        return path\n\n        for move in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = current_x + move[0], current_y + move[1]\n\n            if not (0 <= next_x < width and 0 <= next_y < height):\n                continue\n\n            if (next_x, next_y) in visited or (next_x, next_y) in impassable_coords:\n                continue\n\n            next_tile_type = grid[next_y][next_x]\n            \n            if next_tile_type not in traversable_tiles:\n                continue\n\n            if next_tile_type == 'ledge':\n                if next_y > current_y:\n                    ledge_jump_y = next_y + 1\n                    if 0 <= ledge_jump_y < height and (next_x, ledge_jump_y) not in visited:\n                        if grid[ledge_jump_y][next_x] in traversable_tiles and (next_x, ledge_jump_y) not in impassable_coords:\n                            new_path = path + [(next_x, next_y), (next_x, ledge_jump_y)]\n                            visited.add((next_x, next_y))\n                            visited.add((next_x, ledge_jump_y))\n                            queue.append(((next_x, ledge_jump_y), new_path))\n                continue\n            \n            visited.add((next_x, next_y))\n            new_path = path + [(next_x, next_y)]\n            queue.append(((next_x, next_y), new_path))\n            \n    return []\n\nfound_path = find_path_bfs()\n\nif found_path:\n    path_plan = [{'x': x + 1, 'y': y + 1} for x, y in found_path]\n    target_x, target_y = path_plan[-1]['x'], path_plan[-1]['y']\n    reasoning = f'Path found to target at ({target_x}, {target_y}).'\n    print(json.dumps({'path': path_plan, 'reasoning': reasoning}))\nelse:\n    print(json.dumps({'path': [], 'reasoning': 'Could not find a path to any reachable targets.'}))"
  },
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "import json\nattacker = input_data['attacker_type']\ndefender1 = input_data['defender_type1']\ndefender2 = input_data.get('defender_type2')\neffectiveness = input_data['effectiveness']\n\ndefender_str = defender1\nif defender2 and defender2 != 'null':\n    defender_str += f'/{defender2}'\n\nif effectiveness == 'super effective':\n    log_string = f'- {attacker} > {defender_str}'\nelif effectiveness == 'not very effective':\n    log_string = f'- {attacker} !> {defender_str}'\nelse:\n    log_string = f'- {defender_str} immune to {attacker}'\n\nprint(json.dumps({'formatted_log': log_string}))"
  }
}