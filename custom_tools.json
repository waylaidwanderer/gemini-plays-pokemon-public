{
  "find_path_v2": {
    "description": "Finds the shortest path between two coordinates on the current map using BFS, considering walls, objects, and hazardous tiles (pits/ladders) as obstacles. Returns a JSON array of buttons.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "description": "If true and the tool returns a list of buttons, they will be pressed automatically.",
          "type": "boolean"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "autopress_buttons"
      ],
      "type": "object"
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef solve():\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    \n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            grid[(x, y)] = tile.attrib['type']\n            \n    impassable = {'WALL', 'unseen', 'FLOOR_UP_WALL', 'WATER', 'PIT'}\n    \n    queue = deque([(start_x, start_y, [])])\n    visited = {(start_x, start_y)}\n    \n    while queue:\n        x, y, path = queue.popleft()\n        \n        if x == end_x and y == end_y:\n            print(json.dumps(path))\n            return\n\n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) in grid and (nx, ny) not in visited:\n                tile_type = grid[(nx, ny)]\n                if tile_type not in impassable:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, path + [btn]))\n\n    print(json.dumps([]))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T20:27:16.465Z",
        "action_counter": 29425
      },
      {
        "commit_message": "Refined to correctly identify objects using 'has-object' attribute and added logic for boulder bridges in pits.",
        "timestamp": "2025-12-28T20:30:14.390Z",
        "action_counter": 29431
      },
      {
        "commit_message": "Refined to correctly handle autopress_buttons by outputting button strings and fixed pathfinding logic for boulder bridges.",
        "timestamp": "2025-12-28T20:30:50.776Z",
        "action_counter": 29432
      },
      {
        "commit_message": "Refined to handle boulder bridges in Blackthorn Gym 1F and improved object detection.",
        "timestamp": "2025-12-28T20:47:40.334Z",
        "action_counter": 29458
      },
      {
        "commit_message": "Fixing missing commit message and improving tile passability logic.",
        "timestamp": "2025-12-28T22:59:48.479Z",
        "action_counter": 29673
      },
      {
        "commit_message": "Fix find_path_v2 by providing a commit message and using input_data correctly.",
        "timestamp": "2025-12-29T03:29:03.821Z",
        "action_counter": 30041
      },
      {
        "commit_message": "Refine find_path_v2 to treat PIT and LADDER tiles as obstacles by default to prevent accidental warps, unless they are the intended destination.",
        "timestamp": "2025-12-29T04:09:14.393Z",
        "action_counter": 30092
      },
      {
        "commit_message": "Refine find_path_v2 to treat all warp tiles (PIT, LADDER) as obstacles unless they are the specific destination, and correctly identify objects using 'has-object'.",
        "timestamp": "2025-12-29T04:10:34.909Z",
        "action_counter": 30094
      },
      {
        "commit_message": "Initial definition with ledge handling.",
        "timestamp": "2026-01-06T20:56:57.721Z",
        "action_counter": 30778
      },
      {
        "commit_message": "Added commit message to update tool.",
        "timestamp": "2026-01-06T21:16:09.438Z",
        "action_counter": 30812
      }
    ]
  },
  "get_type_effectiveness": {
    "description": "Returns the type effectiveness multiplier for an attacking type against one or more defending types.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attack_type": {
          "type": "string"
        },
        "defender_types": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "attack_type",
        "defender_types"
      ]
    },
    "python_script": "import json\n\ndef solve():\n    type_chart = {\n        \"Normal\": {\"Rock\": 0.5, \"Ghost\": 0, \"Steel\": 0.5},\n        \"Fire\": {\"Fire\": 0.5, \"Water\": 0.5, \"Grass\": 2, \"Ice\": 2, \"Bug\": 2, \"Rock\": 0.5, \"Dragon\": 0.5, \"Steel\": 2},\n        \"Water\": {\"Fire\": 2, \"Water\": 0.5, \"Grass\": 0.5, \"Ground\": 2, \"Rock\": 2, \"Dragon\": 0.5},\n        \"Electric\": {\"Water\": 2, \"Electric\": 0.5, \"Grass\": 0.5, \"Ground\": 0, \"Flying\": 2, \"Dragon\": 0.5},\n        \"Grass\": {\"Fire\": 0.5, \"Water\": 2, \"Grass\": 0.5, \"Poison\": 0.5, \"Ground\": 2, \"Flying\": 0.5, \"Bug\": 0.5, \"Rock\": 2, \"Dragon\": 0.5, \"Steel\": 0.5},\n        \"Ice\": {\"Fire\": 0.5, \"Water\": 0.5, \"Grass\": 2, \"Ice\": 0.5, \"Ground\": 2, \"Flying\": 2, \"Dragon\": 2, \"Steel\": 0.5},\n        \"Fighting\": {\"Normal\": 2, \"Ice\": 2, \"Poison\": 0.5, \"Flying\": 0.5, \"Psychic\": 0.5, \"Bug\": 0.5, \"Rock\": 2, \"Ghost\": 0, \"Dark\": 2, \"Steel\": 2},\n        \"Poison\": {\"Grass\": 2, \"Poison\": 0.5, \"Ground\": 0.5, \"Bug\": 0.5, \"Rock\": 0.5, \"Ghost\": 0.5, \"Steel\": 0},\n        \"Ground\": {\"Fire\": 2, \"Electric\": 2, \"Grass\": 0.5, \"Poison\": 2, \"Flying\": 0, \"Bug\": 0.5, \"Rock\": 2, \"Steel\": 2},\n        \"Flying\": {\"Electric\": 0.5, \"Grass\": 2, \"Fighting\": 2, \"Bug\": 2, \"Rock\": 0.5, \"Steel\": 0.5},\n        \"Psychic\": {\"Fighting\": 2, \"Poison\": 2, \"Psychic\": 0.5, \"Dark\": 0, \"Steel\": 0.5},\n        \"Bug\": {\"Fire\": 0.5, \"Grass\": 2, \"Fighting\": 0.5, \"Poison\": 0.5, \"Flying\": 0.5, \"Psychic\": 2, \"Ghost\": 0.5, \"Dark\": 2, \"Steel\": 0.5},\n        \"Rock\": {\"Fire\": 2, \"Ice\": 2, \"Fighting\": 0.5, \"Ground\": 0.5, \"Flying\": 2, \"Bug\": 2, \"Steel\": 0.5},\n        \"Ghost\": {\"Normal\": 0, \"Psychic\": 2, \"Ghost\": 2, \"Dark\": 0.5, \"Steel\": 0.5},\n        \"Dragon\": {\"Dragon\": 2, \"Steel\": 0.5},\n        \"Dark\": {\"Fighting\": 0.5, \"Psychic\": 2, \"Ghost\": 2, \"Dark\": 0.5, \"Steel\": 0.5},\n        \"Steel\": {\"Fire\": 0.5, \"Water\": 0.5, \"Electric\": 0.5, \"Ice\": 2, \"Rock\": 2, \"Steel\": 0.5}\n    }\n    \n    attack_type = input_data['attack_type']\n    defender_types = input_data['defender_types']\n    \n    multiplier = 1.0\n    for def_type in defender_types:\n        multiplier *= type_chart.get(attack_type, {}).get(def_type, 1.0)\n        \n    print(multiplier)\n\nsolve()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-29T09:15:53.174Z",
        "action_counter": 30566
      },
      {
        "commit_message": "Initial definition with Gen 2 types.",
        "timestamp": "2026-01-06T20:56:57.722Z",
        "action_counter": 30778
      }
    ]
  },
  "press_menu_buttons": {
    "description": "Presses a sequence of buttons to navigate menus, bypassing the directional/action mixing restriction. Use for menu navigation ONLY. Returns the sequence of buttons as a JSON array.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nprint(json.dumps(input_data['buttons']))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-29T01:56:30.654Z",
        "action_counter": 29934
      }
    ]
  },
  "switch_to_pokemon_v2": {
    "description": "Navigates the party menu to switch to a specific Pokémon during battle. Assumes the party menu is open and the cursor is on the first Pokémon.",
    "input_schema": {
      "type": "object",
      "properties": {
        "party_index": {
          "type": "integer",
          "description": "The 1-indexed position of the Pokémon to switch to."
        }
      },
      "required": [
        "party_index"
      ]
    },
    "python_script": "import json\nindex = int(input_data['party_index'])\n# Assuming cursor starts at 1\ndiff = index - 1\nbuttons = [\"Down\"] * diff + [\"A\", \"A\"]\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-29T09:08:35.371Z",
        "action_counter": 30552
      }
    ]
  },
  "use_item_from_bag_v2": {
    "description": "Calculates the button sequence to use an item from a specific bag pocket on a Pokémon. Assumes the bag is open and the cursor is at the top of the 'Items' pocket. Pockets: Items, Balls, Key Items, TM/HM.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory": {
          "description": "The current items list from Game State for the target pocket.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "pokemon_index": {
          "description": "The 1-indexed position of the Pokémon in the party.",
          "type": "integer"
        },
        "target_item": {
          "description": "The name of the item to use (e.g., 'HYPER POTION').",
          "type": "string"
        },
        "target_pocket": {
          "description": "The pocket where the item is located.",
          "enum": [
            "Items",
            "Balls",
            "Key Items",
            "TM/HM"
          ],
          "type": "string"
        }
      },
      "required": [
        "inventory",
        "target_item",
        "pokemon_index",
        "target_pocket"
      ]
    },
    "python_script": "import json\n\nitems = input_data['inventory']\ntarget = input_data['target_item'].upper()\npkmn_idx = int(input_data['pokemon_index'])\ntarget_pocket = input_data['target_pocket']\n\n# Pocket order: Items <-> Balls <-> Key Items <-> TM/HM\npockets = [\"Items\", \"Balls\", \"Key Items\", \"TM/HM\"]\ntarget_pocket_idx = pockets.index(target_pocket)\n# Current pocket is assumed to be Items (index 0)\npocket_diff = target_pocket_idx - 0\n\nbuttons = []\nif pocket_diff > 0:\n    buttons += [\"Right\"] * pocket_diff\nelif pocket_diff < 0:\n    buttons += [\"Left\"] * abs(pocket_diff)\n\ntarget_idx = -1\nfor i, item_str in enumerate(items):\n    if target in item_str.upper():\n        target_idx = i\n        break\n\nif target_idx == -1:\n    print(json.dumps([]))\nelse:\n    buttons += [\"Down\"] * target_idx + [\"A\", \"A\"]\n    buttons += [\"Down\"] * (pkmn_idx - 1) + [\"A\"]\n    print(json.dumps(buttons))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-06T19:29:13.516Z",
        "action_counter": 30642
      }
    ]
  }
}