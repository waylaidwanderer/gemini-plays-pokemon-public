{
  "find_path": {
    "description": "Finds the shortest path between two points on the current map using BFS. It avoids walls, impassable trees, and correctly handles one-way ledges.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef find_path_logic():\n    try:\n        root = ET.fromstring(map_xml_string)\n        grid = {}\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.attrib['id'])\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.attrib['id'])\n                grid[(x, y)] = tile_elem.attrib['type']\n    except Exception:\n        print(\"Error: Could not parse map XML.\")\n        return\n\n    base_walkable = ['FLOOR', 'TALL_GRASS', 'unseen']\n    impassable = ['WALL', 'HEADBUTT_TREE', 'CUT_TREE']\n\n    try:\n        start_x, start_y = int(input_data['start_x']), int(input_data['start_y'])\n        end_x, end_y = int(input_data['end_x']), int(input_data['end_y'])\n        start, end = (start_x, start_y), (end_x, end_y)\n    except (KeyError, ValueError):\n        print(\"Error: Invalid input coordinates.\")\n        return\n\n    if not (start in grid and end in grid):\n        print(\"Error: Coordinates are out of bounds.\")\n        return\n\n    queue = deque([(start, [start])])\n    visited = {start}\n\n    while queue:\n        (current_pos, path) = queue.popleft()\n        x, y = current_pos\n\n        if current_pos == end:\n            print(json.dumps(path))\n            return\n\n        for dx, dy, move_dir in [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n            neighbor = (x + dx, y + dy)\n\n            if neighbor in grid and neighbor not in visited:\n                neighbor_type = grid.get(neighbor, 'unseen')\n                if neighbor_type in impassable:\n                    continue\n                \n                is_valid_move = False\n                if neighbor_type in base_walkable:\n                    is_valid_move = True\n                elif move_dir == 'Down' and 'LEDGE' in neighbor_type:\n                    is_valid_move = True\n                elif move_dir == 'Right' and 'RIGHT_LEDGE' in neighbor_type:\n                    is_valid_move = True\n                elif move_dir == 'Left' and 'LEFT_LEDGE' in neighbor_type:\n                    is_valid_move = True\n\n                if is_valid_move:\n                    visited.add(neighbor)\n                    new_path = list(path)\n                    new_path.append(neighbor)\n                    queue.append((neighbor, new_path))\n    \n    print(\"No path found.\")\n\nfind_path_logic()"
  }
}