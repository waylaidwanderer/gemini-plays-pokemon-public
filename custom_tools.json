{
  "find_path": {
    "description": "Finds the shortest path between two points on the current map using Breadth-First Search (BFS). It considers traversable tile types and avoids impassable ones. The output is a list of coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef find_path():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.attrib['width'])\n        height = int(root.attrib['height'])\n        \n        grid = []\n        for y, row_elem in enumerate(root.findall('Row')):\n            row = []\n            for x, tile_elem in enumerate(row_elem.findall('Tile')):\n                traversable_types = ['TYPE_3fe2']\n                tile_type = tile_elem.attrib['type']\n                is_traversable = tile_type in traversable_types\n                row.append(is_traversable)\n            grid.append(row)\n\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        end_x = int(input_data['end_x'])\n        end_y = int(input_data['end_y'])\n\n        if not (0 <= start_x < width and 0 <= start_y < height and 0 <= end_x < width and 0 <= end_y < height):\n            print(json.dumps({\"error\": \"Start or end coordinates are out of bounds.\"}))\n            return\n\n        if not grid[start_y][start_x]:\n            print(json.dumps({\"error\": \"Start position is on an impassable tile.\"}))\n            return\n        \n        if not grid[end_y][end_x]:\n            print(json.dumps({\"error\": \"End position is on an impassable tile.\"}))\n            return\n\n        queue = deque([[(start_x, start_y)]])\n        visited = set([(start_x, start_y)])\n\n        while queue:\n            path = queue.popleft()\n            x, y = path[-1]\n\n            if (x, y) == (end_x, end_y):\n                print(json.dumps([{\"x\": px, \"y\": py} for px, py in path]))\n                return\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < width and 0 <= ny < height and grid[ny][nx] and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    new_path = list(path)\n                    new_path.append((nx, ny))\n                    queue.append(new_path)\n        \n        print(json.dumps(None))\n\n    except Exception as e:\n        print(json.dumps({\"error\": str(e)}))\n\nfind_path()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-01T00:45:55.201Z",
        "action_counter": 156
      }
    ]
  }
}