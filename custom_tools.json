{
  "automated_explorer": {
    "description": "Finds the nearest reachable unseen tile and generates a path to an adjacent traversable tile. Now correctly handles water traversal by checking for SURF capability and planning paths across water even when not currently surfing. Accepts a 'can_surf' parameter.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "can_surf": {
          "type": "string",
          "enum": [
            "true",
            "false"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "can_surf"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\nimport json\n\ndef find_all_reachable_and_paths(start, grid, width, height, can_surf):\n    queue = collections.deque([(start, grid.get(start, {}).get('type') == 'water')])\n    came_from = {start: None}\n    \n    while queue:\n        (current, is_surfing_state) = queue.popleft()\n        \n        for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = current[0] + move_x, current[1] + move_y\n            next_pos = (next_x, next_y)\n            \n            if not (1 <= next_x <= width and 1 <= next_y <= height):\n                continue\n            \n            if next_pos in came_from:\n                continue\n                \n            current_tile_info = grid.get(current, {})\n            next_tile_info = grid.get(next_pos, {})\n            next_tile_type = next_tile_info.get('type')\n            \n            if move_y == 1 and current_tile_info.get('type') != 'ledge' and next_tile_type == 'ledge':\n                ledge_jump_pos = (next_x, next_y + 1)\n                if ledge_jump_pos in came_from: continue\n                if grid.get(ledge_jump_pos, {}).get('type') not in ['impassable', 'unknown']:\n                    came_from[next_pos] = current\n                    came_from[ledge_jump_pos] = next_pos\n                    queue.append((ledge_jump_pos, is_surfing_state))\n                continue\n\n            impassable_types = ['impassable', 'unknown', 'closed_gate']\n            if next_tile_type == 'ledge':\n                 if current_tile_info.get('type') != 'water' and move_y != 1:\n                    continue\n            \n            if next_tile_type in impassable_types:\n                continue\n\n            if next_tile_type == 'water' and not (is_surfing_state or can_surf):\n                continue\n            \n            if next_tile_info.get('has_object') and next_tile_info.get('object_name') != 'Pikachu':\n                continue\n\n            current_elevation = 'elevated' if current_tile_info.get('type') == 'elevated_ground' else 'ground'\n            next_elevation = 'elevated' if next_tile_type == 'elevated_ground' else 'ground'\n            if current_elevation != next_elevation and current_tile_info.get('type') not in ['steps', 'ladder_up', 'ladder_down'] and next_tile_type not in ['steps', 'ladder_up', 'ladder_down']:\n                continue\n            \n            came_from[next_pos] = current\n            queue.append((next_pos, next_tile_type == 'water'))\n            \n    return came_from\n\ndef reconstruct_path(came_from, end):\n    if end not in came_from:\n        return None\n    path = []\n    current = end\n    while current is not None:\n        path.append(list(current))\n        current = came_from.get(current)\n    return path[::-1]\n\ndef main():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        start_node = (start_x, start_y)\n        can_surf = input_data['can_surf'] == 'true'\n\n        grid = {}\n        unseen_tiles = []\n\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                grid[(x, y)] = {\n                    'type': tile_elem.get('type'),\n                    'has_object': tile_elem.get('has-object') == 'true',\n                    'object_name': tile_elem.find('Object').get('id-name') if tile_elem.find('Object') is not None else None\n                }\n                if tile_elem.get('seen') == 'false':\n                    unseen_tiles.append((x, y))\n\n        if not unseen_tiles:\n            print(json.dumps({'status': 'success', 'message': 'No unseen tiles found.'}))\n            return\n\n        came_from = find_all_reachable_and_paths(start_node, grid, width, height, can_surf)\n        reachable_nodes = set(came_from.keys())\n        \n        targetable_unseen_tiles = [tile for tile in unseen_tiles if any((tile[0] + dx, tile[1] + dy) in reachable_nodes for dx, dy in [(0,1),(0,-1),(1,0),(-1,0)])]\n\n        if not targetable_unseen_tiles:\n            print(json.dumps({'status': 'error', 'message': 'No unseen tiles are adjacent to reachable areas.', 'reachable_nodes_count': len(reachable_nodes)}))\n            return\n\n        shortest_path = None\n        target_unseen = None\n        \n        sorted_targets = sorted(targetable_unseen_tiles, key=lambda t: (abs(t[0] - start_x) + abs(t[1] - start_y)))\n\n        for tile in sorted_targets:\n            best_adj_path = None\n            for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adj_x, adj_y = tile[0] + move_x, tile[1] + move_y\n                adj_pos = (adj_x, adj_y)\n                if adj_pos in reachable_nodes:\n                    path = reconstruct_path(came_from, adj_pos)\n                    if path and (best_adj_path is None or len(path) < len(best_adj_path)):\n                        best_adj_path = path\n            \n            if best_adj_path:\n                shortest_path = best_adj_path\n                target_unseen = tile\n                break\n        \n        if shortest_path:\n            print(json.dumps({'status': 'success', 'path': shortest_path, 'target_unseen_tile': target_unseen}))\n        else:\n            print(json.dumps({'status': 'error', 'message': 'Could not find a path to any adjacent tile of any reachable unseen tiles.'}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'status': 'error', 'message': f'An exception occurred: {traceback.format_exc()}'}))\n\nmain()"
  },
  "find_wkg_node_by_coords": {
    "description": "Finds a World Knowledge Graph node ID by map ID and coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "map_id": {
          "type": "string"
        },
        "x": {
          "type": "string"
        },
        "y": {
          "type": "string"
        }
      },
      "required": [
        "map_id",
        "x",
        "y"
      ]
    },
    "python_script": "import json\n\ndef find_node():\n    try:\n        wkg = json.loads(world_knowledge_graph_json_string)\n        target_map_id = input_data['map_id']\n        target_x = int(input_data['x'])\n        target_y = int(input_data['y'])\n\n        for node in wkg['nodes']:\n            if str(node['map_id']) == str(target_map_id) and node['coordinates']['x'] == target_x and node['coordinates']['y'] == target_y:\n                print(json.dumps({'status': 'success', 'node_id': node['id']}))\n                return\n        \n        print(json.dumps({'status': 'error', 'message': f'Node not found on map {target_map_id} at ({target_x}, {target_y}).'}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'status': 'error', 'message': f'An exception occurred: {traceback.format_exc()}'}))\n\nfind_node()"
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map. It now correctly handles impassable tiles, dynamic transitions between walking and surfing, and navigates ledges.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "is_surfing": {
          "type": "string",
          "enum": [
            "true",
            "false"
          ]
        },
        "can_surf": {
          "type": "string",
          "enum": [
            "true",
            "false"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "is_surfing",
        "can_surf"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\nimport json\n\ndef pathfinder(start_x, start_y, end_x, end_y, is_surfing, can_surf):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    grid = [[None for _ in range(width + 1)] for _ in range(height + 1)]\n    \n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        if not (1 <= y <= height): continue\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id'])\n            if not (1 <= x <= width): continue\n            grid[y][x] = tile_elem\n\n    target_coords = (end_x, end_y)\n    traversable_walk = ['ground', 'grass', 'cleared_boulder_barrier', 'open_gate', 'steps', 'ladder_up', 'ladder_down', 'teleport', 'hole']\n    traversable_surf = ['water']\n\n    def is_tile_enterable(x, y):\n        if not (1 <= x <= width and 1 <= y <= height): return (False, None)\n        tile = grid[y][x]\n        if tile is None: return (False, None)\n        \n        object_on_tile = tile.find('Object')\n        if object_on_tile is not None:\n            obj_name = object_on_tile.attrib.get('id-name')\n            if obj_name != 'Pikachu' and (x, y) != target_coords:\n                return (False, None)\n\n        tile_type = tile.attrib.get('type', 'unknown')\n        is_warp = tile.attrib.get('is-warp') == 'true'\n        \n        if tile_type in traversable_surf: return (can_surf, 'surf')\n        if tile_type in traversable_walk or is_warp: return (True, 'walk')\n        return (False, None)\n\n    def get_neighbors(x, y, current_is_surfing):\n        neighbors = []\n        for dx, dy, move in [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n            nx, ny = x + dx, y + dy\n            if not (1 <= nx <= width and 1 <= ny <= height): continue\n\n            tile = grid[ny][nx]\n            if tile is None: continue\n            tile_type = tile.attrib.get('type')\n\n            if tile_type == 'ledge':\n                if dy == 1 and not current_is_surfing:\n                    ledge_landing_y = ny + 1\n                    enterable, _ = is_tile_enterable(nx, ledge_landing_y)\n                    if 1 <= ledge_landing_y <= height and enterable:\n                        neighbors.append(((nx, ledge_landing_y), move, False))\n                continue\n\n            enterable, terrain_type = is_tile_enterable(nx, ny)\n            if not enterable:\n                continue\n\n            next_surfing_state = (terrain_type == 'surf')\n            neighbors.append(((nx, ny), move, next_surfing_state))\n        return neighbors\n\n    potential_ends = []\n    end_enterable, _ = is_tile_enterable(end_x, end_y)\n    if end_enterable:\n        potential_ends.append(target_coords)\n    else:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_x, adj_y = target_coords[0] + dx, target_coords[1] + dy\n            adj_enterable, _ = is_tile_enterable(adj_x, adj_y)\n            if adj_enterable:\n                potential_ends.append((adj_x, adj_y))\n\n    if not potential_ends:\n        print(json.dumps([]))\n        return\n\n    start_node = (start_x, start_y)\n    queue = collections.deque([(start_node, [], is_surfing)])\n    visited = set([(start_node, is_surfing)])\n\n    while queue:\n        (current_pos, moves, current_surfing_state) = queue.popleft()\n        if current_pos in potential_ends:\n            print(json.dumps(moves))\n            return\n        for neighbor_pos, move, next_surfing_state in get_neighbors(current_pos[0], current_pos[1], current_surfing_state):\n            if (neighbor_pos, next_surfing_state) not in visited:\n                visited.add((neighbor_pos, next_surfing_state))\n                new_moves = list(moves)\n                new_moves.append(move)\n                queue.append((neighbor_pos, new_moves, next_surfing_state))\n\n    print(json.dumps([]))\n\npathfinder(int(input_data['start_x']), int(input_data['start_y']), int(input_data['end_x']), int(input_data['end_y']), input_data['is_surfing'] == 'true', input_data['can_surf'] == 'true')\n"
  },
  "wkg_updater": {
    "description": "Checks if WKG nodes and an edge for a transition exist. If not, it prints the necessary `manage_world_knowledge` tool calls to create them.",
    "input_schema": {
      "type": "object",
      "properties": {
        "source_map_id": {
          "type": "string"
        },
        "source_x": {
          "type": "string"
        },
        "source_y": {
          "type": "string"
        },
        "source_name": {
          "type": "string"
        },
        "dest_map_id": {
          "type": "string"
        },
        "dest_x": {
          "type": "string"
        },
        "dest_y": {
          "type": "string"
        },
        "dest_name": {
          "type": "string"
        },
        "connection_type": {
          "type": "string"
        },
        "is_one_way": {
          "type": "string"
        },
        "dest_entry_point": {
          "type": "string"
        }
      },
      "required": [
        "source_map_id",
        "source_x",
        "source_y",
        "source_name",
        "dest_map_id",
        "dest_x",
        "dest_y",
        "dest_name",
        "connection_type",
        "is_one_way",
        "dest_entry_point"
      ]
    },
    "python_script": "import json\n\nwkg = json.loads(world_knowledge_graph_json_string)\nnodes = wkg.get('nodes', [])\nedges = wkg.get('edges', [])\n\nsource_map_id = input_data['source_map_id']\nsource_x = int(input_data['source_x'])\nsource_y = int(input_data['source_y'])\nsource_name = input_data['source_name']\ndest_map_id = input_data['dest_map_id']\ndest_x = int(input_data['dest_x'])\ndest_y = int(input_data['dest_y'])\ndest_name = input_data['dest_name']\nconnection_type = input_data['connection_type']\nis_one_way = input_data['is_one_way'].lower() == 'true'\ndest_entry_point_str = input_data['dest_entry_point']\ndest_entry_point = int(dest_entry_point_str) if dest_entry_point_str.isdigit() else None\n\ndef find_wkg_node_by_coords(nodes_list, map_id_str, x_coord, y_coord):\n    for node in nodes_list:\n        if str(node.get('map_id')) == map_id_str and node.get('coordinates', {}).get('x') == x_coord and node.get('coordinates', {}).get('y') == y_coord:\n            return node['id']\n    return None\n\ndef check_wkg_edge_exists(edges_list, source_id, dest_id):\n    for edge in edges_list:\n        if (edge.get('source_node_id') == source_id and edge.get('destination_node_id') == dest_id) or \\\n           (edge.get('source_node_id') == dest_id and edge.get('destination_node_id') == source_id):\n            return True\n    return False\n\noutputs = []\nsource_node_id = find_wkg_node_by_coords(nodes, source_map_id, source_x, source_y)\ndest_node_id = find_wkg_node_by_coords(nodes, dest_map_id, dest_x, dest_y)\n\nif not source_node_id:\n    payload = {\n        \"map_id\": source_map_id,\n        \"name\": source_name,\n        \"coordinates\": {\"x\": source_x, \"y\": source_y},\n        \"type\": connection_type,\n        \"tags\": []\n    }\n    outputs.append(f\"manage_world_knowledge action: add_node payload: '{json.dumps(payload)}'\")\n\nif not dest_node_id:\n    payload = {\n        \"map_id\": dest_map_id,\n        \"name\": dest_name,\n        \"coordinates\": {\"x\": dest_x, \"y\": dest_y},\n        \"type\": connection_type,\n        \"tags\": []\n    }\n    outputs.append(f\"manage_world_knowledge action: add_node payload: '{json.dumps(payload)}'\")\n\nif source_node_id and dest_node_id:\n    if not check_wkg_edge_exists(edges, source_node_id, dest_node_id):\n        edge_payload = {\n            \"source_node_id\": source_node_id,\n            \"destination_node_id\": dest_node_id,\n            \"connection_type\": connection_type,\n            \"source_coordinates\": {\"x\": source_x, \"y\": source_y, \"map_id\": source_map_id},\n            \"destination_coordinates\": {\"x\": dest_x, \"y\": dest_y, \"map_id\": dest_map_id},\n            \"is_one_way\": is_one_way\n        }\n        if connection_type == \"warp\" and dest_entry_point is not None:\n            edge_payload[\"destination_entry_point\"] = dest_entry_point\n        outputs.append(f\"manage_world_knowledge action: add_edge payload: '{json.dumps(edge_payload)}'\")\n\nif not outputs:\n    print(\"WKG is already up-to-date for this transition.\")\nelse:\n    for output in outputs:\n        print(output)"
  }
}