{
  "puzzle_solver": {
    "description": "Solves Sokoban-style boulder puzzles. Takes optional start coordinates, but requires goal coordinates for the final boulder position. It uses a Breadth-First Search algorithm to find the optimal sequence of moves.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer",
          "nullable": true
        },
        "start_y": {
          "type": "integer",
          "nullable": true
        },
        "goal_x": {
          "type": "integer"
        },
        "goal_y": {
          "type": "integer"
        }
      },
      "required": [
        "goal_x",
        "goal_y"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\n\n# Parse map data\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\n\nwalls = set()\nboulders = []\nplayer_start = None\n\nfor r_idx, row_elem in enumerate(root.findall('Row')):\n    y = r_idx + 1\n    for t_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n        x = t_idx + 1\n        tile_type = tile_elem.get('type')\n        if tile_type == 'WALL':\n            walls.add((x, y))\n        if tile_elem.find('Object[@id-name=\"BOULDER\"]') is not None:\n            boulders.append((x, y))\n        if tile_elem.find('Player') is not None:\n            player_start = (x, y)\n\n# Override start position if provided\nif 'start_x' in input_data and input_data['start_x'] is not None:\n    player_start = (int(input_data['start_x']), int(input_data['start_y']))\n\ngoal_pos = (int(input_data['goal_x']), int(input_data['goal_y']))\n\n# --- BFS Solver ---\ninitial_state = (player_start, tuple(sorted(boulders)))\nqueue = collections.deque([(initial_state, [])])\nvisited = {initial_state}\n\npath_found = False\nwhile queue:\n    (current_player, current_boulders), path = queue.popleft()\n\n    # Check for goal state\n    if goal_pos in current_boulders:\n        print(f\"Solution found: {path}\")\n        path_found = True\n        break\n\n    # Explore neighbors\n    for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n        next_player_pos = (current_player[0] + dx, current_player[1] + dy)\n\n        # Simple move (no push)\n        if next_player_pos not in walls and next_player_pos not in current_boulders:\n            new_state = (next_player_pos, current_boulders)\n            if new_state not in visited:\n                visited.add(new_state)\n                queue.append((new_state, path + [move]))\n            continue\n\n        # Boulder push\n        if next_player_pos in current_boulders:\n            boulder_to_push = next_player_pos\n            next_boulder_pos = (boulder_to_push[0] + dx, boulder_to_push[1] + dy)\n\n            if next_boulder_pos not in walls and next_boulder_pos not in current_boulders:\n                new_boulders = list(current_boulders)\n                new_boulders.remove(boulder_to_push)\n                new_boulders.append(next_boulder_pos)\n                new_boulders_tuple = tuple(sorted(new_boulders))\n                \n                new_state = (next_player_pos, new_boulders_tuple)\n                if new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, path + [f\"Push {move}\"])) \n\nif not path_found:\n    print(\"No solution found.\")"
  },
  "pathfinder": {
    "description": "Finds the shortest path between two points on the current map using the A* algorithm. It considers specified traversable tiles and avoids obstacles. It can now path to a tile adjacent to an impassable destination.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "traversable_tiles": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "traversable_tiles"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\nimport json\n\nclass AStar:\n    def __init__(self, map_xml, traversable_tiles):\n        self.root = ET.fromstring(map_xml)\n        self.width = int(self.root.get('width'))\n        self.height = int(self.root.get('height'))\n        self.traversable_tiles = set(traversable_tiles)\n        self.walls = set()\n        self.objects = set()\n        self.ledges = {}\n\n        for row_elem in self.root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.find('Object') is not None\n\n                if has_object:\n                    self.objects.add((x, y))\n                \n                if tile_type in ['FLOOR_UP_WALL', 'LEDGE']:\n                    self.ledges[(x, y)] = (x, y + 1)\n                \n                if tile_type not in self.traversable_tiles:\n                    self.walls.add((x,y))\n\n    def heuristic(self, a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def get_neighbors(self, pos):\n        x, y = pos\n        neighbors = []\n        \n        if pos in self.ledges:\n            nx, ny = self.ledges[pos]\n            if (nx, ny) not in self.walls and (nx, ny) not in self.objects:\n                neighbors.append(((nx, ny), 1))\n            return neighbors\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            neighbor_pos = (nx, ny)\n\n            if 1 <= nx <= self.width and 1 <= ny <= self.height:\n                if neighbor_pos in self.walls or neighbor_pos in self.objects:\n                    continue\n                \n                if neighbor_pos in self.ledges and pos != (neighbor_pos[0], neighbor_pos[1] - 1):\n                    continue\n\n                neighbors.append((neighbor_pos, 1))\n        return neighbors\n\n    def find_path_internal(self, start, end):\n        open_set = [(0, start)]\n        came_from = {}\n        g_score = {start: 0}\n        f_score = {start: self.heuristic(start, end)}\n\n        while open_set:\n            _, current = heapq.heappop(open_set)\n\n            if current == end:\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(start)\n                return path[::-1]\n\n            for neighbor, cost in self.get_neighbors(current):\n                tentative_g_score = g_score[current] + cost\n                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = tentative_g_score + self.heuristic(neighbor, end)\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n        return None\n\n    def find_path(self, start, end):\n        path = self.find_path_internal(start, end)\n        if path:\n            return path\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_x, adj_y = end[0] + dx, end[1] + dy\n            adj_pos = (adj_x, adj_y)\n            if adj_pos not in self.walls and adj_pos not in self.objects and adj_pos not in self.ledges:\n                path_adj = self.find_path_internal(start, adj_pos)\n                if path_adj:\n                    return path_adj\n        \n        return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    traversable = json.loads(input_data['traversable_tiles'])\n\n    astar = AStar(map_xml_string, traversable)\n    path = astar.find_path((start_x, start_y), (end_x, end_y))\n\n    if path:\n        print(json.dumps(path))\n    else:\n        print(\"No path found.\")\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")"
  },
  "sokoban_solver": {
    "description": "Solves Sokoban-style boulder puzzles by finding the shortest sequence of player movements. It takes the player's starting position, the boulder's starting position, and the boulder's goal position. It models the player and boulder as a combined state and uses a Breadth-First Search algorithm. This version is optimized to avoid re-visiting states and correctly models player movement (player moves into the boulder's old spot after a push).",
    "input_schema": {
      "type": "object",
      "properties": {
        "player_start_x": {
          "type": "integer"
        },
        "player_start_y": {
          "type": "integer"
        },
        "boulder_start_x": {
          "type": "integer"
        },
        "boulder_start_y": {
          "type": "integer"
        },
        "boulder_goal_x": {
          "type": "integer"
        },
        "boulder_goal_y": {
          "type": "integer"
        }
      },
      "required": [
        "player_start_x",
        "player_start_y",
        "boulder_start_x",
        "boulder_start_y",
        "boulder_goal_x",
        "boulder_goal_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\nroot = ET.fromstring(map_xml_string)\nmap_width = int(root.get('width'))\nmap_height = int(root.get('height'))\nimpassable = set()\n\nfor tile in root.findall('.//Tile'):\n    tile_type = tile.get('type')\n    if tile_type in ['WALL', 'NPC', 'BOULDER'] or tile.find('Object') is not None:\n        x_str, y_str = tile.get('coordinate').strip('()').split(',')\n        impassable.add((int(x_str), int(y_str)))\n\nplayer_start_x = int(input_data['player_start_x'])\nplayer_start_y = int(input_data['player_start_y'])\nboulder_start_x = int(input_data['boulder_start_x'])\nboulder_start_y = int(input_data['boulder_start_y'])\nboulder_goal_x = int(input_data['boulder_goal_x'])\nboulder_goal_y = int(input_data['boulder_goal_y'])\n\ndef find_path(start_pos, end_pos, current_boulder_pos):\n    q = deque([(start_pos, [])])\n    visited_player = {start_pos}\n    temp_impassable = impassable.copy()\n    temp_impassable.add(current_boulder_pos)\n\n    while q:\n        (px, py), path = q.popleft()\n        if (px, py) == end_pos:\n            return path\n\n        for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = px + dx, py + dy\n            if 0 < nx <= map_width and 0 < ny <= map_height and (nx, ny) not in temp_impassable and (nx, ny) not in visited_player:\n                visited_player.add((nx, ny))\n                q.append(((nx, ny), path + [move]))\n    return None\n\ninitial_state = ((player_start_x, player_start_y), (boulder_start_x, boulder_start_y))\nqueue = deque([(initial_state, [])])\nvisited_states = {initial_state}\n\nwhile queue:\n    (player_pos, boulder_pos), path = queue.popleft()\n\n    if boulder_pos == (boulder_goal_x, boulder_goal_y):\n        print(f\"Solution found: {path}\")\n        break\n\n    for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n        required_player_pos = (boulder_pos[0] - dx, boulder_pos[1] - dy)\n        new_boulder_pos = (boulder_pos[0] + dx, boulder_pos[1] + dy)\n\n        if not (0 < new_boulder_pos[0] <= map_width and 0 < new_boulder_pos[1] <= map_height and new_boulder_pos not in impassable):\n            continue\n\n        player_path_to_push = find_path(player_pos, required_player_pos, boulder_pos)\n\n        if player_path_to_push is not None:\n            new_player_pos = boulder_pos # CORRECTED LOGIC: Player moves into the boulder's old spot.\n            new_state = (new_player_pos, new_boulder_pos)\n            if new_state not in visited_states:\n                visited_states.add(new_state)\n                new_path = path + player_path_to_push + [f'Push {move}']\n                queue.append((new_state, new_path))\nelse:\n    print(\"No solution found.\")\n"
  }
}