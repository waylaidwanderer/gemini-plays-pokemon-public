{
  "menu_navigator_v2_fixed": {
    "description": "Executes a sequence of button presses to navigate menus. Returns a JSON array of buttons. Use this to bypass the restriction on mixing directional and action inputs. Automatically handles autopress_buttons.",
    "input_schema": {
      "properties": {
        "sequence": {
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "sequence"
      ],
      "type": "object"
    },
    "python_script": "import json\nprint(json.dumps(input_data.get('sequence', [])))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-14T06:16:48.631Z",
        "action_counter": 47221
      }
    ]
  },
  "find_traversable_path_v3": {
    "description": "Finds a traversable path from the player's current position to a target coordinate on the current map, accounting for wall, buoy, water (surf), ledge, and FLOOR_UP_WALL mechanics. Returns a JSON array of button strings.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\nimport sys\n\ndef find_path(xml_string, start_x, start_y, target_x, target_y):\n    try:\n        root = ET.fromstring(xml_string)\n    except:\n        return []\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    grid = {}\n    objects = set()\n    \n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            t_type = tile.get('type')\n            grid[(x, y)] = t_type\n            if tile.find('Object') is not None:\n                objects.add((x, y))\n            for marker in tile.findall('Marker'):\n                emoji = marker.get('emoji')\n                if emoji in ['üë§', 'üìç', 'ü™®', 'üõü', 'üß±', 'üö´']:\n                    objects.add((x, y))\n\n    def can_move(x, y, nx, ny, surfing):\n        if not (0 <= nx < width and 0 <= ny < height): return False\n        t_type = grid.get((nx, ny))\n        if t_type is None or t_type == 'unseen': return True\n        if (nx, ny) in objects and (nx, ny) != (target_x, target_y): return False\n        \n        # FLOOR_UP_WALL is a ledge face, impassable from all directions\n        if t_type in ['WALL', 'BUOY', 'FLOOR_UP_WALL']: return False\n        \n        if surfing:\n            if t_type != 'WATER': return False\n        else:\n            if t_type == 'WATER': return False\n        \n        curr_type = grid.get((x, y))\n        dx, dy = nx - x, ny - y\n        if t_type == 'LEDGE_HOP_DOWN' and dy != 1: return False\n        if curr_type == 'LEDGE_HOP_DOWN' and dy != 1: return False\n        \n        return True\n\n    initial_tile = grid.get((start_x, start_y))\n    initial_surfing = (initial_tile == 'WATER')\n    queue = deque([((start_x, start_y), [], initial_surfing)])\n    visited = {((start_x, start_y), initial_surfing)}\n    \n    while queue:\n        (x, y), path, surfing = queue.popleft()\n        if (x, y) == (target_x, target_y):\n            return path\n            \n        for dx, dy, btn in [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny, surfing) not in visited and can_move(x, y, nx, ny, surfing):\n                visited.add((nx, ny, surfing))\n                queue.append(((nx, ny), path + [btn], surfing))\n                \n        if not surfing:\n            for dx, dy, btn in [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n                nx, ny = x + dx, y + dy\n                if grid.get((nx, ny)) == 'WATER' and (nx, ny, True) not in visited:\n                    visited.add((nx, ny, True))\n                    queue.append(((nx, ny), path + [btn, 'A', 'A'], True))\n        else:\n            for dx, dy, btn in [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n                nx, ny = x + dx, y + dy\n                t_type = grid.get((nx, ny))\n                if t_type and t_type not in ['WATER', 'BUOY', 'WALL', 'unseen', 'FLOOR_UP_WALL'] and (nx, ny, False) not in visited:\n                    if can_move(x, y, nx, ny, False):\n                        visited.add((nx, ny, False))\n                        queue.append(((nx, ny), path + [btn, 'A'], False))\n    return []\n\ndata = input_data\nres = find_path(map_xml_string, int(data.get('start_x', 0)), int(data.get('start_y', 0)), int(data.get('target_x', 0)), int(data.get('target_y', 0)))\nprint(json.dumps(res))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-14T17:50:48.771Z",
        "action_counter": 47848
      },
      {
        "commit_message": "Added LEDGE_HOP_DOWN logic and improved robustness.",
        "timestamp": "2026-01-14T18:08:44.623Z",
        "action_counter": 47869
      },
      {
        "commit_message": "Added Map Marker support and improved ledge face logic. FLOOR_UP_WALL is now impassable from all directions. Tool now respects markers for NPCs, items, and obstacles.",
        "timestamp": "2026-01-14T18:11:11.248Z",
        "action_counter": 47872
      },
      {
        "commit_message": "Corrected FLOOR_UP_WALL logic: it only blocks Northward movement. Improved robustness.",
        "timestamp": "2026-01-14T18:13:27.939Z",
        "action_counter": 47876
      },
      {
        "commit_message": "FLOOR_UP_WALL is now treated as a solid wall (impassable from all directions). This reflects the observation that ledge faces cannot be walked upon.",
        "timestamp": "2026-01-14T18:16:27.096Z",
        "action_counter": 47878
      }
    ]
  },
  "fly_map_navigator": {
    "description": "Generates the button sequence to navigate the 2D Fly map from a starting city to a target city in Johto. Returns a JSON array of buttons. Use this once the Town Map is open during a Fly command.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_city": {
          "type": "string",
          "enum": [
            "New Bark",
            "Cherrygrove",
            "Violet",
            "Azalea",
            "Goldenrod",
            "Ecruteak",
            "Olivine",
            "Cianwood",
            "Mahogany",
            "Lake of Rage",
            "Blackthorn"
          ]
        },
        "target_city": {
          "type": "string",
          "enum": [
            "New Bark",
            "Cherrygrove",
            "Violet",
            "Azalea",
            "Goldenrod",
            "Ecruteak",
            "Olivine",
            "Cianwood",
            "Mahogany",
            "Lake of Rage",
            "Blackthorn"
          ]
        }
      },
      "required": [
        "start_city",
        "target_city"
      ]
    },
    "python_script": "import json\n\ndef solve():\n    # Cursor Grid (X, Y) based on observed Johto Town Map layout\n    grid = {\n        \"New Bark\": (14, 10),\n        \"Cherrygrove\": (12, 10),\n        \"Violet\": (12, 6),\n        \"Azalea\": (10, 12),\n        \"Goldenrod\": (6, 9),\n        \"Ecruteak\": (6, 5),\n        \"Olivine\": (2, 6),\n        \"Cianwood\": (0, 9),\n        \"Mahogany\": (10, 5),\n        \"Lake of Rage\": (10, 3),\n        \"Blackthorn\": (14, 5)\n    }\n    \n    start_city = input_data.get('start_city')\n    target_city = input_data.get('target_city')\n    \n    if start_city not in grid or target_city not in grid:\n        print(json.dumps([]))\n        return\n        \n    start_x, start_y = grid[start_city]\n    target_x, target_y = grid[target_city]\n    \n    dx = target_x - start_x\n    dy = target_y - start_y\n    \n    buttons = []\n    # In Pok√©mon Crystal Fly Map:\n    # Left decreases X, Right increases X\n    # Up decreases Y, Down increases Y\n    \n    if dx < 0:\n        buttons.extend([\"Left\"] * abs(dx))\n    elif dx > 0:\n        buttons.extend([\"Right\"] * dx)\n        \n    if dy < 0:\n        buttons.extend([\"Up\"] * abs(dy))\n    elif dy > 0:\n        buttons.extend([\"Down\"] * dy)\n        \n    buttons.append(\"A\")\n    print(json.dumps(buttons))\n\nsolve()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-14T19:21:33.009Z",
        "action_counter": 47928
      }
    ]
  },
  "fly_to_city_stable": {
    "description": "Navigates the Fly map from a starting city to a target city with adjustable timing to prevent dropped inputs. Accounts for the 7-tap-per-unit grid.",
    "input_schema": {
      "type": "object",
      "properties": {
        "initial_sleep_ms": {
          "default": 1000,
          "type": "integer"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "wait_ms": {
          "default": 300,
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import json\n\n# input_data is automatically provided as a dictionary.\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\ntarget_x = int(input_data['target_x'])\ntarget_y = int(input_data['target_y'])\nwait_ms = int(input_data.get('wait_ms', 300))\ninitial_sleep = int(input_data.get('initial_sleep_ms', 1000))\n\nbuttons = [f'sleep {initial_sleep}']\n\n# The Johto Fly map uses a sub-grid where 7 taps = 1 coordinate unit.\ndx = (target_x - start_x) * 7\ndy = (target_y - start_y) * 7\n\nx_btn = 'Right' if dx > 0 else 'Left'\ny_btn = 'Down' if dy > 0 else 'Up'\n\nfor _ in range(abs(dx)):\n    buttons.append(x_btn)\n    buttons.append(f'sleep {wait_ms}')\n\nfor _ in range(abs(dy)):\n    buttons.append(y_btn)\n    buttons.append(f'sleep {wait_ms}')\n\nbuttons.append('A')\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-14T20:19:25.182Z",
        "action_counter": 48003
      },
      {
        "commit_message": "Fixing NameError by using the automatically provided input_data variable instead of trying to parse a non-existent input_params string.",
        "timestamp": "2026-01-14T20:19:58.173Z",
        "action_counter": 48005
      },
      {
        "commit_message": "Adding initial_sleep_ms parameter to allow for longer map opening animations.",
        "timestamp": "2026-01-14T20:22:48.896Z",
        "action_counter": 48008
      },
      {
        "commit_message": "Refining tool to account for the 7-tap-per-unit grid on the Johto Fly map. Every coordinate unit requires 7 directional presses.",
        "timestamp": "2026-01-14T20:36:43.676Z",
        "action_counter": 48025
      }
    ]
  }
}