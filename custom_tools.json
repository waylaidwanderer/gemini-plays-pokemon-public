{
  "find_path_v2": {
    "description": "Calculates a path between two coordinates on the current map using BFS, accounting for walls, objects, and avoiding unintentional warps. Returns a list of button strings.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer",
          "nullable": true
        },
        "start_y": {
          "type": "integer",
          "nullable": true
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "can_surf": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef find_path():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.attrib['width'])\n        height = int(root.attrib['height'])\n        \n        start_x = input_data.get('start_x')\n        start_y = input_data.get('start_y')\n        end_x = int(input_data['end_x'])\n        end_y = int(input_data['end_y'])\n        can_surf = bool(input_data.get('can_surf', False))\n        \n        if start_x is None or start_y is None:\n            for row in root.findall('Row'):\n                y = int(row.attrib['id'])\n                for tile in row.findall('Tile'):\n                    if tile.find('Player') is not None or tile.attrib.get('has-player') == 'true':\n                        start_x = int(tile.attrib['id'])\n                        start_y = y\n                        break\n                if start_x is not None: break\n\n        if start_x is None:\n            print(json.dumps([]))\n            return\n\n        grid = {}\n        warps = set()\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                t_type = tile.attrib['type']\n                has_object = tile.attrib.get('has-object') == 'true'\n                is_warp = tile.attrib.get('is-warp') == 'true'\n                \n                passable_types = ['FLOOR', 'TALL_GRASS', 'CAVE', 'GRASS', 'SAND', 'STAIRS', 'DOCK', 'WARP', 'STAIRCASE', 'ICE', 'WHIRLPOOL', 'WATER', 'DIRT', 'PATH', 'DOOR']\n                is_blocked = (t_type not in passable_types)\n                \n                if has_object:\n                    if tile.find('Player') is None and tile.attrib.get('has-player') != 'true':\n                        is_blocked = True\n\n                if t_type == 'WATER' and not can_surf: is_blocked = True\n                if t_type == 'WHIRLPOOL': is_blocked = True\n\n                grid[(x, y)] = is_blocked\n                if is_warp: warps.add((x, y))\n\n        queue = deque([(start_x, start_y, [])])\n        visited = set([(start_x, start_y)])\n        while queue:\n            x, y, path = queue.popleft()\n            if x == end_x and y == end_y:\n                print(json.dumps(path))\n                return\n            if (x, y) in warps and (x != start_x or y != start_y): continue\n            for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:\n                    if not grid.get((nx, ny), True) or (nx == end_x and ny == end_y):\n                        visited.add((nx, ny))\n                        queue.append((nx, ny, path + [btn]))\n        print(json.dumps([]))\n    except Exception:\n        print(json.dumps([]))\n\nfind_path()",
    "history": [
      {
        "commit_message": "Refined find_path to use the globally available map_xml_string and removed it from input_schema. Fixed one-way logic and impassable types.",
        "timestamp": "2025-12-23T14:36:16.850Z",
        "action_counter": 14568
      },
      {
        "commit_message": "Updated find_path_v2 to automatically detect player position from map_xml_string if start_x/y are not provided. Added start_x/y to input_schema as optional properties.",
        "timestamp": "2025-12-23T14:37:43.655Z",
        "action_counter": 14570
      },
      {
        "commit_message": "Fixed a bug in find_path_v2 where the path reconstruction loop would never terminate if the start position was found, leading to a KeyError: (None, None). Also fixed start_x/y handling to properly detect player position from XML if not provided as arguments.",
        "timestamp": "2025-12-23T14:38:20.004Z",
        "action_counter": 14571
      },
      {
        "commit_message": "Corrected output format of find_path_v2 to return a flat list of coordinates, matching the expected input for the navigate tool.",
        "timestamp": "2025-12-23T14:41:01.719Z",
        "action_counter": 14573
      },
      {
        "commit_message": "Fixed a bug in path reconstruction where (None, None) was not correctly identified as the termination condition, causing a KeyError. Also improved player position detection.",
        "timestamp": "2025-12-23T14:54:49.565Z",
        "action_counter": 14596
      },
      {
        "commit_message": "Refined find_path_v2 to handle pathfinding more robustly, correctly detecting the player's position from the XML if not provided, and returning a list of coordinate objects suitable for the navigate tool's path_plan. Added checks for impassable tiles including HEADBUTT_TREE and WATER.",
        "timestamp": "2025-12-23T14:56:11.952Z",
        "action_counter": 14599
      },
      {
        "commit_message": "Fixing find_path_v2 to correctly return a JSON array of button strings when autopress_buttons is true, and ensuring it handles the end tile correctly even if it's marked as impassable (like an NPC).",
        "timestamp": "2025-12-23T17:23:41.688Z",
        "action_counter": 14852
      },
      {
        "commit_message": "Updating find_path_v2 to support an optional 'can_surf' parameter. When true, WATER tiles are treated as traversable. This allows for pathfinding across ponds and oceans when the player has a Pokemon with Surf.",
        "timestamp": "2025-12-23T18:04:50.520Z",
        "action_counter": 14936
      },
      {
        "commit_message": "Refined passable types and added better error handling for unreachable destinations.",
        "timestamp": "2025-12-23T20:52:10.769Z",
        "action_counter": 15273
      },
      {
        "commit_message": "Refined passable types, added better error handling, and fixed button output for overworld/menu navigation.",
        "timestamp": "2025-12-23T20:52:38.251Z",
        "action_counter": 15274
      },
      {
        "commit_message": "Reverted to returning coordinates for 'navigate' tool and added specific logic for FLOOR_UP_WALL one-way tiles.",
        "timestamp": "2025-12-23T20:54:14.377Z",
        "action_counter": 15278
      },
      {
        "commit_message": "Fix find_path_v2 to handle autopress_buttons correctly by returning a JSON array of button strings when enabled, and account for one-way tiles like LEDGE and FLOOR_UP_WALL.",
        "timestamp": "2025-12-23T21:48:39.009Z",
        "action_counter": 15375
      },
      {
        "commit_message": "Fix find_path_v2 to handle autopress_buttons correctly and add one-way tile logic for LEDGE and FLOOR_UP_WALL.",
        "timestamp": "2025-12-23T21:49:12.615Z",
        "action_counter": 15376
      },
      {
        "commit_message": "Fix find_path_v2 by removing the function wrapper and ensuring it prints the result directly to stdout, and refine traversable types to include CAVE and warps.",
        "timestamp": "2025-12-23T21:51:09.492Z",
        "action_counter": 15382
      },
      {
        "commit_message": "Refine find_path_v2 to handle traversable types more robustly (including LONG_GRASS), fix button output logic, and improve error reporting when no path is found.",
        "timestamp": "2025-12-23T21:52:41.372Z",
        "action_counter": 15383
      },
      {
        "commit_message": "Ensure all outputs of find_path_v2 are JSON-encoded arrays of strings to prevent parsing errors in the harness, and include WARP in the passable list.",
        "timestamp": "2025-12-23T21:55:48.757Z",
        "action_counter": 15387
      },
      {
        "commit_message": "Added can_surf parameter and updated pathfinding logic for ledges and one-way walls.",
        "timestamp": "2025-12-24T02:44:55.343Z",
        "action_counter": 16074
      },
      {
        "commit_message": "Fixed FLOOR_UP_WALL logic and improved ledge hopping.",
        "timestamp": "2025-12-24T02:48:02.495Z",
        "action_counter": 16081
      },
      {
        "commit_message": "Fixed FLOOR_UP_WALL logic to block Southward movement as verified on Route 42.",
        "timestamp": "2025-12-24T02:53:18.188Z",
        "action_counter": 16094
      },
      {
        "commit_message": "Fixed FLOOR_UP_WALL logic to block Northward entry.",
        "timestamp": "2025-12-24T02:56:43.743Z",
        "action_counter": 16101
      },
      {
        "commit_message": "Corrected FLOOR_UP_WALL logic to block Southward movement.",
        "timestamp": "2025-12-24T03:01:54.819Z",
        "action_counter": 16109
      },
      {
        "commit_message": "Finalized ledge and FLOOR_UP_WALL (Southward block) logic for accurate pathfinding.",
        "timestamp": "2025-12-24T03:26:52.936Z",
        "action_counter": 16154
      },
      {
        "commit_message": "Implement robust BFS pathfinding for overworld navigation, accounting for ledge directions and hypothetical floor-up-wall behavior.",
        "timestamp": "2025-12-24T04:03:42.841Z",
        "action_counter": 16231
      },
      {
        "commit_message": "Refine pathfinding logic: allow destination to be an object-occupied tile and ensure the start tile's object/impassable status doesn't block the initial step.",
        "timestamp": "2025-12-24T04:09:54.304Z",
        "action_counter": 16244
      },
      {
        "commit_message": "Fix IndexError by checking sys.argv length and improve player position detection.",
        "timestamp": "2025-12-24T04:16:01.527Z",
        "action_counter": 16258
      },
      {
        "commit_message": "Refine find_path_v2 to use the injected input_data dictionary instead of sys.argv, and improve error handling.",
        "timestamp": "2025-12-24T04:18:55.006Z",
        "action_counter": 16263
      },
      {
        "commit_message": "Refined to avoid unintentional map transitions by treating warp tiles as impassable unless they are the intended destination. Also added a check for 'unseen' tiles to prioritize verified paths.",
        "timestamp": "2025-12-24T20:58:30.935Z",
        "action_counter": 18061
      },
      {
        "commit_message": "Refined find_path_v2 to correctly handle MART_SHELF and COUNTER collision, and avoid unintentional warps.",
        "timestamp": "2025-12-24T23:59:49.423Z",
        "action_counter": 18378
      },
      {
        "commit_message": "Refined find_path_v2: improved player detection, added more passable types, and allowed the destination tile to be visited even if it is marked as blocked or contains an object.",
        "timestamp": "2025-12-25T00:02:22.686Z",
        "action_counter": 18383
      },
      {
        "commit_message": "Added DOOR to passable types in find_path_v2.",
        "timestamp": "2025-12-25T00:38:17.038Z",
        "action_counter": 18482
      }
    ]
  },
  "navigate_menu_v2": {
    "description": "Executes a sequence of button presses for menu navigation, allowing mixing of directional and action buttons. Includes support for pauses between presses.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The sequence of buttons and/or 'sleep <ms>' commands to execute."
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nprint(json.dumps(input_data.get(\"buttons\", [])))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-24T11:42:51.849Z",
        "action_counter": 17071
      }
    ]
  },
  "navigate_fly_map": {
    "description": "Calculates the button sequence to move the cursor on the Johto FLY map between cities and selects the target. Includes pauses between presses.",
    "input_schema": {
      "type": "object",
      "properties": {
        "current_city": {
          "type": "string",
          "enum": [
            "NEW BARK TOWN",
            "CHERRYGROVE CITY",
            "VIOLET CITY",
            "AZALEA TOWN",
            "GOLDENROD CITY",
            "ECRUTEAK CITY",
            "OLIVINE CITY",
            "CIANWOOD CITY",
            "MAHOGANY TOWN",
            "BLACKTHORN CITY"
          ]
        },
        "target_city": {
          "type": "string",
          "enum": [
            "NEW BARK TOWN",
            "CHERRYGROVE CITY",
            "VIOLET CITY",
            "AZALEA TOWN",
            "GOLDENROD CITY",
            "ECRUTEAK CITY",
            "OLIVINE CITY",
            "CIANWOOD CITY",
            "MAHOGANY TOWN",
            "BLACKTHORN CITY"
          ]
        }
      },
      "required": [
        "current_city",
        "target_city"
      ]
    },
    "python_script": "import json\n\ndef solve():\n    current_city = input_data[\"current_city\"]\n    target_city = input_data[\"target_city\"]\n    \n    # Johto Fly Map Layout (x, y)\n    # Row 0: Cianwood(0,0) - Olivine(1,0) - Ecruteak(2,0) - Mahogany(3,0) - Blackthorn(4,0)\n    # Row 1:                 Goldenrod(1,1) - Violet(2,1) - Cherrygrove(3,1) - New Bark(4,1)\n    # Row 2:                                  Azalea(2,2)\n    \n    grid = {\n        \"CIANWOOD CITY\": (0, 0),\n        \"OLIVINE CITY\": (1, 0),\n        \"ECRUTEAK CITY\": (2, 0),\n        \"MAHOGANY TOWN\": (3, 0),\n        \"BLACKTHORN CITY\": (4, 0),\n        \"GOLDENROD CITY\": (1, 1),\n        \"VIOLET CITY\": (2, 1),\n        \"CHERRYGROVE CITY\": (3, 1),\n        \"NEW BARK TOWN\": (4, 1),\n        \"AZALEA TOWN\": (2, 2)\n    }\n    \n    start = grid[current_city]\n    end = grid[target_city]\n    \n    buttons = []\n    dx = end[0] - start[0]\n    dy = end[1] - start[1]\n    \n    # Move horizontally then vertically\n    if dx > 0: buttons.extend([\"Right\"] * dx)\n    elif dx < 0: buttons.extend([\"Left\"] * abs(dx))\n    \n    if dy > 0: buttons.extend([\"Down\"] * dy)\n    elif dy < 0: buttons.extend([\"Up\"] * abs(dy))\n    \n    final_buttons = []\n    for b in buttons:\n        final_buttons.append(b)\n        final_buttons.append(\"sleep 500\")\n    final_buttons.append(\"A\")\n    \n    print(json.dumps(final_buttons))\n\nsolve()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-24T14:06:36.256Z",
        "action_counter": 17301
      },
      {
        "commit_message": "Fixed IndexError by using a dictionary-based adjacency map and safer enumeration. Updated Johto FLY map connections based on observed cursor behavior.",
        "timestamp": "2025-12-24T14:21:17.157Z",
        "action_counter": 17342
      },
      {
        "commit_message": "Refined FLY map navigation to use the linear vertical cycle (Up/Down) based on observed behavior (New Bark -> Cherrygrove -> Violet -> Azalea -> Goldenrod -> Ecruteak).",
        "timestamp": "2025-12-24T14:48:39.533Z",
        "action_counter": 17401
      },
      {
        "commit_message": "Fix navigate_fly_map to handle the case where the target city is the same as the current city by returning ['A'].",
        "timestamp": "2025-12-25T05:29:01.372Z",
        "action_counter": 19051
      },
      {
        "commit_message": "Added sleep commands and explicit Johto city order to improve reliability.",
        "timestamp": "2025-12-25T14:03:25.801Z",
        "action_counter": 19924
      },
      {
        "commit_message": "Fixing IndexError in navigate_fly_map by using a more robust distance calculation and ensuring city names match the schema exactly. Added error handling.",
        "timestamp": "2025-12-25T14:53:07.376Z",
        "action_counter": 19996
      },
      {
        "commit_message": "Refined Johto Fly map grid coordinates to correct the Olivine -> Ecruteak direction and other relative city positions.",
        "timestamp": "2025-12-25T20:13:11.924Z",
        "action_counter": 20522
      }
    ]
  },
  "navigate_menu_v3": {
    "description": "Executes a sequence of button presses for menu navigation, starting with a 4-press 'B' reset to clear any open menus or dialogue and ensure a consistent starting state. Use for navigating deep menus where cursor persistence might be an issue.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The sequence of buttons and/or 'sleep <ms>' commands to execute."
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nimport sys\n\ndef main():\n    try:\n        data = sys.stdin.read().strip()\n        if not data:\n            print(json.dumps([\"B\", \"B\", \"B\", \"B\"]))\n            return\n        \n        input_data = json.loads(data)\n        buttons = input_data.get('buttons', [])\n        \n        # Start with a B-reset (4 presses) to clear any existing menu state\n        output = [\"B\", \"B\", \"B\", \"B\"]\n        output.extend(buttons)\n        \n        print(json.dumps(output))\n    except Exception:\n        # Fallback to just the reset if anything goes wrong\n        print(json.dumps([\"B\", \"B\", \"B\", \"B\"]))\n\nif __name__ == \"__main__\":\n    main()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-25T17:22:50.838Z",
        "action_counter": 20251
      },
      {
        "commit_message": "Added robust input handling and ensured JSON output for menu navigation.",
        "timestamp": "2025-12-25T17:40:42.715Z",
        "action_counter": 20282
      }
    ]
  },
  "navigate_fly_map_v2": {
    "description": "Calculates the button sequence to move the cursor on the Johto FLY map between cities and selects the target. Includes pauses between presses.",
    "input_schema": {
      "type": "object",
      "properties": {
        "current_city": {
          "type": "string",
          "enum": [
            "NEW BARK TOWN",
            "CHERRYGROVE CITY",
            "VIOLET CITY",
            "AZALEA TOWN",
            "GOLDENROD CITY",
            "ECRUTEAK CITY",
            "OLIVINE CITY",
            "CIANWOOD CITY",
            "MAHOGANY TOWN",
            "BLACKTHORN CITY"
          ]
        },
        "target_city": {
          "type": "string",
          "enum": [
            "NEW BARK TOWN",
            "CHERRYGROVE CITY",
            "VIOLET CITY",
            "AZALEA TOWN",
            "GOLDENROD CITY",
            "ECRUTEAK CITY",
            "OLIVINE CITY",
            "CIANWOOD CITY",
            "MAHOGANY TOWN",
            "BLACKTHORN CITY"
          ]
        }
      },
      "required": [
        "current_city",
        "target_city"
      ]
    },
    "python_script": "import json\n\ndef solve():\n    current_city = input_data[\"current_city\"]\n    target_city = input_data[\"target_city\"]\n    \n    # Johto Fly Map Layout (x, y)\n    # Row 0: Cianwood(0,0) - Olivine(1,0) - Ecruteak(2,0) - Mahogany(3,0) - Blackthorn(4,0)\n    # Row 1:                 Goldenrod(1,1) - Violet(2,1) - Cherrygrove(3,1) - New Bark(4,1)\n    # Row 2:                                  Azalea(2,2)\n    \n    grid = {\n        \"CIANWOOD CITY\": (0, 0),\n        \"OLIVINE CITY\": (1, 0),\n        \"ECRUTEAK CITY\": (2, 0),\n        \"MAHOGANY TOWN\": (3, 0),\n        \"BLACKTHORN CITY\": (4, 0),\n        \"GOLDENROD CITY\": (1, 1),\n        \"VIOLET CITY\": (2, 1),\n        \"CHERRYGROVE CITY\": (3, 1),\n        \"NEW BARK TOWN\": (4, 1),\n        \"AZALEA TOWN\": (2, 2)\n    }\n    \n    start = grid[current_city]\n    end = grid[target_city]\n    \n    buttons = []\n    dx = end[0] - start[0]\n    dy = end[1] - start[1]\n    \n    # Move horizontally\n    if dx > 0: buttons.extend([\"Right\"] * dx)\n    elif dx < 0: buttons.extend([\"Left\"] * abs(dx))\n    \n    # Move vertically\n    if dy > 0: buttons.extend([\"Down\"] * dy)\n    elif dy < 0: buttons.extend([\"Up\"] * abs(dy))\n    \n    final_buttons = []\n    for b in buttons:\n        final_buttons.append(b)\n        final_buttons.append(\"sleep 500\")\n    final_buttons.append(\"A\")\n    \n    print(json.dumps(final_buttons))\n\nsolve()\n",
    "history": [
      {
        "commit_message": "Corrected Johto Fly map grid to reflect the actual 2D layout (Rows 0-2) and city positions. Fixed Olivine to Ecruteak direction.",
        "timestamp": "2025-12-25T20:32:46.630Z",
        "action_counter": 20541
      }
    ]
  }
}