{
  "mash_a": {
    "description": "Presses the 'A' button 8 times in a row. Useful for quickly advancing dialogue or spamming the first attack in battles.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "python_script": "print('[\"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\"]')",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T02:05:26.666Z",
        "action_counter": 92
      },
      {
        "commit_message": "Fixed sandbox error and ensured the tool returns a valid list of buttons.",
        "timestamp": "2026-01-17T07:39:14.105Z",
        "action_counter": 575
      }
    ]
  },
  "patrol_grass": {
    "description": "Moves the player Left and Right to search for wild Pokemon, and presses A to handle battle introductions.",
    "input_schema": {},
    "python_script": "import json\ncmds = [\"Left\", \"Right\", \"Left\", \"Right\", \"A\", \"A\", \"A\", \"A\"]\nprint(json.dumps(cmds))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T02:06:33.549Z",
        "action_counter": 93
      }
    ]
  },
  "scan_surroundings": {
    "description": "Scans the Mental Map around the player and returns the type and coordinates of nearby tiles. Useful for identifying walls, ledges, and navigable paths without walking into them.",
    "input_schema": {
      "type": "object",
      "properties": {
        "radius": {
          "type": "integer",
          "description": "The radius of tiles to scan around the player. Defaults to 2."
        }
      },
      "required": [
        "radius"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    player_pos = None\n    \n    # Find player position\n    for row in root.findall(\"Row\"):\n        for tile in row.findall(\"Tile\"):\n            if tile.find(\"Player\") is not None:\n                player_pos = (int(tile.get(\"id\")), int(row.get(\"id\")))\n                break\n        if player_pos: break\n\n    if not player_pos:\n        print(\"Error: Player not found in Mental Map.\")\n    else:\n        px, py = player_pos\n        radius = input_data.get('radius', 2)\n        map_id = root.get('id')\n        print(f\"Scanning radius {radius} around {player_pos} on map {map_id}:\")\n        \n        for y in range(py - radius, py + radius + 1):\n            row = root.find(f\"./Row[@id='{y}']\")\n            if row is not None:\n                row_str = \"\"\n                for x in range(px - radius, px + radius + 1):\n                    tile = row.find(f\"./Tile[@id='{x}']\")\n                    if tile is not None:\n                        t_type = tile.get(\"type\")\n                        row_str += f\"[{x},{y}: {t_type}] \"\n                    else:\n                        row_str += f\"[{x},{y}: N/A] \"\n                print(row_str)\n            else:\n                print(f\"Row {y} not found.\")\n\nexcept Exception as e:\n    print(f\"Error executing scan_surroundings: {e}\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T03:27:06.196Z",
        "action_counter": 213
      }
    ]
  },
  "check_path_connectivity": {
    "description": "Checks if a path exists between coordinates in the Mental Map, respecting obstacles and ledges. Useful for checking if you are trapped or if a route is valid.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "target_min_x": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ],
      "additionalProperties": false
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef main(input_data):\n    start_x = input_data['start_x']\n    start_y = input_data['start_y']\n    target_x = input_data.get('target_x')\n    target_y = input_data.get('target_y')\n    target_min_x = input_data.get('target_min_x')\n\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.attrib['width'])\n        height = int(root.attrib['height'])\n        \n        grid = {}\n        # Known obstacles\n        obstacles = {\n            'TYPE_2889', # Tree Wall\n            'TYPE_5519', # Cut Tree\n            'TYPE_c453', # Ledge (Treat as obstacle for safety)\n        }\n        \n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                t_type = tile.attrib.get('type', 'unseen')\n                \n                is_walkable = True\n                if t_type in obstacles:\n                    is_walkable = False\n                \n                # Check markers for manual overrides\n                markers = tile.findall('Marker')\n                for m in markers:\n                    if 'Blocked' in m.text or 'Wall' in m.text or 'Dead End' in m.text:\n                        is_walkable = False\n                \n                grid[(x, y)] = is_walkable\n\n        # BFS\n        queue = deque([(start_x, start_y, [])])\n        visited = set([(start_x, start_y)])\n        \n        found_path = None\n        \n        while queue:\n            cx, cy, path = queue.popleft()\n            \n            if target_x is not None and target_y is not None:\n                if cx == target_x and cy == target_y:\n                    found_path = path + [(cx, cy)]\n                    break\n            elif target_min_x is not None:\n                if cx >= target_min_x:\n                    found_path = path + [(cx, cy)]\n                    break\n            \n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = cx + dx, cy + dy\n                if 0 <= nx < width and 0 <= ny < height:\n                    if (nx, ny) not in visited and grid.get((nx, ny), False):\n                        visited.add((nx, ny))\n                        queue.append((nx, ny, path + [(cx, cy)]))\n        \n        if found_path:\n            print(f\"Path found (Length {len(found_path)})\")\n        else:\n            print(\"No path found.\")\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    main(input_data)",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T04:38:25.635Z",
        "action_counter": 310
      },
      {
        "commit_message": "Fixed autopress_buttons support by returning JSON list of buttons.",
        "timestamp": "2026-01-17T05:14:56.870Z",
        "action_counter": 363
      },
      {
        "commit_message": "Initial definition of check_path_connectivity tool to help verify navigation paths.",
        "timestamp": "2026-01-17T19:59:31.235Z",
        "action_counter": 1608
      }
    ]
  },
  "find_nearest_unseen": {
    "description": "Finds the nearest 'unseen' tile in the Mental Map to the current player position. Useful for systematically clearing fog of war.",
    "input_schema": {
      "type": "object",
      "properties": {
        "player_x": {
          "type": "integer"
        },
        "player_y": {
          "type": "integer"
        }
      },
      "required": [
        "player_x",
        "player_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport math\n\nmap_xml = map_xml_string\npx = input_data['player_x']\npy = input_data['player_y']\n\nroot = ET.fromstring(map_xml)\nunseen_tiles = []\n\nfor row in root.findall('Row'):\n    y = int(row.get('id'))\n    for tile in row.findall('Tile'):\n        t_type = tile.get('type')\n        if t_type == 'unseen':\n            x = int(tile.get('id'))\n            dist = math.sqrt((x - px)**2 + (y - py)**2)\n            unseen_tiles.append({'x': x, 'y': y, 'dist': dist})\n\nif not unseen_tiles:\n    print(\"No unseen tiles found.\")\nelse:\n    # Sort by distance\n    unseen_tiles.sort(key=lambda t: t['dist'])\n    nearest = unseen_tiles[0]\n    print(f\"Nearest unseen tile is at ({nearest['x']}, {nearest['y']}) with distance {nearest['dist']:.2f}\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T05:16:24.634Z",
        "action_counter": 364
      }
    ]
  },
  "mash_a_fixed": {
    "description": "Presses the 'A' button 8 times in a row. Useful for quickly advancing dialogue or spamming the first attack in battles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "autopress_buttons"
      ]
    },
    "python_script": "print([\"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\"])",
    "history": [
      {
        "commit_message": "Re-defining tool to attempt to trigger sandbox re-initialization after 'container not running' error.",
        "timestamp": "2026-01-17T11:31:30.337Z",
        "action_counter": 931
      }
    ]
  },
  "bfs_check_path": {
    "description": "Checks if a path exists between two points using BFS on the Mental Map. Returns True/False and the path length.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef check_path(start_x, start_y, target_x, target_y):\n    try:\n        # map_xml_string is injected into the environment\n        if 'map_xml_string' not in globals():\n            print(\"Error: map_xml_string not found in globals.\")\n            return\n\n        root = ET.fromstring(map_xml_string)\n        \n        # Parse map dimensions\n        width = int(root.attrib['width'])\n        height = int(root.attrib['height'])\n        \n        # Build grid of walkable tiles\n        walkable = set()\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                t_type = tile.attrib.get('type', 'unseen')\n                \n                # Define walkable types\n                # Excluding known walls/obstacles\n                # TYPE_2889: Tree/Wall\n                # TYPE_80fc: Wall/Roof?\n                # TYPE_5519: Cut Tree\n                # TYPE_fed7: Ledge (Usually one way, treating as obstacle for general BFS unless logic added)\n                # TYPE_c453: Ledge\n                if t_type not in ['TYPE_2889', 'TYPE_80fc', 'TYPE_5519', 'TYPE_fed7', 'TYPE_c453']: \n                    walkable.add((x, y))\n                    \n        start = (start_x, start_y)\n        target = (target_x, target_y)\n        \n        if start not in walkable:\n            print(f\"Start {start} is not walkable or is an obstacle.\")\n            # return # Attempt to path anyway if start is 'obstacle' (e.g. current pos on ledge)\n            \n        if target not in walkable:\n            print(f\"Target {target} is not walkable or is an obstacle.\")\n            return\n\n        queue = deque([(start, 0)])\n        visited = {start}\n        \n        while queue:\n            (curr_x, curr_y), dist = queue.popleft()\n            \n            if (curr_x, curr_y) == target:\n                print(f\"Path found! Distance: {dist}\")\n                return\n            \n            # Check neighbors (Up, Down, Left, Right)\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = curr_x + dx, curr_y + dy\n                \n                if (nx, ny) in walkable and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append(((nx, ny), dist + 1))\n                    \n        print(\"No path found.\")\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n\ncheck_path(start_x, start_y, target_x, target_y)",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T13:46:49.913Z",
        "action_counter": 1128
      },
      {
        "commit_message": "Initial definition of BFS pathfinding tool to check connectivity on the Mental Map.",
        "timestamp": "2026-01-17T18:35:27.285Z",
        "action_counter": 1502
      },
      {
        "commit_message": "Initial definition of BFS path checking tool to replace the broken connectivity tool.",
        "timestamp": "2026-01-17T21:09:57.634Z",
        "action_counter": 1713
      }
    ]
  },
  "run_from_battle": {
    "description": "Automates the sequence to run from a wild Pokemon battle (Down -> Right -> A).",
    "input_schema": {
      "type": "object",
      "properties": {
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "autopress_buttons"
      ]
    },
    "python_script": "print([\"Down\", \"Right\", \"A\"])",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-17T14:26:27.544Z",
        "action_counter": 1176
      },
      {
        "commit_message": "Refined run_from_battle to strictly follow the Down -> Right -> A sequence for Gen 2 menus.",
        "timestamp": "2026-01-17T22:44:14.380Z",
        "action_counter": 1861
      }
    ]
  }
}