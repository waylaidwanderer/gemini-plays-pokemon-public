{
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map using the A* algorithm, avoiding impassable tiles and objects.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nimport heapq\n\ndef find_path(grid, start, end):\n    rows, cols = len(grid), len(grid[0])\n    open_set = [(0, start)]\n    came_from = {}\n    g_score = { (r, c): float('inf') for r in range(rows) for c in range(cols) }\n    g_score[start] = 0\n    f_score = { (r, c): float('inf') for r in range(rows) for c in range(cols) }\n    f_score[start] = abs(start[0] - end[0]) + abs(start[1] - end[1])\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n        if current == end:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            return path[::-1]\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dr, current[1] + dc)\n            if 0 <= neighbor[0] < rows and 0 <= neighbor[1] < cols and grid[neighbor[0]][neighbor[1]] == 0:\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score[neighbor]:\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = tentative_g_score + abs(neighbor[0] - end[0]) + abs(neighbor[1] - end[1])\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    return None\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\ngrid = [[0 for _ in range(width)] for _ in range(height)]\n\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.get('id')) - 1\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.get('id')) - 1\n        tile_type = tile_elem.get('type')\n        obj = tile_elem.find('Object')\n        is_impassable = tile_type in ['impassable', 'unknown', 'closed_gate']\n        has_blocking_object = obj is not None and obj.get('id-name') != 'Pikachu'\n        if is_impassable or has_blocking_object:\n            grid[y][x] = 1\n\npath = find_path(grid, (start_y - 1, start_x - 1), (end_y - 1, end_x - 1))\n\nif path:\n    formatted_path = [{\"x\": x + 1, \"y\": y + 1} for y, x in path]\n    print(json.dumps({\"path_found\": True, \"path\": formatted_path}))\nelse:\n    print(json.dumps({\"path_found\": False, \"path\": []}))\n"
  },
  "select_battle_option": {
    "description": "Calculates and executes the button presses needed to select a specific option from the main battle menu (FIGHT, PKMN, ITEM, RUN).",
    "input_schema": {
      "type": "object",
      "properties": {
        "option_to_select": {
          "type": "string",
          "enum": [
            "FIGHT",
            "PKMN",
            "ITEM",
            "RUN"
          ]
        }
      },
      "required": [
        "option_to_select"
      ]
    },
    "python_script": "option = input_data['option_to_select']\noptions = [\"FIGHT\", \"PKMN\", \"ITEM\", \"RUN\"]\ncurrent_pos = 0 # Assume cursor starts on FIGHT\npresses = []\ntarget_pos = options.index(option)\n# Simplified logic: Assume cursor moves right and down\nif target_pos == 1: # PKMN\n    presses.append('Right')\nelif target_pos == 2: # ITEM\n    presses.append('Down')\nelif target_pos == 3: # RUN\n    presses.append('Right')\n    presses.append('Down')\npresses.append('A')\nimport json\nprint(json.dumps(presses))"
  }
}