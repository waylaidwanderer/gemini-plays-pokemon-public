{
  "master_navigator": {
    "description": "A consolidated navigation tool that handles pathfinding. It can find a path to a specific coordinate. It now considers map markers for obstacles and correctly handles ledges.",
    "input_schema": {
      "type": "object",
      "properties": {
        "mode": {
          "type": "string",
          "enum": [
            "pathfind"
          ]
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer",
          "nullable": true
        },
        "end_y": {
          "type": "integer",
          "nullable": true
        },
        "traversable_tiles": {
          "type": "string"
        }
      },
      "required": [
        "mode",
        "start_x",
        "start_y",
        "traversable_tiles"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\nimport sys\n\nsys.stderr = sys.stdout\n\ndef find_path(map_xml_string, start_x, start_y, end_x, end_y, traversable_tiles_str):\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n\n        if not (1 <= start_x <= width and 1 <= start_y <= height):\n            return {\"error\": f\"Start coordinates ({start_x},{start_y}) are outside map boundaries (1-{width}, 1-{height}).\"}\n        if not (1 <= end_x <= width and 1 <= end_y <= height):\n            return {\"error\": f\"Goal coordinates ({end_x},{end_y}) are outside map boundaries (1-{width}, 1-{height}).\"}\n\n        traversable_tiles = traversable_tiles_str.split(',')\n\n        grid = [[True for _ in range(width + 1)] for _ in range(height + 1)]\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                is_player_tile = tile_elem.find('Player') is not None\n                \n                is_traversable = tile_type in traversable_tiles\n                \n                if 'LEDGE' in tile_type and is_traversable:\n                    is_traversable = False\n                \n                if has_object and not is_player_tile and is_traversable:\n                    is_traversable = False\n                \n                for marker in tile_elem.findall('Marker'):\n                    if marker.get('emoji') == 'ðŸš«' and is_traversable:\n                        is_traversable = False\n                        break\n                \n                grid[y][x] = is_traversable\n\n        def heuristic(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n        start = (start_x, start_y)\n        goal = (end_x, end_y)\n        \n        if not grid[goal[1]][goal[0]]:\n            found_new_goal = False\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_goal = (goal[0] + dx, goal[1] + dy)\n                if 1 <= new_goal[0] <= width and 1 <= new_goal[1] <= height and grid[new_goal[1]][new_goal[0]]:\n                    goal = new_goal\n                    found_new_goal = True\n                    break\n            if not found_new_goal:\n                 return {\"error\": f\"Goal ({end_x},{end_y}) and all adjacent tiles are not traversable.\"}\n\n        open_set = [(0, start)]\n        came_from = {}\n        g_score = { (x,y): float('inf') for y in range(height+1) for x in range(width+1) }\n        g_score[start] = 0\n        f_score = { (x,y): float('inf') for y in range(height+1) for x in range(width+1) }\n        f_score[start] = heuristic(start, goal)\n        \n        while open_set:\n            _, current = heapq.heappop(open_set)\n\n            if current == goal:\n                path = []\n                while current in came_from:\n                    path.append({'x': current[0], 'y': current[1]})\n                    current = came_from[current]\n                path.append({'x': start[0], 'y': start[1]})\n                return list(reversed(path))\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                neighbor = (current[0] + dx, current[1] + dy)\n                nx, ny = neighbor\n\n                if not (1 <= nx <= width and 1 <= ny <= height):\n                    continue\n                \n                if not grid[ny][nx]:\n                    continue\n\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, goal)\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n        \n        return {\"error\": \"No path found.\"}\n\n    except Exception as e:\n        return {\"error\": str(e)}\n\ntry:\n    mode = input_data['mode']\n    if mode == 'pathfind':\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        end_x = int(input_data['end_x'])\n        end_y = int(input_data['end_y'])\n        traversable_tiles_str = input_data['traversable_tiles']\n\n        path = find_path(map_xml_string, start_x, start_y, end_x, end_y, traversable_tiles_str)\n\n        if isinstance(path, dict) and \"error\" in path:\n            print(json.dumps(path))\n        elif path:\n            print(json.dumps({\"path\": path}))\n        else:\n            print(json.dumps({\"error\": \"No path found.\"}))\n    else:\n        print(json.dumps({\"error\": f\"Invalid mode: {mode}\"}))\n\nexcept Exception as e:\n    print(json.dumps({\"error\": f\"Tool execution failed: {str(e)}\"}))"
  }
}