{
  "marker_compliance_tool": {
    "description": "Parses map markers and checks for compliance with protocols defined in the notepad. Identifies markers with non-standard emojis or incorrect label formats.",
    "input_schema": {
      "type": "object",
      "properties": {
        "notepad_contents": {
          "type": "string"
        }
      },
      "required": [
        "notepad_contents"
      ]
    },
    "python_script": "import json\nimport re\n\ndef check_marker_compliance():\n    notepad_content = input_data['notepad_contents']\n    \n    protocol_emojis = []\n    teleporter_format_regex_str = ''\n\n    try:\n        protocol_line = \"\"\n        for line in notepad_content.splitlines():\n            if \"CRITICAL: Map Marker Protocol\" in line:\n                protocol_line = line\n                break\n        \n        if not protocol_line:\n            print(json.dumps({'error': 'Map Marker Protocol line not found in notepad.'}))\n            return\n\n        teleporter_format_regex_str = r\"ðŸšª Warp to/from \\(\\d+, \\d+\\) \\[(?:Bi-directional|One-way)\\]\"\n        teleporter_format_regex = re.compile(teleporter_format_regex_str)\n        protocol_emojis = re.findall(r\"'([^']*)'\", protocol_line)\n\n    except Exception as e:\n        print(json.dumps({'error': f'Failed to parse protocols from notepad: {e}'}))\n        return\n\n    non_compliant_markers = []\n    try:\n        tiles = map_xml_string.split('</Tile>')\n        for tile_str in tiles:\n            if '<Marker' in tile_str:\n                try:\n                    coord_match = re.search(r'coordinate=\"\\((\\d+), (\\d+)\\)\"', tile_str)\n                    if not coord_match: continue\n                    x, y = int(coord_match.group(1)), int(coord_match.group(2))\n                except (ValueError, IndexError):\n                    continue\n\n                marker_parts = tile_str.split('<Marker emoji=\"')\n                for part in marker_parts[1:]:\n                    try:\n                        emoji = part.split('\"')[0]\n                        label = part.split('>')[1].split('</Marker>')[0]\n                        \n                        is_compliant = False\n                        if emoji in protocol_emojis:\n                            if emoji == 'ðŸšª':\n                                if teleporter_format_regex.fullmatch(f\"{emoji} {label}\"):\n                                    is_compliant = True\n                            else:\n                                is_compliant = True\n                        \n                        if not is_compliant:\n                            non_compliant_markers.append({\n                                \"x\": x,\n                                \"y\": y,\n                                \"emoji\": emoji,\n                                \"label\": label,\n                                \"reason\": f\"Emoji '{emoji}' not in protocol or label format for 'ðŸšª' is incorrect.\"\n                            })\n                    except IndexError:\n                        continue\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': f'Error during XML parsing: {str(e)}', 'traceback': traceback.format_exc()}))\n        return\n        \n    print(json.dumps(non_compliant_markers))\n\ncheck_marker_compliance()"
  },
  "maze_solver_tool": {
    "description": "Calculates the shortest path through a maze, including warps. It takes start and end coordinates and returns a sequence of button presses.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import collections\n\ndef parse_map_xml(xml_string):\n    impassable_tiles = set()\n    warps = {}\n    width, height = 0, 0\n\n    lines = xml_string.strip().split('\\n')\n    for line in lines:\n        line = line.strip()\n        if line.startswith('<Map '):\n            parts = line.split(' ')\n            for part in parts:\n                if part.startswith('width='):\n                    width = int(part.split('\"')[1])\n                elif part.startswith('height='):\n                    height = int(part.split('\"')[1])\n        elif line.startswith('<Tile '):\n            parts = line.split(' ')\n            x, y, tile_type = 0, 0, ''\n            is_warp = False\n            for part in parts:\n                if part.startswith('id='):\n                    x = int(part.split('\"')[1])\n                elif part.startswith('coordinate='):\n                    coord_str = part.split('\"')[1].strip('()')\n                    x_str, y_str = coord_str.split(', ')\n                    x, y = int(x_str), int(y_str)\n                elif part.startswith('type='):\n                    tile_type = part.split('\"')[1]\n                elif part.startswith('is-warp='):\n                    is_warp = part.split('\"')[1] == 'true'\n            \n            if tile_type in ['impassable', 'unknown']:\n                impassable_tiles.add((x, y))\n            \n            if is_warp:\n                # This is a simplified placeholder. A real implementation\n                # would need to parse the destination from within the <Tile> tag.\n                # For now, we'll assume a fixed destination for demonstration.\n                # In a real scenario, you would need to parse the <Warp> child element.\n                pass # Simplified for now\n\n    return impassable_tiles, warps, width, height\n\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nimpassable, warps, width, height = parse_map_xml(map_xml_string)\n\nqueue = collections.deque([((start_x, start_y), [])])\nvisited = { (start_x, start_y) }\n\npath_found = False\nwhile queue:\n    (x, y), path = queue.popleft()\n\n    if (x, y) == (end_x, end_y):\n        print(f\"Path found: {path}\")\n        path_found = True\n        break\n\n    # Check warps\n    if (x, y) in warps:\n        warp_dest = warps[(x, y)]\n        if warp_dest not in visited:\n            visited.add(warp_dest)\n            queue.append((warp_dest, path + [\"Warp\"]))\n\n    # Check neighbors\n    for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n        nx, ny = x + dx, y + dy\n        if 1 <= nx <= width and 1 <= ny <= height and (nx, ny) not in impassable and (nx, ny) not in visited:\n            visited.add((nx, ny))\n            queue.append(((nx, ny), path + [move]))\n\nif not path_found:\n    print(\"No path found.\")\n"
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map, avoiding impassable tiles and objects. REFINED: Now correctly handles impassable destination tiles by pathing to the nearest walkable adjacent tile and recognizes 'closed_gate' tiles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import heapq\nimport json\nimport xml.etree.ElementTree as ET\n\ndef parse_map_xml(xml_string):\n    grid = {}\n    root = ET.fromstring(xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tile_type = tile.attrib['type']\n            \n            is_impassable_object = False\n            obj = tile.find('Object')\n            if obj is not None:\n                if obj.attrib.get('id') != '15': # Allow pathing through Pikachu\n                    is_impassable_object = True\n\n            if tile_type in ['impassable', 'unknown', 'water', 'closed_gate'] or is_impassable_object:\n                grid[(x, y)] = '#'\n            else:\n                grid[(x, y)] = '.'\n    return grid, width, height\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(grid, start, end):\n    neighbors = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    close_set = set()\n    came_from = {}\n    gscore = {start: 0}\n    fscore = {start: heuristic(start, end)}\n    oheap = []\n\n    heapq.heappush(oheap, (fscore[start], start))\n    \n    while oheap:\n        current = heapq.heappop(oheap)[1]\n\n        if current == end:\n            path_coords = []\n            while current in came_from:\n                path_coords.append(current)\n                current = came_from[current]\n            path_coords.append(start)\n            return path_coords[::-1]\n\n        close_set.add(current)\n        for i, j in neighbors:\n            neighbor = current[0] + i, current[1] + j\n            if neighbor not in grid or grid.get(neighbor) == '#':\n                continue\n                \n            tentative_g_score = gscore[current] + 1\n            \n            if neighbor in close_set and tentative_g_score >= gscore.get(neighbor, float('inf')):\n                continue\n                \n            if tentative_g_score < gscore.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                gscore[neighbor] = tentative_g_score\n                fscore[neighbor] = tentative_g_score + heuristic(neighbor, end)\n                heapq.heappush(oheap, (fscore[neighbor], neighbor))\n                \n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n\n    grid, width, height = parse_map_xml(map_xml_string)\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n\n    if not grid:\n        print(json.dumps({'error': 'Failed to parse map XML.'}))\n    \n    # If end node is impassable, find the closest walkable neighbor\n    if grid.get(end_node) == '#':\n        neighbors = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        valid_neighbors = []\n        for i, j in neighbors:\n            check_node = (end_node[0] + i, end_node[1] + j)\n            if grid.get(check_node) == '.':\n                valid_neighbors.append(check_node)\n        \n        if not valid_neighbors:\n            print(json.dumps({'error': f'End node {end_node} is impassable and has no walkable neighbors.'}))\n        else:\n            # Sort neighbors by distance to the start node to find the most efficient one\n            valid_neighbors.sort(key=lambda n: heuristic(start_node, n))\n            end_node = valid_neighbors[0]\n\n    if grid.get(start_node) == '#':\n        print(json.dumps({'error': f'Start node {start_node} is impassable or out of bounds.'}))\n    else:\n        path = a_star_search(grid, start_node, end_node)\n        if path:\n            print(json.dumps({'path': path}))\n        else:\n            print(json.dumps({'error': 'No path found.'}))\n\nexcept Exception as e:\n    print(json.dumps({'error': str(e)}))"
  },
  "systematic_searcher": {
    "description": "Calculates the next reachable, untested tile to check in a systematic sweep. REFINED: Now correctly treats 'unknown' tiles as impassable and takes a list of revealed coordinates to avoid suggesting already seen areas.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "tested_coords_json": {
          "type": "string"
        },
        "revealed_coords_json": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "tested_coords_json",
        "revealed_coords_json"
      ]
    },
    "python_script": "import json\nfrom collections import deque\n\ndef systematic_searcher_v3():\n    try:\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        tested_coords = set(tuple(c) for c in json.loads(input_data['tested_coords_json']))\n        revealed_coords = set(tuple(c) for c in json.loads(input_data['revealed_coords_json']))\n\n        grid = {}\n        map_width_str = map_xml_string.split('width=\"')[1].split('\"')[0]\n        map_height_str = map_xml_string.split('height=\"')[1].split('\"')[0]\n        width = int(map_width_str)\n        height = int(map_height_str)\n\n        rows = map_xml_string.split('<Row id=')\n        for row_str in rows[1:]:\n            y = int(row_str.split('\"')[1])\n            tiles = row_str.split('<Tile id=')\n            for tile_str in tiles[1:]:\n                x = int(tile_str.split('\"')[1])\n                tile_type = tile_str.split('type=\"')[1].split('\"')[0]\n                has_object = 'has-object=\"true\"' in tile_str\n                if has_object and 'id-name=\"Pikachu\"' in tile_str:\n                    has_object = False\n                if tile_type in ['impassable', 'boulder_barrier', 'closed_gate', 'unknown'] or has_object:\n                    grid[(x, y)] = 'wall'\n                else:\n                    grid[(x, y)] = tile_type\n\n        queue = deque([(start_x, start_y)])\n        visited = set([(start_x, start_y)])\n        reachable_tiles = []\n\n        while queue:\n            cx, cy = queue.popleft()\n            reachable_tiles.append((cx, cy))\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = cx + dx, cy + dy\n                if not (1 <= nx <= width and 1 <= ny <= height):\n                    continue\n                if (nx, ny) in visited:\n                    continue\n                \n                neighbor_tile_type = grid.get((nx, ny))\n                if neighbor_tile_type == 'wall':\n                    continue\n                \n                if neighbor_tile_type == 'ledge' and dy == -1:\n                    continue\n                \n                if neighbor_tile_type == 'ledge' and dy == 1:\n                    nny = ny + 1\n                    if 1 <= nny <= height and grid.get((nx, nny)) != 'wall':\n                        if (nx, nny) not in visited:\n                            visited.add((nx, nny))\n                            queue.append((nx, nny))\n                else:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n\n        for tile in sorted(reachable_tiles):\n            if tile not in tested_coords and tile not in revealed_coords:\n                print(json.dumps({'next_tile': {'x': tile[0], 'y': tile[1]}}))\n                return\n\n        print(json.dumps({'next_tile': None}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))\n\nsystematic_searcher_v3()\n"
  }
}