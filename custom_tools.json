{
  "find_path": {
    "description": "A consolidated pathfinding tool. Finds a path to specified X, Y coordinates. If no coordinates are provided, it finds a path to the nearest reachable unseen tile. It automatically paths to an adjacent tile if the target is impassable. It can now handle mixed traversal types (walking and surfing) and elevation changes via steps.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string",
          "nullable": true
        },
        "end_y": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\n# Parse the map XML from the provided string\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\ngrid = [['' for _ in range(width)] for _ in range(height)]\nimpassable_coords = set()\nunseen_tiles = []\n\n# Define tile categories for traversal logic\nwalk_types = ['ground', 'grass', 'open_gate', 'cleared_boulder_barrier', 'boulder_switch', 'teleport', 'hole', 'spinner_stop', 'cuttable']\nsurf_types = ['water']\nelevation_types = ['elevated_ground', 'ladder_up', 'ladder_down']\nstep_types = ['steps']\n\n# Populate the grid and identify impassable objects and unseen tiles\nfor r_idx, row_elem in enumerate(root.findall('Row')):\n    y = int(row_elem.get('id')) - 1\n    for c_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n        x = int(tile_elem.get('id')) - 1\n        tile_type = tile_elem.get('type')\n        grid[y][x] = tile_type\n        if tile_elem.get('seen') == 'false':\n            unseen_tiles.append((x, y))\n        # Treat all objects except Pikachu as impassable walls\n        if tile_elem.find('Object') is not None and (tile_elem.find('Object').get('id-name') != 'Pikachu'):\n            impassable_coords.add((x, y))\n\n# Get start and end coordinates from input\nstart_x, start_y = int(input_data['start_x']) - 1, int(input_data['start_y']) - 1\nend_x = int(input_data.get('end_x', None)) - 1 if input_data.get('end_x') else None\nend_y = int(input_data.get('end_y', None)) - 1 if input_data.get('end_y') else None\n\n# Helper function to check if a tile is traversable\ndef is_traversable(x, y):\n    if not (0 <= x < width and 0 <= y < height):\n        return False\n    tile_type = grid[y][x]\n    traversable_set = set(walk_types + surf_types + elevation_types + step_types + ['ledge'])\n    return tile_type in traversable_set and (x, y) not in impassable_coords\n\n# Main BFS pathfinding algorithm\ndef find_path_bfs():\n    if not is_traversable(start_x, start_y):\n        return []\n\n    queue = deque([((start_x, start_y), [(start_x, start_y)])])\n    visited = {(start_x, start_y)}\n\n    while queue:\n        (current_x, current_y), path = queue.popleft()\n\n        # Check if the target is reached\n        target_reached = False\n        if end_x is not None and end_y is not None:\n            if is_traversable(end_x, end_y):\n                if current_x == end_x and current_y == end_y:\n                    target_reached = True\n            else: # Path to an adjacent tile if the target itself is impassable\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    if current_x == end_x + dx and current_y == end_y + dy:\n                        if is_traversable(current_x, current_y):\n                            target_reached = True\n                            break\n        elif unseen_tiles: # Path to the nearest unseen tile if no target is specified\n            for ux, uy in unseen_tiles:\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    if current_x == ux + dx and current_y == uy + dy:\n                        if is_traversable(current_x, current_y):\n                           target_reached = True\n                           break\n                if target_reached: break\n        else:\n            return []\n\n        if target_reached:\n            return path\n\n        # Explore neighbors\n        for move in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = current_x + move[0], current_y + move[1]\n\n            if not (0 <= next_x < width and 0 <= next_y < height) or (next_x, next_y) in visited or not is_traversable(next_x, next_y):\n                continue\n\n            current_tile_type = grid[current_y][current_x]\n            next_tile_type = grid[next_y][next_x]\n\n            # --- CORE TRAVERSAL LOGIC ---\n            can_move = False\n            current_is_walk = current_tile_type in walk_types\n            current_is_surf = current_tile_type in surf_types\n            current_is_elevated = current_tile_type in elevation_types\n            current_is_step = current_tile_type in step_types\n            \n            next_is_walk = next_tile_type in walk_types\n            next_is_surf = next_tile_type in surf_types\n            next_is_elevated = next_tile_type in elevation_types\n            next_is_step = next_tile_type in step_types\n\n            # Rule 1: Movement on the same level (walk-walk, surf-surf, elevated-elevated)\n            if (current_is_walk and next_is_walk) or (current_is_surf and next_is_surf) or (current_is_elevated and next_is_elevated):\n                can_move = True\n            # Rule 2: Movement between elevation levels via steps\n            elif (current_is_walk and next_is_step) or (current_is_step and next_is_walk):\n                can_move = True\n            elif (current_is_elevated and next_is_step) or (current_is_step and next_is_elevated):\n                can_move = True\n            # Rule 3: Movement between water and land (walk or steps)\n            elif (current_is_surf and (next_is_walk or next_is_step)) or ((current_is_walk or next_is_step) and next_is_surf):\n                can_move = True\n\n            if not can_move and next_tile_type != 'ledge':\n                continue\n\n            # Special handling for ledges (one-way downward movement)\n            if next_tile_type == 'ledge':\n                if next_y > current_y:\n                    ledge_jump_y = next_y + 1\n                    if is_traversable(next_x, ledge_jump_y) and (next_x, ledge_jump_y) not in visited:\n                        new_path = path + [(next_x, next_y), (next_x, ledge_jump_y)]\n                        visited.add((next_x, next_y))\n                        visited.add((next_x, ledge_jump_y))\n                        queue.append(((next_x, ledge_jump_y), new_path))\n                continue\n            \n            if can_move:\n              visited.add((next_x, next_y))\n              new_path = path + [(next_x, next_y)]\n              queue.append(((next_x, next_y), new_path))\n            \n    return []\n\nfound_path = find_path_bfs()\n\n# Output the result in the required JSON format\nif found_path:\n    path_plan = [{'x': x + 1, 'y': y + 1} for x, y in found_path]\n    target_x, target_y = path_plan[-1]['x'], path_plan[-1]['y']\n    reasoning = f'Path found to target at ({target_x}, {target_y}).'\n    print(json.dumps({'path': path_plan, 'reasoning': reasoning}))\nelse:\n    print(json.dumps({'path': [], 'reasoning': 'Could not find a path to any reachable targets.'}))"
  },
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "get_impassable_tiles": {
    "description": "Extracts and returns a JSON list of all impassable tile coordinates from the current map XML.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET; import json; root = ET.fromstring(map_xml_string); impassable_tiles = []; for row_elem in root.findall('Row'): y = int(row_elem.get('id')); for tile_elem in row_elem.findall('Tile'): x = int(tile_elem.get('id')); if tile_elem.get('type') == 'impassable' or tile_elem.find('Object') is not None: impassable_tiles.append({'x': x, 'y': y}); print(json.dumps(impassable_tiles))"
  },
  "boulder_push_planner": {
    "description": "Analyzes the map to find a sequence of moves for the player to push a specific boulder to a specific hole. It considers impassable terrain and other objects.",
    "input_schema": {
      "type": "object",
      "properties": {
        "boulder_start_x": {
          "type": "string"
        },
        "boulder_start_y": {
          "type": "string"
        },
        "hole_x": {
          "type": "string"
        },
        "hole_y": {
          "type": "string"
        },
        "player_x": {
          "type": "string"
        },
        "player_y": {
          "type": "string"
        }
      },
      "required": [
        "boulder_start_x",
        "boulder_start_y",
        "hole_x",
        "hole_y",
        "player_x",
        "player_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\n\ndef get_impassable_tiles(exclude_boulder_pos=None):\n    impassable = set()\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id')) - 1\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id')) - 1\n            pos = (x, y)\n            if exclude_boulder_pos and pos == exclude_boulder_pos:\n                continue\n            tile_type = tile_elem.get('type')\n            if tile_type in ['impassable', 'boulder_barrier', 'closed_gate'] or tile_elem.find('Object') is not None:\n                impassable.add(pos)\n    return impassable\n\nplayer_start_x, player_start_y = int(input_data['player_x']) - 1, int(input_data['player_y']) - 1\nboulder_x, boulder_y = int(input_data['boulder_start_x']) - 1, int(input_data['boulder_start_y']) - 1\nhole_x, hole_y = int(input_data['hole_x']) - 1, int(input_data['hole_y']) - 1\n\nstart_state = (player_start_x, player_start_y, boulder_x, boulder_y)\nqueue = deque([(start_state, [])])\nvisited = {start_state}\n\nimpassable_static = get_impassable_tiles()\n\npath_found = False\nfinal_path = []\n\nwhile queue:\n    (px, py, bx, by), path = queue.popleft()\n\n    if (bx, by) == (hole_x, hole_y):\n        path_found = True\n        final_path = path\n        break\n\n    # Player moves\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        npx, npy = px + dx, py + dy\n        if not (0 <= npx < width and 0 <= npy < height):\n            continue\n        if (npx, npy) == (bx, by) or (npx, npy) in impassable_static:\n            continue\n        \n        new_state = (npx, npy, bx, by)\n        if new_state not in visited:\n            visited.add(new_state)\n            queue.append((new_state, path + [{'type': 'move', 'x': npx + 1, 'y': npy + 1}]))\n\n    # Push moves\n    for dx, dy, push_dir in [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n        # Player must be adjacent to boulder, opposite to push direction\n        if (px, py) == (bx - dx, by - dy):\n            nbx, nby = bx + dx, by + dy # New boulder position\n            if not (0 <= nbx < width and 0 <= nby < height):\n                continue\n            if (nbx, nby) in impassable_static:\n                continue\n            \n            new_state = (bx, by, nbx, nby) # Player moves onto boulder's old spot\n            if new_state not in visited:\n                visited.add(new_state)\n                queue.append((new_state, path + [{'type': 'push', 'direction': push_dir, 'boulder_end_x': nbx + 1, 'boulder_end_y': nby + 1}]))\n\nif path_found:\n    print(json.dumps({'path': final_path, 'reasoning': 'Found a sequence of moves to push the boulder into the hole.'}))\nelse:\n    print(json.dumps({'path': [], 'reasoning': 'Could not find a path to push the boulder into the hole.'}))"
  }
}