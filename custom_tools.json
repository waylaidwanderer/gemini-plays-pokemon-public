{
  "find_path": {
    "description": "Calculates a path from the player's current position to a target coordinate (x, y) using BFS. Treats 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', 'BOULDER', 'COUNTER', 'BOOKSHELF', 'PC', 'TV', 'RADIO', 'WINDOW', 'TOWN_MAP', 'MART_SHELF', 'LEDGE', 'TRAP' as obstacles. Explicitly allows traversing 'LADDER' tiles. Context-aware for Surfing. Returns a JSON array of button presses.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "# injected imports [\"sys\", \"json\"]\n# injected variables [\"map_xml_string\", \"input_data\"]\n\nimport xml.etree.ElementTree as ET\nimport collections\nimport json\n\ndef bfs(start_pos, target_pos, obstacles, width, height):\n    queue = collections.deque([[start_pos]])\n    visited = set([start_pos])\n    \n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n\n        if (x, y) == target_pos:\n            return path\n\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited and (nx, ny) not in obstacles:\n                visited.add((nx, ny))\n                new_path = list(path)\n                new_path.append((nx, ny))\n                queue.append(new_path)\n    return None\n\ndef get_buttons(path):\n    buttons = []\n    for i in range(len(path) - 1):\n        x1, y1 = path[i]\n        x2, y2 = path[i+1]\n        if x2 > x1: buttons.append(\"Right\")\n        elif x2 < x1: buttons.append(\"Left\")\n        elif y2 > y1: buttons.append(\"Down\")\n        elif y2 < y1: buttons.append(\"Up\")\n    return buttons\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    player_pos = None\n    obstacles = set()\n    \n    # Obstacle substrings to check against tile types\n    # Removed 'LADDER' from this list to allow traversal\n    obstacle_substrings = ['WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', 'BOULDER', \n                           'COUNTER', 'BOOKSHELF', 'PC', 'TV', 'RADIO', 'WINDOW', \n                           'TOWN_MAP', 'MART_SHELF', 'LEDGE', 'TRAP']\n    \n    obstacle_markers = {'Hole', 'Trap', 'ðŸ’£', 'ðŸ•³ï¸'}\n\n    # Determine if player is surfing (on WATER tile)\n    player_on_water = False\n    for row in root.findall('Row'):\n        for tile in row.findall('Tile'):\n            if tile.find('Player') is not None:\n                if tile.attrib.get('type') == 'WATER':\n                    player_on_water = True\n                break\n        if player_on_water: break\n    \n    if not player_on_water:\n        obstacle_substrings.append('WATER')\n\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tile_type = tile.attrib.get('type', 'FLOOR')\n            \n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n            \n            # Robust substring matching for obstacles\n            if any(obs in tile_type for obs in obstacle_substrings):\n                obstacles.add((x, y))\n                \n            if tile.get('has-object') == 'true' or tile.find('Object') is not None:\n                obstacles.add((x, y))\n            \n            for marker in tile.findall('Marker'):\n                label = marker.text or \"\"\n                emoji = marker.attrib.get('emoji', '')\n                if marker.attrib.get('object_id'):\n                    obstacles.add((x, y))\n                if any(obs in label for obs in obstacle_markers) or any(obs in emoji for obs in obstacle_markers):\n                    obstacles.add((x, y))\n\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    \n    # If target is an obstacle, try to find adjacent valid tile\n    if (target_x, target_y) in obstacles:\n         best_neighbor = None\n         min_dist = float('inf')\n         for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n             nx, ny = target_x + dx, target_y + dy\n             if (nx, ny) not in obstacles and 0 <= nx < width and 0 <= ny < height:\n                 dist = abs(nx - player_pos[0]) + abs(ny - player_pos[1])\n                 if dist < min_dist:\n                     min_dist = dist\n                     best_neighbor = (nx, ny)\n         if best_neighbor:\n             target_pos = best_neighbor\n         else:\n             print(json.dumps([]))\n             exit()\n    else:\n        target_pos = (target_x, target_y)\n\n    if not player_pos:\n        print(json.dumps([]))\n        exit()\n\n    path = bfs(player_pos, target_pos, obstacles, width, height)\n    \n    if path:\n        print(json.dumps(get_buttons(path)))\n    else:\n        print(json.dumps([]))\n\nexcept Exception as e:\n    print(json.dumps([]))",
    "history": [
      {
        "commit_message": "feat: Add find_path tool. Calculates shortest path using BFS, handling walls, objects, and one-way ledges.",
        "timestamp": "2025-11-20T08:35:46.882Z",
        "action_counter": 924
      },
      {
        "commit_message": "fix: Add LADDER to traversable basic_types in find_path. Previously, the tool considered LADDER tiles as walls, preventing pathfinding to or from them.",
        "timestamp": "2025-11-20T10:46:07.670Z",
        "action_counter": 1068
      },
      {
        "commit_message": "fix: Add FLOOR_UP_WALL to traversable tiles when moving down. This tile type appears on Route 32 and visually resembles a ledge, so it is assumed to be jumpable from the north.",
        "timestamp": "2025-11-20T21:10:28.299Z",
        "action_counter": 1479
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. In-game testing proved this tile type blocks movement from the north, contrary to the initial hypothesis that it was a jumpable ledge.",
        "timestamp": "2025-11-20T21:14:51.875Z",
        "action_counter": 1484
      },
      {
        "commit_message": "fix: Reinforce object collision check in find_path and add debug prints for player's neighbors to diagnose issues where objects are ignored.",
        "timestamp": "2025-11-20T23:31:27.320Z",
        "action_counter": 1632
      },
      {
        "commit_message": "fix: Add CAVE to traversable basic_types. This tile type represents cave entrances (warps) and must be traversable to enter dungeons like Union Cave. Also removed debug prints.",
        "timestamp": "2025-11-20T23:38:16.306Z",
        "action_counter": 1641
      },
      {
        "commit_message": "fix: Enable FLOOR_UP_WALL as a traversable ledge when moving down. This is necessary to test if the western ledge at (12, 18) is jumpable, as the eastern path is blocked.",
        "timestamp": "2025-11-21T00:47:29.072Z",
        "action_counter": 1752
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. Verified in-game at (16, 21) that this tile type acts as a wall and cannot be jumped from the north.",
        "timestamp": "2025-11-21T00:59:17.529Z",
        "action_counter": 1768
      },
      {
        "commit_message": "fix: Ensure FLOOR_UP_WALL is treated as a wall. Previous testing at (16, 21) confirmed it is not jumpable from the north.",
        "timestamp": "2025-11-21T01:01:08.516Z",
        "action_counter": 1771
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. Verified in-game at (12, 17) -> (12, 18) that this tile type acts as a wall and cannot be jumped from the north.",
        "timestamp": "2025-11-21T01:05:06.366Z",
        "action_counter": 1776
      },
      {
        "commit_message": "feat: Allow movement UP onto FLOOR_UP_WALL tiles. Verified in-game at Union Cave (5, 19) -> (5, 18) that this tile type acts as a climbable ramp from the south.",
        "timestamp": "2025-11-21T02:01:30.245Z",
        "action_counter": 1847
      },
      {
        "commit_message": "feat: Allow horizontal movement on FLOOR_UP_WALL. The tiles at row 18 act as a traversable ridge connecting the west and east sides of the room.",
        "timestamp": "2025-11-21T02:05:19.643Z",
        "action_counter": 1850
      },
      {
        "commit_message": "feat: Update find_path to automatically target adjacent traversable tiles if the destination is blocked by a wall or object. This eliminates the need for manual coordinate guessing when targeting NPCs or obstacles.",
        "timestamp": "2025-11-22T00:45:06.962Z",
        "action_counter": 3307
      },
      {
        "commit_message": "feat: Enhance find_path to treat tiles with object-linked markers as obstacles. This prevents the pathfinder from routing through off-screen NPCs or objects that are known to exist but not currently rendered in the viewport.",
        "timestamp": "2025-11-22T02:29:58.782Z",
        "action_counter": 3465
      },
      {
        "commit_message": "refactor: Change output format from coordinates to button presses (e.g. [\"Up\", \"Right\"]). This enables compatibility with the `autopress_buttons: true` feature for automated navigation.",
        "timestamp": "2025-11-22T06:33:20.386Z",
        "action_counter": 3846
      },
      {
        "commit_message": "fix: Update find_path to return a JSON array of button strings (e.g. ['Up', 'Right']) instead of coordinates, enabling compatibility with autopress_buttons. Also re-implements logic to path to adjacent tiles if the target is blocked.",
        "timestamp": "2025-11-22T06:37:44.405Z",
        "action_counter": 3851
      },
      {
        "commit_message": "fix: Rewrite find_path to output a JSON array of button strings (e.g. [\"Up\", \"Right\"]) instead of coordinate objects. Adds logic to automatically path to an adjacent tile if the target is blocked by a wall, object, or marker.",
        "timestamp": "2025-11-22T06:42:53.734Z",
        "action_counter": 3857
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE to the obstacles list in find_path. Previously, the pathfinder treated these trees as walkable FLOOR tiles, causing pathfinding failures on Route 36.",
        "timestamp": "2025-11-22T09:46:43.517Z",
        "action_counter": 4061
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE to obstacles list in find_path tool. This prevents pathfinding through solid trees on Route 36.",
        "timestamp": "2025-11-22T09:53:42.815Z",
        "action_counter": 4069
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE to obstacles list in find_path tool. This prevents pathfinding failures where the tool tries to route through solid trees on Route 36.",
        "timestamp": "2025-11-22T10:01:47.695Z",
        "action_counter": 4078
      },
      {
        "commit_message": "fix: Add LEDGE_HOP_DOWN, LEDGE_HOP_UP, LEDGE_HOP_LEFT, and LEDGE_HOP_RIGHT to the obstacles list in find_path. This prevents the pathfinder from incorrectly generating paths that try to walk up one-way ledges, which caused a navigation error on Route 37.",
        "timestamp": "2025-11-22T11:03:50.170Z",
        "action_counter": 4148
      },
      {
        "commit_message": "fix: Update find_path to treat tiles marked with 'Hole' or ðŸ•³ï¸ as obstacles. This prevents the pathfinder from routing the player into pits in the Burned Tower.",
        "timestamp": "2025-11-22T15:38:21.684Z",
        "action_counter": 4436
      },
      {
        "commit_message": "fix: Update find_path to treat tiles marked with 'Hole' or ðŸ•³ï¸ as obstacles. This prevents the pathfinder from routing the player into pits in the Burned Tower.",
        "timestamp": "2025-11-22T15:45:56.249Z",
        "action_counter": 4441
      },
      {
        "commit_message": "fix: Update find_path to correctly identify tiles with 'Hole' markers or object-linked markers as obstacles. This prevents pathfinding through dangerous tiles in the Burned Tower.",
        "timestamp": "2025-11-22T15:59:15.044Z",
        "action_counter": 4454
      },
      {
        "commit_message": "fix: Add PIT to obstacles list in find_path. This prevents the pathfinder from routing the player into pits in the Lighthouse.",
        "timestamp": "2025-11-23T02:50:16.179Z",
        "action_counter": 5202
      },
      {
        "commit_message": "fix: Add LADDER to obstacles list in find_path. This prevents the pathfinder from routing through ladders which are warps, avoiding accidental map transitions.",
        "timestamp": "2025-11-23T05:18:17.385Z",
        "action_counter": 5381
      },
      {
        "commit_message": "fix: Update find_path to be context-aware for Surfing. Now checks if the player is on a WATER tile; if so, removes WATER from the obstacle list. Also added BUOY to the base obstacle list to prevent pathing into buoys.",
        "timestamp": "2025-11-23T12:00:41.709Z",
        "action_counter": 5818
      },
      {
        "commit_message": "fix: Add FLOOR_UP_WALL, FLOOR_DOWN_WALL, FLOOR_LEFT_WALL, and FLOOR_RIGHT_WALL to the obstacles list in find_path. These tiles represent ledges or one-way walls in the current map data (Mt. Mortar) and were causing pathfinding failures.",
        "timestamp": "2025-11-24T01:30:19.414Z",
        "action_counter": 6532
      },
      {
        "commit_message": "fix: Explicitly add FLOOR_UP_WALL, FLOOR_DOWN_WALL, FLOOR_LEFT_WALL, and FLOOR_RIGHT_WALL to the base_obstacles set. These tiles are solid walls (ledge faces) and caused pathfinding errors when the tool incorrectly treated them as traversable.",
        "timestamp": "2025-11-24T02:01:48.846Z",
        "action_counter": 6571
      },
      {
        "commit_message": "fix: Update find_path to treat tiles marked with 'Trap' or 'ðŸ’£' as obstacles. This is critical for navigating the trap-filled corridor in Team Rocket Base B1F.",
        "timestamp": "2025-11-24T20:34:39.795Z",
        "action_counter": 7056
      },
      {
        "commit_message": "fix: Add COUNTER, BOOKSHELF, PC, TV, RADIO, WINDOW, TOWN_MAP, and MART_SHELF to the obstacle list in find_path. These are solid objects that block movement but were previously treated as traversable, causing pathfinding failures in the Rocket Base.",
        "timestamp": "2025-11-24T21:20:07.644Z",
        "action_counter": 7120
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE and CUT_TREE to obstacle_types in find_path. Previously, the tool treated these tiles as traversable, causing invalid paths through solid trees.",
        "timestamp": "2025-11-28T21:17:01.577Z",
        "action_counter": 12561
      },
      {
        "commit_message": "fix: Make obstacle detection robust by treating any tile type containing 'WALL' or 'TREE' as an obstacle. This prevents pathfinding failures on HEADBUTT_TREE or variant wall tiles that were previously missed.",
        "timestamp": "2025-11-28T21:27:51.596Z",
        "action_counter": 12576
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T21:45:16.721Z",
        "action_counter": 12601
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T21:48:50.709Z",
        "action_counter": 12606
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T21:53:24.421Z",
        "action_counter": 12612
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T21:56:57.360Z",
        "action_counter": 12616
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T21:59:09.404Z",
        "action_counter": 12620
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T22:03:11.092Z",
        "action_counter": 12625
      },
      {
        "commit_message": "fix: Added 'BOULDER' to obstacle keywords and explicitly checked for marker IDs to ensure dynamic objects are treated as obstacles. Added redundant checks for object attributes.",
        "timestamp": "2025-11-29T04:38:45.546Z",
        "action_counter": 13141
      },
      {
        "commit_message": "fix: Remove syntax error (garbage characters) from the end of the script and ensure 'BOULDER' is in the obstacle list.",
        "timestamp": "2025-11-29T04:41:30.820Z",
        "action_counter": 13146
      },
      {
        "commit_message": "fix: Remove 'LADDER' from obstacle_substrings. LADDER tiles are traversable and necessary for navigation in multi-floor areas like Dragon's Den. Previously, the tool incorrectly treated them as walls, causing pathfinding failures.",
        "timestamp": "2025-11-30T10:59:03.285Z",
        "action_counter": 14869
      }
    ]
  },
  "select_move": {
    "description": "Automatically selects a move in the battle menu by calculating the required button presses based on the cursor position in the screen text. Requires the move name and current screen text as input. Handles persistent cursor memory by scanning screen text.",
    "input_schema": {
      "type": "object",
      "properties": {
        "move_name": {
          "type": "string"
        },
        "screen_text": {
          "type": "string"
        }
      },
      "required": [
        "move_name",
        "screen_text"
      ]
    },
    "python_script": "import json\n\nmove_name = str(input_data['move_name']).upper()\nscreen_text = str(input_data['screen_text'])\n\nprint(f\"DEBUG: Target Move: {move_name}\")\n# print(f\"DEBUG: Screen Text:\\n{screen_text}\")\n\nlines = screen_text.split('\\n')\ncursor_line_index = -1\ntarget_line_index = -1\n\n# Search from the bottom up to find the menu elements (avoiding log text)\n# We assume the menu is at the bottom.\nfor i in range(len(lines) - 1, -1, -1):\n    line = lines[i]\n    # Check for cursor.\n    # Note: The arrow might be represented differently depending on OCR/Text extraction.\n    # Usually it is 'â–¶'.\n    if 'â–¶' in line and cursor_line_index == -1:\n        cursor_line_index = i\n        print(f\"DEBUG: Found cursor at line {i}: '{line}'\")\n    \n    # Check for target move.\n    if move_name in line and target_line_index == -1:\n        target_line_index = i\n        print(f\"DEBUG: Found target at line {i}: '{line}'\")\n\nbuttons = []\nif cursor_line_index != -1 and target_line_index != -1:\n    diff = target_line_index - cursor_line_index\n    if diff > 0:\n        buttons = [\"Down\"] * diff\n    elif diff < 0:\n        buttons = [\"Up\"] * abs(diff)\n    buttons.append(\"A\")\n    print(json.dumps(buttons))\nelse:\n    print(f\"DEBUG: Failed to find cursor ({cursor_line_index}) or target ({target_line_index})\")\n    # Fail safe: Do not return random buttons. Return empty to avoid bad presses.\n    print(\"[]\")",
    "history": [
      {
        "commit_message": "feat: Add select_move tool to automate move selection in battle menus, preventing manual input errors.",
        "timestamp": "2025-11-25T17:55:51.068Z",
        "action_counter": 7861
      },
      {
        "commit_message": "fix: Refine select_move to strictly validate inputs and ensure robust cursor detection logic, addressing the persistent cursor memory issue identified in critique.",
        "timestamp": "2025-11-30T07:21:13.927Z",
        "action_counter": 14672
      },
      {
        "commit_message": "fix: Refine select_move to strictly validate inputs and ensure robust cursor detection logic, addressing the persistent cursor memory issue identified in critique.",
        "timestamp": "2025-11-30T07:23:59.588Z",
        "action_counter": 14676
      },
      {
        "commit_message": "fix: Refine select_move to strictly validate inputs and ensure robust cursor detection logic, addressing the persistent cursor memory issue identified in critique.",
        "timestamp": "2025-11-30T07:25:07.230Z",
        "action_counter": 14678
      },
      {
        "commit_message": "fix: Refine select_move logic to robustly detect cursor and target move from screen text, adding debug prints to diagnose issues. This ensures the tool correctly handles persistent cursor memory in menus.",
        "timestamp": "2025-11-30T07:34:46.846Z",
        "action_counter": 14693
      }
    ]
  },
  "sequence_press": {
    "description": "Executes a sequence of button presses provided as a comma-separated string. Essential for navigating menus or keyboards where mixing directional and action inputs is required in a single turn.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "string",
          "description": "Comma-separated list of buttons to press, e.g., 'A, Down, Down, A'"
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nbuttons_str = input_data.get('buttons', '')\nif not buttons_str:\n    print('[]')\nelse:\n    button_list = [btn.strip() for btn in buttons_str.split(',')]\n    print(json.dumps(button_list))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-11-22T06:30:16.355Z",
        "action_counter": 3843
      }
    ]
  }
}