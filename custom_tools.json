{
  "unseen_tile_checker": {
    "description": "Analyzes the list of unseen tiles from a system alert and uses pathfinding logic to determine which are actually reachable from the player's current position.",
    "input_schema": {
      "type": "object",
      "properties": {
        "coordinates": {
          "type": "string",
          "description": "A stringified JSON array of coordinate objects, e.g., '[{\"x\":1,\"y\":2}]'"
        }
      },
      "required": [
        "coordinates"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\nimport json\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(start, goal, traversable, one_way_rules):\n    open_set = [(0 + heuristic(start, goal), 0, start)]\n    came_from = {}\n    g_score = {start: 0}\n\n    while open_set:\n        _, current_g, current_node = heapq.heappop(open_set)\n\n        if current_node == goal:\n            return True # Path found\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current_node[0] + dx, current_node[1] + dy)\n\n            if neighbor not in traversable and neighbor != goal: # Allow pathing to the goal even if it's not in the initial traversable set (e.g., unseen)\n                continue\n\n            if neighbor in one_way_rules:\n                allowed_from = one_way_rules[neighbor]\n                if (current_node[0] - neighbor[0], current_node[1] - neighbor[1]) != allowed_from:\n                    continue\n\n            tentative_g_score = current_g + 1\n\n            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                g_score[neighbor] = tentative_g_score\n                f_score = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_score, tentative_g_score, neighbor))\n                came_from[neighbor] = current_node\n\n    return False # No path found\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    player_x, player_y = -1, -1\n    traversable = set()\n    one_way_rules = {}\n\n    impassable_types = ['WALL', 'WINDOW', 'VOID', 'CUT_TREE', 'SIGN', 'BOOKSHELF', 'BLACKBOARD', 'MART_SHELF', 'BUOY', 'TV', 'TOWN_MAP', 'RADIO', 'INCENSE_BURNER', 'BIRD', 'HEADBUTT_TREE', 'FRUIT_TREE', 'COMPUTER', 'PRINTER', 'PC', 'COUNTER', 'CAVE']\n    one_way_types = {\n        'LEDGE_HOP_DOWN': (0, -1),\n        'LEDGE_HOP_LEFT': (1, 0),\n        'LEDGE_HOP_RIGHT': (-1, 0)\n    }\n\n    for row in root.findall('Row'):\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            y = int(row.get('id'))\n            tile_type = tile.get('type')\n\n            if tile.find('Player') is not None:\n                player_x, player_y = x, y\n\n            if tile_type not in impassable_types and tile.find('Object') is None:\n                traversable.add((x, y))\n                if tile_type in one_way_types:\n                    one_way_rules[(x, y)] = one_way_types[tile_type]\n\n    start_node = (player_x, player_y)\n    target_coordinates = json.loads(input_data['coordinates'])\n    reachable_tiles = []\n\n    if start_node == (-1, -1):\n        print('{\"error\": \"Player not found on the map.\"}')\n    else:\n        for coord in target_coordinates:\n            goal_node = (int(coord['x']), int(coord['y']))\n            if a_star_search(start_node, goal_node, traversable, one_way_rules):\n                reachable_tiles.append(coord)\n        print(json.dumps(reachable_tiles))\n\nexcept Exception as e:\n    print(f'{{\"error\": \"An unexpected error occurred in unseen_tile_checker: {str(e)}\"}}')\n",
    "history": [
      {
        "commit_message": "feat: Create unseen_tile_checker tool. This tool automates the process of checking which unseen tiles from a system alert are actually reachable, streamlining exploration and preventing wasted turns trying to path to disconnected areas.",
        "timestamp": "2025-07-29T03:31:55.070Z",
        "action_counter": 15144
      },
      {
        "commit_message": "feat: Create unseen_tile_checker tool. This tool automates the process of checking which unseen tiles from a system alert are actually reachable, streamlining exploration and preventing wasted turns trying to path to disconnected areas.",
        "timestamp": "2025-07-29T06:52:53.467Z",
        "action_counter": 15273
      }
    ]
  },
  "pathfinder": {
    "description": "Finds the shortest path from the player's current position to a target coordinate on the current map using the A* algorithm. It avoids impassable tiles and respects one-way traversal rules.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import json\ndef run(input_data, map_xml_string):\n    try:\n        print(json.dumps({'output': map_xml_string[:500]}))\n    except Exception as e:\n        print(json.dumps({'error': str(e)}))\n",
    "history": [
      {
        "commit_message": "feat: Recreate pathfinder tool after deletion. This is an attempt to resolve the persistent sandbox error by forcing a complete reset of the tool's environment. The script itself remains unchanged as it was previously functional.",
        "timestamp": "2025-07-29T06:31:10.732Z",
        "action_counter": 15245
      },
      {
        "commit_message": "fix: Overhaul pathfinder script for robustness. The previous 'sandbox not running' error was likely a red herring for a script that was crashing silently. This revision adds comprehensive error handling with a try-except block, explicit type casting for input data, and refined logic for parsing the map XML and identifying traversable tiles. This should resolve the persistent failures and restore pathfinding functionality.",
        "timestamp": "2025-07-29T06:51:09.535Z",
        "action_counter": 15271
      },
      {
        "commit_message": "fix: Overhaul pathfinder script for robustness. The previous 'sandbox not running' error was likely a red herring for a script that was crashing silently. This revision adds comprehensive error handling with a try-except block, explicit type casting for input data, and refined logic for parsing the map XML and identifying traversable tiles. This should resolve the persistent failures and restore pathfinding functionality.",
        "timestamp": "2025-07-29T07:16:36.610Z",
        "action_counter": 15305
      },
      {
        "commit_message": "fix: Overhaul pathfinder script for robustness. The previous 'sandbox not running' error was likely a red herring for a script that was crashing silently. This revision adds comprehensive error handling with a try-except block, explicit type casting for input data, and refined logic for parsing the map XML and identifying traversable tiles. This should resolve the persistent failures and restore pathfinding functionality.",
        "timestamp": "2025-07-29T07:34:50.124Z",
        "action_counter": 15331
      },
      {
        "commit_message": "refactor: Simplify script for debugging. This version only attempts to parse the map XML and print a success/failure message. This is to isolate the source of the 'sandbox not running' crash by testing the absolute most basic functionality.",
        "timestamp": "2025-07-29T07:35:55.027Z",
        "action_counter": 15333
      },
      {
        "commit_message": "refactor: Further simplify script for debugging. This version avoids the XML parsing library entirely and only prints the first 500 characters of the map XML string. This is to test if the sandbox can handle basic variable passing and printing, isolating the problem from the potentially crashing ET library.",
        "timestamp": "2025-07-29T07:37:10.616Z",
        "action_counter": 15334
      }
    ]
  }
}