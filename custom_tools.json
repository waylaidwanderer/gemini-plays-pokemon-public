{
  "find_path_v2": {
    "description": "Finds the shortest path between two coordinates on the current map using BFS, considering walls, objects, hazardous tiles, and one-way ledges as obstacles/transitions. Returns a JSON array of buttons.",
    "input_schema": {
      "type": "object",
      "properties": {
        "autopress_buttons": {
          "default": false,
          "type": "boolean"
        },
        "avoid_warps": {
          "default": true,
          "type": "boolean"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "autopress_buttons"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef solve():\n    tree = ET.fromstring(map_xml_string)\n    width = int(tree.attrib['width'])\n    height = int(tree.attrib['height'])\n    \n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    avoid_warps = input_data.get('avoid_warps', True)\n    \n    traversable_types = {'FLOOR', 'TALL_GRASS', 'LONG_GRASS', 'WARP_CARPET_UP', 'WARP_CARPET_DOWN', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'CAVE', 'DOOR', 'STAIRS', 'LADDER', 'FLOOR_UP_WALL', 'FLOOR_DOWN_WALL', 'FLOOR_LEFT_WALL', 'FLOOR_RIGHT_WALL'}\n    warp_types = {'WARP_CARPET_UP', 'WARP_CARPET_DOWN', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'CAVE', 'DOOR', 'STAIRS', 'LADDER'}\n    \n    grid = {}\n    for row in tree.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            grid[(x, y)] = {'type': t_type, 'has_obj': tile.find('Object') is not None}\n\n    queue = deque([(start_x, start_y, [])])\n    visited = {(start_x, start_y)}\n    \n    while queue:\n        cx, cy, path = queue.popleft()\n        if cx == end_x and cy == end_y:\n            print(json.dumps(path))\n            return\n            \n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = cx + dx, cy + dy\n            \n            # Boundary check\n            if not (0 <= nx < width and 0 <= ny < height):\n                continue\n                \n            tile = grid.get((nx, ny))\n            if not tile: continue\n            \n            t_type = tile['type']\n            \n            # Ledge Handling\n            if t_type == 'LEDGE_HOP_DOWN' and btn == 'Down':\n                nx, ny = nx, ny + 1 # Jump over the ledge\n                if not (0 <= nx < width and 0 <= ny < height): continue\n                tile = grid.get((nx, ny))\n                if not tile: continue\n                t_type = tile['type']\n            elif t_type == 'LEDGE_HOP_LEFT' and btn == 'Left':\n                nx, ny = nx - 1, ny\n                if not (0 <= nx < width and 0 <= ny < height): continue\n                tile = grid.get((nx, ny))\n                if not tile: continue\n                t_type = tile['type']\n            elif t_type == 'LEDGE_HOP_RIGHT' and btn == 'Right':\n                nx, ny = nx + 1, ny\n                if not (0 <= nx < width and 0 <= ny < height): continue\n                tile = grid.get((nx, ny))\n                if not tile: continue\n                t_type = tile['type']\n            elif t_type in {'LEDGE_HOP_DOWN', 'LEDGE_HOP_LEFT', 'LEDGE_HOP_RIGHT'}:\n                # Cannot move onto a ledge from any other direction\n                continue\n\n            # Standard collision\n            if t_type not in traversable_types:\n                if not (nx == end_x and ny == end_y):\n                    continue\n            \n            # Warp avoidance\n            if avoid_warps and t_type in warp_types and (nx != end_x or ny != end_y):\n                continue\n                \n            # Object collision\n            if tile['has_obj'] and (nx != start_x or ny != start_y):\n                if not (nx == end_x and ny == end_y):\n                    continue\n            \n            if (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, path + [btn]))\n                \n    print(json.dumps({\"error\": \"No path found\"}))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T20:27:16.465Z",
        "action_counter": 29425
      },
      {
        "commit_message": "Refined to correctly identify objects using 'has-object' attribute and added logic for boulder bridges in pits.",
        "timestamp": "2025-12-28T20:30:14.390Z",
        "action_counter": 29431
      },
      {
        "commit_message": "Refined to correctly handle autopress_buttons by outputting button strings and fixed pathfinding logic for boulder bridges.",
        "timestamp": "2025-12-28T20:30:50.776Z",
        "action_counter": 29432
      },
      {
        "commit_message": "Refined to handle boulder bridges in Blackthorn Gym 1F and improved object detection.",
        "timestamp": "2025-12-28T20:47:40.334Z",
        "action_counter": 29458
      },
      {
        "commit_message": "Fixing missing commit message and improving tile passability logic.",
        "timestamp": "2025-12-28T22:59:48.479Z",
        "action_counter": 29673
      },
      {
        "commit_message": "Fix find_path_v2 by providing a commit message and using input_data correctly.",
        "timestamp": "2025-12-29T03:29:03.821Z",
        "action_counter": 30041
      },
      {
        "commit_message": "Refine find_path_v2 to treat PIT and LADDER tiles as obstacles by default to prevent accidental warps, unless they are the intended destination.",
        "timestamp": "2025-12-29T04:09:14.393Z",
        "action_counter": 30092
      },
      {
        "commit_message": "Refine find_path_v2 to treat all warp tiles (PIT, LADDER) as obstacles unless they are the specific destination, and correctly identify objects using 'has-object'.",
        "timestamp": "2025-12-29T04:10:34.909Z",
        "action_counter": 30094
      },
      {
        "commit_message": "Initial definition with ledge handling.",
        "timestamp": "2026-01-06T20:56:57.721Z",
        "action_counter": 30778
      },
      {
        "commit_message": "Added commit message to update tool.",
        "timestamp": "2026-01-06T21:16:09.438Z",
        "action_counter": 30812
      },
      {
        "commit_message": "Refined ledge handling: ledges are now impassable from all directions except the jump direction. Added more impassable tile types.",
        "timestamp": "2026-01-06T21:17:48.184Z",
        "action_counter": 30816
      },
      {
        "commit_message": "Added CAVE and WARP to impassable tiles to prevent accidental map transitions.",
        "timestamp": "2026-01-06T21:27:34.747Z",
        "action_counter": 30833
      },
      {
        "commit_message": "Added avoid_warps parameter and object detection logic. Refined ledge and warp handling.",
        "timestamp": "2026-01-06T21:37:49.308Z",
        "action_counter": 30841
      },
      {
        "commit_message": "Removed 'unseen' from impassable_base to allow exploration pathing.",
        "timestamp": "2026-01-06T21:53:26.245Z",
        "action_counter": 30871
      },
      {
        "commit_message": "Removed 'unseen' from impassable tiles to allow exploration pathing. Added avoid_warps parameter. Refined ledge and object handling.",
        "timestamp": "2026-01-06T21:58:47.153Z",
        "action_counter": 30880
      },
      {
        "commit_message": "Initial definition with correct schema and logic.",
        "timestamp": "2026-01-07T09:27:38.973Z",
        "action_counter": 32021
      },
      {
        "commit_message": "Refined find_path_v2 to treat HEADBUTT_TREE as an obstacle and allow player to move from their current tile.",
        "timestamp": "2026-01-07T12:10:42.415Z",
        "action_counter": 32283
      },
      {
        "commit_message": "Refined find_path_v2 to handle ledge hopping (LEDGE_HOP_DOWN, LEFT, RIGHT) as one-way jump transitions.",
        "timestamp": "2026-01-07T12:55:12.814Z",
        "action_counter": 32363
      }
    ]
  },
  "press_menu_buttons": {
    "description": "Presses a sequence of buttons to navigate menus, bypassing the directional/action mixing restriction. Use for menu navigation ONLY. Returns the sequence of buttons as a JSON array.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nprint(json.dumps(input_data['buttons']))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-29T01:56:30.654Z",
        "action_counter": 29934
      }
    ]
  },
  "grind_encounters": {
    "description": "Paces back and forth to trigger wild encounters.",
    "input_schema": {
      "properties": {
        "steps": {
          "default": 10,
          "description": "The number of steps to pace (total).",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "python_script": "import json\nsteps = int(input_data.get('steps', 10))\nbuttons = []\nfor _ in range(steps // 2):\n    buttons.extend([\"Left\", \"Right\"])\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-07T15:39:09.904Z",
        "action_counter": 32671
      }
    ]
  },
  "solve_boulders": {
    "description": "Uses BFS to find the sequence of pushes to fill all pits in Blackthorn Gym 2F and returns the full button sequence to execute the solution.",
    "input_schema": {
      "type": "object",
      "properties": {
        "boulders": {
          "additionalProperties": {
            "items": {
              "type": "integer"
            },
            "maxItems": 2,
            "minItems": 2,
            "type": "array"
          },
          "type": "object"
        },
        "player_pos": {
          "items": {
            "type": "integer"
          },
          "maxItems": 2,
          "minItems": 2,
          "type": "array"
        },
        "walls": {
          "items": {
            "items": {
              "type": "integer"
            },
            "maxItems": 2,
            "minItems": 2,
            "type": "array"
          },
          "type": "array"
        }
      },
      "required": [
        "boulders",
        "walls",
        "player_pos"
      ]
    },
    "python_script": "import json\nfrom collections import deque\n\ndef solve():\n    data = input_data\n    grid_width, grid_height = 10, 18\n    walls = set(tuple(w) for w in data.get('walls', []))\n    pits = {(8, 3), (2, 5), (8, 7)}\n    \n    boulders_start = {}\n    for k, v in data.get('boulders', {}).items():\n        try:\n            clean_k = \"\".join(filter(str.isdigit, str(k)))\n            if clean_k:\n                boulders_start[int(clean_k)] = tuple(v)\n        except (ValueError, TypeError):\n            continue\n            \n    player_start = tuple(data.get('player_pos'))\n\n    def is_floor(x, y, current_boulders):\n        if not (0 <= x < grid_width and 0 <= y < grid_height): return False\n        if (x, y) in walls: return False\n        if (x, y) in current_boulders: return False\n        if (x, y) in pits: return False\n        return True\n\n    def get_player_path(start, target, current_boulders):\n        if start == target: return []\n        q, v = deque([(start, [])]), {start}\n        while q:\n            curr, path = q.popleft()\n            for dx, dy, btn in [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n                nxt = (curr[0] + dx, curr[1] + dy)\n                if is_floor(nxt[0], nxt[1], current_boulders) and nxt not in v:\n                    if nxt == target: return path + [btn]\n                    v.add(nxt)\n                    q.append((nxt, path + [btn]))\n        return None\n\n    initial_b = frozenset(boulders_start.items())\n    queue = deque([(initial_b, player_start, [])])\n    visited = {(initial_b, player_start)}\n\n    while queue:\n        curr_b_items, curr_p, push_sequence = queue.popleft()\n        curr_b_dict = dict(curr_b_items)\n        curr_b_pos_set = set(curr_b_dict.values())\n\n        if not curr_b_dict:\n            all_buttons = []\n            temp_b = dict(initial_b)\n            temp_p = player_start\n            for b_id, move_name in push_sequence:\n                bx, by = temp_b[b_id]\n                dx, dy = 0, 0\n                if move_name == 'Down': dy = -1\n                elif move_name == 'Up': dy = 1\n                elif move_name == 'Right': dx = -1\n                elif move_name == 'Left': dx = 1\n                sp = (bx + dx, by + dy)\n                path_to_sp = get_player_path(temp_p, sp, set(temp_b.values()))\n                if path_to_sp is None: break\n                all_buttons.extend(path_to_sp)\n                all_buttons.append(move_name)\n                new_bx, new_by = bx - dx, by - dy\n                if (new_bx, new_by) in pits: del temp_b[b_id]\n                else: temp_b[b_id] = (new_bx, new_by)\n                temp_p = (bx, by)\n            print(json.dumps(all_buttons))\n            return\n\n        for b_id, b_pos in curr_b_dict.items():\n            bx, by = b_pos\n            for dx, dy, name in [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]:\n                tx, ty = bx + dx, by + dy\n                sp = (bx - dx, by - dy)\n                if 0 <= tx < grid_width and 0 <= ty < grid_height and (tx, ty) not in walls and (tx, ty) not in curr_b_pos_set:\n                    if get_player_path(curr_p, sp, curr_b_pos_set) is not None:\n                        new_b_dict = dict(curr_b_dict)\n                        if (tx, ty) in pits: del new_b_dict[b_id]\n                        else: new_b_dict[b_id] = (tx, ty)\n                        new_b_items = frozenset(new_b_dict.items())\n                        if (new_b_items, b_pos) not in visited:\n                            visited.add((new_b_items, b_pos))\n                            queue.append((new_b_items, b_pos, push_sequence + [(b_id, name)]))\n    print(json.dumps([]))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-08T19:07:40.670Z",
        "action_counter": 34921
      },
      {
        "commit_message": "Make boulder ID parsing more robust to handle harness-specific key formatting.",
        "timestamp": "2026-01-08T19:32:32.427Z",
        "action_counter": 34949
      },
      {
        "commit_message": "Fix boulder ID parsing and improve data hygiene to prevent crashes. Ensure coordinate arrays are handled correctly.",
        "timestamp": "2026-01-08T19:44:14.797Z",
        "action_counter": 34965
      },
      {
        "commit_message": "Refine solve_boulders to return a full button sequence for automated execution.",
        "timestamp": "2026-01-08T19:45:15.280Z",
        "action_counter": 34966
      }
    ]
  },
  "solve_boulders_v2": {
    "description": "Uses BFS to find the sequence of pushes to fill all pits in Blackthorn Gym 2F and returns the full button sequence to execute the solution.",
    "input_schema": {
      "type": "object",
      "properties": {
        "boulders": {
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "minItems": 2,
            "maxItems": 2
          }
        },
        "walls": {
          "type": "array",
          "items": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "minItems": 2,
            "maxItems": 2
          }
        },
        "pits": {
          "type": "array",
          "items": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "minItems": 2,
            "maxItems": 2
          }
        },
        "player_pos": {
          "type": "array",
          "items": {
            "type": "integer"
          },
          "minItems": 2,
          "maxItems": 2
        }
      },
      "required": [
        "boulders",
        "walls",
        "pits",
        "player_pos"
      ]
    },
    "python_script": "import collections\nimport json\n\ndef solve():\n    # Input from Gem\n    # boulders = {\"id\": [x, y], ...}\n    # walls = [[x, y], ...]\n    # pits = [[x, y], ...]\n    # player_pos = [x, y]\n    \n    # Static Gym Data (Blackthorn 2F)\n    WIDTH, HEIGHT = 10, 18\n    \n    # Helper to convert list to tuple for hashing\n    def t(l): return tuple(l)\n\n    # State: (player_pos, tuple_of_boulder_positions, filled_pits)\n    initial_boulders = tuple(sorted([(k, t(v)) for k, v in boulders.items()]))\n    initial_state = (t(player_pos), initial_boulders, tuple())\n    \n    wall_set = {t(w) for w in walls}\n    pit_set = {t(p) for p in pits}\n    \n    queue = collections.deque([(initial_state, [])])\n    visited = {initial_state}\n    \n    while queue:\n        (curr_p, curr_b, filled), path = queue.popleft()\n        \n        if len(filled) == len(pit_set):\n            print(json.dumps(path))\n            return\n\n        # Try moving in 4 directions\n        for dx, dy, btn in [(0, -1, \"Up\"), (0, 1, \"Down\"), (-1, 0, \"Left\"), (1, 0, \"Right\")]:\n            nx, ny = curr_p[0] + dx, curr_p[1] + dy\n            if not (0 <= nx < WIDTH and 0 <= ny < HEIGHT): continue\n            \n            new_p = (nx, ny)\n            \n            # Check if hitting a boulder\n            boulder_id = None\n            b_list = list(curr_b)\n            for i, (bid, bpos) in enumerate(b_list):\n                if bpos == new_p:\n                    boulder_id = i\n                    break\n            \n            if boulder_id is not None:\n                # Try pushing boulder\n                bx, by = b_list[boulder_id][1]\n                bnx, bny = bx + dx, by + dy\n                \n                # Check if push is valid (within bounds, not a wall, not another boulder)\n                if 0 <= bnx < WIDTH and 0 <= bny < HEIGHT:\n                    target = (bnx, bny)\n                    if target not in wall_set and target not in [b[1] for b in b_list]:\n                        new_b_list = list(b_list)\n                        new_filled = list(filled)\n                        \n                        if target in pit_set and target not in filled:\n                            # Boulder falls in pit\n                            new_b_list.pop(boulder_id)\n                            new_filled.append(target)\n                        else:\n                            # Boulder moves to new tile\n                            new_b_list[boulder_id] = (b_list[boulder_id][0], target)\n                        \n                        new_b_tuple = tuple(sorted(new_b_list))\n                        new_filled_tuple = tuple(sorted(new_filled))\n                        next_state = (new_p, new_b_tuple, new_filled_tuple)\n                        \n                        if next_state not in visited:\n                            visited.add(next_state)\n                            queue.append((next_state, path + [btn]))\n            else:\n                # Just move player\n                if new_p not in wall_set:\n                    next_state = (new_p, curr_b, filled)\n                    if next_state not in visited:\n                        visited.add(next_state)\n                        queue.append((next_state, path + [btn]))\n\nsolve()\n",
    "history": [
      {
        "commit_message": "Update solve_boulders to include explicit pit locations and improve BFS search for Blackthorn Gym 2F.",
        "timestamp": "2026-01-08T20:50:44.832Z",
        "action_counter": 35041
      }
    ]
  }
}