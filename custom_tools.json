{
  "pathfinder": {
    "description": "Finds a path to a target coordinate using a Breadth-First Search algorithm. This is a rebuilt version with verified grid-parsing.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\ntry:\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\nexcept (ValueError, ET.ParseError) as e:\n    print(json.dumps({'error': f'Failed to parse inputs or map XML: {e}'}))\n    exit()\nplayer_pos = None\nfor row_elem in root.findall('Row'):\n    tile_with_player = row_elem.find('Tile[Player]')\n    if tile_with_player is not None:\n        player_pos = (int(tile_with_player.attrib['id']), int(row_elem.attrib['id']))\n        break\nif player_pos is None:\n    print(json.dumps({'error': 'Player start position not found.'}))\n    exit()\ngrid = [['' for _ in range(width + 1)] for _ in range(height + 1)]\nimpassable_base_types = ['impassable', 'cuttable', 'boulder_barrier', 'closed_gate', 'water']\nfor r_elem in root.findall('Row'):\n    y = int(r_elem.attrib['id'])\n    for t_elem in r_elem.findall('Tile'):\n        x = int(t_elem.attrib['id'])\n        tile_type = t_elem.attrib['type']\n        obj = t_elem.find('Object')\n        has_blocking_obj = obj is not None and obj.attrib.get('id-name') != 'Pikachu'\n        if tile_type in impassable_base_types or has_blocking_obj:\n            grid[y][x] = 'impassable'\n        else:\n            grid[y][x] = tile_type\nstart = player_pos\ngoal = (target_x, target_y)\nif not (1 <= goal[0] <= width and 1 <= goal[1] <= height and grid[goal[1]][goal[0]] != 'impassable'):\n    found_new_goal = False\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n        n_goal = (goal[0] + dx, goal[1] + dy)\n        if 1 <= n_goal[0] <= width and 1 <= n_goal[1] <= height and grid[n_goal[1]][n_goal[0]] != 'impassable':\n            goal = n_goal\n            found_new_goal = True\n            break\n    if not found_new_goal:\n        print(json.dumps({'error': 'Target is on an impassable tile with no valid neighbors.'}))\n        exit()\nqueue = deque([(start, [start])])\nvisited = {start}\nwhile queue:\n    current, path = queue.popleft()\n    if current == goal:\n        print(json.dumps(path))\n        exit()\n    (x, y) = current\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n        neighbor = (x + dx, y + dy)\n        nx, ny = neighbor\n        if not (1 <= nx <= width and 1 <= ny <= height and grid[ny][nx] != 'impassable' and neighbor not in visited):\n            continue\n        neighbor_tile_type = grid[ny][nx]\n        if neighbor_tile_type == 'ledge' and dy != 1:\n            continue\n        visited.add(neighbor)\n        new_path = list(path)\n        new_path.append(neighbor)\n        queue.append((neighbor, new_path))\nprint(json.dumps([]))"
  },
  "boulder_puzzle_solver": {
    "description": "Analyzes the map XML for a boulder puzzle and provides a step-by-step solution. This version includes A* pathfinding to ensure the player can reach the boulders before attempting a push. It correctly handles puzzles with more boulders than switches, includes an iteration limit, and validates that the player can reach the exact push position. **This version now correctly checks for the SURF HM and allows the player pathfinding to traverse water tiles.**",
    "input_schema": {
      "type": "object",
      "properties": {
        "boulder_coords": {
          "type": "string"
        },
        "switch_coords": {
          "type": "string"
        },
        "party_data": {
          "type": "string"
        }
      },
      "required": [
        "boulder_coords",
        "switch_coords",
        "party_data"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\nfrom collections import deque\n\ndef solve_boulder_puzzle(input_data):\n    grid = {}\n    player_pos = None\n    map_width = 0\n    map_height = 0\n    party_data = []\n\n    def parse_map_and_party(xml_string, party_str):\n        nonlocal grid, player_pos, map_width, map_height, party_data\n        root = ET.fromstring(xml_string)\n        map_width = int(root.get('width'))\n        map_height = int(root.get('height'))\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                is_warp = tile_elem.get('is-warp') == 'true'\n                object_id_name = None\n                obj_elem = tile_elem.find('Object')\n                if obj_elem is not None:\n                    object_id_name = obj_elem.get('id-name')\n                if tile_elem.find('Player') is not None:\n                    player_pos = (x, y)\n                grid[(x, y)] = {'type': tile_type, 'has_object': has_object, 'is_warp': is_warp, 'object_id_name': object_id_name}\n        party_data = json.loads(party_str) if party_str else []\n\n    def has_hm(hm_name):\n        for pokemon in party_data:\n            if not pokemon.get('is_fainted', False):\n                for move in pokemon.get('moves', []):\n                    if isinstance(move, dict) and move.get('name') == hm_name: return True\n                    elif isinstance(move, str) and move == hm_name: return True\n        return False\n\n    def is_player_traversable(from_coord, to_coord, current_boulders):\n        if to_coord not in grid: return False\n        to_tile = grid[to_coord]\n        from_tile = grid[from_coord]\n        from_type = from_tile['type']\n        to_type = to_tile['type']\n\n        if to_type in ['impassable', 'boulder_barrier'] or to_coord in current_boulders: return False\n        if to_tile['has_object'] and not to_tile['is_warp'] and to_tile.get('object_id_name') != 'PIKACHU': return False\n        \n        if to_type == 'water' and has_hm('SURF'):\n            if from_type in ['ground', 'steps', 'grass', 'water']:\n                return True\n        if from_type == 'water' and to_type in ['ground', 'steps', 'grass'] and has_hm('SURF'):\n            return True\n\n        valid_land_types = {'ground', 'grass', 'steps', 'elevated_ground', 'ladder_up', 'ladder_down'}\n        if from_type in valid_land_types and to_type in valid_land_types:\n            if from_type == 'steps' and to_type in {'ground', 'grass', 'elevated_ground', 'steps'}: return True\n            if to_type == 'steps' and from_type in {'ground', 'grass', 'elevated_ground'}: return True\n            if from_type == to_type: return True\n            if from_type in {'ground', 'grass'} and to_type in {'ground', 'grass'}: return True\n            if from_type in {'ladder_up', 'ladder_down'} or to_type in {'ladder_up', 'ladder_down'}: return True\n            return False\n        return False\n\n    def get_player_neighbors(node, current_boulders):\n        x, y = node\n        neighbors = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 1 <= nx <= map_width and 1 <= ny <= map_height:\n                if is_player_traversable((x, y), (nx, ny), current_boulders):\n                    neighbors.append((nx, ny))\n        return neighbors\n\n    def player_a_star(start, goal, current_boulders):\n        frontier = [(0, start)]\n        came_from = {start: None}\n        cost_so_far = {start: 0}\n        max_iterations = 2000\n        iterations = 0\n        while frontier:\n            iterations += 1\n            if iterations > max_iterations: return None\n            _, current = heapq.heappop(frontier)\n            if current == goal: break\n            for next_node in get_player_neighbors(current, current_boulders):\n                new_cost = cost_so_far[current] + 1\n                if next_node not in cost_so_far or new_cost < cost_so_far[next_node]:\n                    cost_so_far[next_node] = new_cost\n                    priority = new_cost + abs(goal[0] - next_node[0]) + abs(goal[1] - next_node[1])\n                    heapq.heappush(frontier, (priority, next_node))\n                    came_from[next_node] = current\n        else: return None\n        path = []\n        current = goal\n        while current is not None: path.append(current); current = came_from.get(current)\n        path.reverse()\n        return path\n\n    def get_boulder_neighbors(state, current_player_pos):\n        neighbors = []\n        boulders = set(state)\n        for i, boulder in enumerate(state):\n            bx, by = boulder\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                player_pos_req = (bx - dx, by - dy)\n                new_boulder_pos = (bx + dx, by + dy)\n                if new_boulder_pos in boulders or new_boulder_pos not in grid or grid[new_boulder_pos]['type'] in ['impassable', 'boulder_barrier'] or (grid[new_boulder_pos]['has_object'] and not grid[new_boulder_pos]['is_warp'] and grid[new_boulder_pos].get('object_id_name') != 'PIKACHU'): continue\n                path_to_push = player_a_star(current_player_pos, player_pos_req, boulders)\n                if path_to_push:\n                    new_state_list = list(state)\n                    new_state_list[i] = new_boulder_pos\n                    new_state_tuple = tuple(sorted(new_state_list))\n                    move = {'boulder_index': i, 'start_pos': boulder, 'end_pos': new_boulder_pos, 'player_path': path_to_push}\n                    neighbors.append((new_state_tuple, move))\n        return neighbors\n\n    def puzzle_heuristic(state, switches):\n        total_dist = 0\n        unplaced_boulders = sorted([b for b in state if b not in switches])\n        open_switches = sorted([s for s in switches if s not in state])\n        for boulder in unplaced_boulders:\n            if not open_switches: break\n            min_dist = float('inf')\n            best_switch = None\n            for switch in open_switches:\n                dist = abs(boulder[0] - switch[0]) + abs(boulder[1] - switch[1])\n                if dist < min_dist: min_dist = dist; best_switch = switch\n            total_dist += min_dist\n            if best_switch: open_switches.remove(best_switch)\n        return total_dist\n\n    def puzzle_a_star_solver(start_state, switches, initial_player_pos):\n        start_node = (tuple(sorted(start_state)), initial_player_pos)\n        frontier = [(puzzle_heuristic(start_node[0], switches), start_node)]\n        came_from = {start_node: (None, None)}\n        cost_so_far = {start_node: 0}\n        max_iterations = 15000\n        iterations = 0\n        while frontier:\n            iterations += 1\n            if iterations > max_iterations: return 'timeout'\n            _, current_node = heapq.heappop(frontier)\n            current_state, current_player_pos = current_node\n            if len(switches) > 0 and set(switches).issubset(set(current_state)):\n                path = []\n                curr = current_node\n                while curr is not None:\n                    parent, move = came_from.get(curr, (None, None))\n                    if move: path.append(move)\n                    curr = parent\n                path.reverse()\n                return path\n            for next_state, move in get_boulder_neighbors(current_state, current_player_pos):\n                new_cost = cost_so_far[current_node] + 1\n                next_player_pos = move['start_pos']\n                next_node = (next_state, next_player_pos)\n                if next_node not in cost_so_far or new_cost < cost_so_far[next_node]:\n                    cost_so_far[next_node] = new_cost\n                    priority = new_cost + puzzle_heuristic(next_state, switches)\n                    heapq.heappush(frontier, (priority, next_node))\n                    came_from[next_node] = (current_node, move)\n        return None\n\n    try:\n        parse_map_and_party(map_xml_string, input_data['party_data'])\n        boulder_coords = [tuple(coord) for coord in json.loads(input_data['boulder_coords'])]\n        switch_coords = [tuple(coord) for coord in json.loads(input_data['switch_coords'])]\n        solution = puzzle_a_star_solver(boulder_coords, switch_coords, player_pos)\n        if solution == 'timeout':\n            print(json.dumps({'error': 'Solver timed out after too many iterations.'}))\n        elif solution:\n            print(json.dumps({'solution_path': solution}))\n        else:\n            print(json.dumps({'error': 'No solution found for the puzzle.'}))\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': f'An error occurred: {str(e)}', 'traceback': traceback.format_exc()}))\n\nsolve_boulder_puzzle(input_data)\n"
  },
  "find_closest_unseen_tile": {
    "description": "Finds the closest reachable unseen tile and a reachable adjacent tile to pathfind to. This version uses a more robust traversal logic that correctly handles non-adjacent traversals like warps and ladders.",
    "input_schema": {
      "type": "object",
      "properties": {
        "party_data": {
          "type": "string"
        }
      },
      "required": [
        "party_data"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport collections\nimport heapq\n\ndef parse_party_data(party_data_str):\n    try:\n        party_data = json.loads(party_data_str)\n        hms_known = set()\n        for pokemon in party_data:\n            for move in pokemon.get('moves', []):\n                if isinstance(move, dict):\n                    move_name = move.get('name', '').upper()\n                    if move_name == 'CUT':\n                        hms_known.add('cut')\n                    elif move_name == 'SURF':\n                        hms_known.add('surf')\n        return hms_known\n    except (json.JSONDecodeError, TypeError):\n        return set()\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(start, goal, walls, map_width, map_height, hms_known, water_tiles, cut_trees, ledges):\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {start: 0}\n    f_score = {start: heuristic(start, goal)}\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == goal:\n            return True # Path found\n\n        if current in ledges:\n            neighbors = [(current[0], current[1] + 1)]\n        else:\n            neighbors = [(current[0] + dx, current[1] + dy) for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]]\n\n        for neighbor in neighbors:\n            if not (1 <= neighbor[0] <= map_width and 1 <= neighbor[1] <= map_height):\n                continue\n\n            if neighbor in ledges and current[1] != neighbor[1] - 1:\n                continue\n\n            tentative_g_score = g_score[current] + 1\n\n            if tentative_g_score >= g_score.get(neighbor, float('inf')):\n                continue\n\n            if neighbor in walls or (neighbor in cut_trees and 'cut' not in hms_known) or (neighbor in water_tiles and 'surf' not in hms_known):\n                continue\n\n            came_from[neighbor] = current\n            g_score[neighbor] = tentative_g_score\n            f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n            heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    return False # No path found\n\ntry:\n    party_data_str = input_data['party_data']\n    hms = parse_party_data(party_data_str)\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.attrib['width'])\n    map_height = int(root.attrib['height'])\n\n    player_pos = None\n    unseen_tiles = []\n    walls = set()\n    water_tiles = set()\n    cut_trees = set()\n    ledges = set()\n\n    for tile in root.findall('.//Tile'):\n        x, y = int(tile.get('id')), int(tile.get('coordinate').split(',')[1].strip(')'))\n        tile_type = tile.get('type')\n\n        if tile.get('seen') != 'true':\n            unseen_tiles.append((x, y))\n        if tile.find('Player') is not None:\n            player_pos = (x, y)\n        \n        impassable_types = ['impassable', 'boulder_barrier', 'closed_gate', 'unknown']\n        obj = tile.find('Object')\n        is_impassable_obj = obj is not None and obj.get('id-name') != 'Pikachu'\n        if tile_type in impassable_types or is_impassable_obj:\n            walls.add((x, y))\n        elif tile_type == 'water':\n            water_tiles.add((x, y))\n        elif tile_type == 'cuttable':\n            cut_trees.add((x, y))\n        elif tile_type == 'ledge':\n            ledges.add((x, y))\n\n    if not player_pos:\n        print(json.dumps({'error': 'Player not found.'}))\n    else:\n        reachable_unseen = []\n        for ux, uy in unseen_tiles:\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adj_tile = (ux + dx, uy + dy)\n                if not (1 <= adj_tile[0] <= map_width and 1 <= adj_tile[1] <= map_height):\n                    continue\n                if adj_tile in walls or adj_tile in unseen_tiles:\n                    continue\n                \n                if a_star_search(player_pos, adj_tile, walls, map_width, map_height, hms, water_tiles, cut_trees, ledges):\n                    dist = heuristic(player_pos, adj_tile)\n                    reachable_unseen.append({'unseen': (ux, uy), 'adj': adj_tile, 'dist': dist})\n                    break\n\n        if not reachable_unseen:\n            print(json.dumps({'message': 'No reachable unseen tiles found.'}))\n        else:\n            closest = min(reachable_unseen, key=lambda x: x['dist'])\n            print(json.dumps({\n                'closest_reachable_unseen_tile': {'x': closest['unseen'][0], 'y': closest['unseen'][1]},\n                'adjacent_tile': {'x': closest['adj'][0], 'y': closest['adj'][1]}\n            }))\n\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))"
  },
  "robust_pathfinder": {
    "description": "A more robust A* pathfinding tool that can be told to avoid specific 'hazard' coordinates. This version includes corrected ledge traversal logic and accounts for the player's movement state (walking vs. surfing).",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "party_data": {
          "type": "string"
        },
        "movement_state": {
          "type": "string"
        },
        "hazard_coords": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "target_x",
        "target_y",
        "party_data",
        "movement_state"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\nimport json\n\ndef parse_party_data(party_data_str):\n    try:\n        party_data = json.loads(party_data_str)\n        hms_known = set()\n        for pokemon in party_data.get('party', []):\n            for move in pokemon.get('moves', []):\n                if isinstance(move, dict):\n                    move_name = move.get('name', '').upper()\n                    if move_name == 'CUT':\n                        hms_known.add('cut')\n                    elif move_name == 'SURF':\n                        hms_known.add('surf')\n                    elif move_name == 'STRENGTH':\n                        hms_known.add('strength')\n        return hms_known\n    except (json.JSONDecodeError, TypeError):\n        return set()\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(start, goal, walls, map_width, map_height, hms_known, water_tiles, cut_trees, ledges, movement_state):\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {start: 0}\n    f_score = {start: heuristic(start, goal)}\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            return path[::-1]\n\n        if current in ledges:\n            neighbors = [(current[0], current[1] + 1)]\n        else:\n            neighbors = [(current[0] + dx, current[1] + dy) for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]]\n\n        for neighbor in neighbors:\n            if not (1 <= neighbor[0] <= map_width and 1 <= neighbor[1] <= map_height):\n                continue\n\n            if neighbor in ledges and current[1] != neighbor[1] - 1:\n                continue\n\n            tentative_g_score = g_score[current] + 1\n\n            if tentative_g_score >= g_score.get(neighbor, float('inf')):\n                continue\n\n            is_water_impassable = (neighbor in water_tiles and movement_state == 'walking')\n            if neighbor in walls or (neighbor in cut_trees and 'cut' not in hms_known) or is_water_impassable:\n                continue\n\n            came_from[neighbor] = current\n            g_score[neighbor] = tentative_g_score\n            f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n            heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    return None\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.get('width'))\n    map_height = int(root.get('height'))\n    \n    player_pos = None\n    walls = set()\n    water_tiles = set()\n    cut_trees = set()\n    ledges = set()\n\n    for tile in root.findall('.//Tile'):\n        x_str = tile.get('id')\n        y_str_part = tile.get('coordinate').split(',')\n        if len(y_str_part) < 2:\n            continue\n        y_str = y_str_part[1].strip(')')\n        if not x_str or not y_str:\n            continue\n        x, y = int(x_str), int(y_str)\n        tile_type = tile.get('type')\n        \n        if tile.find('Player') is not None:\n            player_pos = (x, y)\n        \n        impassable_types = ['impassable', 'boulder_barrier', 'closed_gate', 'unknown']\n        obj = tile.find('Object')\n        is_impassable_obj = obj is not None and obj.get('id-name') != 'Pikachu'\n        if tile_type in impassable_types or is_impassable_obj:\n            walls.add((x, y))\n        elif tile_type == 'water':\n            water_tiles.add((x, y))\n        elif tile_type == 'cuttable':\n            cut_trees.add((x, y))\n        elif tile_type == 'ledge':\n            ledges.add((x,y))\n\n    if 'hazard_coords' in input_data and input_data['hazard_coords']:\n        try:\n            hazards = json.loads(input_data['hazard_coords'])\n            for hx, hy in hazards:\n                walls.add((int(hx), int(hy)))\n        except (json.JSONDecodeError, ValueError, TypeError):\n            pass\n\n    start_pos = player_pos\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    goal_pos = (target_x, target_y)\n    \n    party_data_str = input_data.get('party_data', '[]')\n    hms = parse_party_data(party_data_str)\n    movement_state = input_data.get('movement_state', 'walking')\n\n    if not start_pos:\n        print(json.dumps({'error': 'Player position not found in map data.'}))\n    else:\n        path = a_star_search(start_pos, goal_pos, walls, map_width, map_height, hms, water_tiles, cut_trees, ledges, movement_state)\n        if path:\n            final_path = []\n            i = 0\n            while i < len(path):\n                current_tile = path[i]\n                final_path.append(current_tile)\n                if current_tile in ledges and i > 0:\n                    if i + 1 < len(path):\n                        next_tile_on_path = path[i+1]\n                        if next_tile_on_path[0] == current_tile[0] and next_tile_on_path[1] == current_tile[1] + 1:\n                             i += 1\n                i += 1\n            print(json.dumps(final_path))\n        else:\n            print(json.dumps({'error': 'No path found.'}))\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))"
  },
  "grid_parser_debugger": {
    "description": "A diagnostic tool to parse the map_xml_string and print a list of all coordinates identified as impassable walls. Used to debug grid-parsing logic in other tools.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    walls = []\n    for tile in root.findall('.//Tile'):\n        x_str = tile.get('id')\n        y_str_part = tile.get('coordinate').split(',')\n        if len(y_str_part) < 2:\n            continue\n        y_str = y_str_part[1].strip(')')\n        if not x_str or not y_str:\n            continue\n        x, y = int(x_str), int(y_str)\n        tile_type = tile.get('type')\n        \n        impassable_types = ['impassable', 'boulder_barrier', 'closed_gate', 'unknown']\n        obj = tile.find('Object')\n        is_impassable_obj = obj is not None and obj.get('id-name') != 'Pikachu'\n        \n        if tile_type in impassable_types or is_impassable_obj:\n            walls.append({'x': x, 'y': y, 'type': tile_type, 'has_impassable_object': is_impassable_obj})\n            \n    print(json.dumps(walls, indent=2))\nexcept Exception as e:\n    import traceback\n    print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))"
  }
}