{
  "execute_battle_move": {
    "description": "Selects 'FIGHT' from the main battle menu and then selects a move based on the provided slot index (1-4). Automatically mashes 'B' afterwards to advance battle text. Requires 'autopress_buttons: true'.",
    "input_schema": {
      "type": "object",
      "properties": {
        "move_slot": {
          "type": "integer",
          "description": "The move slot to use (1-4). Defaults to 1.",
          "default": 1
        }
      }
    },
    "python_script": "import json\ntry:\n    data = input_data\nexcept NameError:\n    data = {}\n\nslot = int(data.get('move_slot', 1))\n\ncmds = []\n# Select FIGHT (Assumes cursor is on FIGHT)\ncmds.append(\"A\")\ncmds.append(\"sleep 250\")\n\n# Navigate to move slot\n# Slot 1 is top, 2 is one down, etc.\n# Note: Cursor memory might affect this, but usually resets or stays on last used.\n# If we assume it stays on last used, we might need a \"reset\" or absolute knowledge.\n# For now, assuming top/reset for simplicity or relying on user to know.\n# Actually, in Gen 2, it often remembers. But if we only use Slot 1 (Tackle), it's fine.\nif slot == 2:\n    cmds.append(\"Down\")\nelif slot == 3:\n    cmds.extend([\"Down\", \"Down\"])\nelif slot == 4:\n    cmds.extend([\"Down\", \"Down\", \"Down\"])\n\ncmds.append(\"sleep 250\")\ncmds.append(\"A\") # Select Move\n\n# Advance Text\ncmds.append(\"sleep 500\")\ncmds.extend([\"B\"] * 5)\n\nprint(json.dumps(cmds))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-15T21:10:24.341Z",
        "action_counter": 121
      }
    ]
  }
}