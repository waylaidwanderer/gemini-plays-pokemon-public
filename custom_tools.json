{
  "find_path_to_target": {
    "description": "Calculates the shortest path from a start to an end coordinate on the current map using the A* algorithm. It considers tile traversability and objects as obstacles. If the target tile is impassable, it finds a path to an adjacent traversable tile. Returns a JSON string of the coordinate path or an empty list if no path is found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef find_path(start_x, start_y, end_x, end_y, map_xml_string):\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.attrib['width'])\n    map_height = int(root.attrib['height'])\n\n    traversable_tiles = {'FLOOR', 'WARP_CARPET_DOWN', 'DOOR', 'STAIRCASE', 'TALL_GRASS'}\n    ledge_tiles = {'LEDGE_HOP_DOWN', 'LEDGE_HOP_RIGHT', 'LEDGE_HOP_LEFT'}\n    \n    grid = [[{'type': 'unseen', 'traversable': 0} for _ in range(map_width)] for _ in range(map_height)]\n    \n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id'])\n            tile_type = tile_elem.attrib.get('type', 'unseen')\n            grid[y][x]['type'] = tile_type\n            \n            if tile_type in traversable_tiles or tile_type in ledge_tiles:\n                grid[y][x]['traversable'] = 1\n            \n            if tile_elem.find('Object') is not None:\n                grid[y][x]['traversable'] = 0\n\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n\n    if grid[start_y][start_x]['traversable'] == 0:\n        return []\n\n    if grid[end_y][end_x]['traversable'] == 0:\n        found_new_target = False\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor_x, neighbor_y = end_x + dx, end_y + dy\n            if 0 <= neighbor_x < map_width and 0 <= neighbor_y < map_height and grid[neighbor_y][neighbor_x]['traversable'] == 1:\n                end_node = (neighbor_x, neighbor_y)\n                found_new_target = True\n                break\n        if not found_new_target:\n            return []\n\n    open_set = []\n    heapq.heappush(open_set, (0, start_node))\n    came_from = {}\n    g_score = { (c_x, c_y): float('inf') for c_x in range(map_width) for c_y in range(map_height) }\n    g_score[start_node] = 0\n    f_score = { (c_x, c_y): float('inf') for c_x in range(map_width) for c_y in range(map_height) }\n    f_score[start_node] = abs(start_node[0] - end_node[0]) + abs(start_node[1] - end_node[1])\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == end_node:\n            path = []\n            while current in came_from:\n                path.append({'x': current[0], 'y': current[1]})\n                current = came_from[current]\n            path.append({'x': start_node[0], 'y': start_node[1]})\n            return path[::-1]\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            nx, ny = neighbor\n\n            if not (0 <= nx < map_width and 0 <= ny < map_height) or grid[ny][nx]['traversable'] == 0:\n                continue\n\n            neighbor_type = grid[ny][nx]['type']\n            current_type = grid[current[1]][current[0]]['type']\n\n            # Ledge logic (entering a ledge)\n            if neighbor_type == 'LEDGE_HOP_RIGHT' and dx != 1:\n                continue\n            if neighbor_type == 'LEDGE_HOP_DOWN' and dy != 1:\n                continue\n            if neighbor_type == 'LEDGE_HOP_LEFT' and dx != -1:\n                continue\n\n            # Ledge logic (leaving a ledge)\n            if current_type == 'LEDGE_HOP_RIGHT' and dx == -1:\n                continue\n            if current_type == 'LEDGE_HOP_DOWN' and dy == -1:\n                continue\n            if current_type == 'LEDGE_HOP_LEFT' and dx == 1:\n                continue\n\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = g_score[neighbor] + abs(neighbor[0] - end_node[0]) + abs(neighbor[1] - end_node[1])\n                if neighbor not in [i[1] for i in open_set]:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    return []\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\npath = find_path(start_x, start_y, end_x, end_y, map_xml_string)\nprint(json.dumps(path))",
    "history": [
      {
        "commit_message": "feat: Create A* pathfinding tool. This tool, `find_path_to_target`, provides essential navigation capabilities, allowing for automated and optimal path calculation. It parses the map XML, identifies walkable tiles, and avoids obstacles like walls and NPCs. This is a foundational tool to improve exploration efficiency and solve reachability problems.",
        "timestamp": "2025-10-27T01:14:44.384Z",
        "action_counter": 156
      },
      {
        "commit_message": "fix: Add debug prints to diagnose pathing failures. The tool is incorrectly reporting no path in some situations. These prints will help visualize the grid and the A* algorithm's state to identify the bug.",
        "timestamp": "2025-10-27T01:32:49.803Z",
        "action_counter": 198
      },
      {
        "commit_message": "fix: Correct boundary checks and grid initialization for 0-indexed coordinates. The previous implementation used 1-based logic (`0 < nx`), preventing pathing into the 0th row or column. The grid was also incorrectly sized. This change aligns the tool with the game's 0-indexed coordinate system, enabling correct pathfinding across the entire map.",
        "timestamp": "2025-10-27T01:33:43.716Z",
        "action_counter": 200
      },
      {
        "commit_message": "feat: Add adjacent tile pathing for impassable targets. The A* algorithm will now check if the destination tile is blocked (e.g., by an object or wall). If it is, the tool will automatically search for a valid, traversable adjacent tile to use as the new destination. This prevents pathing failures when trying to approach NPCs or objects and makes the tool more robust and user-friendly.",
        "timestamp": "2025-10-27T04:36:36.648Z",
        "action_counter": 572
      },
      {
        "commit_message": "feat: Add TALL_GRASS and ledge tiles to traversable set. The pathfinder was unable to navigate through tall grass or over ledges, blocking progress on Route 29. This update adds 'TALL_GRASS', 'LEDGE_HOP_DOWN', and 'LEDGE_HOP_RIGHT' to the list of walkable tiles, enabling the tool to find paths through these areas.",
        "timestamp": "2025-10-27T05:18:36.345Z",
        "action_counter": 653
      },
      {
        "commit_message": "fix: Implement directional traversal for ledge tiles. The pathfinder was treating ledges as regular walkable tiles, causing it to generate invalid paths. This update adds logic to ensure that ledge tiles can only be traversed in the correct direction (e.g., right for 'LEDGE_HOP_RIGHT'), fixing pathing failures on routes like Route 29.",
        "timestamp": "2025-10-27T05:20:02.532Z",
        "action_counter": 656
      },
      {
        "commit_message": "fix: Add logic for leaving ledges. The pathfinder was creating invalid paths by attempting to move 'backwards' off a ledge tile (e.g., left from a LEDGE_HOP_RIGHT). This adds checks for the current tile's type to prevent illegal moves away from ledges, ensuring path validity.",
        "timestamp": "2025-10-27T05:43:50.864Z",
        "action_counter": 703
      },
      {
        "commit_message": "feat: Add CUT_TREE to traversable tiles for diagnostics. The path forward appears to be blocked by a CUT_TREE. This change is a temporary diagnostic measure to confirm if this is the sole obstacle preventing westward progression. If a path can be calculated with this change, it will validate that finding a way to remove the tree is the correct next step. This is not a permanent change and will be reverted after the test.",
        "timestamp": "2025-10-27T06:40:57.208Z",
        "action_counter": 798
      },
      {
        "commit_message": "revert: Remove CUT_TREE from traversable tiles. The diagnostic test to confirm the CUT_TREE as the primary obstacle is complete. This change reverts the pathfinder to its standard operational state to prevent invalid path generation in the future.",
        "timestamp": "2025-10-27T06:42:04.380Z",
        "action_counter": 800
      },
      {
        "commit_message": "feat: Add support for LEDGE_HOP_LEFT traversal. The pathfinder was unable to navigate westward on Route 29 because it lacked the logic to handle left-facing ledges. This update adds 'LEDGE_HOP_LEFT' to the set of recognized ledge tiles and implements the necessary directional constraints, enabling the tool to find correct paths through these areas.",
        "timestamp": "2025-10-27T09:44:56.021Z",
        "action_counter": 964
      },
      {
        "commit_message": "fix: Add debug prints to diagnose ledge traversal failure. The pathfinder is failing to navigate left-facing ledges despite the logic appearing correct. This update adds detailed print statements to the ledge-handling section to trace the algorithm's decisions and identify the exact point of failure.",
        "timestamp": "2025-10-27T09:46:19.675Z",
        "action_counter": 966
      },
      {
        "commit_message": "refactor: Remove debug print statements. The extensive print statements added to diagnose the ledge traversal issue are no longer necessary. This commit cleans up the code by removing them, resulting in cleaner and more concise tool output for standard pathfinding operations.",
        "timestamp": "2025-10-27T10:25:57.405Z",
        "action_counter": 1039
      }
    ]
  },
  "generate_nickname_inputs": {
    "description": "Calculates the optimal sequence of button presses to enter a given nickname on the Pokémon naming screen. It handles both uppercase and lowercase letters and minimizes cursor movement.",
    "input_schema": {
      "type": "object",
      "properties": {
        "nickname": {
          "type": "string",
          "description": "The desired nickname, up to 10 characters."
        }
      },
      "required": [
        "nickname"
      ]
    },
    "python_script": "import json\n\ninput_nickname = input_data['nickname']\n\nkeyboards = {\n    'UPPER': [\n        ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'],\n        ['J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R'],\n        ['S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '-'],\n        ['?', '!', '/', '.', ',', 'lower', 'DEL', 'END']\n    ],\n    'lower': [\n        ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'],\n        ['j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r'],\n        ['s', 't', 'u', 'v', 'w', 'x', 'y', 'z', ' '],\n        ['(', ')', ':', ';', '[', ']', 'UPPER', 'DEL', 'END']\n    ]\n}\n\ndef find_char_pos(char, keyboard_layout):\n    for r, row in enumerate(keyboard_layout):\n        if char in row:\n            return (r, row.index(char))\n    return None\n\npresses = []\ncurrent_pos = (0, 0) # Start on 'A'\ncurrent_keyboard = 'UPPER'\n\nfor i, char in enumerate(input_nickname):\n    target_keyboard = 'UPPER' if 'A' <= char <= 'Z' or i == 0 else 'lower'\n    if char.islower():\n        target_keyboard = 'lower'\n\n    if current_keyboard != target_keyboard:\n        switch_key = 'lower' if target_keyboard == 'lower' else 'UPPER'\n        target_pos = find_char_pos(switch_key, keyboards[current_keyboard])\n        dr, dc = target_pos[0] - current_pos[0], target_pos[1] - current_pos[1]\n        presses.extend(['Down'] * dr if dr > 0 else ['Up'] * abs(dr))\n        presses.extend(['Right'] * dc if dc > 0 else ['Left'] * abs(dc))\n        presses.append('A')\n        current_keyboard = target_keyboard\n        current_pos = find_char_pos('a' if current_keyboard == 'lower' else 'A', keyboards[current_keyboard])\n\n    target_pos = find_char_pos(char, keyboards[current_keyboard])\n    dr, dc = target_pos[0] - current_pos[0], target_pos[1] - current_pos[1]\n    presses.extend(['Down'] * dr if dr > 0 else ['Up'] * abs(dr))\n    presses.extend(['Right'] * dc if dc > 0 else ['Left'] * abs(dc))\n    presses.append('A')\n    current_pos = target_pos\n\nend_pos = find_char_pos('END', keyboards[current_keyboard])\ndr, dc = end_pos[0] - current_pos[0], end_pos[1] - current_pos[1]\npresses.extend(['Down'] * dr if dr > 0 else ['Up'] * abs(dr))\npresses.extend(['Right'] * dc if dc > 0 else ['Left'] * abs(dc))\npresses.append('A')\n\nprint(json.dumps(presses))",
    "history": [
      {
        "commit_message": "feat: Create nicknaming automation tool. This tool, `generate_nickname_inputs`, automates the tedious and error-prone process of entering a Pokémon's nickname. It calculates the optimal button presses to navigate the on-screen keyboard for any given name, saving significant time and preventing manual input errors. This is a major quality-of-life improvement.",
        "timestamp": "2025-10-27T05:03:16.685Z",
        "action_counter": 623
      }
    ]
  },
  "find_reachable_unseen_tiles": {
    "description": "Finds all unseen tiles on the current map that are reachable from the player's current position. It performs a breadth-first search (BFS) starting from the player to identify all accessible tiles, then returns the coordinates of any unseen tiles found within that accessible area.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef find_reachable_unseen(start_x, start_y, map_xml_string):\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.attrib['width'])\n    map_height = int(root.attrib['height'])\n\n    traversable_types = {'FLOOR', 'WARP_CARPET_DOWN', 'DOOR', 'STAIRCASE', 'TALL_GRASS'}\n    ledge_types = {'LEDGE_HOP_DOWN', 'LEDGE_HOP_RIGHT', 'LEDGE_HOP_LEFT'}\n\n    grid = [[{'type': 'unseen', 'seen': False, 'traversable': False} for _ in range(map_width)] for _ in range(map_height)]\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id'])\n            tile_type = tile_elem.attrib.get('type', 'unseen')\n            seen = tile_elem.attrib.get('seen') == 'true'\n            grid[y][x]['type'] = tile_type\n            grid[y][x]['seen'] = seen\n            \n            is_traversable = tile_type in traversable_types or tile_type in ledge_types\n            has_object = tile_elem.find('Object') is not None\n            \n            if is_traversable and not has_object:\n                grid[y][x]['traversable'] = True\n\n    q = deque([(start_x, start_y)])\n    visited = set([(start_x, start_y)])\n    reachable_unseen = []\n\n    while q:\n        cx, cy = q.popleft()\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n\n            if not (0 <= nx < map_width and 0 <= ny < map_height):\n                continue\n\n            if (nx, ny) in visited:\n                continue\n\n            current_tile_type = grid[cy][cx]['type']\n            neighbor_tile_type = grid[ny][nx]['type']\n\n            # Ledge logic (leaving a ledge)\n            if current_tile_type == 'LEDGE_HOP_DOWN' and dy == -1: continue\n            if current_tile_type == 'LEDGE_HOP_RIGHT' and dx == -1: continue\n            if current_tile_type == 'LEDGE_HOP_LEFT' and dx == 1: continue\n\n            # Ledge logic (entering a ledge)\n            if neighbor_tile_type == 'LEDGE_HOP_DOWN' and dy != 1: continue\n            if neighbor_tile_type == 'LEDGE_HOP_RIGHT' and dx != 1: continue\n            if neighbor_tile_type == 'LEDGE_HOP_LEFT' and dx != -1: continue\n            \n            if grid[ny][nx]['traversable']:\n                visited.add((nx, ny))\n                q.append((nx, ny))\n\n    # Now, check for adjacent unseen tiles from all reachable tiles\n    final_unseen_list = set()\n    for x, y in visited:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < map_width and 0 <= ny < map_height and not grid[ny][nx]['seen']:\n                final_unseen_list.add((nx, ny))\n\n    print(json.dumps([{'x': x, 'y': y} for x, y in sorted(list(final_unseen_list))]))\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nfind_reachable_unseen(start_x, start_y, map_xml_string)",
    "history": [
      {
        "commit_message": "feat: Create tool to find reachable unseen tiles. This tool addresses the system's sticky alert about potentially reachable unseen tiles. It performs a BFS from the player's position, respecting all traversal rules including ledges, to find all accessible tiles. It then identifies and returns a list of all unseen tiles adjacent to this accessible area, providing a reliable target list for exploration and preventing attempts to pathfind to unreachable locations.",
        "timestamp": "2025-10-27T09:24:39.107Z",
        "action_counter": 936
      }
    ]
  }
}