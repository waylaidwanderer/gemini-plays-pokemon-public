{
  "find_path": {
    "description": "Calculates a path using Dijkstra. Context-aware: detects if Player is Surfing (on WATER tile) or Walking. If Surfing, strictly penalizes dismounting (Water->Land) unless destination is Land. Treats Map Markers with object_ids and specific labels as obstacles. Optimistic for unseen tiles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef get_buttons(path):\n    buttons = []\n    for i in range(len(path) - 1):\n        x1, y1 = path[i]\n        x2, y2 = path[i+1]\n        if x2 > x1: buttons.append(\"Right\")\n        elif x2 < x1: buttons.append(\"Left\")\n        elif y2 > y1: buttons.append(\"Down\")\n        elif y2 < y1: buttons.append(\"Up\")\n    return buttons\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    target_pos = (target_x, target_y)\n    \n    player_pos = None\n    tile_data = {}\n    \n    obstacle_substrings = ['WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', 'BOULDER', \n                           'COUNTER', 'BOOKSHELF', 'PC', 'TV', 'RADIO', 'WINDOW', \n                           'TOWN_MAP', 'MART_SHELF', 'LEDGE', 'TRAP']\n    # Treat warps as obstacles to avoid accidental entry, unless target\n    warp_types = ['DOOR', 'CAVE', 'STAIRS', 'WARP']\n    obstacle_markers = {'Hole', 'Trap', 'ðŸ’£', 'ðŸ•³ï¸'}\n\n    # 1. Parse Map Data\n    player_on_water = False\n    for row in root.findall('Row'):\n        for tile in row.findall('Tile'):\n            if tile.find('Player') is not None:\n                player_pos = (int(tile.attrib['id']), int(row.attrib['id']))\n                if tile.attrib.get('type') == 'WATER':\n                    player_on_water = True\n                break\n        if player_pos: break\n\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib.get('type', 'FLOOR')\n            \n            is_obstacle = False\n            if any(obs in t_type for obs in obstacle_substrings):\n                is_obstacle = True\n            # Warps are obstacles unless target\n            if any(w in t_type for w in warp_types) and (x, y) != target_pos:\n                is_obstacle = True\n            if tile.get('has-object') == 'true' or tile.find('Object') is not None:\n                is_obstacle = True\n            for marker in tile.findall('Marker'):\n                if marker.attrib.get('object_id'): is_obstacle = True\n                label = marker.text or \"\"\n                emoji = marker.attrib.get('emoji', \"\")\n                if any(obs in label for obs in obstacle_markers) or any(obs in emoji for obs in obstacle_markers):\n                    is_obstacle = True\n            \n            is_water = 'WATER' in t_type or 'WHIRLPOOL' in t_type or 'unseen' in t_type\n            \n            tile_data[(x, y)] = {'obstacle': is_obstacle, 'is_water': is_water}\n\n    if not player_pos:\n        print(json.dumps([]))\n        exit()\n        \n    # If target is obstacle, try neighbors\n    if tile_data.get(target_pos, {'obstacle': True})['obstacle']:\n         best_neighbor = None\n         min_dist = float('inf')\n         for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n             nx, ny = target_x + dx, target_y + dy\n             if not tile_data.get((nx, ny), {'obstacle': True})['obstacle']:\n                 dist = abs(nx - player_pos[0]) + abs(ny - player_pos[1])\n                 if dist < min_dist:\n                     min_dist = dist\n                     best_neighbor = (nx, ny)\n         if best_neighbor:\n             target_pos = best_neighbor\n         else:\n             # If no neighbors, return empty (can't reach)\n             print(json.dumps([]))\n             exit()\n\n    # 2. Dijkstra Search\n    pq = [(0, player_pos[0], player_pos[1], [player_pos])]\n    visited = {}\n    final_path = None\n    \n    SURF_DISMOUNT_PENALTY = 10000\n    WALK_WATER_PENALTY = 10000\n    \n    while pq:\n        cost, cx, cy, path = heapq.heappop(pq)\n        \n        if (cx, cy) == target_pos:\n            final_path = path\n            break\n            \n        if (cx, cy) in visited and visited[(cx, cy)] <= cost:\n            continue\n        visited[(cx, cy)] = cost\n        \n        curr_is_water = tile_data.get((cx, cy), {}).get('is_water', False)\n        \n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) in tile_data and not tile_data[(nx, ny)]['obstacle']:\n                next_is_water = tile_data[(nx, ny)]['is_water']\n                step_cost = 1\n                \n                if player_on_water:\n                    # Surfing: Heavily penalize landing unless it's the target or adjacent to target\n                    if curr_is_water and not next_is_water:\n                        is_target_related = ((nx, ny) == target_pos) or (abs(nx - target_x) + abs(ny - target_y) <= 1)\n                        if not is_target_related:\n                            step_cost = SURF_DISMOUNT_PENALTY\n                else:\n                    # Walking: Heavily penalize entering water\n                    if not curr_is_water and next_is_water:\n                        step_cost = WALK_WATER_PENALTY\n                \n                new_cost = cost + step_cost\n                if (nx, ny) not in visited or new_cost < visited[(nx, ny)]:\n                    new_path = list(path)\n                    new_path.append((nx, ny))\n                    heapq.heappush(pq, (new_cost, nx, ny, new_path))\n                    \n    if final_path:\n        print(json.dumps(get_buttons(final_path)))\n    else:\n        print(json.dumps([]))\n\nexcept Exception as e:\n    print(json.dumps([]))",
    "history": [
      {
        "commit_message": "feat: Add find_path tool. Calculates shortest path using BFS, handling walls, objects, and one-way ledges.",
        "timestamp": "2025-11-20T08:35:46.882Z",
        "action_counter": 924
      },
      {
        "commit_message": "fix: Add LADDER to traversable basic_types in find_path. Previously, the tool considered LADDER tiles as walls, preventing pathfinding to or from them.",
        "timestamp": "2025-11-20T10:46:07.670Z",
        "action_counter": 1068
      },
      {
        "commit_message": "fix: Add FLOOR_UP_WALL to traversable tiles when moving down. This tile type appears on Route 32 and visually resembles a ledge, so it is assumed to be jumpable from the north.",
        "timestamp": "2025-11-20T21:10:28.299Z",
        "action_counter": 1479
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. In-game testing proved this tile type blocks movement from the north, contrary to the initial hypothesis that it was a jumpable ledge.",
        "timestamp": "2025-11-20T21:14:51.875Z",
        "action_counter": 1484
      },
      {
        "commit_message": "fix: Reinforce object collision check in find_path and add debug prints for player's neighbors to diagnose issues where objects are ignored.",
        "timestamp": "2025-11-20T23:31:27.320Z",
        "action_counter": 1632
      },
      {
        "commit_message": "fix: Add CAVE to traversable basic_types. This tile type represents cave entrances (warps) and must be traversable to enter dungeons like Union Cave. Also removed debug prints.",
        "timestamp": "2025-11-20T23:38:16.306Z",
        "action_counter": 1641
      },
      {
        "commit_message": "fix: Enable FLOOR_UP_WALL as a traversable ledge when moving down. This is necessary to test if the western ledge at (12, 18) is jumpable, as the eastern path is blocked.",
        "timestamp": "2025-11-21T00:47:29.072Z",
        "action_counter": 1752
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. Verified in-game at (16, 21) that this tile type acts as a wall and cannot be jumped from the north.",
        "timestamp": "2025-11-21T00:59:17.529Z",
        "action_counter": 1768
      },
      {
        "commit_message": "fix: Ensure FLOOR_UP_WALL is treated as a wall. Previous testing at (16, 21) confirmed it is not jumpable from the north.",
        "timestamp": "2025-11-21T01:01:08.516Z",
        "action_counter": 1771
      },
      {
        "commit_message": "fix: Remove FLOOR_UP_WALL from traversable tiles. Verified in-game at (12, 17) -> (12, 18) that this tile type acts as a wall and cannot be jumped from the north.",
        "timestamp": "2025-11-21T01:05:06.366Z",
        "action_counter": 1776
      },
      {
        "commit_message": "feat: Allow movement UP onto FLOOR_UP_WALL tiles. Verified in-game at Union Cave (5, 19) -> (5, 18) that this tile type acts as a climbable ramp from the south.",
        "timestamp": "2025-11-21T02:01:30.245Z",
        "action_counter": 1847
      },
      {
        "commit_message": "feat: Allow horizontal movement on FLOOR_UP_WALL. The tiles at row 18 act as a traversable ridge connecting the west and east sides of the room.",
        "timestamp": "2025-11-21T02:05:19.643Z",
        "action_counter": 1850
      },
      {
        "commit_message": "feat: Update find_path to automatically target adjacent traversable tiles if the destination is blocked by a wall or object. This eliminates the need for manual coordinate guessing when targeting NPCs or obstacles.",
        "timestamp": "2025-11-22T00:45:06.962Z",
        "action_counter": 3307
      },
      {
        "commit_message": "feat: Enhance find_path to treat tiles with object-linked markers as obstacles. This prevents the pathfinder from routing through off-screen NPCs or objects that are known to exist but not currently rendered in the viewport.",
        "timestamp": "2025-11-22T02:29:58.782Z",
        "action_counter": 3465
      },
      {
        "commit_message": "refactor: Change output format from coordinates to button presses (e.g. [\"Up\", \"Right\"]). This enables compatibility with the `autopress_buttons: true` feature for automated navigation.",
        "timestamp": "2025-11-22T06:33:20.386Z",
        "action_counter": 3846
      },
      {
        "commit_message": "fix: Update find_path to return a JSON array of button strings (e.g. ['Up', 'Right']) instead of coordinates, enabling compatibility with autopress_buttons. Also re-implements logic to path to adjacent tiles if the target is blocked.",
        "timestamp": "2025-11-22T06:37:44.405Z",
        "action_counter": 3851
      },
      {
        "commit_message": "fix: Rewrite find_path to output a JSON array of button strings (e.g. [\"Up\", \"Right\"]) instead of coordinate objects. Adds logic to automatically path to an adjacent tile if the target is blocked by a wall, object, or marker.",
        "timestamp": "2025-11-22T06:42:53.734Z",
        "action_counter": 3857
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE to the obstacles list in find_path. Previously, the pathfinder treated these trees as walkable FLOOR tiles, causing pathfinding failures on Route 36.",
        "timestamp": "2025-11-22T09:46:43.517Z",
        "action_counter": 4061
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE to obstacles list in find_path tool. This prevents pathfinding through solid trees on Route 36.",
        "timestamp": "2025-11-22T09:53:42.815Z",
        "action_counter": 4069
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE to obstacles list in find_path tool. This prevents pathfinding failures where the tool tries to route through solid trees on Route 36.",
        "timestamp": "2025-11-22T10:01:47.695Z",
        "action_counter": 4078
      },
      {
        "commit_message": "fix: Add LEDGE_HOP_DOWN, LEDGE_HOP_UP, LEDGE_HOP_LEFT, and LEDGE_HOP_RIGHT to the obstacles list in find_path. This prevents the pathfinder from incorrectly generating paths that try to walk up one-way ledges, which caused a navigation error on Route 37.",
        "timestamp": "2025-11-22T11:03:50.170Z",
        "action_counter": 4148
      },
      {
        "commit_message": "fix: Update find_path to treat tiles marked with 'Hole' or ðŸ•³ï¸ as obstacles. This prevents the pathfinder from routing the player into pits in the Burned Tower.",
        "timestamp": "2025-11-22T15:38:21.684Z",
        "action_counter": 4436
      },
      {
        "commit_message": "fix: Update find_path to treat tiles marked with 'Hole' or ðŸ•³ï¸ as obstacles. This prevents the pathfinder from routing the player into pits in the Burned Tower.",
        "timestamp": "2025-11-22T15:45:56.249Z",
        "action_counter": 4441
      },
      {
        "commit_message": "fix: Update find_path to correctly identify tiles with 'Hole' markers or object-linked markers as obstacles. This prevents pathfinding through dangerous tiles in the Burned Tower.",
        "timestamp": "2025-11-22T15:59:15.044Z",
        "action_counter": 4454
      },
      {
        "commit_message": "fix: Add PIT to obstacles list in find_path. This prevents the pathfinder from routing the player into pits in the Lighthouse.",
        "timestamp": "2025-11-23T02:50:16.179Z",
        "action_counter": 5202
      },
      {
        "commit_message": "fix: Add LADDER to obstacles list in find_path. This prevents the pathfinder from routing through ladders which are warps, avoiding accidental map transitions.",
        "timestamp": "2025-11-23T05:18:17.385Z",
        "action_counter": 5381
      },
      {
        "commit_message": "fix: Update find_path to be context-aware for Surfing. Now checks if the player is on a WATER tile; if so, removes WATER from the obstacle list. Also added BUOY to the base obstacle list to prevent pathing into buoys.",
        "timestamp": "2025-11-23T12:00:41.709Z",
        "action_counter": 5818
      },
      {
        "commit_message": "fix: Add FLOOR_UP_WALL, FLOOR_DOWN_WALL, FLOOR_LEFT_WALL, and FLOOR_RIGHT_WALL to the obstacles list in find_path. These tiles represent ledges or one-way walls in the current map data (Mt. Mortar) and were causing pathfinding failures.",
        "timestamp": "2025-11-24T01:30:19.414Z",
        "action_counter": 6532
      },
      {
        "commit_message": "fix: Explicitly add FLOOR_UP_WALL, FLOOR_DOWN_WALL, FLOOR_LEFT_WALL, and FLOOR_RIGHT_WALL to the base_obstacles set. These tiles are solid walls (ledge faces) and caused pathfinding errors when the tool incorrectly treated them as traversable.",
        "timestamp": "2025-11-24T02:01:48.846Z",
        "action_counter": 6571
      },
      {
        "commit_message": "fix: Update find_path to treat tiles marked with 'Trap' or 'ðŸ’£' as obstacles. This is critical for navigating the trap-filled corridor in Team Rocket Base B1F.",
        "timestamp": "2025-11-24T20:34:39.795Z",
        "action_counter": 7056
      },
      {
        "commit_message": "fix: Add COUNTER, BOOKSHELF, PC, TV, RADIO, WINDOW, TOWN_MAP, and MART_SHELF to the obstacle list in find_path. These are solid objects that block movement but were previously treated as traversable, causing pathfinding failures in the Rocket Base.",
        "timestamp": "2025-11-24T21:20:07.644Z",
        "action_counter": 7120
      },
      {
        "commit_message": "fix: Add HEADBUTT_TREE and CUT_TREE to obstacle_types in find_path. Previously, the tool treated these tiles as traversable, causing invalid paths through solid trees.",
        "timestamp": "2025-11-28T21:17:01.577Z",
        "action_counter": 12561
      },
      {
        "commit_message": "fix: Make obstacle detection robust by treating any tile type containing 'WALL' or 'TREE' as an obstacle. This prevents pathfinding failures on HEADBUTT_TREE or variant wall tiles that were previously missed.",
        "timestamp": "2025-11-28T21:27:51.596Z",
        "action_counter": 12576
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T21:45:16.721Z",
        "action_counter": 12601
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T21:48:50.709Z",
        "action_counter": 12606
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T21:53:24.421Z",
        "action_counter": 12612
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T21:56:57.360Z",
        "action_counter": 12616
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T21:59:09.404Z",
        "action_counter": 12620
      },
      {
        "commit_message": "fix: Update find_path to use robust substring matching for obstacle detection. Now treats any tile type containing 'WALL', 'TREE', 'PIT', 'HOLE', 'BUOY', 'WHIRLPOOL', 'ROCK', etc. as an obstacle. This fixes the issue where HEADBUTT_TREE variants were treated as traversable.",
        "timestamp": "2025-11-28T22:03:11.092Z",
        "action_counter": 12625
      },
      {
        "commit_message": "fix: Added 'BOULDER' to obstacle keywords and explicitly checked for marker IDs to ensure dynamic objects are treated as obstacles. Added redundant checks for object attributes.",
        "timestamp": "2025-11-29T04:38:45.546Z",
        "action_counter": 13141
      },
      {
        "commit_message": "fix: Remove syntax error (garbage characters) from the end of the script and ensure 'BOULDER' is in the obstacle list.",
        "timestamp": "2025-11-29T04:41:30.820Z",
        "action_counter": 13146
      },
      {
        "commit_message": "fix: Remove 'LADDER' from obstacle_substrings. LADDER tiles are traversable and necessary for navigation in multi-floor areas like Dragon's Den. Previously, the tool incorrectly treated them as walls, causing pathfinding failures.",
        "timestamp": "2025-11-30T10:59:03.285Z",
        "action_counter": 14869
      },
      {
        "commit_message": "fix: Update find_path to be context-aware for Surfing. Now, if the player is surfing, all non-water tiles are treated as obstacles UNLESS they are the specific target destination. This prevents the pathfinder from creating routes that cut corners over land, which causes accidental dismounting.",
        "timestamp": "2025-11-30T11:33:19.757Z",
        "action_counter": 14914
      },
      {
        "commit_message": "feat: Update find_path to use Dijkstra with weighted edges. Adds high penalty for Land->Water transitions when player is surfing to prevent accidental dismounting/corner-cutting. Treats 'unseen' tiles as Water to allow optimistic pathfinding.",
        "timestamp": "2025-11-30T11:37:19.429Z",
        "action_counter": 14916
      },
      {
        "commit_message": "fix: Improve terrain handling. 1) When Walking, treat WATER tiles as obstacles. 2) When Surfing, penalize Water->Land transitions (dismounting) unless the land tile is the specific target. This prevents accidental dismounting and walking on water.",
        "timestamp": "2025-11-30T12:31:57.252Z",
        "action_counter": 14977
      },
      {
        "commit_message": "fix: Improve terrain handling. 1) When Walking, treat WATER tiles as obstacles. 2) When Surfing, penalize Water->Land transitions (dismounting) unless the land tile is the specific target. This prevents accidental dismounting and walking on water.",
        "timestamp": "2025-11-30T12:49:59.585Z",
        "action_counter": 14982
      },
      {
        "commit_message": "fix: Improve terrain handling. 1) When Walking, treat WATER tiles as obstacles. 2) When Surfing, penalize Water->Land transitions (dismounting) unless the land tile is the specific target. This prevents accidental dismounting and walking on water.",
        "timestamp": "2025-11-30T13:08:37.662Z",
        "action_counter": 14990
      },
      {
        "commit_message": "fix: Improve find_path robustness. 1) Better Player detection using has-player attribute. 2) Optimistic 'unseen' tile handling (matches current state). 3) Prevent start node from being treated as obstacle.",
        "timestamp": "2025-11-30T13:13:01.533Z",
        "action_counter": 14993
      },
      {
        "commit_message": "fix: Improve terrain handling. 1) When Surfing, penalize ANY transition between Water and Land (cost 1000). This encourages staying in the current medium (Water) until the destination requires landing, preventing inefficient 'island hopping' or accidental dismounting. 2) When Walking, treat Water as high-cost/obstacle to prefer land paths.",
        "timestamp": "2025-11-30T13:35:12.114Z",
        "action_counter": 14997
      },
      {
        "commit_message": "fix: Redefine find_path to strictly handle Surfing state. Detects player_on_water from map XML. If Surfing, penalizes Water->Land transitions (dismounting) unless destination is Land. If Walking, treats Water as high-cost. Optimistic handling for unseen tiles matching current medium.",
        "timestamp": "2025-11-30T13:57:04.458Z",
        "action_counter": 15011
      },
      {
        "commit_message": "fix: Improve find_path logic for surfing transitions. Explicitly penalize Water->Land (dismounting) unless destination is Land. Correctly detect 'is_water' property from map XML. Optimistic handling for unseen tiles.",
        "timestamp": "2025-11-30T13:58:34.916Z",
        "action_counter": 15013
      },
      {
        "commit_message": "fix: Add DOOR, CAVE, and STAIRS to obstacle list in find_path. This prevents the pathfinder from routing through warps as shortcuts, ensuring it sticks to the current map logic unless the warp is the explicit target.",
        "timestamp": "2025-11-30T14:01:17.738Z",
        "action_counter": 15014
      },
      {
        "commit_message": "fix: Redefine find_path to strictly handle Surfing state. Detects player_on_water from map XML. If Surfing, penalizes Water->Land transitions (dismounting) unless destination is Land. If Walking, treats Water as high-cost. Optimistic handling for unseen tiles matching current medium.",
        "timestamp": "2025-11-30T14:05:52.961Z",
        "action_counter": 15018
      },
      {
        "commit_message": "fix: Overhaul find_path logic for surfing. 1) Strictly detect player state (Water/Land). 2) If Surfing, apply massive 10000 cost to dismounting UNLESS destination is the target or adjacent. 3) If Walking, apply massive cost to entering water. 4) Treat warps (DOOR, CAVE) as obstacles to prevent accidental entry.",
        "timestamp": "2025-11-30T14:13:34.568Z",
        "action_counter": 15023
      }
    ]
  },
  "select_move": {
    "description": "Automatically selects a move in the battle menu by calculating the required button presses based on the cursor position in the screen text. Requires the move name and current screen text as input. Handles persistent cursor memory by scanning screen text.",
    "input_schema": {
      "type": "object",
      "properties": {
        "move_name": {
          "type": "string"
        },
        "screen_text": {
          "type": "string"
        }
      },
      "required": [
        "move_name",
        "screen_text"
      ]
    },
    "python_script": "import json\n\nmove_name = str(input_data['move_name']).upper()\nscreen_text = str(input_data['screen_text'])\n\nprint(f\"DEBUG: Target Move: {move_name}\")\n# print(f\"DEBUG: Screen Text:\\n{screen_text}\")\n\nlines = screen_text.split('\\n')\ncursor_line_index = -1\ntarget_line_index = -1\n\n# Search from the bottom up to find the menu elements (avoiding log text)\n# We assume the menu is at the bottom.\nfor i in range(len(lines) - 1, -1, -1):\n    line = lines[i]\n    # Check for cursor.\n    # Note: The arrow might be represented differently depending on OCR/Text extraction.\n    # Usually it is 'â–¶'.\n    if 'â–¶' in line and cursor_line_index == -1:\n        cursor_line_index = i\n        print(f\"DEBUG: Found cursor at line {i}: '{line}'\")\n    \n    # Check for target move.\n    if move_name in line and target_line_index == -1:\n        target_line_index = i\n        print(f\"DEBUG: Found target at line {i}: '{line}'\")\n\nbuttons = []\nif cursor_line_index != -1 and target_line_index != -1:\n    diff = target_line_index - cursor_line_index\n    if diff > 0:\n        buttons = [\"Down\"] * diff\n    elif diff < 0:\n        buttons = [\"Up\"] * abs(diff)\n    buttons.append(\"A\")\n    print(json.dumps(buttons))\nelse:\n    print(f\"DEBUG: Failed to find cursor ({cursor_line_index}) or target ({target_line_index})\")\n    # Fail safe: Do not return random buttons. Return empty to avoid bad presses.\n    print(\"[]\")",
    "history": [
      {
        "commit_message": "feat: Add select_move tool to automate move selection in battle menus, preventing manual input errors.",
        "timestamp": "2025-11-25T17:55:51.068Z",
        "action_counter": 7861
      },
      {
        "commit_message": "fix: Refine select_move to strictly validate inputs and ensure robust cursor detection logic, addressing the persistent cursor memory issue identified in critique.",
        "timestamp": "2025-11-30T07:21:13.927Z",
        "action_counter": 14672
      },
      {
        "commit_message": "fix: Refine select_move to strictly validate inputs and ensure robust cursor detection logic, addressing the persistent cursor memory issue identified in critique.",
        "timestamp": "2025-11-30T07:23:59.588Z",
        "action_counter": 14676
      },
      {
        "commit_message": "fix: Refine select_move to strictly validate inputs and ensure robust cursor detection logic, addressing the persistent cursor memory issue identified in critique.",
        "timestamp": "2025-11-30T07:25:07.230Z",
        "action_counter": 14678
      },
      {
        "commit_message": "fix: Refine select_move logic to robustly detect cursor and target move from screen text, adding debug prints to diagnose issues. This ensures the tool correctly handles persistent cursor memory in menus.",
        "timestamp": "2025-11-30T07:34:46.846Z",
        "action_counter": 14693
      }
    ]
  },
  "sequence_press": {
    "description": "Executes a sequence of button presses provided as a comma-separated string. Essential for navigating menus or keyboards where mixing directional and action inputs is required in a single turn.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "string",
          "description": "Comma-separated list of buttons to press, e.g., 'A, Down, Down, A'"
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nbuttons_str = input_data.get('buttons', '')\nif not buttons_str:\n    print('[]')\nelse:\n    button_list = [btn.strip() for btn in buttons_str.split(',')]\n    print(json.dumps(button_list))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-11-22T06:30:16.355Z",
        "action_counter": 3843
      }
    ]
  }
}