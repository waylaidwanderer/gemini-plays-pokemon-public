{
  "pathfinder": {
    "description": "Calculates the shortest path from the player's current position to a target coordinate. This version correctly handles pathing to a tile adjacent to an impassable target, and includes logic for traversing ledges.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "party_data": {
          "type": "string"
        },
        "impassable_coords": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "target_x",
        "target_y",
        "party_data"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef pathfinder_script(map_xml_string, input_data):\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    impassable_coords_str = input_data.get('impassable_coords')\n    \n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    start_x, start_y = -1, -1\n    player_found = False\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            if tile_elem.attrib.get('has-player') == 'true':\n                x = int(tile_elem.attrib['id'])\n                start_x, start_y = x, y\n                player_found = True\n                break\n        if player_found:\n            break\n\n    if not player_found:\n        return json.dumps({\"error\": \"Player not found on map.\"})\n\n    start = (start_x - 1, start_y - 1)\n    target = (target_x - 1, target_y - 1)\n    \n    extra_impassable = set()\n    if impassable_coords_str and impassable_coords_str != 'null':\n        coords_list = json.loads(impassable_coords_str)\n        for item in coords_list:\n            extra_impassable.add((item['x'] - 1, item['y'] - 1))\n\n    walkable_types = {'ground', 'grass', 'cleared_boulder_barrier', 'open_gate', 'gate_offscreen', 'steps', 'elevated_ground', 'teleport', 'hole', 'ladder_up', 'ladder_down', 'spinner_stop', 'boulder_switch'}\n    \n    tile_map = {}\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id']) - 1\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id']) - 1\n            tile_map[(x, y)] = tile_elem\n\n    def get_tile_type(x, y):\n        if (x, y) in tile_map:\n            return tile_map[(x, y)].attrib.get('type', 'unknown')\n        return 'unknown'\n\n    def is_impassable(x, y):\n        tile_elem = tile_map.get((x,y))\n        if not tile_elem:\n            return True\n        tile_type = tile_elem.attrib.get('type', 'unknown')\n        return (\n            tile_type not in walkable_types and tile_type != 'ledge' or\n            (tile_elem.find('Object') is not None and tile_elem.find(\".//Object[@id-name='Pikachu']\") is None) or\n            (x, y) in extra_impassable\n        )\n\n    def is_walkable(x, y):\n        if not (0 <= x < width and 0 <= y < height):\n            return False\n        tile_type = get_tile_type(x, y)\n        return tile_type in walkable_types and not is_impassable(x, y)\n\n    end = target\n    if not is_walkable(end[0], end[1]):\n        possible_ends = []\n        for dx, dy in [(0, -1), (1, 0), (0, 1), (-1, 0)]:\n            adj_x, adj_y = target[0] + dx, target[1] + dy\n            if is_walkable(adj_x, adj_y):\n                possible_ends.append((adj_x, adj_y))\n        \n        if not possible_ends:\n            return json.dumps({\"error\": \"No walkable adjacent tile to target\"})\n        \n        end = min(possible_ends, key=lambda p: abs(p[0] - start[0]) + abs(p[1] - start[1]))\n\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = { (x, y): float('inf') for y in range(height) for x in range(width) }\n    g_score[start] = 0\n    f_score = { (x, y): float('inf') for y in range(height) for x in range(width) }\n    f_score[start] = heuristic(start, end)\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == end:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            final_path = [{'x': x + 1, 'y': y + 1} for x, y in path]\n            return json.dumps(final_path)\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n\n            if not (0 <= neighbor[0] < width and 0 <= neighbor[1] < height):\n                continue\n\n            neighbor_type = get_tile_type(neighbor[0], neighbor[1])\n            actual_neighbor = neighbor\n            cost = 1\n\n            if neighbor_type == 'ledge':\n                if dy == 1: # Moving down onto a ledge\n                    actual_neighbor = (neighbor[0], neighbor[1] + 1)\n                    if not is_walkable(actual_neighbor[0], actual_neighbor[1]):\n                        continue\n                else: # Trying to move onto a ledge from side/below\n                    continue\n            elif is_impassable(neighbor[0], neighbor[1]):\n                continue\n\n            tentative_g_score = g_score[current] + cost\n            if tentative_g_score < g_score.get(actual_neighbor, float('inf')):\n                came_from[actual_neighbor] = current\n                g_score[actual_neighbor] = tentative_g_score\n                f_score[actual_neighbor] = g_score[actual_neighbor] + heuristic(actual_neighbor, end)\n                if actual_neighbor not in [i[1] for i in open_set]:\n                    heapq.heappush(open_set, (f_score[actual_neighbor], actual_neighbor))\n\n    return json.dumps({\"error\": \"No path found\"})\n\ntry:\n    print(pathfinder_script(map_xml_string, input_data))\nexcept Exception as e:\n    import traceback\n    print(json.dumps({\"error\": f\"An unexpected error occurred: {e}\", \"traceback\": traceback.format_exc()}))"
  },
  "spinner_maze_solver": {
    "description": "A tool to solve spinner mazes by calculating the optimal path. This version correctly validates that all intermediate tiles in a spinner's path are walkable.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\nimport traceback\n\ndef spinner_maze_solver(input_data, map_xml_string):\n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n        root = ET.fromstring(map_xml_string)\n\n        tile_map = {}\n        player_pos = None\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                tile_type = tile_elem.get('type')\n                has_obj = tile_elem.find('Object') is not None and tile_elem.find('Object').get('id-name') != 'PIKACHU'\n                spinner_info = tile_elem.find('Spinner')\n                spinner_direction = spinner_info.get('direction') if spinner_info is not None else None\n                tile_map[(x, y)] = {'type': tile_type, 'has_obj': has_obj, 'spinner': spinner_direction}\n                if tile_elem.find('Player') is not None:\n                    player_pos = (x, y)\n\n        if not player_pos:\n            print(json.dumps({'error': 'Player position not found.'}))\n            return\n\n        def is_walkable(coord):\n            if coord not in tile_map: return False\n            tile = tile_map[coord]\n            if tile['has_obj']: return False\n            return tile['type'] not in ['impassable', 'boulder_barrier', 'unknown', 'closed_gate']\n\n        def get_spinner_destination(start_coord):\n            path = [start_coord]\n            visited = {start_coord}\n            current_pos = start_coord\n            \n            while tile_map.get(current_pos, {}).get('spinner') and tile_map[current_pos]['spinner'] != 'stop':\n                direction = tile_map[current_pos]['spinner']\n                next_pos_list = list(current_pos)\n                if direction == 'up': next_pos_list[1] -= 1\n                elif direction == 'down': next_pos_list[1] += 1\n                elif direction == 'left': next_pos_list[0] -= 1\n                elif direction == 'right': next_pos_list[0] += 1\n                next_pos = tuple(next_pos_list)\n\n                if not is_walkable(next_pos) or next_pos in visited:\n                    return None, []\n                \n                current_pos = next_pos\n                visited.add(current_pos)\n                path.append(current_pos)\n\n            return current_pos, path\n\n        target_node = (target_x, target_y)\n        if not is_walkable(target_node):\n            found_new_target = False\n            for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                adj_target = (target_x + dx, target_y + dy)\n                if is_walkable(adj_target):\n                    target_node = adj_target\n                    found_new_target = True\n                    break\n            if not found_new_target:\n                print(json.dumps({'error': 'Target is impassable and no adjacent traversable tile found.'}))\n                return\n\n        open_set = [(0, player_pos)]\n        came_from = {}\n        g_score = {player_pos: 0}\n\n        def heuristic(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n        print(f'Starting search from {player_pos} to {target_node}')\n        while open_set:\n            _, current = heapq.heappop(open_set)\n            print(f'Popped {current} from open set.')\n\n            if current == target_node:\n                print('Target reached!')\n                path_segments = []\n                curr = target_node\n                while curr in came_from:\n                    prev, trigger = came_from[curr]\n                    path_segments.append((curr, trigger))\n                    curr = prev\n                path_segments.reverse()\n\n                final_path = [player_pos]\n                for segment_end, trigger_step in path_segments:\n                    final_path.append(trigger_step)\n                    if tile_map[trigger_step]['spinner']:\n                        dest, spin_path = get_spinner_destination(trigger_step)\n                        if spin_path and len(spin_path) > 1:\n                            final_path.extend(spin_path[1:])\n                \n                seen = set()\n                unique_path = []\n                for p in final_path:\n                    if p not in seen:\n                        unique_path.append(p)\n                        seen.add(p)\n\n                print(json.dumps([{'x': x, 'y': y} for x, y in unique_path]))\n                return\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                neighbor = (current[0] + dx, current[1] + dy)\n                if not is_walkable(neighbor): continue\n\n                move_cost = 1\n                final_dest = neighbor\n                if tile_map[neighbor]['spinner']:\n                    dest, spin_path = get_spinner_destination(neighbor)\n                    if dest is None: continue\n                    final_dest = dest\n                    move_cost = len(spin_path)\n                \n                tentative_g_score = g_score.get(current, float('inf')) + move_cost\n                if final_dest not in g_score or tentative_g_score < g_score[final_dest]:\n                    print(f'  Found better path to {final_dest} via {neighbor} (from {current})')\n                    g_score[final_dest] = tentative_g_score\n                    f_score = tentative_g_score + heuristic(final_dest, target_node)\n                    heapq.heappush(open_set, (f_score, final_dest))\n                    came_from[final_dest] = (current, neighbor)\n\n        print(json.dumps({'error': 'No path found.'}))\n    except Exception as e:\n        print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))\n\nspinner_maze_solver(input_data, map_xml_string)"
  },
  "boulder_puzzle_solver": {
    "description": "Analyzes the map XML for a boulder puzzle and provides a step-by-step solution. This version includes A* pathfinding to ensure the player can reach the boulders before attempting a push. It correctly handles puzzles with more boulders than switches, includes an iteration limit, and validates that the player can reach the exact push position. **This version now correctly checks for the SURF HM and allows the player pathfinding to traverse water tiles.**",
    "input_schema": {
      "type": "object",
      "properties": {
        "boulder_coords": {
          "type": "string"
        },
        "switch_coords": {
          "type": "string"
        },
        "party_data": {
          "type": "string"
        }
      },
      "required": [
        "boulder_coords",
        "switch_coords",
        "party_data"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\nfrom collections import deque\n\ndef solve_boulder_puzzle(input_data):\n    grid = {}\n    player_pos = None\n    map_width = 0\n    map_height = 0\n    party_data = []\n\n    def parse_map_and_party(xml_string, party_str):\n        nonlocal grid, player_pos, map_width, map_height, party_data\n        root = ET.fromstring(xml_string)\n        map_width = int(root.get('width'))\n        map_height = int(root.get('height'))\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                is_warp = tile_elem.get('is-warp') == 'true'\n                object_id_name = None\n                obj_elem = tile_elem.find('Object')\n                if obj_elem is not None:\n                    object_id_name = obj_elem.get('id-name')\n                if tile_elem.find('Player') is not None:\n                    player_pos = (x, y)\n                grid[(x, y)] = {'type': tile_type, 'has_object': has_object, 'is_warp': is_warp, 'object_id_name': object_id_name}\n        party_data = json.loads(party_str) if party_str else []\n\n    def has_hm(hm_name):\n        for pokemon in party_data:\n            if not pokemon.get('is_fainted', False):\n                for move in pokemon.get('moves', []):\n                    if isinstance(move, dict) and move.get('name') == hm_name: return True\n                    elif isinstance(move, str) and move == hm_name: return True\n        return False\n\n    def is_player_traversable(from_coord, to_coord, current_boulders):\n        if to_coord not in grid: return False\n        to_tile = grid[to_coord]\n        from_tile = grid[from_coord]\n        from_type = from_tile['type']\n        to_type = to_tile['type']\n\n        if to_type in ['impassable', 'boulder_barrier'] or to_coord in current_boulders: return False\n        if to_tile['has_object'] and not to_tile['is_warp'] and to_tile.get('object_id_name') != 'PIKACHU': return False\n        \n        if to_type == 'water' and has_hm('SURF'):\n            if from_type in ['ground', 'steps', 'grass', 'water']:\n                return True\n        if from_type == 'water' and to_type in ['ground', 'steps', 'grass'] and has_hm('SURF'):\n            return True\n\n        valid_land_types = {'ground', 'grass', 'steps', 'elevated_ground', 'ladder_up', 'ladder_down'}\n        if from_type in valid_land_types and to_type in valid_land_types:\n            if from_type == 'steps' and to_type in {'ground', 'grass', 'elevated_ground', 'steps'}: return True\n            if to_type == 'steps' and from_type in {'ground', 'grass', 'elevated_ground'}: return True\n            if from_type == to_type: return True\n            if from_type in {'ground', 'grass'} and to_type in {'ground', 'grass'}: return True\n            if from_type in {'ladder_up', 'ladder_down'} or to_type in {'ladder_up', 'ladder_down'}: return True\n            return False\n        return False\n\n    def get_player_neighbors(node, current_boulders):\n        x, y = node\n        neighbors = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 1 <= nx <= map_width and 1 <= ny <= map_height:\n                if is_player_traversable((x, y), (nx, ny), current_boulders):\n                    neighbors.append((nx, ny))\n        return neighbors\n\n    def player_a_star(start, goal, current_boulders):\n        frontier = [(0, start)]\n        came_from = {start: None}\n        cost_so_far = {start: 0}\n        max_iterations = 2000\n        iterations = 0\n        while frontier:\n            iterations += 1\n            if iterations > max_iterations: return None\n            _, current = heapq.heappop(frontier)\n            if current == goal: break\n            for next_node in get_player_neighbors(current, current_boulders):\n                new_cost = cost_so_far[current] + 1\n                if next_node not in cost_so_far or new_cost < cost_so_far[next_node]:\n                    cost_so_far[next_node] = new_cost\n                    priority = new_cost + abs(goal[0] - next_node[0]) + abs(goal[1] - next_node[1])\n                    heapq.heappush(frontier, (priority, next_node))\n                    came_from[next_node] = current\n        else: return None\n        path = []\n        current = goal\n        while current is not None: path.append(current); current = came_from.get(current)\n        path.reverse()\n        return path\n\n    def get_boulder_neighbors(state, current_player_pos):\n        neighbors = []\n        boulders = set(state)\n        for i, boulder in enumerate(state):\n            bx, by = boulder\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                player_pos_req = (bx - dx, by - dy)\n                new_boulder_pos = (bx + dx, by + dy)\n                if new_boulder_pos in boulders or new_boulder_pos not in grid or grid[new_boulder_pos]['type'] in ['impassable', 'boulder_barrier'] or (grid[new_boulder_pos]['has_object'] and not grid[new_boulder_pos]['is_warp'] and grid[new_boulder_pos].get('object_id_name') != 'PIKACHU'): continue\n                path_to_push = player_a_star(current_player_pos, player_pos_req, boulders)\n                if path_to_push:\n                    new_state_list = list(state)\n                    new_state_list[i] = new_boulder_pos\n                    new_state_tuple = tuple(sorted(new_state_list))\n                    move = {'boulder_index': i, 'start_pos': boulder, 'end_pos': new_boulder_pos, 'player_path': path_to_push}\n                    neighbors.append((new_state_tuple, move))\n        return neighbors\n\n    def puzzle_heuristic(state, switches):\n        total_dist = 0\n        unplaced_boulders = sorted([b for b in state if b not in switches])\n        open_switches = sorted([s for s in switches if s not in state])\n        for boulder in unplaced_boulders:\n            if not open_switches: break\n            min_dist = float('inf')\n            best_switch = None\n            for switch in open_switches:\n                dist = abs(boulder[0] - switch[0]) + abs(boulder[1] - switch[1])\n                if dist < min_dist: min_dist = dist; best_switch = switch\n            total_dist += min_dist\n            if best_switch: open_switches.remove(best_switch)\n        return total_dist\n\n    def puzzle_a_star_solver(start_state, switches, initial_player_pos):\n        start_node = (tuple(sorted(start_state)), initial_player_pos)\n        frontier = [(puzzle_heuristic(start_node[0], switches), start_node)]\n        came_from = {start_node: (None, None)}\n        cost_so_far = {start_node: 0}\n        max_iterations = 15000\n        iterations = 0\n        while frontier:\n            iterations += 1\n            if iterations > max_iterations: return 'timeout'\n            _, current_node = heapq.heappop(frontier)\n            current_state, current_player_pos = current_node\n            if len(switches) > 0 and set(switches).issubset(set(current_state)):\n                path = []\n                curr = current_node\n                while curr is not None:\n                    parent, move = came_from.get(curr, (None, None))\n                    if move: path.append(move)\n                    curr = parent\n                path.reverse()\n                return path\n            for next_state, move in get_boulder_neighbors(current_state, current_player_pos):\n                new_cost = cost_so_far[current_node] + 1\n                next_player_pos = move['start_pos']\n                next_node = (next_state, next_player_pos)\n                if next_node not in cost_so_far or new_cost < cost_so_far[next_node]:\n                    cost_so_far[next_node] = new_cost\n                    priority = new_cost + puzzle_heuristic(next_state, switches)\n                    heapq.heappush(frontier, (priority, next_node))\n                    came_from[next_node] = (current_node, move)\n        return None\n\n    try:\n        parse_map_and_party(map_xml_string, input_data['party_data'])\n        boulder_coords = [tuple(coord) for coord in json.loads(input_data['boulder_coords'])]\n        switch_coords = [tuple(coord) for coord in json.loads(input_data['switch_coords'])]\n        solution = puzzle_a_star_solver(boulder_coords, switch_coords, player_pos)\n        if solution == 'timeout':\n            print(json.dumps({'error': 'Solver timed out after too many iterations.'}))\n        elif solution:\n            print(json.dumps({'solution_path': solution}))\n        else:\n            print(json.dumps({'error': 'No solution found for the puzzle.'}))\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': f'An error occurred: {str(e)}', 'traceback': traceback.format_exc()}))\n\nsolve_boulder_puzzle(input_data)\n"
  },
  "find_closest_unseen_tile": {
    "description": "Finds the closest reachable unseen tile and a reachable adjacent tile to pathfind to. This version uses the full, robust traversal logic.",
    "input_schema": {
      "type": "object",
      "properties": {
        "party_data": {
          "type": "string"
        }
      },
      "required": [
        "party_data"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport sys\n\ndef find_closest_unseen_tile(map_xml_string, input_data):\n    try:\n        party_data = json.loads(input_data['party_data'])\n\n        def parse_map(xml_string):\n            root = ET.fromstring(xml_string)\n            grid = {}\n            player_pos = None\n            unseen_tiles = []\n            for row_elem in root.findall('Row'):\n                y = int(row_elem.get('id'))\n                for tile_elem in row_elem.findall('Tile'):\n                    x = int(tile_elem.get('id'))\n                    tile_type = tile_elem.get('type')\n                    seen = tile_elem.get('seen') == 'true'\n                    has_object = tile_elem.get('has-object') == 'true'\n                    object_id_name = None\n                    obj_elem = tile_elem.find('Object')\n                    if obj_elem is not None:\n                        object_id_name = obj_elem.get('id-name')\n                    if tile_elem.find('Player') is not None:\n                        player_pos = (x, y)\n                    grid[(x, y)] = {'type': tile_type, 'has_object': has_object, 'object_id_name': object_id_name, 'seen': seen}\n                    if not seen:\n                        unseen_tiles.append((x, y))\n            return grid, player_pos, unseen_tiles, int(root.get('width')), int(root.get('height'))\n\n        has_surf = any('SURF' in move for pokemon in party_data for move in pokemon.get('moves', []))\n        has_cut = any('CUT' in move for pokemon in party_data for move in pokemon.get('moves', []))\n\n        def is_traversable_for_bfs(coord, from_coord, grid):\n            tile = grid.get(coord)\n            if not tile or not tile['seen']: return False\n            if tile['has_object'] and tile['object_id_name'] != 'Pikachu': return False\n            from_tile = grid.get(from_coord)\n            if not from_tile: return False\n\n            if tile['type'] == 'ledge': return from_coord[1] == coord[1] - 1\n            if from_tile['type'] == 'ledge': return coord[0] == from_coord[0] and coord[1] == from_coord[1] + 1\n            \n            if tile['type'] == 'water':\n                if from_tile['type'] in ['ground', 'grass', 'steps']: return has_surf\n                return from_tile['type'] == 'water'\n\n            if tile['type'] == 'cuttable':\n                if not has_cut: return False\n            elif tile['type'] in ['unknown', 'impassable']: return False\n\n            walkable_land = ['ground', 'grass', 'steps', 'cleared_boulder_barrier', 'open_gate', 'gate_offscreen', 'cuttable']\n            if tile['type'] in walkable_land and from_tile['type'] in walkable_land: return True\n            if from_tile['type'] == 'water' and tile['type'] in walkable_land: return True\n\n            return False\n\n        def get_neighbors(node, grid, map_width, map_height):\n            neighbors = []\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                neighbor = (node[0] + dx, node[1] + dy)\n                if 1 <= neighbor[0] <= map_width and 1 <= neighbor[1] <= map_height:\n                    if is_traversable_for_bfs(neighbor, node, grid):\n                        neighbors.append(neighbor)\n            return neighbors\n\n        def bfs_find_reachable(start, grid, map_width, map_height):\n            frontier = [start]\n            reachable = {start}\n            while frontier:\n                current = frontier.pop(0)\n                for neighbor in get_neighbors(current, grid, map_width, map_height):\n                    if neighbor not in reachable:\n                        reachable.add(neighbor)\n                        frontier.append(neighbor)\n            return reachable\n\n        grid, player_pos, unseen_tiles, map_width, map_height = parse_map(map_xml_string)\n        if player_pos is None: raise ValueError('Player position not found.')\n\n        reachable_seen_tiles = bfs_find_reachable(player_pos, grid, map_width, map_height)\n        \n        border_unseen_tiles = []\n        for tile_coord in unseen_tiles:\n            x, y = tile_coord\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                neighbor = (x + dx, y + dy)\n                if neighbor in reachable_seen_tiles:\n                    border_unseen_tiles.append(tile_coord)\n                    break\n\n        if not border_unseen_tiles:\n            print(json.dumps({'message': 'No reachable unseen tiles found.'}))\n            return\n\n        closest_tile = min(border_unseen_tiles, key=lambda t: abs(t[0] - player_pos[0]) + abs(t[1] - player_pos[1]))\n\n        for dx, dy in sorted([(0, 1), (0, -1), (1, 0), (-1, 0)], key=lambda p: (abs((closest_tile[0] + p[0]) - player_pos[0]) + abs((closest_tile[1] + p[1]) - player_pos[1]))):\n            adj_tile = (closest_tile[0] + dx, closest_tile[1] + dy)\n            if adj_tile in reachable_seen_tiles:\n                print(json.dumps({'closest_reachable_unseen_tile': {'x': closest_tile[0], 'y': closest_tile[1]}, 'adjacent_tile': {'x': adj_tile[0], 'y': adj_tile[1]}}))\n                return\n        \n        print(json.dumps({'message': 'Found a reachable unseen tile, but no reachable adjacent tile to path to.'}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': str(e), 'traceback': traceback.format_exc()}))\n\nfind_closest_unseen_tile(map_xml_string, input_data)"
  },
  "path_tester": {
    "description": "A minimal A* pathfinding tool for debugging. Takes a simplified map string ('.', '#'), start/end coordinates, and returns a path or an error. This version now handles pathing to a tile adjacent to an impassable target.",
    "input_schema": {
      "type": "object",
      "properties": {
        "map_string": {
          "type": "string"
        },
        "width": {
          "type": "integer"
        },
        "height": {
          "type": "integer"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        }
      },
      "required": [
        "map_string",
        "width",
        "height",
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import heapq\n\ndef path_tester_script(input_data):\n    map_str = input_data['map_string']\n    width = int(input_data['width'])\n    height = int(input_data['height'])\n    start = (int(input_data['start_x']), int(input_data['start_y']))\n    target = (int(input_data['end_x']), int(input_data['end_y']))\n\n    grid = []\n    for i in range(height):\n        row = map_str[i * width : (i + 1) * width]\n        grid.append(list(row))\n\n    def is_valid(x, y):\n        return 0 <= x < width and 0 <= y < height\n\n    def is_walkable(x, y):\n        return is_valid(x, y) and grid[y][x] == '.'\n\n    end = target\n    if not is_walkable(target[0], target[1]):\n        found_adjacent = False\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_x, adj_y = target[0] + dx, target[1] + dy\n            if is_walkable(adj_x, adj_y):\n                end = (adj_x, adj_y)\n                found_adjacent = True\n                break\n        if not found_adjacent:\n            return 'No walkable adjacent tile to target'\n\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = { (x, y): float('inf') for y in range(height) for x in range(width) }\n    g_score[start] = 0\n    f_score = { (x, y): float('inf') for y in range(height) for x in range(width) }\n    f_score[start] = heuristic(start, end)\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == end:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            return path[::-1]\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if is_walkable(neighbor[0], neighbor[1]):\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, end)\n                    if neighbor not in [i[1] for i in open_set]:\n                        heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    return 'No path found'\n\nresult = path_tester_script(input_data)\nprint(result)"
  }
}