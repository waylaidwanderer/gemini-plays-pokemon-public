{
  "find_path": {
    "description": "Finds the shortest path between two points on the current map using BFS. It avoids walls, impassable trees, objects, and correctly handles one-way ledges.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef find_path_script(map_xml_string, start_x_str, start_y_str, end_x_str, end_y_str):\n    start_x, start_y, end_x, end_y = int(start_x_str), int(start_y_str), int(end_x_str), int(end_y_str)\n    \n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = [[None for _ in range(width)] for _ in range(height)]\n    impassable_tiles = {\"WALL\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"LEDGE\", \"WATER\"}\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            has_object = tile_elem.find('Object') is not None\n            \n            if has_object:\n                grid[y][x] = 'OBJECT_OBSTACLE'\n            elif tile_type == 'unseen':\n                grid[y][x] = 'FLOOR'\n            else:\n                grid[y][x] = tile_type\n\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n\n    if not (0 <= start_x < width and 0 <= start_y < height and 0 <= end_x < width and 0 <= end_y < height):\n        return \"Start or end coordinates are out of bounds.\"\n\n    if grid[start_y][start_x] in impassable_tiles or grid[start_y][start_x] == 'OBJECT_OBSTACLE':\n        return f\"Start tile ({start_x},{start_y}) with type {grid[start_y][start_x]} is impassable.\"\n    if grid[end_y][end_x] in impassable_tiles or grid[end_y][end_x] == 'OBJECT_OBSTACLE':\n        return f\"End tile ({end_x},{end_y}) with type {grid[end_y][end_x]} is impassable.\"\n\n    queue = deque([[start_node]])\n    visited = {start_node}\n\n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n\n        if (x, y) == end_node:\n            return f\"Path found: {path}\"\n\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = x + dx, y + dy\n\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:\n                current_tile_type = grid[y][x]\n                next_tile_type = grid[ny][nx]\n\n                can_move = next_tile_type not in impassable_tiles and next_tile_type != 'OBJECT_OBSTACLE'\n\n                if 'LEDGE' in current_tile_type:\n                    is_hop_down = 'DOWN' in current_tile_type and dy == 1\n                    is_hop_right = 'RIGHT' in current_tile_type and dx == 1\n                    is_hop_left = 'LEFT' in current_tile_type and dx == -1\n                    if is_hop_down or is_hop_right or is_hop_left:\n                        can_move = True\n                    elif any(s in current_tile_type for s in ['DOWN', 'RIGHT', 'LEFT']):\n                        can_move = False\n\n                if can_move:\n                    visited.add((nx, ny))\n                    new_path = list(path)\n                    new_path.append((nx, ny))\n                    queue.append(new_path)\n    \n    return \"No path found.\"\n\nprint(find_path_script(map_xml_string, input_data['start_x'], input_data['start_y'], input_data['end_x'], input_data['end_y']))"
  },
  "path_master": {
    "description": "Finds the shortest path on the current map using BFS. Avoids a comprehensive list of impassable tiles, objects (which are also impassable), and correctly handles one-way ledges.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\nimport sys\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nroot = ET.fromstring(map_xml_string)\n\nimpassable_types = {\n    \"WALL\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"WATER\", \"MART_SHELF\", \"COUNTER\",\n    \"BUOY\", \"TOWN_MAP\", \"WINDOW\", \"BOOKSHELF\", \"TV\", \"RADIO\", \"VOID\"\n}\n\ngrid = {}\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.get('id'))\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.get('id'))\n        tile_type = tile_elem.get('type')\n        has_object = tile_elem.find('Object') is not None\n        is_impassable = tile_type in impassable_types or has_object\n        grid[f'({x},{y})'] = {'type': tile_type, 'impassable': is_impassable}\n\nstart_node = f'({start_x},{start_y})'\nend_node = f'({end_x},{end_y})'\n\nif grid.get(start_node, {}).get('impassable', True) or grid.get(end_node, {}).get('impassable', True):\n    print(json.dumps([]))\n    sys.exit()\n\nqueue = deque([start_node])\nvisited = {start_node}\nparent_map = {start_node: None}\npath_found = False\n\nwhile queue:\n    node_str = queue.popleft()\n    x, y = map(int, node_str.strip('()').split(','))\n\n    if node_str == end_node:\n        path_found = True\n        break\n\n    for move_name, (dx, dy) in [('Up', (0, -1)), ('Down', (0, 1)), ('Left', (-1, 0)), ('Right', (1, 0))]:\n        nx, ny = x + dx, y + dy\n        next_node_str = f'({nx},{ny})'\n        \n        if next_node_str in grid and next_node_str not in visited:\n            current_tile_data = grid.get(node_str)\n            next_tile_data = grid.get(next_node_str)\n            \n            can_move = not next_tile_data.get('impassable', True)\n            \n            current_type = current_tile_data.get('type', '')\n            if 'LEDGE' in current_type:\n                if move_name == 'Up': can_move = False\n                elif 'DOWN' in current_type and move_name != 'Down': can_move = False\n                elif 'LEFT' in current_type and move_name != 'Left': can_move = False\n                elif 'RIGHT' in current_type and move_name != 'Right': can_move = False\n\n            next_type = next_tile_data.get('type', '')\n            if 'LEDGE' in next_type and move_name == 'Up':\n                can_move = False\n\n            if can_move:\n                visited.add(next_node_str)\n                parent_map[next_node_str] = node_str\n                queue.append(next_node_str)\n\nif path_found:\n    path = []\n    curr_str = end_node\n    while curr_str is not None:\n        path.append(curr_str)\n        curr_str = parent_map.get(curr_str)\n    path.reverse()\n    print(f\"Reconstructed path: {path}\", file=sys.stderr)\n    \n    moves = []\n    for i in range(1, len(path)):\n        px, py = map(int, path[i-1].strip('()').split(','))\n        cx, cy = map(int, path[i].strip('()').split(','))\n        if cx > px: moves.append(\"Right\")\n        elif cx < px: moves.append(\"Left\")\n        elif cy > py: moves.append(\"Down\")\n        elif cy < py: moves.append(\"Up\")\n    print(f\"Generated moves: {moves}\", file=sys.stderr)\n    print(json.dumps(moves))\nelse:\n    print(json.dumps([]))\n"
  }
}