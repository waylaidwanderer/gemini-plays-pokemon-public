{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "boulder_push_planner": {
    "description": "Analyzes the map to find a sequence of moves for the player to push a specific boulder to a specific hole. It considers impassable terrain and other objects.",
    "input_schema": {
      "type": "object",
      "properties": {
        "boulder_start_x": {
          "type": "string"
        },
        "boulder_start_y": {
          "type": "string"
        },
        "hole_x": {
          "type": "string"
        },
        "hole_y": {
          "type": "string"
        },
        "player_x": {
          "type": "string"
        },
        "player_y": {
          "type": "string"
        }
      },
      "required": [
        "boulder_start_x",
        "boulder_start_y",
        "hole_x",
        "hole_y",
        "player_x",
        "player_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\ngrid = [['' for _ in range(width)] for _ in range(height)]\nimpassable_tiles = set()\n\nfor r_idx, row_elem in enumerate(root.findall('Row')):\n    y = int(row_elem.get('id')) - 1\n    for c_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n        x = int(tile_elem.get('id')) - 1\n        tile_type = tile_elem.get('type')\n        grid[y][x] = tile_type\n        if tile_type in ['impassable', 'boulder_barrier', 'closed_gate'] or tile_elem.find('Object') is not None:\n            impassable_tiles.add((x, y))\n\nboulder_start_x, boulder_start_y = int(input_data['boulder_start_x']) - 1, int(input_data['boulder_start_y']) - 1\nhole_x, hole_y = int(input_data['hole_x']) - 1, int(input_data['hole_y']) - 1\nplayer_x, player_y = int(input_data['player_x']) - 1, int(input_data['player_y']) - 1\n\ndef bfs_path(start, end, obstacles):\n    queue = deque([(start, [])])\n    visited = {start}\n    while queue:\n        (cx, cy), path = queue.popleft()\n        if (cx, cy) == end:\n            return path\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            if (0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited and (nx, ny) not in obstacles):\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [(nx, ny)]))\n    return None\n\ndef find_boulder_path():\n    initial_state = (player_x, player_y, boulder_start_x, boulder_start_y)\n    queue = deque([(initial_state, [])])\n    visited_states = {initial_state}\n    \n    while queue:\n        (px, py, bx, by), plan = queue.popleft()\n\n        if (bx, by) == (hole_x, hole_y):\n            return plan\n\n        for move_dir in [('Up', 0, -1), ('Down', 0, 1), ('Left', -1, 0), ('Right', 1, 0)]:\n            move_name, dx, dy = move_dir\n            player_push_pos = (bx - dx, by - dy)\n            \n            if not (0 <= player_push_pos[0] < width and 0 <= player_push_pos[1] < height):\n                continue\n\n            path_to_push_pos = bfs_path((px, py), player_push_pos, impassable_tiles | {(bx, by)})\n\n            if path_to_push_pos is not None:\n                new_bx, new_by = bx + dx, by + dy\n\n                if not (0 <= new_bx < width and 0 <= new_by < height) or (new_bx, new_by) in impassable_tiles:\n                    continue\n\n                new_state = (bx, by, new_bx, new_by)\n                if new_state not in visited_states:\n                    visited_states.add(new_state)\n                    new_plan = plan + [{'path_to_push': [{'x': x+1, 'y': y+1} for x, y in path_to_push_pos], 'push_direction': move_name}]\n                    queue.append((new_state, new_plan))\n\n    return None\n\npath_result = find_boulder_path()\nif path_result:\n    print(json.dumps({'plan': path_result, 'reasoning': 'Found a valid plan to push the boulder.'}))\nelse:\n    print(json.dumps({'plan': [], 'reasoning': 'Could not find a valid plan to push the boulder.'}))"
  },
  "find_path": {
    "description": "A consolidated pathfinding tool. Finds a path to specified X, Y coordinates, considering the current movement state (walking or surfing). It can now avoid a specified list of coordinates. If no end coordinates are provided, it finds a path to the nearest reachable unseen tile. It automatically paths to an adjacent tile if the target is impassable. It can handle elevation changes via steps. This version includes fixes for tile traversal logic and input validation.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string",
          "nullable": true
        },
        "end_y": {
          "type": "string",
          "nullable": true
        },
        "movement_mode": {
          "type": "string",
          "enum": [
            "walking",
            "surfing"
          ]
        },
        "avoid_coords": {
          "type": "string",
          "nullable": true,
          "description": "A JSON string representing a list of coordinate objects, e.g., '[{\"x\":\"10\",\"y\":\"12\"}]'"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "movement_mode"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef find_path(input_data):\n    try:\n        map_xml = ET.fromstring(map_xml_string)\n        width = int(map_xml.get('width'))\n        height = int(map_xml.get('height'))\n\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        movement_mode = input_data['movement_mode']\n\n        end_x = int(input_data.get('end_x')) if input_data.get('end_x') is not None else None\n        end_y = int(input_data.get('end_y')) if input_data.get('end_y') is not None else None\n\n        avoid_coords_str = input_data.get('avoid_coords')\n        avoid_coords = set()\n        if avoid_coords_str:\n            try:\n                avoid_list = json.loads(avoid_coords_str)\n                for coord in avoid_list:\n                    avoid_coords.add((int(coord['x']), int(coord['y'])))\n            except (json.JSONDecodeError, KeyError, TypeError) as e:\n                print(json.dumps({\"error\": f\"Error decoding avoid_coords: {e}. Ignoring.\"}))\n\n        start_node = (start_x, start_y)\n        if start_node in avoid_coords:\n            print(json.dumps({\"error\": f\"Start node ({start_x}, {start_y}) is in the avoid list.\"}))\n            return\n\n        grid = [[None for _ in range(width + 1)] for _ in range(height + 1)]\n        unseen_tiles = []\n\n        for r_idx, row in enumerate(map_xml.findall('Row')):\n            y = int(row.get('id'))\n            for t_idx, tile in enumerate(row.findall('Tile')):\n                x = int(tile.get('id'))\n                tile_type = tile.get('type')\n                is_warp = tile.get('is-warp') == 'true'\n                has_object = tile.find('Object') is not None and tile.find('Object').get('id-name') != 'Pikachu'\n                is_seen = tile.get('seen') == 'true'\n\n                if not is_seen:\n                    unseen_tiles.append((x, y))\n                \n                grid[y][x] = {\n                    'type': tile_type,\n                    'is_warp': is_warp,\n                    'has_object': has_object\n                }\n\n        def is_traversable(x, y, mode):\n            if not (1 <= x <= width and 1 <= y <= height):\n                return False\n            if (x, y) in avoid_coords:\n                return False\n            \n            tile_info = grid[y][x]\n            if tile_info is None or tile_info['has_object']:\n                return False\n\n            tile_type = tile_info['type']\n            if mode == 'walking':\n                return tile_type in ['ground', 'grass', 'cleared_boulder_barrier', 'open_gate', 'steps', 'elevated_ground', 'spinner_stop', 'teleport'] or tile_type.startswith('spinner')\n            elif mode == 'surfing':\n                return tile_type == 'water'\n            return False\n\n        def get_neighbors(x, y, mode):\n            neighbors = []\n            current_tile_type = grid[y][x]['type']\n\n            for dx, dy, direction in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n                nx, ny = x + dx, y + dy\n                if not (1 <= nx <= width and 1 <= ny <= height):\n                    continue\n\n                neighbor_tile_type = grid[ny][nx]['type']\n\n                if mode == 'walking':\n                    if direction == 'Down' and neighbor_tile_type == 'ledge':\n                        if is_traversable(nx, ny + 1, mode):\n                            neighbors.append(((nx, ny + 1), direction))\n                        continue\n                    if current_tile_type == 'steps' and neighbor_tile_type in ['ground', 'elevated_ground']:\n                         if is_traversable(nx, ny, mode):\n                            neighbors.append(((nx, ny), direction))\n                         continue\n                    if current_tile_type in ['ground', 'elevated_ground'] and neighbor_tile_type == 'steps':\n                         if is_traversable(nx, ny, mode):\n                            neighbors.append(((nx, ny), direction))\n                         continue\n                    if current_tile_type == 'elevated_ground' and neighbor_tile_type != 'elevated_ground' and neighbor_tile_type != 'steps':\n                        continue\n\n                if is_traversable(nx, ny, mode):\n                    neighbors.append(((nx, ny), direction))\n            return neighbors\n\n        def heuristic(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n        def a_star(start, goal_func, h_func):\n            open_set = [(0, start)]\n            came_from = {}\n            g_score = { (x, y): float('inf') for y in range(height + 1) for x in range(width + 1) }\n            g_score[start] = 0\n            f_score = { (x, y): float('inf') for y in range(height + 1) for x in range(width + 1) }\n            f_score[start] = h_func(start)\n\n            while open_set:\n                _, current = heapq.heappop(open_set)\n\n                if goal_func(current):\n                    path = []\n                    while current in came_from:\n                        path.append(current)\n                        current = came_from[current]\n                    path.append(start)\n                    return path[::-1]\n\n                for neighbor_pos, direction in get_neighbors(current[0], current[1], movement_mode):\n                    tentative_g_score = g_score[current] + 1\n                    if tentative_g_score < g_score.get(neighbor_pos, float('inf')):\n                        came_from[neighbor_pos] = current\n                        g_score[neighbor_pos] = tentative_g_score\n                        f_score[neighbor_pos] = tentative_g_score + h_func(neighbor_pos)\n                        heapq.heappush(open_set, (f_score[neighbor_pos], neighbor_pos))\n            return None\n\n        if end_x is not None and end_y is not None:\n            goal_node = (end_x, end_y)\n            if not is_traversable(goal_node[0], goal_node[1], movement_mode):\n                adj_goals = []\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    adj_x, adj_y = goal_node[0] + dx, goal_node[1] + dy\n                    if is_traversable(adj_x, adj_y, movement_mode):\n                        adj_goals.append((adj_x, adj_y))\n                \n                if not adj_goals:\n                    print(json.dumps({\"error\": f\"Goal ({end_x}, {end_y}) and its adjacent tiles are unreachable.\"}))\n                    return\n                \n                adj_goals.sort(key=lambda p: heuristic(start_node, p))\n                final_goal = adj_goals[0]\n            else:\n                final_goal = goal_node\n\n            path = a_star(start_node, lambda p: p == final_goal, lambda p: heuristic(p, final_goal))\n            if path:\n                print(json.dumps({\"path\": path}))\n            else:\n                print(json.dumps({\"error\": f\"No path found from ({start_x}, {start_y}) to ({end_x}, {end_y}) or its adjacent tiles.\"}))\n        else:\n            if not unseen_tiles:\n                print(json.dumps({\"error\": \"No unseen tiles to path to.\"}))\n                return\n\n            unseen_set = set(unseen_tiles)\n            def is_adj_to_unseen(p):\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    if (p[0] + dx, p[1] + dy) in unseen_set:\n                        return True\n                return False\n\n            def h_to_nearest_unseen(p):\n                return min(heuristic(p, unseen) for unseen in unseen_tiles)\n\n            path = a_star(start_node, is_adj_to_unseen, h_to_nearest_unseen)\n            if path:\n                print(json.dumps({\"path\": path}))\n            else:\n                print(json.dumps({\"error\": \"No path found to any unseen tile.\"}))\n\n    except Exception as e:\n        print(json.dumps({\"error\": f\"An unexpected error occurred: {str(e)}\"}))\n\nfind_path(input_data)"
  },
  "get_impassable_tiles": {
    "description": "Extracts and returns a JSON list of all impassable tile coordinates from the current map XML.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET; import json; root = ET.fromstring(map_xml_string); impassable_tiles = []; for row_elem in root.findall('Row'): y = int(row_elem.get('id')); for tile_elem in row_elem.findall('Tile'): x = int(tile_elem.get('id')); if tile_elem.get('type') == 'impassable' or tile_elem.find('Object') is not None: impassable_tiles.append({'x': x, 'y': y}); print(json.dumps(impassable_tiles))"
  },
  "shop_automation_planner": {
    "description": "A placeholder tool to acknowledge the need for shop automation. The player's repeated errors in the shop menu indicate a need for a more streamlined process. This tool serves as a commitment to either developing a viable automation solution in the future or improving manual execution to prevent such errors. Direct UI control is not possible with current tool capabilities, so the immediate focus will be on careful, deliberate manual input.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "python_script": "print(\"Automation acknowledged. The critique regarding error-prone manual item purchasing is valid. While direct UI control tools cannot be built, I will proceed with methodical, single-input-per-turn actions to eliminate errors.\")"
  }
}