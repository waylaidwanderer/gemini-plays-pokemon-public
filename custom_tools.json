{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "boulder_push_planner": {
    "description": "Analyzes the map to find a sequence of moves for the player to push a specific boulder to a specific hole. It considers impassable terrain and other objects.",
    "input_schema": {
      "type": "object",
      "properties": {
        "boulder_start_x": {
          "type": "string"
        },
        "boulder_start_y": {
          "type": "string"
        },
        "hole_x": {
          "type": "string"
        },
        "hole_y": {
          "type": "string"
        },
        "player_x": {
          "type": "string"
        },
        "player_y": {
          "type": "string"
        }
      },
      "required": [
        "boulder_start_x",
        "boulder_start_y",
        "hole_x",
        "hole_y",
        "player_x",
        "player_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\ngrid = [['' for _ in range(width)] for _ in range(height)]\nimpassable_tiles = set()\n\nfor r_idx, row_elem in enumerate(root.findall('Row')):\n    y = int(row_elem.get('id')) - 1\n    for c_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n        x = int(tile_elem.get('id')) - 1\n        tile_type = tile_elem.get('type')\n        grid[y][x] = tile_type\n        if tile_type in ['impassable', 'boulder_barrier', 'closed_gate'] or tile_elem.find('Object') is not None:\n            impassable_tiles.add((x, y))\n\nboulder_start_x, boulder_start_y = int(input_data['boulder_start_x']) - 1, int(input_data['boulder_start_y']) - 1\nhole_x, hole_y = int(input_data['hole_x']) - 1, int(input_data['hole_y']) - 1\nplayer_x, player_y = int(input_data['player_x']) - 1, int(input_data['player_y']) - 1\n\ndef bfs_path(start, end, obstacles):\n    queue = deque([(start, [])])\n    visited = {start}\n    while queue:\n        (cx, cy), path = queue.popleft()\n        if (cx, cy) == end:\n            return path\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            if (0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited and (nx, ny) not in obstacles):\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [(nx, ny)]))\n    return None\n\ndef find_boulder_path():\n    initial_state = (player_x, player_y, boulder_start_x, boulder_start_y)\n    queue = deque([(initial_state, [])])\n    visited_states = {initial_state}\n    \n    while queue:\n        (px, py, bx, by), plan = queue.popleft()\n\n        if (bx, by) == (hole_x, hole_y):\n            return plan\n\n        for move_dir in [('Up', 0, -1), ('Down', 0, 1), ('Left', -1, 0), ('Right', 1, 0)]:\n            move_name, dx, dy = move_dir\n            player_push_pos = (bx - dx, by - dy)\n            \n            if not (0 <= player_push_pos[0] < width and 0 <= player_push_pos[1] < height):\n                continue\n\n            path_to_push_pos = bfs_path((px, py), player_push_pos, impassable_tiles | {(bx, by)})\n\n            if path_to_push_pos is not None:\n                new_bx, new_by = bx + dx, by + dy\n\n                if not (0 <= new_bx < width and 0 <= new_by < height) or (new_bx, new_by) in impassable_tiles:\n                    continue\n\n                new_state = (bx, by, new_bx, new_by)\n                if new_state not in visited_states:\n                    visited_states.add(new_state)\n                    new_plan = plan + [{'path_to_push': [{'x': x+1, 'y': y+1} for x, y in path_to_push_pos], 'push_direction': move_name}]\n                    queue.append((new_state, new_plan))\n\n    return None\n\npath_result = find_boulder_path()\nif path_result:\n    print(json.dumps({'plan': path_result, 'reasoning': 'Found a valid plan to push the boulder.'}))\nelse:\n    print(json.dumps({'plan': [], 'reasoning': 'Could not find a valid plan to push the boulder.'}))"
  },
  "find_path": {
    "description": "A robust pathfinding tool. Finds a path to specified X, Y coordinates, considering the current movement state (walking or surfing). It can now avoid a specified list of coordinates. If no end coordinates are provided, it finds a path to the nearest reachable unseen tile. It automatically paths to an adjacent tile if the target is impassable. It can handle elevation changes via steps, off-screen gates, and correctly paths through Pikachu.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string",
          "nullable": true
        },
        "end_y": {
          "type": "string",
          "nullable": true
        },
        "movement_mode": {
          "type": "string",
          "enum": [
            "walking",
            "surfing"
          ]
        },
        "avoid_coords": {
          "type": "string",
          "nullable": true,
          "description": "A JSON string representing a list of coordinate objects, e.g., '[{\"x\":\"10\",\"y\":\"12\"}]'"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "movement_mode"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef parse_map_xml(xml_string):\n    root = ET.fromstring(xml_string)\n    grid = {}\n    unseen_tiles = []\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tile_type = tile.get('type')\n            is_warp = tile.get('is-warp') == 'true'\n            is_seen = tile.get('seen') == 'true'\n            object_info = None\n            object_element = tile.find('Object')\n            has_object = object_element is not None\n            if has_object:\n                object_id_name = object_element.get('id-name')\n                object_info = {'id_name': object_id_name}\n            grid[(x, y)] = {'type': tile_type, 'is_warp': is_warp, 'has_object': has_object, 'is_seen': is_seen, 'object_info': object_info}\n            if not is_seen:\n                unseen_tiles.append((x, y))\n    return grid, width, height, unseen_tiles\n\ndef is_walkable(tile_data, movement_mode):\n    walkable_types = ['ground', 'grass', 'cleared_boulder_barrier', 'boulder_switch', 'open_gate', 'gate_offscreen', 'steps', 'elevated_ground', 'ladder_up', 'ladder_down', 'hole']\n    surfable_types = ['water']\n    if movement_mode == 'walking':\n        return tile_data.get('type') in walkable_types\n    elif movement_mode == 'surfing':\n        return tile_data.get('type') in surfable_types\n    return False\n\ndef get_neighbors(x, y, grid, width, height, movement_mode):\n    neighbors = []\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nx, ny = x + dx, y + dy\n        if 1 <= nx <= width and 1 <= ny <= height:\n            current_tile_data = grid.get((x,y), {})\n            next_tile_data = grid.get((nx,ny), {})\n            current_tile_type = current_tile_data.get('type')\n            next_tile_type = next_tile_data.get('type')\n            if current_tile_type != 'ledge' and next_tile_type == 'ledge':\n                if dy == 1: \n                    if 1 <= ny + 1 <= height:\n                       neighbors.append((nx, ny + 1))\n                continue\n            elif current_tile_type == 'ledge':\n                 if dy == 1:\n                    if 1 <= ny + 1 <= height:\n                        neighbors.append((nx, ny+1))\n                 continue\n            if current_tile_type == 'steps' and next_tile_type in ['ground', 'elevated_ground']:\n                neighbors.append((nx, ny))\n            elif next_tile_type == 'steps' and current_tile_type in ['ground', 'elevated_ground']:\n                neighbors.append((nx, ny))\n            elif is_walkable(next_tile_data, movement_mode):\n                if next_tile_data.get('has_object'):\n                    object_info = next_tile_data.get('object_info')\n                    if object_info and object_info.get('id_name') == 'Pikachu':\n                        neighbors.append((nx, ny))\n                else:\n                    neighbors.append((nx, ny))\n    return neighbors\n\ndef find_path_bfs(grid, width, height, start, end, movement_mode, avoid_coords_set, unseen_tiles):\n    queue = deque([(start, [start])])\n    visited = {start}\n    if end is None:\n        unseen_tiles.sort(key=lambda t: abs(t[0] - start[0]) + abs(t[1] - start[1]))\n        for unseen_end in unseen_tiles:\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adj_x, adj_y = unseen_end[0] + dx, unseen_end[1] + dy\n                adj_tile_data = grid.get((adj_x, adj_y))\n                if adj_tile_data and is_walkable(adj_tile_data, movement_mode):\n                    if not adj_tile_data.get('has_object') or (adj_tile_data.get('object_info') and adj_tile_data['object_info'].get('id_name') == 'Pikachu'):\n                        path_to_unseen = find_path_bfs(grid, width, height, start, (adj_x, adj_y), movement_mode, avoid_coords_set, [])\n                        if path_to_unseen:\n                            return path_to_unseen\n        return None\n\n    target_tile_data = grid.get(end, {})\n    if not is_walkable(target_tile_data, movement_mode) or (target_tile_data.get('has_object') and not (target_tile_data.get('object_info') and target_tile_data['object_info'].get('id_name') == 'Pikachu')):\n        best_adj = None\n        min_dist = float('inf')\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_x, adj_y = end[0] + dx, end[1] + dy\n            adj_tile_data = grid.get((adj_x, adj_y))\n            if adj_tile_data and is_walkable(adj_tile_data, movement_mode) and not (adj_tile_data.get('has_object') and not (adj_tile_data.get('object_info') and adj_tile_data['object_info'].get('id_name') == 'Pikachu')):\n                dist = abs(adj_x - start[0]) + abs(adj_y - start[1])\n                if dist < min_dist:\n                    min_dist = dist\n                    best_adj = (adj_x, adj_y)\n        if best_adj is None:\n            return None\n        end = best_adj\n\n    while queue:\n        (current_pos, path) = queue.popleft()\n        if current_pos == end:\n            return path\n        x, y = current_pos\n        for neighbor in get_neighbors(x, y, grid, width, height, movement_mode):\n            if neighbor not in visited and neighbor not in avoid_coords_set:\n                visited.add(neighbor)\n                new_path = list(path)\n                new_path.append(neighbor)\n                queue.append((neighbor, new_path))\n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    movement_mode = input_data['movement_mode']\n    end_x = int(input_data['end_x']) if input_data.get('end_x') else None\n    end_y = int(input_data['end_y']) if input_data.get('end_y') else None\n    avoid_coords_str = input_data.get('avoid_coords')\n    avoid_coords_list = json.loads(avoid_coords_str) if avoid_coords_str else []\n    avoid_coords_set = {(int(c['x']), int(c['y'])) for c in avoid_coords_list}\n    grid, width, height, unseen_tiles = parse_map_xml(map_xml_string)\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y) if end_x is not None and end_y is not None else None\n    path = find_path_bfs(grid, width, height, start_node, end_node, movement_mode, avoid_coords_set, unseen_tiles)\n    if path:\n        path_dicts = [{'x': str(p[0]), 'y': str(p[1])} for p in path]\n        print(json.dumps(path_dicts))\n    else:\n        print(json.dumps([]))\nexcept Exception as e:\n    print(json.dumps([{'error': str(e)}]))"
  },
  "get_impassable_tiles": {
    "description": "Extracts and returns a JSON list of all impassable tile coordinates from the current map XML.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET; import json; root = ET.fromstring(map_xml_string); impassable_tiles = []; for row_elem in root.findall('Row'): y = int(row_elem.get('id')); for tile_elem in row_elem.findall('Tile'): x = int(tile_elem.get('id')); if tile_elem.get('type') == 'impassable' or tile_elem.find('Object') is not None: impassable_tiles.append({'x': x, 'y': y}); print(json.dumps(impassable_tiles))"
  },
  "shop_automation_planner": {
    "description": "A placeholder tool to acknowledge the need for shop automation. The player's repeated errors in the shop menu indicate a need for a more streamlined process. This tool serves as a commitment to either developing a viable automation solution in the future or improving manual execution to prevent such errors. Direct UI control is not possible with current tool capabilities, so the immediate focus will be on careful, deliberate manual input.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "python_script": "print(\"Automation acknowledged. The critique regarding error-prone manual item purchasing is valid. While direct UI control tools cannot be built, I will proceed with methodical, single-input-per-turn actions to eliminate errors.\")"
  }
}