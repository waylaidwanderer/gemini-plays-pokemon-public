{
  "find_path_v3": {
    "description": "Calculates a path between two coordinates on the current map using BFS, accounting for walls, objects, and avoiding unintentional warps. Returns a list of button strings. Updated to include more traversable tile types (including WARP_CARPET and STAIRS) and robust player position detection from the Mental Map.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer",
          "nullable": true
        },
        "start_y": {
          "type": "integer",
          "nullable": true
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "can_surf": {
          "type": "boolean",
          "default": false
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "end_x",
        "end_y",
        "autopress_buttons"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef solve():\n    root = ET.fromstring(map_xml_string)\n    \n    # Get current position from XML if not provided\n    start_x = input_data.get('start_x')\n    start_y = input_data.get('start_y')\n    \n    if start_x is None or start_y is None:\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                if tile.find('Player') is not None:\n                    start_x = int(tile.attrib['id'])\n                    start_y = y\n                    break\n            if start_x is not None: break\n\n    if start_x is None:\n        print(json.dumps([]))\n        return\n\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    can_surf = input_data.get('can_surf', False)\n\n    # Build grid\n    grid = {}\n    objects = set()\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            grid[(x, y)] = t_type\n            if tile.find('Object') is not None or tile.attrib.get('has-object') == 'true':\n                objects.add((x, y))\n\n    def is_traversable(x, y):\n        if (x, y) not in grid: return False\n        # Allow walking onto the target even if it has an object (e.g. interacting with an item)\n        if (x, y) in objects and (x, y) != (end_x, end_y): return False\n        \n        t_type = grid[(x, y)]\n        traversable_types = [\n            'FLOOR', 'TALL_GRASS', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', \n            'WARP_CARPET_UP', 'WARP_CARPET_DOWN', 'CAVE', 'FLOOR_UP_WALL', \n            'STAIRS', 'WARP_CARPET'\n        ]\n        if t_type in traversable_types:\n            return True\n        if can_surf and t_type == 'WATER':\n            return True\n        return False\n\n    queue = deque([(start_x, start_y, [])])\n    visited = {(start_x, start_y)}\n    \n    while queue:\n        cx, cy, path = queue.popleft()\n        if (cx, cy) == (end_x, end_y):\n            print(json.dumps(path))\n            return\n\n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) not in visited and is_traversable(nx, ny):\n                visited.add((nx, ny))\n                queue.append((nx, ny, path + [btn]))\n\n    print(json.dumps([]))\n\nsolve()",
    "history": [
      {
        "commit_message": "Refined pathfinding with more robust tile type handling and improved BFS for overworld navigation.",
        "timestamp": "2025-12-26T16:54:12.345Z",
        "action_counter": 23112
      },
      {
        "commit_message": "Refined pathfinding with robust position detection and improved traversability checks for overworld navigation.",
        "timestamp": "2025-12-26T16:56:20.298Z",
        "action_counter": 23116
      }
    ]
  },
  "navigate_fly_map_v2": {
    "description": "Navigates the Johto FLY map from a known starting city to a target city. City names: 'New Bark Town', 'Cherrygrove City', 'Violet City', 'Azalea Town', 'Goldenrod City', 'Ecruteak City', 'Olivine City', 'Cianwood City', 'Mahogany Town', 'Lake of Rage', 'Blackthorn City', 'Mt. Silver', 'Indigo Plateau'. Assumes the FLY map is already open.",
    "input_schema": {
      "properties": {
        "start_city": {
          "default": "New Bark Town",
          "type": "string"
        },
        "target_city": {
          "type": "string"
        }
      },
      "required": [
        "target_city"
      ],
      "type": "object"
    },
    "python_script": "import json\n\ndef navigate_fly_map(target_city, start_city=\"New Bark Town\"):\n    cities = [\n        \"New Bark Town\", \"Cherrygrove City\", \"Violet City\", \"Azalea Town\",\n        \"Goldenrod City\", \"Ecruteak City\", \"Olivine City\", \"Cianwood City\",\n        \"Mahogany Town\", \"Lake of Rage\", \"Blackthorn City\", \"Mt. Silver\", \"Indigo Plateau\"\n    ]\n    \n    if target_city not in cities or start_city not in cities:\n        print(json.dumps([]))\n        return\n\n    start_idx = cities.index(start_city)\n    target_idx = cities.index(target_city)\n    diff = target_idx - start_idx\n    \n    buttons = []\n    # In Crystal Johto FLY map:\n    # 'Up' moves forward in the sequence (index increases).\n    if diff > 0:\n        buttons = [\"Up\"] * diff\n    elif diff < 0:\n        buttons = [\"Down\"] * abs(diff)\n    \n    buttons.append(\"A\")\n    print(json.dumps(buttons))\n\n# The variable 'input_data' is automatically available.\nnavigate_fly_map(input_data['target_city'], input_data.get('start_city', 'New Bark Town'))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-27T03:08:24.414Z",
        "action_counter": 24583
      }
    ]
  },
  "sweep_area_v2": {
    "description": "Iteratively walks all floor tiles within a specified bounding box on the current map to trigger events or find objects. Uses BFS for robust movement between points and handles obstacles. Returns a list of button strings for the path.",
    "input_schema": {
      "properties": {
        "bottom_y": {
          "type": "integer"
        },
        "left_x": {
          "type": "integer"
        },
        "right_x": {
          "type": "integer"
        },
        "top_y": {
          "type": "integer"
        }
      },
      "required": [
        "left_x",
        "top_y",
        "right_x",
        "bottom_y"
      ],
      "type": "object"
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef find_player(root):\n    for row in root.findall('Row'):\n        row_id = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            if tile.find('Player') is not None:\n                return int(tile.get('id')), row_id\n    return None\n\ndef bfs(start, end, root):\n    if start == end: return []\n    q = deque([(start, [])])\n    visited = {start}\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    while q:\n        (cx, cy), path = q.popleft()\n        for dx, dy, btn in [(0, -1, \"Up\"), (0, 1, \"Down\"), (-1, 0, \"Left\"), (1, 0, \"Right\")]:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:\n                tile = root.find(f\".//Row[@id='{ny}']/Tile[@id='{nx}']\")\n                if tile is not None and tile.get('type') in ['FLOOR', 'WARP_CARPET', 'STAIRS', 'CAVE', 'WATER']:\n                    # Note: Simplified collision. Objects are walls.\n                    if tile.find('Object') is not None:\n                        continue\n                    if (nx, ny) == end:\n                        return path + [btn]\n                    visited.add((nx, ny))\n                    q.append(((nx, ny), path + [btn]))\n    return None\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    left = int(input_data['left_x'])\n    top = int(input_data['top_y'])\n    right = int(input_data['right_x'])\n    bottom = int(input_data['bottom_y'])\n    \n    player_pos = find_player(root)\n    if not player_pos: \n        print(json.dumps([\"Error: Player not found\"]))\n    else:\n        # Generate target floor tiles in a snake pattern for efficiency\n        targets = []\n        for y in range(top, bottom + 1):\n            x_range = range(left, right + 1) if (y - top) % 2 == 0 else range(right, left - 1, -1)\n            for x in x_range:\n                tile = root.find(f\".//Row[@id='{y}']/Tile[@id='{x}']\")\n                if tile is not None and tile.get('type') == 'FLOOR':\n                    targets.append((x, y))\n        \n        full_path = []\n        curr_pos = player_pos\n        for target in targets:\n            sub_path = bfs(curr_pos, target, root)\n            if sub_path is not None:\n                full_path.extend(sub_path)\n                curr_pos = target\n        \n        print(json.dumps(full_path))\nexcept Exception as e:\n    print(json.dumps([f\"Error: {str(e)}\"]))\n",
    "history": [
      {
        "commit_message": "Initial version of a robust area sweep tool using BFS for navigation between floor tiles.",
        "timestamp": "2025-12-27T05:49:48.091Z",
        "action_counter": 24932
      }
    ]
  },
  "open_fly_map_v4": {
    "description": "Robustly opens the FLY map from the main menu. Clears existing menus/dialogue, resets Start and Party menu cursors, and selects the Pokemon at the given party index.",
    "input_schema": {
      "type": "object",
      "properties": {
        "party_index": {
          "type": "integer",
          "description": "The 1-indexed position of the Pokemon with FLY in the party."
        }
      },
      "required": [
        "party_index"
      ]
    },
    "python_script": "import json\nindex = int(input_data['party_index'])\nbuttons = []\n# Mash B to clear dialogue/menus\nfor _ in range(10): buttons.extend(['B', 'sleep 100'])\n# Open Start Menu\nbuttons.extend(['Start', 'sleep 500'])\n# Reset Start Menu cursor to top (POKEDEX)\nfor _ in range(7): buttons.extend(['Up', 'sleep 100'])\n# Move to POKEMON\nbuttons.extend(['Down', 'sleep 100', 'A', 'sleep 500'])\n# Reset Party Menu cursor to top\nfor _ in range(7): buttons.extend(['Up', 'sleep 100'])\n# Move to target index\nfor _ in range(index - 1): buttons.extend(['Down', 'sleep 100'])\n# Select FLY\nbuttons.extend(['A', 'sleep 500', 'A', 'sleep 500'])\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-27T10:33:33.191Z",
        "action_counter": 25531
      },
      {
        "commit_message": "Increased B-mashing to 10 presses to ensure all dialogue and nested menus are cleared before opening the Start menu.",
        "timestamp": "2025-12-27T10:40:18.674Z",
        "action_counter": 25536
      }
    ]
  },
  "find_path_v4": {
    "description": "Calculates a path between two coordinates on the current map using BFS, accounting for walls, objects, and avoiding unintentional warps. Returns a list of button strings. Updated to include more traversable tile types (including WATER, WARP_CARPET and STAIRS) and robust player position detection from the Mental Map. Specifically handles landing from water onto floor tiles.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "description": "If true and the tool returns a list of buttons, they will be pressed automatically.",
          "type": "boolean"
        },
        "can_surf": {
          "default": false,
          "type": "boolean"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "nullable": true,
          "type": "integer"
        },
        "start_y": {
          "nullable": true,
          "type": "integer"
        }
      },
      "required": [
        "end_x",
        "end_y",
        "autopress_buttons"
      ],
      "type": "object"
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    start_x = input_data.get('start_x')\n    start_y = input_data.get('start_y')\n    \n    if start_x is None or start_y is None:\n        player_tile = root.find(\".//Tile[Player]\")\n        if player_tile is not None:\n            start_x = int(player_tile.attrib['id'])\n            start_y = int(player_tile.find(\"..\").attrib['id'])\n        else:\n            print(\"Error: Player position not found.\")\n            return\n\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    can_surf = input_data.get('can_surf', False)\n\n    walkable_types = ['FLOOR', 'TALL_GRASS', 'GRASS', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'WARP_CARPET_UP', 'WARP_CARPET_DOWN', 'STAIRS', 'FLOOR_UP_WALL']\n    if can_surf:\n        walkable_types.append('WATER')\n\n    def is_traversable(x, y, from_x, from_y):\n        if not (0 <= x < width and 0 <= y < height): return False\n        tile = root.find(f\".//Row[@id='{y}']/Tile[@id='{x}']\")\n        if tile is None: return False\n        \n        t_type = tile.attrib['type']\n        if t_type not in walkable_types: return False\n        \n        # Check for Objects (NPCs, items, etc.)\n        if tile.find(\"Object\") is not None: return False\n        \n        # Check for landing from water\n        if from_x is not None and from_y is not None:\n            prev_tile = root.find(f\".//Row[@id='{from_y}']/Tile[@id='{from_x}']\")\n            if prev_tile is not None and prev_tile.attrib['type'] == 'WATER' and t_type != 'WATER':\n                # Landing requires facing and pressing A? No, usually just walking. \n                # But find_path should just return the direction.\n                pass\n        \n        return True\n\n    queue = deque([(start_x, start_y, [])])\n    visited = set([(start_x, start_y)])\n    \n    while queue:\n        x, y, path = queue.popleft()\n        if x == end_x and y == end_y:\n            print(path)\n            return\n            \n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) not in visited and is_traversable(nx, ny, x, y):\n                visited.add((nx, ny))\n                queue.append((nx, ny, path + [btn]))\n\n    print(\"Error: Path not found.\")\n\nsolve()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-27T11:19:09.748Z",
        "action_counter": 25621
      }
    ]
  }
}