{
  "find_path": {
    "description": "Finds a path from the player's current position to a target coordinate on the current map using BFS. Returns a list of coordinate dictionaries, or a list of button strings if autopress_buttons is true. If the target is impassable, it finds a path to an adjacent traversable tile.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "description": "If true and the tool returns a list of buttons, they will be pressed automatically.",
          "type": "boolean"
        },
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y",
        "autopress_buttons"
      ],
      "type": "object"
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport collections\nimport json\n\ndef solve():\n    try:\n        if not map_xml_string:\n            print(\"Error: map_xml_string is empty.\")\n            return\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        print(f\"Error parsing XML: {e}\")\n        return\n\n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n        autopress = input_data.get('autopress_buttons', False)\n    except (KeyError, ValueError) as e:\n        print(f\"Error in input data: {e}\")\n        return\n    \n    # Map out the grid and find the player\n    tiles = {}\n    start_x, start_y = None, None\n    for row in root.findall('Row'):\n        row_id_attr = row.attrib.get('id')\n        if row_id_attr is None: continue\n        y = int(row_id_attr)\n        for tile in row.findall('Tile'):\n            tile_id_attr = tile.attrib.get('id')\n            if tile_id_attr is None: continue\n            x = int(tile_id_attr)\n            tiles[(x, y)] = tile\n            if tile.find('Player') is not None:\n                start_x, start_y = x, y\n    \n    if start_x is None:\n        print(\"Error: Player position not found in XML.\")\n        return\n    \n    # BFS to find the path\n    queue = collections.deque([(start_x, start_y, [{\"x\": start_x, \"y\": start_y}])])\n    visited = set([(start_x, start_y)])\n    reachable = {}\n    \n    impassable_types = [\"WALL\", \"HEADBUTT_TREE\", \"WATER\", \"BOOKSHELF\", \"WINDOW\", \"TRASHCAN\", \"PC\", \"BOOKSHELVES\", \"unseen\", \"VOID\"]\n    \n    while queue:\n        x, y, path = queue.popleft()\n        reachable[(x, y)] = path\n        if x == target_x and y == target_y:\n            break\n            \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) in visited: continue\n            \n            tile = tiles.get((nx, ny))\n            if tile is None: continue\n            \n            tile_type = tile.attrib.get('type', 'unseen')\n            # Check if tile is impassable\n            if tile_type in impassable_types or \"LEDGE\" in tile_type or tile.attrib.get('has-object') == 'true':\n                continue\n                \n            visited.add((nx, ny))\n            queue.append((nx, ny, path + [{\"x\": nx, \"y\": ny}]))\n            \n    final_path = reachable.get((target_x, target_y))\n    \n    # If target is unreachable, find the closest reachable tile\n    if final_path is None:\n        best_dist = float('inf')\n        for (rx, ry), rpath in reachable.items():\n            dist = abs(rx - target_x) + abs(ry - target_y)\n            if dist < best_dist:\n                best_dist = dist\n                final_path = rpath\n                \n    if final_path is None:\n        print(\"Error: No reachable tiles found.\")\n        return\n\n    if autopress:\n        buttons = []\n        for i in range(len(final_path) - 1):\n            curr = final_path[i]\n            next_t = final_path[i+1]\n            if next_t['x'] > curr['x']: buttons.append(\"Right\")\n            elif next_t['x'] < curr['x']: buttons.append(\"Left\")\n            elif next_t['y'] > curr['y']: buttons.append(\"Down\")\n            elif next_t['y'] < curr['y']: buttons.append(\"Up\")\n        print(json.dumps(buttons))\n    else:\n        print(json.dumps(final_path))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-17T22:12:33.740Z",
        "action_counter": 34
      },
      {
        "commit_message": "Refined find_path to handle impassable targets by finding a path to an adjacent tile, and improved collision detection.",
        "timestamp": "2025-12-17T22:15:22.920Z",
        "action_counter": 41
      },
      {
        "commit_message": "Refined find_path to correctly handle impassable targets and improved error reporting.",
        "timestamp": "2025-12-17T22:54:25.130Z",
        "action_counter": 116
      },
      {
        "commit_message": "Updated find_path to support autopress_buttons by returning a JSON array of button strings.",
        "timestamp": "2025-12-17T22:56:11.542Z",
        "action_counter": 121
      },
      {
        "commit_message": "Fixing script to use injected input_data and handle impassable targets by searching for the nearest reachable tile.",
        "timestamp": "2025-12-17T23:01:40.135Z",
        "action_counter": 132
      },
      {
        "commit_message": "Refining find_path to avoid using the '..' selector, which may not be supported, and improving overall robustness.",
        "timestamp": "2025-12-17T23:03:24.005Z",
        "action_counter": 134
      },
      {
        "commit_message": "Further refining find_path for robustness and better error handling. Added more debug prints.",
        "timestamp": "2025-12-17T23:07:19.867Z",
        "action_counter": 143
      }
    ]
  }
}