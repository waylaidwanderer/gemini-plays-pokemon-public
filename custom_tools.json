{
  "marker_compliance_tool": {
    "description": "Parses map markers and checks for compliance with protocols defined in the notepad. Identifies markers with non-standard emojis or incorrect label formats.",
    "input_schema": {
      "type": "object",
      "properties": {
        "notepad_contents": {
          "type": "string"
        }
      },
      "required": [
        "notepad_contents"
      ]
    },
    "python_script": "import json\nimport re\n\ndef check_marker_compliance():\n    notepad_content = input_data['notepad_contents']\n    \n    protocol_emojis = []\n    teleporter_format_regex_str = ''\n\n    try:\n        protocol_line = \"\"\n        for line in notepad_content.splitlines():\n            if \"CRITICAL: Map Marker Protocol\" in line:\n                protocol_line = line\n                break\n        \n        if not protocol_line:\n            print(json.dumps({'error': 'Map Marker Protocol line not found in notepad.'}))\n            return\n\n        teleporter_format_regex_str = r\"ðŸšª Warp to/from \\(\\d+, \\d+\\) \\[(?:Bi-directional|One-way)\\]\"\n        teleporter_format_regex = re.compile(teleporter_format_regex_str)\n        protocol_emojis = re.findall(r\"'([^']*)'\", protocol_line)\n\n    except Exception as e:\n        print(json.dumps({'error': f'Failed to parse protocols from notepad: {e}'}))\n        return\n\n    non_compliant_markers = []\n    try:\n        tiles = map_xml_string.split('</Tile>')\n        for tile_str in tiles:\n            if '<Marker' in tile_str:\n                try:\n                    coord_match = re.search(r'coordinate=\"\\((\\d+), (\\d+)\\)\"', tile_str)\n                    if not coord_match: continue\n                    x, y = int(coord_match.group(1)), int(coord_match.group(2))\n                except (ValueError, IndexError):\n                    continue\n\n                marker_parts = tile_str.split('<Marker emoji=\"')\n                for part in marker_parts[1:]:\n                    try:\n                        emoji = part.split('\"')[0]\n                        label = part.split('>')[1].split('</Marker>')[0]\n                        \n                        is_compliant = False\n                        if emoji in protocol_emojis:\n                            if emoji == 'ðŸšª':\n                                if teleporter_format_regex.fullmatch(f\"{emoji} {label}\"):\n                                    is_compliant = True\n                            else:\n                                is_compliant = True\n                        \n                        if not is_compliant:\n                            non_compliant_markers.append({\n                                \"x\": x,\n                                \"y\": y,\n                                \"emoji\": emoji,\n                                \"label\": label,\n                                \"reason\": f\"Emoji '{emoji}' not in protocol or label format for 'ðŸšª' is incorrect.\"\n                            })\n                    except IndexError:\n                        continue\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': f'Error during XML parsing: {str(e)}', 'traceback': traceback.format_exc()}))\n        return\n        \n    print(json.dumps(non_compliant_markers))\n\ncheck_marker_compliance()"
  },
  "systematic_searcher": {
    "description": "Calculates the next reachable, untested tile to check in a systematic sweep. It parses the map XML to find all walkable tiles and uses BFS to find the nearest target.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "tested_coords_json": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "tested_coords_json"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef parse_map(xml_str):\n    walkable = set()\n    impassable = set()\n    root = ET.fromstring(xml_str)\n    for row in root.findall('Row'):\n        for tile in row.findall('Tile'):\n            coord_str = tile.get('coordinate')\n            x_str, y_str = coord_str.strip('()').split(',')\n            x, y = int(x_str), int(y_str)\n            tile_type = tile.get('type')\n            has_obj = tile.find('Object') is not None and tile.find('Object').get('id-name') != 'Pikachu'\n            if tile_type in ['impassable', 'unknown', 'closed_gate'] or has_obj:\n                impassable.add((x, y))\n            else:\n                walkable.add((x, y))\n    return walkable, impassable\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\ntested_coords = set(tuple(c) for c in json.loads(input_data['tested_coords_json']))\n\nwalkable, impassable = parse_map(map_xml_string)\n\nqueue = deque([((start_x, start_y), [])])\nvisited = set([(start_x, start_y)])\n\nwhile queue:\n    (x, y), path = queue.popleft()\n\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n        adj_x, adj_y = x + dx, y + dy\n        if (adj_x, adj_y) in impassable and (adj_x, adj_y) not in tested_coords:\n            print(json.dumps({'target_x': x, 'target_y': y, 'wall_x': adj_x, 'wall_y': adj_y}))\n            exit()\n\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n        next_x, next_y = x + dx, y + dy\n        if (next_x, next_y) in walkable and (next_x, next_y) not in visited:\n            visited.add((next_x, next_y))\n            new_path = list(path)\n            new_path.append((next_x, next_y))\n            queue.append(((next_x, next_y), new_path))\n\nprint(json.dumps({'error': 'No new adjacent walls to test.'}))"
  },
  "find_next_exploration_target": {
    "description": "Analyzes unseen tiles and reachable barriers to suggest the most logical next exploration target. Prioritizes the closest unseen tile. If none exist, it finds the closest reachable barrier based on Manhattan distance from the player's current coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "unseen_tiles_json": {
          "type": "string"
        },
        "reachable_barriers_json": {
          "type": "string"
        },
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "unseen_tiles_json",
        "reachable_barriers_json",
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import json\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nunseen_tiles = json.loads(input_data['unseen_tiles_json'])\nreachable_barriers = json.loads(input_data['reachable_barriers_json'])\n\nstart_pos = (start_x, start_y)\nnext_target = None\nmin_dist = float('inf')\nreasoning = ''\n\nif unseen_tiles:\n    for tile in unseen_tiles:\n        dist = heuristic(start_pos, (tile['x'], tile['y']))\n        if dist < min_dist:\n            min_dist = dist\n            next_target = tile\n    if next_target:\n        reasoning = f'The closest unseen tile is at ({next_target[\"x\"]}, {next_target[\"y\"]}) with a distance of {min_dist}.'\n    else:\n        reasoning = 'No unseen tiles found.'\nelif reachable_barriers:\n    for barrier in reachable_barriers:\n        dist = heuristic(start_pos, (barrier['x'], barrier['y']))\n        if dist < min_dist:\n            min_dist = dist\n            next_target = barrier\n    if next_target:\n        reasoning = f'No unseen tiles. The closest reachable barrier is at ({next_target[\"x\"]}, {next_target[\"y\"]}) with a distance of {min_dist}.'\n    else:\n        reasoning = 'No reachable barriers found.'\nelse:\n    reasoning = 'No unseen tiles or reachable barriers to suggest.'\n\nif next_target:\n    print(json.dumps({'next_target_x': next_target['x'], 'next_target_y': next_target['y'], 'reasoning': reasoning}))\nelse:\n    print(json.dumps({'next_target_x': None, 'next_target_y': None, 'reasoning': reasoning}))"
  },
  "gate_navigator": {
    "description": "Calculates the shortest path to an adjacent, walkable tile of a specified gate. Useful for navigating to gates that are visually open but still marked as 'closed_gate' in the map data.",
    "input_schema": {
      "type": "object",
      "properties": {
        "gate_x": {
          "type": "string"
        },
        "gate_y": {
          "type": "string"
        }
      },
      "required": [
        "gate_x",
        "gate_y"
      ]
    },
    "python_script": "import heapq\nimport json\nimport xml.etree.ElementTree as ET\n\ndef parse_map_for_nav(xml_str):\n    grid = {}\n    player_pos = None\n    try:\n        root = ET.fromstring(xml_str)\n        for row in root.findall('Row'):\n            for tile in row.findall('Tile'):\n                coord_str = tile.get('coordinate')\n                x_str, y_str = coord_str.strip('()').split(',')\n                x, y = int(x_str), int(y_str)\n                tile_type = tile.get('type')\n                if tile.find('Player') is not None:\n                    player_pos = (x, y)\n                obj_element = tile.find('Object')\n                is_pikachu = False\n                if obj_element is not None and obj_element.get('id-name') == 'Pikachu':\n                    is_pikachu = True\n                has_object = obj_element is not None\n                impassable_types = ['impassable', 'unknown', 'closed_gate', 'water']\n                is_impassable = tile_type in impassable_types or (has_object and not is_pikachu)\n                grid[(x, y)] = {'type': tile_type, 'impassable': is_impassable}\n    except Exception as e:\n        return None, None, f'XML Parse Error: {e}'\n    return grid, player_pos, None\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(grid, start, end):\n    open_set = [(0, start)]\n    came_from = {}\n    g_score = {pos: float('inf') for pos in grid}\n    g_score[start] = 0\n    f_score = {pos: float('inf') for pos in grid}\n    f_score[start] = heuristic(start, end)\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n        if current == end:\n            path = [current]\n            while current in came_from:\n                current = came_from[current]\n                path.append(current)\n            return path[::-1], 'Path found.'\n        \n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if neighbor in grid and not grid[neighbor]['impassable']:\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, end)\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    return None, 'No path found.'\n\ntry:\n    gate_x = int(input_data['gate_x'])\n    gate_y = int(input_data['gate_y'])\n    gate_pos = (gate_x, gate_y)\n\n    game_map, start_pos, error_msg = parse_map_for_nav(map_xml_string)\n\n    if error_msg:\n        print(json.dumps({'error': error_msg}))\n    elif not start_pos:\n        print(json.dumps({'error': 'Player start position not found in map data.'}))\n    else:\n        walkable_neighbors = []\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            neighbor = (gate_pos[0] + dx, gate_pos[1] + dy)\n            if neighbor in game_map and not game_map[neighbor]['impassable']:\n                walkable_neighbors.append(neighbor)\n        \n        if not walkable_neighbors:\n            print(json.dumps({'error': f'Gate at {gate_pos} has no walkable neighbors.'}))\n        else:\n            target_pos = min(walkable_neighbors, key=lambda pos: heuristic(start_pos, pos))\n            path_coords, msg = a_star_search(game_map, start_pos, target_pos)\n            if path_coords:\n                print(json.dumps([{'x': x, 'y': y} for x, y in path_coords]))\n            else:\n                print(json.dumps({'error': msg}))\nexcept Exception as e:\n    print(json.dumps({'error': f'An unexpected error occurred: {e}'}))"
  },
  "find_path": {
    "description": "Calculates the shortest path between two points on the current map using BFS, avoiding impassable tiles and objects. Returns a sequence of coordinates for the path_plan.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef find_path_tool():\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    grid = [['' for _ in range(width)] for _ in range(height)]\n    walkable_types = ['ground', 'grass', 'open_gate', 'cleared_boulder_barrier', 'boulder_switch', 'teleport', 'hole', 'spinner_stop', 'ladder_up', 'ladder_down', 'steps']\n    impassable_coords = set()\n\n    for r_idx, row_elem in enumerate(root.findall('Row')):\n        y = int(row_elem.get('id')) - 1\n        for c_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n            x = int(tile_elem.get('id')) - 1\n            tile_type = tile_elem.get('type')\n            grid[y][x] = tile_type\n            obj = tile_elem.find('Object')\n            if obj is not None and obj.get('id-name') != 'Pikachu':\n                impassable_coords.add((x, y))\n\n    start_x = int(input_data['start_x']) - 1\n    start_y = int(input_data['start_y']) - 1\n    end_x = int(input_data['end_x']) - 1\n    end_y = int(input_data['end_y']) - 1\n\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n\n    queue = deque([(start_node, [start_node])])\n    visited = {start_node}\n\n    while queue:\n        (current_x, current_y), path = queue.popleft()\n\n        if (current_x, current_y) == end_node:\n            # Convert path from 0-indexed to 1-indexed for the output\n            path_plan = [{'x': x + 1, 'y': y + 1} for x, y in path]\n            print(json.dumps(path_plan))\n            return\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = current_x + dx, current_y + dy\n            \n            if grid[current_y][current_x] == 'ledge' and dy == 1:\n                next_y = current_y + 2\n\n            if 0 <= next_x < width and 0 <= next_y < height:\n                neighbor = (next_x, next_y)\n                if neighbor not in visited:\n                    tile_type = grid[next_y][next_x]\n                    is_walkable = tile_type in walkable_types or (tile_type == 'ledge' and next_y > current_y)\n                    is_object_blocked = neighbor in impassable_coords\n                    if is_walkable and not is_object_blocked:\n                        visited.add(neighbor)\n                        new_path = path + [neighbor]\n                        queue.append((neighbor, new_path))\n\n    print(json.dumps([])) # Return empty list if no path is found\n\nfind_path_tool()"
  }
}