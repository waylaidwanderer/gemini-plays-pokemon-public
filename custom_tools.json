{
  "sequence_press": {
    "description": "Executes a sequence of button presses to navigate menus or perform actions. Allows mixing directional and action buttons.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\ntry:\n    buttons = input_data['buttons']\n    print(json.dumps(buttons))\nexcept KeyError:\n    print(\"Error: 'buttons' key not found in input_data\")\n    print(f\"input_data keys: {input_data.keys()}\")",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T08:10:06.907Z",
        "action_counter": 33328
      },
      {
        "commit_message": "Initial definition of sequence_press tool",
        "timestamp": "2026-01-11T10:39:20.952Z",
        "action_counter": 33514
      },
      {
        "commit_message": "Debugging tool to find variable injection method",
        "timestamp": "2026-01-11T10:41:14.927Z",
        "action_counter": 33517
      },
      {
        "commit_message": "Fix variable access by using input_data dictionary",
        "timestamp": "2026-01-11T10:43:22.032Z",
        "action_counter": 33520
      }
    ]
  },
  "pathfind": {
    "description": "Finds a path from the player's current position to a target coordinate using BFS. Returns a list of buttons.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "target_x",
        "target_y",
        "autopress_buttons"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\n# Access arguments from global input_data\ntry:\n    target_x = input_data['target_x']\n    target_y = input_data['target_y']\nexcept NameError:\n    target_x = 0\n    target_y = 0\n\ndef get_player_position(root):\n    for row in root.findall('.//Row'):\n        for tile in row.findall('.//Tile'):\n            if tile.find('Player') is not None:\n                coord = tile.get('coordinate')\n                x, y = map(int, coord.strip('()').split(','))\n                return x, y\n    return None\n\ndef is_walkable(tile):\n    if tile is None: return False\n    if tile.get('seen') == 'false': return False\n    \n    tile_type = tile.get('type')\n    allowed_types = ['FLOOR', 'WARP_CARPET_DOWN', 'WARP_CARPET_UP', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'LADDER', 'DOOR']\n    if tile_type not in allowed_types:\n        return False\n        \n    if tile.find('Object') is not None:\n        return False\n        \n    return True\n\ndef solve_path(target_x, target_y):\n    try:\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        print(json.dumps([]))\n        return\n\n    start_pos = get_player_position(root)\n    if not start_pos:\n        print(json.dumps([]))\n        return\n\n    start_x, start_y = start_pos\n    \n    tiles = {}\n    for row in root.findall('.//Row'):\n        for tile in row.findall('.//Tile'):\n            coord = tile.get('coordinate')\n            x, y = map(int, coord.strip('()').split(','))\n            tiles[(x, y)] = tile\n\n    queue = deque([(start_x, start_y, [])])\n    visited = set([(start_x, start_y)])\n    \n    while queue:\n        curr_x, curr_y, path = queue.popleft()\n        \n        if curr_x == target_x and curr_y == target_y:\n            print(json.dumps(path))\n            return\n            \n        moves = [\n            (0, -1, 'Up'),\n            (0, 1, 'Down'),\n            (-1, 0, 'Left'),\n            (1, 0, 'Right')\n        ]\n        \n        for dx, dy, btn in moves:\n            nx, ny = curr_x + dx, curr_y + dy\n            if (nx, ny) in visited:\n                continue\n                \n            if (nx, ny) in tiles and is_walkable(tiles[(nx, ny)]):\n                visited.add((nx, ny))\n                queue.append((nx, ny, path + [btn]))\n\n    print(json.dumps([]))\n\nsolve_path(target_x, target_y)",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T09:01:19.563Z",
        "action_counter": 33384
      },
      {
        "commit_message": "Fixed NameError by using globals().get() to safely retrieve injected arguments. Added autopress_buttons support.",
        "timestamp": "2026-01-11T16:48:12.265Z",
        "action_counter": 34015
      },
      {
        "commit_message": "Refined JSON output compliance using json.dumps to avoid parsing errors.",
        "timestamp": "2026-01-11T16:49:46.390Z",
        "action_counter": 34017
      },
      {
        "commit_message": "Added debug logic to inspect available variables if arguments are missing.",
        "timestamp": "2026-01-11T16:50:53.134Z",
        "action_counter": 34018
      },
      {
        "commit_message": "Updated to retrieve arguments from `input_data` global dictionary.",
        "timestamp": "2026-01-11T16:51:34.865Z",
        "action_counter": 34019
      },
      {
        "commit_message": "Fixed XML parsing logic to correctly iterate Rows and Tiles instead of using unsupported '..' XPath.",
        "timestamp": "2026-01-11T16:52:03.375Z",
        "action_counter": 34020
      },
      {
        "commit_message": "Added WARP_CARPET_* and DOOR types to traversable list.",
        "timestamp": "2026-01-11T17:10:57.545Z",
        "action_counter": 34044
      },
      {
        "commit_message": "Fixing pathfind tool to return valid JSON array on failure instead of an object, preventing schema validation errors.",
        "timestamp": "2026-01-12T04:10:40.878Z",
        "action_counter": 34986
      },
      {
        "commit_message": "Fixed 'pathfind' tool by explicitly accessing 'target_x' and 'target_y' from the 'input_data' dictionary, resolving the NameError.",
        "timestamp": "2026-01-12T04:13:03.377Z",
        "action_counter": 34988
      }
    ]
  },
  "zigzag_sweep": {
    "description": "Generates and executes a zigzag button sequence to sweep a rectangular area. Useful for hunting in grass patches.",
    "input_schema": {
      "type": "object",
      "properties": {
        "cols": {
          "type": "integer",
          "description": "Number of columns (width) of the area."
        },
        "rows": {
          "type": "integer",
          "description": "Number of rows (height) of the area."
        },
        "start_side": {
          "type": "string",
          "enum": [
            "left",
            "right"
          ],
          "default": "left",
          "description": "The side you are starting on. 'left' means Top-Left, 'right' means Top-Right."
        }
      },
      "required": [
        "cols",
        "rows"
      ]
    },
    "python_script": "import json\n\nbuttons = []\ncols = int(input_data['cols'])\nrows = int(input_data['rows'])\nstart_side = input_data.get('start_side', 'left')\n\nfor r in range(rows):\n    if start_side == 'left':\n        # Even rows (0, 2): Right\n        # Odd rows (1, 3): Left\n        direction = 'Right' if r % 2 == 0 else 'Left'\n    else:\n        # Even rows (0, 2): Left\n        # Odd rows (1, 3): Right\n        direction = 'Left' if r % 2 == 0 else 'Right'\n        \n    for _ in range(cols - 1):\n        buttons.append(direction)\n        \n    if r < rows - 1:\n        buttons.append('Down')\n\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T19:32:17.062Z",
        "action_counter": 34231
      }
    ]
  },
  "perform_roamer_shuffle": {
    "description": "Closes the open Pokegear Map, travels North to Ecruteak and immediately back South to Route 37 to update Roamer coordinates, then re-opens the Pokegear Map. Assumes the player is at Route 37 (8,0) and the Start Menu cursor is over the Pokegear.",
    "input_schema": {},
    "python_script": "print('[\"B\", \"sleep 500\", \"B\", \"sleep 500\", \"Up\", \"sleep 3000\", \"Down\", \"sleep 3000\", \"Start\", \"sleep 1000\", \"A\", \"sleep 1000\", \"Right\", \"sleep 500\", \"A\"]')",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-12T05:29:19.379Z",
        "action_counter": 35103
      }
    ]
  }
}