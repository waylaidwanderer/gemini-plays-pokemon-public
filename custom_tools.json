{
  "advanced_pathfinder": {
    "description": "An advanced pathfinder that ignores most tile types to find hidden passages, but respects truly impassable tiles, objects, and closed gates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\ngrid = [['' for _ in range(width)] for _ in range(height)]\nimpassable_coords = set()\n\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.get('id')) - 1\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.get('id')) - 1\n        grid[y][x] = tile_elem.get('type')\n        obj = tile_elem.find('Object')\n        if obj is not None and obj.get('id-name') != 'Pikachu':\n            impassable_coords.add((x, y))\n\nstart_x = int(input_data['start_x']) - 1\nstart_y = int(input_data['start_y']) - 1\nend_x = int(input_data['end_x']) - 1\nend_y = int(input_data['end_y']) - 1\n\nstart_node = (start_x, start_y)\nend_node = (end_x, end_y)\n\nqueue = deque([(start_node, [start_node])])\nvisited = {start_node}\n\npath_found = False\nwhile queue:\n    (current_x, current_y), path = queue.popleft()\n\n    if (current_x, current_y) == end_node:\n        path_plan = [{'x': x + 1, 'y': y + 1} for x, y in path]\n        print(json.dumps(path_plan))\n        path_found = True\n        break\n\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        next_x, next_y = current_x + dx, current_y + dy\n\n        if 0 <= next_x < width and 0 <= next_y < height:\n            neighbor = (next_x, next_y)\n            if neighbor not in visited:\n                tile_type = grid[next_y][next_x]\n                if tile_type not in ['impassable', 'closed_gate'] and neighbor not in impassable_coords:\n                    visited.add(neighbor)\n                    new_path = path + [neighbor]\n                    queue.append((neighbor, new_path))\n\nif not path_found:\n    print(json.dumps([]))"
  },
  "find_next_exploration_target": {
    "description": "Analyzes unseen tiles and reachable barriers to suggest the most logical next exploration target. Prioritizes the closest unseen tile. If none exist, it finds the closest reachable barrier based on Manhattan distance from the player's current coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "unseen_tiles_json": {
          "type": "string"
        },
        "reachable_barriers_json": {
          "type": "string"
        },
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "unseen_tiles_json",
        "reachable_barriers_json",
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import json\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nunseen_tiles = json.loads(input_data['unseen_tiles_json'])\nreachable_barriers = json.loads(input_data['reachable_barriers_json'])\n\nstart_pos = (start_x, start_y)\nnext_target = None\nmin_dist = float('inf')\nreasoning = ''\n\nif unseen_tiles:\n    for tile in unseen_tiles:\n        dist = heuristic(start_pos, (tile['x'], tile['y']))\n        if dist < min_dist:\n            min_dist = dist\n            next_target = tile\n    if next_target:\n        reasoning = f'The closest unseen tile is at ({next_target[\"x\"]}, {next_target[\"y\"]}) with a distance of {min_dist}.'\n    else:\n        reasoning = 'No unseen tiles found.'\nelif reachable_barriers:\n    for barrier in reachable_barriers:\n        dist = heuristic(start_pos, (barrier['x'], barrier['y']))\n        if dist < min_dist:\n            min_dist = dist\n            next_target = barrier\n    if next_target:\n        reasoning = f'No unseen tiles. The closest reachable barrier is at ({next_target[\"x\"]}, {next_target[\"y\"]}) with a distance of {min_dist}.'\n    else:\n        reasoning = 'No reachable barriers found.'\nelse:\n    reasoning = 'No unseen tiles or reachable barriers to suggest.'\n\nif next_target:\n    print(json.dumps({'next_target_x': next_target['x'], 'next_target_y': next_target['y'], 'reasoning': reasoning}))\nelse:\n    print(json.dumps({'next_target_x': None, 'next_target_y': None, 'reasoning': reasoning}))"
  },
  "find_path": {
    "description": "A consolidated pathfinding tool. Finds a path to specified X, Y coordinates. If no coordinates are provided, it finds a path to the nearest reachable unseen tile. It automatically paths to an adjacent tile if the target is impassable. It can now handle mixed traversal types (walking and surfing).",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string",
          "nullable": true
        },
        "end_y": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\ngrid = [['' for _ in range(width)] for _ in range(height)]\nimpassable_coords = set()\nunseen_tiles = []\n\nwalk_types = ['ground', 'grass', 'open_gate', 'cleared_boulder_barrier', 'boulder_switch', 'teleport', 'hole', 'spinner_stop', 'ladder_up', 'ladder_down', 'steps', 'cuttable']\nsurf_types = ['water']\ntraversable_tiles = set(walk_types + surf_types)\ntraversable_tiles.add('ledge')\n\nfor r_idx, row_elem in enumerate(root.findall('Row')):\n    y = int(row_elem.get('id')) - 1\n    for c_idx, tile_elem in enumerate(row_elem.findall('Tile')):\n        x = int(tile_elem.get('id')) - 1\n        tile_type = tile_elem.get('type')\n        grid[y][x] = tile_type\n        if tile_elem.get('seen') == 'false':\n            unseen_tiles.append((x, y))\n        if tile_elem.find('Object') is not None and (tile_elem.find('Object').get('id-name') != 'Pikachu'):\n            impassable_coords.add((x, y))\n\nstart_x, start_y = int(input_data['start_x']) - 1, int(input_data['start_y']) - 1\nend_x = int(input_data.get('end_x', None)) - 1 if input_data.get('end_x') else None\nend_y = int(input_data.get('end_y', None)) - 1 if input_data.get('end_y') else None\n\ndef find_path_bfs():\n    start_tile_type = grid[start_y][start_x]\n    if start_tile_type not in traversable_tiles:\n        return []\n\n    queue = deque([((start_x, start_y), [(start_x, start_y)])])\n    visited = {(start_x, start_y)}\n\n    while queue:\n        (current_x, current_y), path = queue.popleft()\n\n        if end_x is not None and end_y is not None:\n            if grid[end_y][end_x] in traversable_tiles and (end_x, end_y) not in impassable_coords:\n                if current_x == end_x and current_y == end_y:\n                    return path\n            else:\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    if current_x == end_x + dx and current_y == end_y + dy:\n                        return path\n        else:\n            if not unseen_tiles:\n                return []\n            for ux, uy in unseen_tiles:\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    if current_x == ux + dx and current_y == uy + dy:\n                        return path\n\n        for move in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = current_x + move[0], current_y + move[1]\n\n            if not (0 <= next_x < width and 0 <= next_y < height):\n                continue\n\n            if (next_x, next_y) in visited or (next_x, next_y) in impassable_coords:\n                continue\n\n            next_tile_type = grid[next_y][next_x]\n            \n            if next_tile_type not in traversable_tiles:\n                continue\n\n            if next_tile_type == 'ledge':\n                if next_y > current_y:\n                    ledge_jump_y = next_y + 1\n                    if 0 <= ledge_jump_y < height and (next_x, ledge_jump_y) not in visited:\n                        if grid[ledge_jump_y][next_x] in traversable_tiles and (next_x, ledge_jump_y) not in impassable_coords:\n                            new_path = path + [(next_x, next_y), (next_x, ledge_jump_y)]\n                            visited.add((next_x, next_y))\n                            visited.add((next_x, ledge_jump_y))\n                            queue.append(((next_x, ledge_jump_y), new_path))\n                continue\n            \n            visited.add((next_x, next_y))\n            new_path = path + [(next_x, next_y)]\n            queue.append(((next_x, next_y), new_path))\n            \n    return []\n\nfound_path = find_path_bfs()\n\nif found_path:\n    path_plan = [{'x': x + 1, 'y': y + 1} for x, y in found_path]\n    target_x, target_y = path_plan[-1]['x'], path_plan[-1]['y']\n    reasoning = f'Path found to target at ({target_x}, {target_y}).'\n    print(json.dumps({'path': path_plan, 'reasoning': reasoning}))\nelse:\n    print(json.dumps({'path': [], 'reasoning': 'Could not find a path to any reachable targets.'}))"
  },
  "get_unseen_tiles": {
    "description": "Parses the map XML to find all unseen tiles and returns them as a JSON list. This helps identify new areas for exploration.",
    "input_schema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "python_script": "import xml.etree.ElementTree as ET; import json; root = ET.fromstring(map_xml_string); unseen_tiles = []; for row_elem in root.findall('Row'): y = int(row_elem.get('id')); for tile_elem in row_elem.findall('Tile'): if tile_elem.get('seen') == 'false': x = int(tile_elem.get('id')); unseen_tiles.append({'x': x, 'y': y}); print(json.dumps(unseen_tiles))"
  },
  "find_hm_spot_tool": {
    "description": "Scans tiles adjacent to the player to find a valid location to initiate an HM field move like SURF or CUT. This prevents wasting time on repeated failed attempts.",
    "input_schema": {
      "type": "object",
      "properties": {
        "hm_type": {
          "type": "string",
          "enum": [
            "cut",
            "surf"
          ]
        },
        "player_x": {
          "type": "string"
        },
        "player_y": {
          "type": "string"
        }
      },
      "required": [
        "hm_type",
        "player_x",
        "player_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\nroot = ET.fromstring(map_xml_string)\nwidth = int(root.get('width'))\nheight = int(root.get('height'))\n\nplayer_x = int(input_data['player_x'])\nplayer_y = int(input_data['player_y'])\nhm_type = input_data['hm_type']\n\ntarget_tile_type = 'cuttable' if hm_type == 'cut' else 'water'\n\nfor move in [('Up', 0, -1), ('Down', 0, 1), ('Left', -1, 0), ('Right', 1, 0)]:\n    direction, dx, dy = move\n    check_x, check_y = player_x + dx, player_y + dy\n\n    if not (1 <= check_x <= width and 1 <= check_y <= height):\n        continue\n\n    tile_xpath = f\".//Row[@id='{check_y}']/Tile[@id='{check_x}']\"\n    tile_elem = root.find(tile_xpath)\n    if tile_elem is not None and tile_elem.get('type') == target_tile_type:\n        print(json.dumps({'status': 'found', 'direction_to_face': direction, 'x': check_x, 'y': check_y}))\n        exit()\n\nprint(json.dumps({'status': 'not_found', 'reasoning': f'No adjacent {target_tile_type} tile found.'}))"
  }
}