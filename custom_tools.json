{
  "auto_attacker": {
    "description": "Automatically selects 'FIGHT' from the main battle menu (if present) and then selects the specified move from the move menu. Returns only the directional presses needed to highlight the move. Does not press 'A' to confirm.",
    "input_schema": {
      "type": "object",
      "properties": {
        "move_to_select": {
          "type": "string"
        },
        "pokemon_move_list": {
          "type": "string"
        },
        "screen_text": {
          "type": "string"
        },
        "current_selected_move": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "move_to_select",
        "pokemon_move_list",
        "screen_text"
      ]
    },
    "python_script": "import sys\nimport json\n\ntry:\n    screen_text = input_data['screen_text']\n    move_to_select = input_data['move_to_select']\n    pokemon_move_list_str = input_data['pokemon_move_list']\n    current_selected_move = input_data.get('current_selected_move')\n\n    button_sequence = []\n\n    if '→FIGHT' in screen_text and 'PKMN' in screen_text:\n        button_sequence.append('A')\n\n    moves = json.loads(pokemon_move_list_str)\n\n    start_index = 0\n    if current_selected_move and current_selected_move in moves:\n        start_index = moves.index(current_selected_move)\n    \n    if move_to_select not in moves:\n        print(json.dumps([]))\n        sys.exit()\n\n    target_index = moves.index(move_to_select)\n\n    if target_index != start_index:\n        presses = target_index - start_index\n        if presses > 0:\n            button_sequence.extend(['Down'] * presses)\n        else:\n            button_sequence.extend(['Up'] * abs(presses))\n\n    print(json.dumps(button_sequence))\n\nexcept Exception as e:\n    print(json.dumps([]))",
    "history": [
      {
        "commit_message": "feat: Create auto_attacker tool to streamline battle actions. In response to my 50-turn reflection identifying an inefficiency, this tool combines the logic of selecting a move and pressing 'A' to use it into a single, automated command. This is a critical step to improve my turn-by-turn efficiency in combat.",
        "timestamp": "2025-08-20T00:25:17.302Z",
        "action_counter": 155553
      },
      {
        "commit_message": "refactor: Add 'FIGHT' selection to automate full attack sequence. In response to a direct Overwatch critique, this commit refactors the tool to handle the entire attack process, from selecting 'FIGHT' on the main menu to executing the chosen move. This eliminates the previous multi-turn manual process, improving battle efficiency and preventing user error. This is a critical fix to adhere to the immediate action mandate.",
        "timestamp": "2025-08-20T01:45:41.444Z",
        "action_counter": 155731
      },
      {
        "commit_message": "refactor: Remove all 'A' presses to comply with system input rules. The tool now only calculates and outputs the directional presses required to highlight a move in the menu, preventing mixed-input errors. The user must manually press 'A' in subsequent turns.",
        "timestamp": "2025-08-20T02:07:25.147Z",
        "action_counter": 155779
      },
      {
        "commit_message": "feat: Create auto_attacker tool to streamline battle actions. In response to my 50-turn reflection identifying an inefficiency, this tool combines the logic of selecting a move and pressing 'A' to use it into a single, automated command. This is a critical step to improve my turn-by-turn efficiency in combat.",
        "timestamp": "2025-08-20T04:21:47.836Z",
        "action_counter": 156070
      },
      {
        "commit_message": "fix: Implement vertical list logic for move selection. The previous version incorrectly assumed a 2x2 grid for the move menu, leading to incorrect directional outputs. This commit replaces the faulty grid logic with a simple index comparison for a linear, vertical menu, ensuring correct navigation. This is a critical fix to restore the tool's core functionality.",
        "timestamp": "2025-08-20T04:23:23.452Z",
        "action_counter": 156074
      },
      {
        "commit_message": "fix: Implement 2x2 grid logic for move selection. The previous version incorrectly assumed a vertical list, causing incorrect navigation and move selection. This commit replaces the faulty logic with a coordinate-based system that correctly calculates Up/Down and Left/Right presses for a 2x2 grid. This is a critical fix to restore the tool's core functionality and prevent future battle errors, as mandated by an Overwatch critique.",
        "timestamp": "2025-08-20T06:14:21.880Z",
        "action_counter": 156301
      },
      {
        "commit_message": "fix: Revert to vertical list logic for move selection. My previous fix incorrectly assumed a 2x2 grid, but in-game observation confirms the move menu is a simple vertical list. This commit reverts the logic to correctly calculate only Up/Down presses. This is a critical fix to restore the tool's core functionality based on direct evidence from the game screen.",
        "timestamp": "2025-08-20T06:15:54.921Z",
        "action_counter": 156304
      },
      {
        "commit_message": "fix: Add robust error handling to prevent JSONDecodeError. The tool was failing due to an empty output, causing a JSON parsing error. This commit wraps the logic in a try-except block and adds checks for move existence to ensure a valid JSON array (`[]`) is always printed, even on failure. This is a critical fix to restore the tool's core functionality.",
        "timestamp": "2025-08-21T16:44:16.041Z",
        "action_counter": 158973
      },
      {
        "commit_message": "fix: Correct move list parsing logic. The tool was previously using `split(',')` on a JSON string, causing parsing errors. This commit replaces the faulty logic with `json.loads()` to correctly parse the move list array. This is a critical fix to restore the tool's core functionality.",
        "timestamp": "2025-08-21T19:59:08.825Z",
        "action_counter": 159301
      },
      {
        "commit_message": "refactor: Add 'FIGHT' selection to auto_attacker. In response to an Overwatch critique, this commit refactors the tool to automatically select the 'FIGHT' option from the main battle menu if it is present. This streamlines a common two-turn action into a single, more efficient tool call, improving overall battle tempo.",
        "timestamp": "2025-08-22T05:09:01.214Z",
        "action_counter": 160327
      },
      {
        "commit_message": "fix: Correct FIGHT selection and revert to vertical move logic. The tool was incorrectly pressing 'Right' before 'A' to select FIGHT, and was using flawed 2x2 grid logic for move selection. This commit corrects the FIGHT selection to a single 'A' press and reinstates the correct vertical list logic for move navigation. This is a critical fix to restore core functionality.",
        "timestamp": "2025-08-22T05:14:41.360Z",
        "action_counter": 160338
      }
    ]
  },
  "battle_screen_parser": {
    "description": "A tool that can parse the battle screen text to automatically generate the structured JSON required as input for the master_battle_agent. This will eliminate the current manual and error-prone data entry step, significantly improving battle efficiency.",
    "input_schema": {
      "type": "object",
      "properties": {
        "screen_text": {
          "type": "string"
        }
      },
      "required": [
        "screen_text"
      ]
    },
    "python_script": "import json\nimport re\n\ndef parse_battle_screen(screen_text):\n    lines = screen_text.strip().split('\\n')\n    \n    player_party = []\n    enemy_pokemon = {}\n    active_pokemon_name = None\n    \n    # Regex patterns\n    party_pattern = re.compile(r'([A-Z]+)\\s+LV (\\d+)\\s+(FNT|SLP|PAR|PSN|BRN|FRZ)?\\s*(\\d+)\\/(\\d+)')\n    enemy_pattern = re.compile(r'([A-Z]+)\\s+LV (\\d+)')\n    active_pattern = re.compile(r'Go! ([A-Z]+)!')\n    switch_pattern = re.compile(r'Do it! ([A-Z]+)!')\n    \n    # This is a simplified parser. It assumes a certain structure.\n    # It will need to be made more robust over time.\n    \n    try:\n        # Try to parse enemy info from the top lines\n        match = enemy_pattern.match(lines[0])\n        if match:\n            enemy_pokemon = {\n                \"species\": match.group(1),\n                \"level\": int(match.group(2)),\n                \"hp_percentage\": 100 # Placeholder\n            }\n\n        # Try to parse party info\n        for line in lines:\n            party_match = party_pattern.search(line)\n            if party_match:\n                status = party_match.group(3) if party_match.group(3) else 'OK'\n                player_party.append({\n                    \"name\": party_match.group(1).capitalize(), # Assuming name is species\n                    \"species\": party_match.group(1).capitalize(),\n                    \"level\": int(party_match.group(2)),\n                    \"hp\": int(party_match.group(4)),\n                    \"max_hp\": int(party_match.group(5)),\n                    \"status\": status\n                })\n            \n            active_match = active_pattern.search(line)\n            if active_match:\n                active_pokemon_name = active_match.group(1).capitalize()\n                \n            switch_match = switch_pattern.search(line)\n            if switch_match:\n                active_pokemon_name = switch_match.group(1).capitalize()\n\n    except Exception as e:\n        # In case of parsing error, return empty structure\n        return json.dumps({\"player_party\": [], \"enemy_pokemon\": {}, \"active_pokemon_name\": None, \"error\": str(e)})\n\n    # If active_pokemon_name wasn't found, try to infer it\n    # This is a placeholder for more complex logic\n    if not active_pokemon_name and player_party:\n        # Simplistic assumption: first non-fainted is active if not specified\n        for p in player_party:\n            if p['status'] != 'FNT' and p['hp'] > 0:\n                active_pokemon_name = p['name']\n                break\n\n    result = {\n        \"player_party\": player_party,\n        \"enemy_pokemon\": enemy_pokemon,\n        \"active_pokemon_name\": active_pokemon_name\n    }\n    \n    return json.dumps(result, indent=2)\n\n\ninput_text = input_data.get('screen_text', '')\nparsed_data = parse_battle_screen(input_text)\nprint(parsed_data)\n",
    "history": [
      {
        "commit_message": "feat: Create battle_screen_parser tool to automate data entry. In response to an Overwatch critique identifying deferred development as a core violation, this tool automates the extraction of key battle data from screen text. This will streamline the input process for the `master_battle_agent`, improving battle efficiency and adhering to the immediate action directive.",
        "timestamp": "2025-08-22T00:12:14.901Z",
        "action_counter": 159782
      },
      {
        "commit_message": "feat: Create battle_screen_parser tool to automate data entry. In response to an Overwatch critique identifying deferred development as a core violation, this tool automates the extraction of key battle data from screen text. This will streamline the input process for the `master_battle_agent`, improving battle efficiency and adhering to the immediate action directive.",
        "timestamp": "2025-08-22T02:44:28.656Z",
        "action_counter": 160067
      }
    ]
  },
  "find_path": {
    "description": "Finds the shortest path between two points on the current map using the A* algorithm. Can find a path to an adjacent tile if the destination is impassable. Can optionally accept a list of coordinates to treat as temporarily impassable. On failure, it will report the coordinates of the blocking tile(s).",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "temp_impassable": {
          "type": "string",
          "description": "Optional. JSON string of coordinates to treat as temporarily impassable. e.g., '[{\"x\":10,\"y\":5}]'",
          "nullable": true
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef find_path(start_x_str, start_y_str, end_x_str, end_y_str, temp_impassable_str=None):\n    start_x, start_y = int(start_x_str), int(start_y_str)\n    end_x, end_y = int(end_x_str), int(end_y_str)\n    \n    temp_impassable = set()\n    if temp_impassable_str:\n        try:\n            impassable_coords = json.loads(temp_impassable_str)\n            for item in impassable_coords:\n                temp_impassable.add((item['x'], item['y']))\n        except (json.JSONDecodeError, TypeError):\n            pass\n\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.get('width'))\n    map_height = int(root.get('height'))\n    \n    grid = [[float('inf') for _ in range(map_width + 1)] for _ in range(map_height + 1)]\n    traversable_types = ['ground', 'grass', 'steps', 'elevated_ground', 'cleared_boulder_barrier', 'ladder_up', 'ladder_down']\n    tile_types_dict = {}\n\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tile_type = tile.get('type')\n            tile_types_dict[(x, y)] = tile_type\n\n            if (x, y) in temp_impassable:\n                grid[y][x] = float('inf')\n                continue\n\n            cost = float('inf')\n            has_impassable_object = False\n            is_pikachu_tile = False\n            \n            obj = tile.find('Object')\n            if obj is not None and 'id-name' in obj.attrib:\n                if obj.attrib['id-name'] == 'Pikachu':\n                    is_pikachu_tile = True\n                else:\n                    has_impassable_object = True\n\n            if tile_type in traversable_types and not has_impassable_object:\n                cost = 2 if is_pikachu_tile else 1\n            \n            grid[y][x] = cost\n\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n\n    if grid[end_y][end_x] == float('inf'):\n        possible_goals = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = end_x + dx, end_y + dy\n            if 1 <= nx <= map_width and 1 <= ny <= map_height and grid[ny][nx] != float('inf'):\n                possible_goals.append((nx, ny))\n        \n        if not possible_goals:\n            print(json.dumps({'status': 'failure', 'reason': 'Destination and all adjacent tiles are impassable.'}))\n            return\n        \n        possible_goals.sort(key=lambda pos: abs(pos[0] - start_x) + abs(pos[1] - start_y))\n        end_node = possible_goals[0]\n        end_x, end_y = end_node\n\n    open_set = [(0, start_node)]\n    came_from = {}\n    g_score = { (x,y): float('inf') for x in range(map_width + 1) for y in range(map_height + 1) }\n    g_score[start_node] = 0\n    f_score = { (x,y): float('inf') for x in range(map_width + 1) for y in range(map_height + 1) }\n    f_score[start_node] = abs(start_x - end_x) + abs(start_y - end_y)\n\n    visited_nodes = set()\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n        visited_nodes.add(current)\n\n        if current == end_node:\n            path = []\n            while current in came_from:\n                path.append({'x': current[0], 'y': current[1]})\n                current = came_from[current]\n            path.append({'x': start_node[0], 'y': start_node[1]})\n            path.reverse()\n            print(json.dumps({'status': 'success', 'path': path}))\n            return\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            nx, ny = neighbor\n\n            if not (1 <= nx <= map_width and 1 <= ny <= map_height):\n                continue\n\n            neighbor_tile_type = tile_types_dict.get(neighbor, 'impassable')\n            if neighbor_tile_type == 'ledge':\n                if dy == -1 or dy == 0: \n                    continue\n            \n            if grid[ny][nx] == float('inf'):\n                continue\n\n            tentative_g_score = g_score[current] + grid[ny][nx]\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                h_score = abs(nx - end_x) + abs(ny - end_y)\n                f_score[neighbor] = tentative_g_score + h_score\n                if neighbor not in [item[1] for item in open_set]:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    closest_node_to_end = None\n    min_dist_to_end = float('inf')\n    for node in visited_nodes:\n        dist = abs(node[0] - end_x) + abs(node[1] - end_y)\n        if dist < min_dist_to_end:\n            min_dist_to_end = dist\n            closest_node_to_end = node\n\n    if closest_node_to_end:\n        blocking_tiles = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (closest_node_to_end[0] + dx, closest_node_to_end[1] + dy)\n            nx, ny = neighbor\n            if 1 <= nx <= map_width and 1 <= ny <= map_height and grid[ny][nx] == float('inf'):\n                 blocking_tiles.append({'x': nx, 'y': ny})\n        \n        if blocking_tiles:\n            print(json.dumps({'status': 'failure', 'reason': 'Path blocked by impassable tiles.', 'blocking_tiles': blocking_tiles}))\n            return\n\n    print(json.dumps({'status': 'failure', 'reason': 'No path found. The start and end points may be in disconnected regions of the map.'}))\n\nfind_path(input_data['start_x'], input_data['start_y'], input_data['end_x'], input_data['end_y'], input_data.get('temp_impassable'))",
    "history": [
      {
        "commit_message": "feat: Create find_path tool to automate navigation. In response to a critical overwatch review identifying over 100 wasted turns due to manual navigation failure, this tool implements an A* pathfinding algorithm. It parses the map XML, handles impassable destinations by targeting adjacent tiles, and will prevent future catastrophic navigation loops. This replaces the previous, unused pathfinding tool.",
        "timestamp": "2025-08-20T09:43:44.097Z",
        "action_counter": 156512
      },
      {
        "commit_message": "refactor: Add weighted pathfinding to avoid Pikachu. In response to an Overwatch critique, this commit refactors the A* algorithm to assign a higher movement cost to the tile occupied by Pikachu. This addresses the issue of the pathfinder generating suboptimal routes that require an extra button press to traverse, improving navigation efficiency by prioritizing paths that do not pass through the follower Pokémon.",
        "timestamp": "2025-08-21T17:46:30.664Z",
        "action_counter": 159061
      },
      {
        "commit_message": "feat: Add optional temporary impassable tiles. In response to an Overwatch critique, this commit refactors the `find_path` tool to accept an optional JSON string of coordinates to treat as impassable. This addresses the tool's failure to navigate around invisible, scripted barriers, such as the one in Lorelei's Room, and will prevent future navigation loops caused by this limitation.",
        "timestamp": "2025-08-22T03:48:43.455Z",
        "action_counter": 160172
      },
      {
        "commit_message": "feat: Add diagnostic output on pathfinding failure. In response to an Overwatch critique, this commit refactors the `find_path` tool to report the specific coordinates of the blocking tile(s) when it fails to find a path. This will provide critical context for debugging navigation loops and distinguishing between tool errors and scripted barriers.",
        "timestamp": "2025-08-22T04:04:27.249Z",
        "action_counter": 160203
      },
      {
        "commit_message": "feat: Add diagnostic output on pathfinding failure. In response to an Overwatch critique, this commit refactors the `find_path` tool to report the specific coordinates of the blocking tile(s) when it fails to find a path. This will provide critical context for debugging navigation loops and distinguishing between tool errors and scripted barriers.",
        "timestamp": "2025-08-22T04:05:24.496Z",
        "action_counter": 160204
      },
      {
        "commit_message": "fix: Add ledge traversal logic to prevent invalid paths. The previous version failed to account for one-way ledge traversal, causing it to generate invalid paths upwards and sideways onto ledges. This commit adds checks during neighbor generation to correctly treat ledges as impassable from below and from the sides, ensuring path validity.",
        "timestamp": "2025-08-22T12:56:19.110Z",
        "action_counter": 160653
      },
      {
        "commit_message": "refactor: Enhance diagnostic output on pathfinding failure. In response to an Overwatch critique, this commit refactors the `find_path` tool to provide a more descriptive failure reason when the start and end points are in completely disconnected map regions. This replaces the generic 'No path found' message, providing better context for debugging navigation failures.",
        "timestamp": "2025-08-22T15:55:53.642Z",
        "action_counter": 160801
      },
      {
        "commit_message": "feat: Add diagnostic output on pathfinding failure. In response to an Overwatch critique, this commit refactors the `find_path` tool to report the specific coordinates of the blocking tile(s) when it fails to find a path. This will provide critical context for debugging navigation loops and distinguishing between tool errors and scripted barriers.",
        "timestamp": "2025-08-22T18:28:27.919Z",
        "action_counter": 160981
      }
    ]
  },
  "get_next_switch_press": {
    "description": "Calculates the single next directional press (Up or Down) required to move the cursor one step closer to a target Pokémon in the party menu. Designed for step-by-step execution to handle the 'Party Menu Cursor Anomaly'.",
    "input_schema": {
      "type": "object",
      "properties": {
        "party_pokemon_list": {
          "type": "string"
        },
        "current_selection_name": {
          "type": "string"
        },
        "target_name": {
          "type": "string"
        }
      },
      "required": [
        "party_pokemon_list",
        "current_selection_name",
        "target_name"
      ]
    },
    "python_script": "import json\nparty_list_str = input_data['party_pokemon_list']\ncurrent_selection = input_data['current_selection_name']\ntarget = input_data['target_name']\ntry:\n    party_list = json.loads(party_list_str)\nexcept json.JSONDecodeError:\n    cleaned_str = party_list_str.replace('[', '').replace(']', '').replace('\"', '')\n    party_list = [p.strip() for p in cleaned_str.split(',')]\n\nbutton_sequence = []\nif current_selection in party_list and target in party_list:\n    current_index = party_list.index(current_selection)\n    target_index = party_list.index(target)\n    if current_index < target_index:\n        button_sequence.append(\"Down\")\n    elif current_index > target_index:\n        button_sequence.append(\"Up\")\nprint(json.dumps(button_sequence))",
    "history": [
      {
        "commit_message": "feat: Create get_next_switch_press tool to replace buggy auto_switcher. In response to an Overwatch critique, this commit replaces the unreliable `auto_switcher` with a new, single-step tool. This tool calculates only the next required directional press, making it robust against the 'Party Menu Cursor Anomaly' by allowing for re-evaluation of the cursor's position each turn. This is a critical fix to prevent future switch errors.",
        "timestamp": "2025-08-22T05:54:01.769Z",
        "action_counter": 160418
      }
    ]
  }
}