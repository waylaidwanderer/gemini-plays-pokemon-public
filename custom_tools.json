{
  "interact_with_tile_v1": {
    "description": "Navigates to a specific tile on the current map and interacts with it using the A button. Useful for cutting trees, talking to NPCs behind counters, or interacting with objects. Uses BFS for pathfinding.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import json\nfrom collections import deque\nimport xml.etree.ElementTree as ET\n\ndef solve():\n    try:\n        data = input_data\n        target_x = int(data['target_x'])\n        target_y = int(data['target_y'])\n        \n        root = ET.fromstring(map_xml_string)\n        width = int(root.attrib['width'])\n        height = int(root.attrib['height'])\n        \n        grid = [[False for _ in range(width)] for _ in range(height)]\n        player_pos = None\n        \n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                t_type = tile.attrib['type']\n                \n                if tile.find('Player') is not None:\n                    player_pos = (x, y)\n                \n                # Check traversability\n                walkable_types = ['FLOOR', 'TALL_GRASS', 'GATEHOUSE_FLOOR', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'WARP_CARPET_UP', 'WARP_CARPET_DOWN']\n                is_walkable = t_type in walkable_types\n                \n                # Objects and warps act as walls for pathfinding to interaction points\n                if tile.find('Object') is not None or tile.attrib.get('is-warp') == 'true':\n                    is_walkable = False\n                \n                # The target tile itself might be an object (like a tree), but we need to stand ADJACENT to it.\n                # So we treat the target as non-walkable.\n                if x == target_x and y == target_y:\n                    is_walkable = False\n                    \n                grid[y][x] = is_walkable\n\n        if not player_pos:\n            print(json.dumps([]))\n            return\n\n        queue = deque([(player_pos, [])])\n        visited = {player_pos}\n        \n        while queue:\n            (curr_x, curr_y), path = queue.popleft()\n            \n            # Check if adjacent to target\n            if abs(curr_x - target_x) + abs(curr_y - target_y) == 1:\n                final_btn = \"\"\n                if target_x > curr_x: final_btn = \"Right\"\n                elif target_x < curr_x: final_btn = \"Left\"\n                elif target_y > curr_y: final_btn = \"Down\"\n                elif target_y < curr_y: final_btn = \"Up\"\n                \n                print(json.dumps(path + [final_btn, \"A\"]))\n                return\n            \n            for dx, dy, btn in [(0, -1, \"Up\"), (0, 1, \"Down\"), (-1, 0, \"Left\"), (1, 0, \"Right\")]:\n                nx, ny = curr_x + dx, curr_y + dy\n                if 0 <= nx < width and 0 <= ny < height and grid[ny][nx] and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append(((nx, ny), path + [btn]))\n\n        print(json.dumps([]))\n    except Exception as e:\n        print(json.dumps([f\"Error: {str(e)}\"]))\n\nsolve()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-27T19:51:30.216Z",
        "action_counter": 26672
      }
    ]
  },
  "navigate_fly_map_v2": {
    "description": "Navigates the Johto FLY map from a known starting city to a target city. City names: 'New Bark Town', 'Cherrygrove City', 'Violet City', 'Azalea Town', 'Goldenrod City', 'Ecruteak City', 'Olivine City', 'Cianwood City', 'Mahogany Town', 'Lake of Rage', 'Blackthorn City', 'Mt. Silver', 'Indigo Plateau'. Assumes the FLY map is already open.",
    "input_schema": {
      "properties": {
        "start_city": {
          "default": "New Bark Town",
          "type": "string"
        },
        "target_city": {
          "type": "string"
        }
      },
      "required": [
        "target_city"
      ],
      "type": "object"
    },
    "python_script": "import json\n\ndef navigate_fly_map(target_city, start_city=\"New Bark Town\"):\n    cities = [\n        \"New Bark Town\", \"Cherrygrove City\", \"Violet City\", \"Azalea Town\",\n        \"Goldenrod City\", \"Ecruteak City\", \"Olivine City\", \"Cianwood City\",\n        \"Mahogany Town\", \"Lake of Rage\", \"Blackthorn City\", \"Mt. Silver\", \"Indigo Plateau\"\n    ]\n    \n    if target_city not in cities or start_city not in cities:\n        print(json.dumps([]))\n        return\n\n    start_idx = cities.index(start_city)\n    target_idx = cities.index(target_city)\n    diff = target_idx - start_idx\n    \n    buttons = []\n    # In Crystal Johto FLY map:\n    # 'Up' moves forward in the sequence (index increases).\n    if diff > 0:\n        buttons = [\"Up\"] * diff\n    elif diff < 0:\n        buttons = [\"Down\"] * abs(diff)\n    \n    buttons.append(\"A\")\n    print(json.dumps(buttons))\n\n# The variable 'input_data' is automatically available.\nnavigate_fly_map(input_data['target_city'], input_data.get('start_city', 'New Bark Town'))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-27T03:08:24.414Z",
        "action_counter": 24583
      }
    ]
  },
  "find_path_v9": {
    "description": "Advanced pathfinding that tracks surfing state and handles land-to-water transitions by inserting the necessary 'A' button presses. Returns a JSON array of button strings. Treats LEDGE_HOP tiles as impassable. Updated to properly handle BUOY tiles as impassable, correctly parse the map XML, avoid tiles with Objects or Warps, and ONLY use tiles that have been 'seen'.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "description": "If true and the tool returns a list of buttons, they will be pressed automatically.",
          "type": "boolean"
        },
        "can_cut": {
          "default": false,
          "type": "boolean"
        },
        "can_surf": {
          "default": false,
          "type": "boolean"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        }
      },
      "required": [
        "end_x",
        "end_y",
        "autopress_buttons"
      ],
      "type": "object"
    },
    "python_script": "import collections\nimport json\nimport heapq\nimport xml.etree.ElementTree as ET\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n    except Exception:\n        print(json.dumps([]))\n        return\n\n    if root.tag == \"Map\":\n        map_elem = root\n    else:\n        map_elem = root.find(\".//Map\")\n        \n    if map_elem is None:\n        print(json.dumps([]))\n        return\n        \n    width = int(map_elem.get(\"width\"))\n    height = int(map_elem.get(\"height\"))\n    \n    grid = {}\n    player_pos = None\n    \n    for row in map_elem.findall(\".//Row\"):\n        y = int(row.get(\"id\"))\n        for tile in row.findall(\"Tile\"):\n            x = int(tile.get(\"id\"))\n            t_type = tile.get(\"type\")\n            seen = tile.get(\"seen\") == \"true\"\n            has_object = tile.get(\"has-object\") == \"true\"\n            is_warp = tile.get(\"is-warp\") == \"true\"\n            \n            if tile.find(\"Player\") is not None:\n                player_pos = (x, y)\n                \n            grid[(x, y)] = {\"type\": t_type, \"seen\": seen, \"has_object\": has_object, \"is_warp\": is_warp}\n\n    if player_pos is None:\n        print(json.dumps([]))\n        return\n\n    target_x = int(input_data[\"end_x\"])\n    target_y = int(input_data[\"end_y\"])\n    can_surf = input_data.get(\"can_surf\", False)\n\n    start_is_surfing = grid[player_pos][\"type\"] == \"WATER\"\n    # priority queue: (cost, x, y, surfing, path)\n    pq = [(0, player_pos[0], player_pos[1], start_is_surfing, [])]\n    visited = {} # (x, y, surfing) -> min_cost\n    \n    while pq:\n        cost, x, y, surfing, path = heapq.heappop(pq)\n        \n        state = (x, y, surfing)\n        if state in visited and visited[state] <= cost:\n            continue\n        visited[state] = cost\n        \n        if (x, y) == (target_x, target_y):\n            print(json.dumps(path))\n            return\n            \n        for dx, dy, btn in [(0, -1, \"Up\"), (0, 1, \"Down\"), (-1, 0, \"Left\"), (1, 0, \"Right\")]:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx < width and 0 <= ny < height:\n                tile = grid.get((nx, ny))\n                if not tile: continue\n                \n                t_type = tile[\"type\"]\n                has_obj = tile[\"has_object\"]\n                is_warp = tile[\"is_warp\"]\n                seen = tile[\"seen\"]\n                \n                if not seen or t_type in [\"WALL\", \"BUOY\", \"LEDGE_HOP_DOWN\", \"LEDGE_HOP_UP\", \"LEDGE_HOP_LEFT\", \"LEDGE_HOP_RIGHT\", \"unseen\"]:\n                    continue\n                    \n                if (has_obj or is_warp) and (nx, ny) != (target_x, target_y):\n                    continue\n                \n                if t_type == \"WATER\":\n                    if surfing:\n                        new_cost = cost + 1\n                        new_path = path + [btn]\n                        heapq.heappush(pq, (new_cost, nx, ny, True, new_path))\n                    elif can_surf:\n                        # Land to Water\n                        new_cost = cost + 3\n                        new_path = path + [\"A\", \"A\", btn]\n                        heapq.heappush(pq, (new_cost, nx, ny, True, new_path))\n                else:\n                    # To Land\n                    new_cost = cost + 1\n                    new_path = path + [btn]\n                    heapq.heappush(pq, (new_cost, nx, ny, False, new_path))\n\n    print(json.dumps([]))\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T02:45:06.552Z",
        "action_counter": 27535
      },
      {
        "commit_message": "Added logic to avoid warp tiles and objects unless they are the target, and fixed XML root parsing.",
        "timestamp": "2025-12-28T02:50:23.048Z",
        "action_counter": 27542
      },
      {
        "commit_message": "Added 'seen' check to ensure pathfinding only uses explored tiles, and improved land-to-water transition logic.",
        "timestamp": "2025-12-28T02:59:16.603Z",
        "action_counter": 27549
      },
      {
        "commit_message": "Updated to Dijkstra's algorithm to correctly handle land-to-water transition costs (3 actions), and retained 'seen' and object/warp avoidance logic.",
        "timestamp": "2025-12-28T03:14:05.418Z",
        "action_counter": 27571
      }
    ]
  },
  "find_path_v10": {
    "description": "Improved pathfinding that treats HEADBUTT_TREE and CUT_TREE as impassable and handles surfing transitions. Returns a JSON array of button strings.",
    "input_schema": {
      "properties": {
        "can_cut": {
          "default": true,
          "type": "boolean"
        },
        "can_surf": {
          "default": true,
          "type": "boolean"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        }
      },
      "required": [
        "end_x",
        "end_y"
      ],
      "type": "object"
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\n# input_data is provided by the harness\ntarget_x = int(input_data['end_x'])\ntarget_y = int(input_data['end_y'])\ncan_surf = input_data.get('can_surf', True)\n\nroot = ET.fromstring(map_xml_string)\ngrid = {}\nstart_pos = None\nfor row in root.findall('Row'):\n    y = int(row.get('id'))\n    for tile in row.findall('Tile'):\n        x = int(tile.get('id'))\n        t_type = tile.get('type')\n        seen = tile.get('seen') == 'true'\n        is_warp = tile.get('is-warp') == 'true'\n        has_obj = tile.get('has-object') == 'true'\n        if tile.find('Player') is not None:\n            start_pos = (x, y)\n        grid[(x, y)] = {'has_obj': has_obj, 'is_warp': is_warp, 'seen': seen, 'type': t_type}\n\nif not start_pos:\n    print('[]')\nelse:\n    impassable = {'WALL', 'HEADBUTT_TREE', 'CUT_TREE', 'BUOY', 'LEDGE_HOP_DOWN'}\n\n    # Detect initial surfing state based on player's current tile\n    initial_surfing = grid[start_pos]['type'] == 'WATER'\n\n    queue = deque([(start_pos[0], start_pos[1], [], initial_surfing)])\n    visited = set()\n\n    found = False\n    while queue:\n        x, y, path, surfing = queue.popleft()\n        if (x, y, surfing) in visited: continue\n        visited.add((x, y, surfing))\n\n        if x == target_x and y == target_y:\n            print(json.dumps(path))\n            found = True\n            break\n\n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) not in grid: continue\n            tile = grid[(nx, ny)]\n\n            if not tile['seen']: continue\n            \n            # Allow target tile to have object or warp\n            if (tile['has_obj'] or tile['is_warp']) and (nx != target_x or ny != target_y):\n                continue\n\n            if surfing:\n                if tile['type'] == 'WATER':\n                    queue.append((nx, ny, path + [btn], True))\n                elif tile['type'] in {'FLOOR', 'TALL_GRASS'}:\n                    queue.append((nx, ny, path + [btn], False))\n            else:\n                if tile['type'] == 'WATER' and can_surf:\n                    queue.append((nx, ny, path + [btn, 'A', 'A', btn], True))\n                elif tile['type'] not in impassable:\n                    queue.append((nx, ny, path + [btn], False))\n    if not found:\n        print('[]')",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T03:21:24.968Z",
        "action_counter": 27584
      },
      {
        "commit_message": "Fixing JSON output and logic for start position and target tile.",
        "timestamp": "2025-12-28T03:22:47.944Z",
        "action_counter": 27587
      },
      {
        "commit_message": "Refining pathfinding to correctly detect initial surfing state based on the player's starting tile type.",
        "timestamp": "2025-12-28T03:24:10.152Z",
        "action_counter": 27589
      },
      {
        "commit_message": "Treating CUT_TREE and HEADBUTT_TREE as impassable for navigation.",
        "timestamp": "2025-12-28T03:26:29.057Z",
        "action_counter": 27592
      }
    ]
  }
}