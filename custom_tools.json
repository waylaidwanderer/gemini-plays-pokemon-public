{
  "pc_navigator": {
    "description": "A unified tool to navigate the PC. It can select options in vertical menus, move the cursor in the Pok√©mon box grid, and switch between boxes. Outputs button presses for use with autopress_buttons=true.",
    "input_schema": {
      "type": "object",
      "properties": {
        "mode": {
          "type": "string",
          "enum": [
            "menu_select",
            "box_navigate",
            "box_select"
          ]
        },
        "current_cursor_position": {
          "type": "string",
          "nullable": true
        },
        "target_option": {
          "type": "string",
          "nullable": true
        },
        "menu_options": {
          "type": "string",
          "nullable": true
        },
        "current_slot": {
          "type": "string",
          "nullable": true
        },
        "target_slot": {
          "type": "string",
          "nullable": true
        },
        "target_box_number": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "mode"
      ]
    },
    "python_script": "import json\n\ndef execute_pc_navigation():\n    buttons = [\"sleep 500\"]\n    try:\n        mode = input_data.get('mode')\n        if mode == 'menu_select':\n            current_pos = int(input_data['current_cursor_position'])\n            target_opt = input_data['target_option']\n            menu_opts_str = input_data['menu_options']\n            options = [opt.strip() for opt in menu_opts_str.split(',')]\n            current_index = current_pos - 1\n            if target_opt not in options:\n                print(json.dumps([f'ERROR: Target <{target_opt}> not in options']))\n                return\n            target_index = options.index(target_opt)\n            moves = target_index - current_index\n            if moves > 0:\n                buttons.extend(['Down'] * moves)\n            elif moves < 0:\n                buttons.extend(['Up'] * abs(moves))\n            buttons.append('A')\n        elif mode == 'box_navigate':\n            cur_x, cur_y = map(int, input_data['current_slot'].split(','))\n            tar_x, tar_y = map(int, input_data['target_slot'].split(','))\n            dx = tar_x - cur_x\n            dy = tar_y - cur_y\n            if dx > 0: buttons.extend(['Right'] * dx)\n            if dx < 0: buttons.extend(['Left'] * abs(dx))\n            if dy > 0: buttons.extend(['Down'] * dy)\n            if dy < 0: buttons.extend(['Up'] * abs(dy))\n        elif mode == 'box_select':\n            buttons.append('ERROR: box_select mode is disabled')\n        else:\n            buttons.append(f'ERROR: Invalid mode <{mode}>')\n        print(json.dumps(buttons))\n    except Exception as e:\n        print(json.dumps([f'ERROR: {str(e)}']))\n\nexecute_pc_navigation()",
    "history": [
      {
        "commit_message": "feat: Consolidate PC navigation tools into pc_navigator. This addresses a major inefficiency identified by an Overwatch critique. The new tool combines the functionality of `select_pc_option`, `pc_box_navigator`, and `select_pc_box` into a single, mode-based tool, fulfilling the core directive of immediate tool maintenance and improving overall efficiency.",
        "timestamp": "2025-11-17T05:16:58.132Z",
        "action_counter": 47853
      },
      {
        "commit_message": "fix: Add initial sleep command to handle text box delays. The tool was failing because it sent inputs before the initial '...turned on the PC' text box cleared. This adds a 500ms delay to the start of all button sequences. Also, temporarily disabled the 'box_select' mode with an error message as its logic cannot be safely reconstructed from the available information.",
        "timestamp": "2025-11-17T07:11:12.958Z",
        "action_counter": 48071
      },
      {
        "commit_message": "fix: Add comprehensive try-except block to prevent crashes. The tool was failing with an unhelpful system error because it produced an empty output when an exception occurred (e.g., target option not found). This commit wraps the entire execution logic in a try-except block that catches any error and prints a properly formatted JSON array containing a descriptive error message. This makes the tool more resilient and provides actionable feedback for debugging.",
        "timestamp": "2025-11-17T07:15:19.086Z",
        "action_counter": 48077
      }
    ]
  },
  "plan_path_to_target": {
    "description": "Generates a path to a target coordinate. NOTE: This tool only PLANS the path. You must set `buttons_to_press` to `['path']` to execute it. This version correctly treats all objects as impassable obstacles, finds an adjacent tile if the target is blocked, reads map markers to avoid off-screen obstacles, avoids pathing through warp tiles that would trigger a transition, dynamically handles water traversal, and now dynamically detects map boundaries to correctly handle negative coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef find_path():\n    try:\n        root = ET.fromstring(map_xml_string)\n    except ET.ParseError:\n        print(json.dumps({'error': 'Failed to parse map XML.'}))\n        return\n\n    try:\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n    except (ValueError, KeyError) as e:\n        print(json.dumps({'error': f'Invalid input data: {e}'}))\n        return\n\n    player_pos = None\n    player_tile_type = None\n    grid = {}\n    all_obstacles = set()\n    \n    all_x = []\n    all_y = []\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        all_y.append(y)\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            all_x.append(x)\n            grid[(x, y)] = tile_elem\n            if tile_elem.find('Player') is not None:\n                player_pos = (x, y)\n                player_tile_type = tile_elem.get('type')\n            if tile_elem.get('has-object') == 'true':\n                all_obstacles.add((x, y))\n    \n    if not all_x or not all_y:\n        print(json.dumps({'error': 'Map data is empty.'}))\n        return\n        \n    min_x, max_x = min(all_x), max(all_x)\n    min_y, max_y = min(all_y), max(all_y)\n\n    if not player_pos:\n        print(json.dumps({'error': 'Player position not found.'}))\n        return\n\n    impassable_tile_types = {\n        'WALL', 'VOID', 'PC', 'TV', 'COUNTER', 'BOOKSHELF', 'WINDOW',\n        'TOWN_MAP', 'POKEDEX', 'RADIO', 'PILLAR', 'MART_SHELF',\n        'INCENSE_BURNER', 'CUT_TREE', 'HEADBUTT_TREE', 'BUOY', 'unseen', 'WHIRLPOOL'\n    }\n    \n    if player_tile_type != 'WATER':\n        impassable_tile_types.add('WATER')\n\n    impassable_warps = {'DOOR', 'LADDER', 'STAIRCASE', 'PIT'}\n\n    print(f\"DEBUG: Player at {player_pos}, Target at ({target_x}, {target_y})\")\n    print(f\"DEBUG: Obstacles: {sorted(list(all_obstacles))}\")\n    \n    queue = deque([(player_pos, [])])\n    visited = {player_pos}\n    \n    target_is_impassable = False\n    target_tile = grid.get((target_x, target_y))\n    if target_tile is not None:\n        if (target_tile.get('type') in impassable_tile_types or (target_x, target_y) in all_obstacles):\n            target_is_impassable = True\n    else: \n        target_is_impassable = True\n    \n    path_found = False\n    loop_count = 0\n    while queue:\n        loop_count += 1\n        (x, y), path = queue.popleft()\n\n        if not target_is_impassable and (x, y) == (target_x, target_y):\n            print(f\"DEBUG: Path found in {loop_count} loops.\")\n            print(json.dumps(path + [{'x': x, 'y': y}]))\n            path_found = True\n            break\n        \n        if target_is_impassable:\n            for dx_adj, dy_adj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                if (x + dx_adj, y + dy_adj) == (target_x, target_y):\n                    print(f\"DEBUG: Path to adjacent tile found in {loop_count} loops.\")\n                    print(json.dumps(path + [{'x': x, 'y': y}]))\n                    path_found = True\n                    break\n            if path_found:\n                break\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = x + dx, y + dy\n            neighbor = (next_x, next_y)\n            \n            if not (min_x <= next_x <= max_x and min_y <= next_y <= max_y):\n                continue\n            if neighbor in visited:\n                continue\n\n            tile = grid.get(neighbor)\n            if tile is None:\n                continue\n            \n            tile_type = tile.get('type')\n            is_obstacle = neighbor in all_obstacles\n\n            if neighbor == (target_x, target_y):\n                print(f\"\\n--- DEBUG: CONSIDERING TARGET TILE {neighbor} ---\")\n                print(f\"  - In visited? {neighbor in visited}\")\n                print(f\"  - Tile type: {tile_type}\")\n                print(f\"  - Is obstacle? {is_obstacle}\")\n                print(f\"  - Is in impassable_tile_types? {tile_type in impassable_tile_types}\")\n                print(f\"  - Is warp & not target? {(tile_type in impassable_warps and neighbor != (target_x, target_y))}\")\n                print(f\"------------------------------------------------\\n\")\n            \n            if tile_type in impassable_tile_types:\n                continue\n            if is_obstacle:\n                continue\n            \n            if tile_type in impassable_warps and neighbor != (target_x, target_y):\n                continue\n\n            current_tile = grid.get((x, y))\n            if current_tile is None: continue\n            current_tile_type = current_tile.get('type')\n\n            if tile_type == 'LEDGE_HOP_DOWN' and dy == -1: continue\n            if tile_type == 'LEDGE_HOP_LEFT' and dx == 1: continue\n            if tile_type == 'LEDGE_HOP_RIGHT' and dx == -1: continue\n            if current_tile_type == 'LEDGE_HOP_DOWN' and dy == -1: continue\n            if current_tile_type == 'LEDGE_HOP_LEFT' and dx == 1: continue\n            if current_tile_type == 'LEDGE_HOP_RIGHT' and dx == -1: continue\n            if tile_type == 'FLOOR_UP_WALL' and dy == -1: continue\n            \n            visited.add(neighbor)\n            new_path = path + [{'x': x, 'y': y}]\n            queue.append((neighbor, new_path))\n    \n    if not path_found:\n        print(f\"DEBUG: No path found after {loop_count} loops. Visited {len(visited)} tiles.\")\n        print(json.dumps({'error': 'No path found.'}))\n    \nfind_path()\n",
    "history": [
      {
        "commit_message": "refactor: Rename tool to plan_path_to_target for clarity. The previous name 'path_and_execute_v3' was misleading, as the tool only generates a path plan, it does not execute it. This was the root cause of a multi-turn hallucination loop. The description has also been updated to explicitly state that `buttons_to_press` must be set to `['path']` to follow the generated route.",
        "timestamp": "2025-11-15T08:20:07.805Z",
        "action_counter": 43411
      },
      {
        "commit_message": "feat: Add map marker parsing to avoid obstacles. The tool was critically failing by pathing into off-screen obstacles like defeated trainers because it only considered objects currently visible. This commit adds logic to parse all <Marker> tags from the map XML and add their coordinates to the set of impassable obstacles, resolving this long-standing failure.",
        "timestamp": "2025-11-15T08:56:50.564Z",
        "action_counter": 43473
      },
      {
        "commit_message": "fix: Correct ledge logic for FLOOR_UP_WALL tiles. The previous implementation incorrectly blocked downward movement onto these tiles, treating them as climbable walls instead of ledges you jump down from. This critical error made it impossible to find paths in areas with ledges, such as Cianwood City. This commit corrects the check to block upward movement (dy == -1), resolving the pathfinding failure.",
        "timestamp": "2025-11-15T19:55:35.826Z",
        "action_counter": 44379
      },
      {
        "commit_message": "fix: Refine obstacle detection to ignore non-blocking markers. The tool was incorrectly treating all map markers, including 'üö™' for doors, as impassable obstacles. This critical error prevented it from finding valid paths that crossed tiles with warp markers. This commit changes the logic to only consider markers with the 'üìç' emoji as obstacles, resolving the pathfinding failure.",
        "timestamp": "2025-11-15T19:58:44.143Z",
        "action_counter": 44384
      },
      {
        "commit_message": "fix: Re-affirm BUOY as impassable tile. The pathfinder generated a path through a BUOY tile at (1, 16) on Route 41, causing a movement failure. Although 'BUOY' was already in the impassable list, this commit re-defines the tool to ensure the rule is correctly applied and prevent future pathing errors.",
        "timestamp": "2025-11-15T20:29:21.283Z",
        "action_counter": 44434
      },
      {
        "commit_message": "fix: Refine warp avoidance logic to allow traversal. The previous implementation treated all warp tiles as impassable, which was too restrictive and caused pathing to fail in areas like the Battle Tower lobby where traversing non-triggering `WARP_CARPET_DOWN` tiles is necessary. This commit changes the logic to only block pathing onto warp types that cause an immediate transition (like `DOOR` or `LADDER`), resolving the critical failure.",
        "timestamp": "2025-11-16T05:11:26.800Z",
        "action_counter": 45500
      },
      {
        "commit_message": "refactor: Add debug prints to trace pathfinding logic. The tool failed to find an obvious path in the Battle Tower lobby. This commit adds logging for the start/end points, detected obstacles, and loop/visited counts to help diagnose the failure.",
        "timestamp": "2025-11-16T14:39:30.610Z",
        "action_counter": 46329
      },
      {
        "commit_message": "fix: Add debug prints to diagnose player position error. The tool incorrectly identified the player's starting position in the previous turn. This commit adds two `print` statements: one to show the raw XML the tool receives, and another to log the exact coordinates where the `<Player/>` tag is found. This will help determine if the issue is with the input data or the parsing logic.",
        "timestamp": "2025-11-16T18:09:43.897Z",
        "action_counter": 46581
      },
      {
        "commit_message": "fix: Add verbose debug prints for path rejection. The tool is failing to find a clear path, indicating a logic error. This commit adds detailed print statements inside the main loop to log exactly why each potential neighbor tile is being rejected (e.g., impassable type, obstacle, ledge logic). This will provide the necessary data to diagnose and fix the root cause of the pathfinding failure.",
        "timestamp": "2025-11-16T18:50:07.166Z",
        "action_counter": 46632
      },
      {
        "commit_message": "fix: Add success-case logging for path expansion. The tool has been failing to find obvious paths. The existing debug prints only showed why tiles were rejected, making it impossible to trace the actual path being built. This commit adds a new print statement to log which neighbor tiles are successfully added to the queue, providing a complete execution trace to diagnose the root cause of the pathfinding failures.",
        "timestamp": "2025-11-16T18:57:43.198Z",
        "action_counter": 46639
      },
      {
        "commit_message": "fix: Remove map marker obstacle detection. The tool was incorrectly treating static 'üìç' markers as impassable obstacles. This was a critical flaw, as it created 'ghost' blockages at the last known positions of moving NPCs, causing pathfinding to fail even on clear paths. This commit removes the marker-based obstacle logic, relying solely on the live `has-object` attribute for accurate, real-time collision detection.",
        "timestamp": "2025-11-16T18:58:54.371Z",
        "action_counter": 46641
      },
      {
        "commit_message": "refactor: Re-add comprehensive debug logging. The tool is still failing to find clear paths. This commit re-introduces both rejection logging (to see why tiles are discarded) and success logging (to trace the actual path being built). This will provide a complete execution trace to diagnose the persistent root cause of the pathfinding failures.",
        "timestamp": "2025-11-16T19:02:58.937Z",
        "action_counter": 46646
      },
      {
        "commit_message": "debug: Add detailed log for target tile rejection. The tool is failing to find obvious paths. This commit adds a special, detailed print block that will trigger only when the target tile itself is being considered as a neighbor. This will log the state of all rejection conditions at that exact moment, providing the necessary data to diagnose why the target is being incorrectly discarded from the pathfinding queue.",
        "timestamp": "2025-11-17T10:41:26.702Z",
        "action_counter": 48358
      }
    ]
  },
  "select_move_tool": {
    "description": "A tool that takes a move slot number (1-4) as input and outputs the correct sequence of directional and action button presses to select and use that move in battle. MUST be called with autopress_buttons=true.",
    "input_schema": {
      "type": "object",
      "properties": {
        "current_cursor_position": {
          "type": "integer",
          "description": "The current position of the cursor (1-4)."
        },
        "target_move_slot": {
          "type": "integer",
          "description": "The target move slot to select (1-4)."
        }
      },
      "required": [
        "current_cursor_position",
        "target_move_slot"
      ]
    },
    "python_script": "import json\n\ncurrent_pos = int(input_data['current_cursor_position'])\ntarget_pos = int(input_data['target_move_slot'])\n\nmoves = []\ndifference = target_pos - current_pos\n\nif difference > 0:\n    for _ in range(difference):\n        moves.append('Down')\nelif difference < 0:\n    for _ in range(abs(difference)):\n        moves.append('Up')\n\nmoves.append('A')\n\nprint(json.dumps(moves))",
    "history": [
      {
        "commit_message": "feat: Create select_move_tool. This tool automates the process of selecting a move in battle, reducing the chance of manual error from incorrect directional inputs. It calculates the necessary 'Up' or 'Down' presses based on the current cursor position and the target move slot, then appends the 'A' button to execute the move. This addresses a recurring potential for mistakes during battle.",
        "timestamp": "2025-11-16T10:45:12.163Z",
        "action_counter": 46047
      },
      {
        "commit_message": "fix: Remove 'A' button press from output. The tool was critically failing because the system rejects mixed directional and action inputs in a single sequence. This commit removes the final 'A' press, making the tool only responsible for positioning the cursor. The user must now press 'A' manually on the following turn. The description has been updated to reflect this new, critical limitation.",
        "timestamp": "2025-11-16T11:30:23.710Z",
        "action_counter": 46111
      },
      {
        "commit_message": "feat: Re-add 'A' button press and update description. The tool was previously modified to remove the 'A' press due to a misunderstanding of system limitations. The `autopress_buttons` feature explicitly allows mixing directional and action inputs, making this change possible. This resolves the redundancy noted in the Overwatch critique by fully automating move selection and execution in a single call.",
        "timestamp": "2025-11-16T12:43:40.977Z",
        "action_counter": 46201
      }
    ]
  },
  "systematic_search_tool": {
    "description": "Analyzes a map layout and a list of already-checked tiles to generate a systematic, efficient search path for finding hidden interactions within the *currently reachable area*. Outputs the next target coordinates as a JSON object.",
    "input_schema": {
      "type": "object",
      "properties": {
        "checked_coordinates": {
          "type": "string",
          "description": "A JSON string of a list of objects, where each object has 'x' and 'y' keys for coordinates that have already been checked."
        },
        "searchable_tile_types": {
          "type": "string",
          "description": "A JSON string of a list of tile type strings to search for (e.g., 'WALL', 'BOOKSHELF')."
        }
      },
      "required": [
        "checked_coordinates",
        "searchable_tile_types"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    \n    checked_coords_list = json.loads(input_data['checked_coordinates'])\n    checked_coords_set = set((int(item['x']), int(item['y'])) for item in checked_coords_list)\n    searchable_tile_types = set(json.loads(input_data['searchable_tile_types']))\n    \n    grid = {}\n    player_pos = None\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            grid[(x, y)] = tile_elem\n            if tile_elem.find('Player') is not None:\n                player_pos = (x, y)\n\n    if not player_pos:\n        raise ValueError(\"Player position not found on the map.\")\n\n    impassable_types = {'WALL', 'VOID', 'PC', 'TV', 'COUNTER', 'BOOKSHELF', 'WINDOW', 'TOWN_MAP', 'POKEDEX', 'RADIO', 'PILLAR', 'MART_SHELF', 'CUT_TREE', 'HEADBUTT_TREE', 'BUOY', 'unseen', 'WHIRLPOOL', 'DOOR', 'LADDER', 'STAIRCASE', 'PIT'}\n\n    reachable_tiles = set()\n    queue = deque([player_pos])\n    visited = {player_pos}\n\n    while queue:\n        x, y = queue.popleft()\n        reachable_tiles.add((x, y))\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor_coord = (x + dx, y + dy)\n            if neighbor_coord in grid and neighbor_coord not in visited:\n                neighbor_tile = grid[neighbor_coord]\n                tile_type = neighbor_tile.get('type')\n                has_object = neighbor_tile.get('has-object') == 'true'\n                \n                if tile_type not in impassable_types and not has_object:\n                    visited.add(neighbor_coord)\n                    queue.append(neighbor_coord)\n\n    searchable_candidates = []\n    for x, y in sorted(list(grid.keys()), key=lambda c: (c[1], c[0])):\n        tile_elem = grid[(x,y)]\n        tile_type = tile_elem.get('type')\n\n        if tile_type in searchable_tile_types and (x, y) not in checked_coords_set:\n            is_accessible = False\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adjacent_coord = (x + dx, y + dy)\n                if adjacent_coord in reachable_tiles:\n                    is_accessible = True\n                    break\n            \n            if is_accessible:\n                searchable_candidates.append({'x': x, 'y': y})\n\n    next_target = searchable_candidates[0] if searchable_candidates else None\n\n    if next_target:\n        print(json.dumps({\n            \"search_complete\": False,\n            \"next_target_x\": next_target['x'],\n            \"next_target_y\": next_target['y']\n        }))\n    else:\n        print(json.dumps({\n            \"search_complete\": True,\n            \"next_target_x\": None,\n            \"next_target_y\": None\n        }))\n\nexcept Exception as e:\n    print(json.dumps({\"error\": str(e)}))",
    "history": [
      {
        "commit_message": "feat: Create systematic_search_tool. This tool automates finding the next searchable tile on a map, addressing a key inefficiency identified by the overwatch critique. It replaces the faulty concept of a search *agent* with a proper computational tool that parses map XML, making the process of finding hidden interactions more robust and efficient.",
        "timestamp": "2025-11-17T07:29:03.356Z",
        "action_counter": 48101
      },
      {
        "commit_message": "fix: Constrain search to reachable tiles. The tool was incorrectly searching the entire map, suggesting targets in inaccessible areas. This commit replaces the simple iteration with a Breadth-First Search (BFS) starting from the player's position to identify all reachable tiles, ensuring that the search is properly scoped to the current room or area. This resolves the critical failure where it suggested checking a wall in a completely separate part of the lighthouse.",
        "timestamp": "2025-11-17T09:47:54.533Z",
        "action_counter": 48292
      },
      {
        "commit_message": "debug: Add print statement for reachable_tiles. The tool is still failing to correctly scope its search to the current area. This commit adds a debug print to output the set of all tiles identified as reachable by the BFS. This will help diagnose why the search is leaking into inaccessible parts of the map.",
        "timestamp": "2025-11-17T09:50:13.821Z",
        "action_counter": 48294
      },
      {
        "commit_message": "refactor: Remove debug print statement. The tool's BFS logic was confirmed to be working correctly after diagnosing a player hallucination about the map layout. This commit removes the temporary `print` statement used for debugging the `reachable_tiles` set.",
        "timestamp": "2025-11-17T09:52:01.668Z",
        "action_counter": 48296
      }
    ]
  },
  "plan_path_with_warnings": {
    "description": "An advanced pathfinding tool that plans a path to a target coordinate and returns a list of warnings for any moving NPCs near the route, suggesting the use of 'stun_npc'.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef find_path_with_warnings():\n    try:\n        root = ET.fromstring(map_xml_string)\n        target_x = int(input_data['target_x'])\n        target_y = int(input_data['target_y'])\n    except (ET.ParseError, ValueError, KeyError) as e:\n        print(json.dumps({'error': f'Input or XML parsing error: {e}'}))\n        return\n\n    player_pos, player_tile_type = None, None\n    grid, all_obstacles, npcs = {}, set(), {}\n    all_x, all_y = [], []\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        all_y.append(y)\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            all_x.append(x)\n            grid[(x, y)] = tile_elem\n            if tile_elem.find('Player') is not None:\n                player_pos = (x, y)\n                player_tile_type = tile_elem.get('type')\n            if tile_elem.get('has-object') == 'true':\n                all_obstacles.add((x, y))\n                for obj in tile_elem.findall('Object'):\n                    obj_id = obj.get('id')\n                    if obj_id is not None:\n                        try:\n                            npc_id = int(obj_id)\n                            if npc_id > 0: npcs[npc_id] = (x, y)\n                        except (ValueError, TypeError): continue\n    \n    if not all_x or not all_y or not player_pos:\n        print(json.dumps({'error': 'Map or player data incomplete.'}))\n        return\n        \n    min_x, max_x, min_y, max_y = min(all_x), max(all_x), min(all_y), max(all_y)\n\n    impassable_tile_types = {'WALL', 'VOID', 'PC', 'TV', 'COUNTER', 'BOOKSHELF', 'WINDOW', 'TOWN_MAP', 'POKEDEX', 'RADIO', 'PILLAR', 'MART_SHELF', 'INCENSE_BURNER', 'CUT_TREE', 'HEADBUTT_TREE', 'BUOY', 'unseen', 'WHIRLPOOL'}\n    if player_tile_type != 'WATER': impassable_tile_types.add('WATER')\n    impassable_warps = {'DOOR', 'LADDER', 'STAIRCASE', 'PIT'}\n\n    queue = deque([(player_pos, [])])\n    visited = {player_pos}\n    \n    target_tile = grid.get((target_x, target_y))\n    target_is_impassable = (target_tile is None or target_tile.get('type') in impassable_tile_types or (target_x, target_y) in all_obstacles)\n    \n    final_path = None\n    while queue:\n        (x, y), path = queue.popleft()\n\n        if not target_is_impassable and (x, y) == (target_x, target_y):\n            final_path = path + [{'x': x, 'y': y}]; break\n        \n        if target_is_impassable:\n            for dx_adj, dy_adj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                if (x + dx_adj, y + dy_adj) == (target_x, target_y):\n                    final_path = path + [{'x': x, 'y': y}]; break\n            if final_path: break\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (x + dx, y + dy)\n            if not (min_x <= neighbor[0] <= max_x and min_y <= neighbor[1] <= max_y) or neighbor in visited: continue\n            tile = grid.get(neighbor)\n            if tile is None: continue\n            tile_type = tile.get('type')\n            if tile_type in impassable_tile_types or neighbor in all_obstacles: continue\n            if tile_type in impassable_warps and neighbor != (target_x, target_y): continue\n            current_tile_type = grid.get((x,y)).get('type')\n            if (tile_type == 'LEDGE_HOP_DOWN' and dy == -1 or tile_type == 'LEDGE_HOP_LEFT' and dx == 1 or tile_type == 'LEDGE_HOP_RIGHT' and dx == -1 or current_tile_type == 'LEDGE_HOP_DOWN' and dy == -1 or current_tile_type == 'LEDGE_HOP_LEFT' and dx == 1 or current_tile_type == 'LEDGE_HOP_RIGHT' and dx == -1 or tile_type == 'FLOOR_UP_WALL' and dy == -1): continue\n            visited.add(neighbor)\n            queue.append((neighbor, path + [{'x': x, 'y': y}]))\n    \n    if final_path:\n        warnings = []\n        path_coords = {(p['x'], p['y']) for p in final_path}\n        for npc_id, (nx, ny) in npcs.items():\n            for px, py in path_coords:\n                if abs(nx - px) + abs(ny - py) == 1:\n                    warnings.append(f'Path passes near moving NPC with ID {npc_id} at ({nx}, {ny}). Consider using stun_npc.')\n                    break\n        print(json.dumps({'path': final_path, 'warnings': sorted(list(set(warnings)))}))\n    else:\n        print(json.dumps({'error': 'No path found.'}))\n\nfind_path_with_warnings()",
    "history": [
      {
        "commit_message": "feat: Create plan_path_with_warnings tool. This addresses a critical overwatch critique regarding repeated pathing failures due to moving NPCs. This new tool enhances the existing pathfinding logic by identifying on-screen NPCs near the generated path and returning a list of warnings, prompting the user to consider using `stun_npc` for a more reliable execution. This is a direct, immediate action to improve my strategic toolkit.",
        "timestamp": "2025-11-17T11:46:53.310Z",
        "action_counter": 48451
      }
    ]
  }
}