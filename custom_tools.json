{
  "dungeon_navigator": {
    "description": "Generates a full, systematic exploration path for the current map segment using a proper DFS algorithm to visit every reachable, non-warp ground tile. This is the primary tool for clearing complex dungeons. The output is a JSON object with a 'path' key containing a list of coordinate objects, suitable for use with the `path_plan`.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n\n    grid = {}\n    for r in root.findall('Row'):\n        y = int(r.get('id'))\n        for t in r.findall('Tile'):\n            x = int(t.get('id'))\n            has_impassable_object = False\n            obj_node = t.find('Object')\n            if obj_node is not None and obj_node.get('id-name') != 'Pikachu':\n                has_impassable_object = True\n            grid[(x, y)] = {\n                'type': t.get('type'),\n                'has_object': has_impassable_object\n            }\n\n    impassable_types = ['impassable', 'unknown', 'cuttable', 'water', 'closed_gate']\n\n    stack = [(start_x, start_y)]\n    visited = set()\n    path = []\n    \n    while stack:\n        cx, cy = stack.pop()\n        \n        if (cx, cy) in visited:\n            continue\n        \n        visited.add((cx, cy))\n        path.append({'x': cx, 'y': cy})\n\n        # Add neighbors to the stack in a consistent order (reversed for LIFO stack)\n        for dx, dy in [(-1, 0), (1, 0), (0, 1), (0, -1)]:\n            nx, ny = cx + dx, cy + dy\n\n            if not (1 <= nx <= width and 1 <= ny <= height):\n                continue\n            \n            neighbor_tile = grid.get((nx, ny))\n            if not neighbor_tile or neighbor_tile['type'] in impassable_types or neighbor_tile['has_object']:\n                continue\n            \n            if neighbor_tile['type'] == 'ledge':\n                if dy == -1 or dx != 0:\n                    continue\n\n            if (nx, ny) not in visited:\n                stack.append((nx, ny))\n\n    print(json.dumps({'path_found': True, 'path': path}))\n\nexcept Exception as e:\n    print(json.dumps({'path_found': False, 'error': str(e)}))"
  },
  "map_segment_analyzer": {
    "description": "Analyzes the current map segment to find all reachable tiles, warps, and objects from the player's current position using a proper BFS. Handles `closed_gate` tiles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\nimport traceback\n\ndef analyze_segment_fixed(map_xml_string, start_x, start_y):\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        start_x, start_y = int(start_x), int(start_y)\n\n        grid = {}\n        for r in root.findall('Row'):\n            y = int(r.get('id'))\n            for t in r.findall('Tile'):\n                x = int(t.get('id'))\n                has_impassable_object = False\n                obj_node = t.find('Object')\n                if obj_node is not None and obj_node.get('id-name') != 'Pikachu':\n                    has_impassable_object = True\n                \n                grid[(x, y)] = {\n                    'type': t.get('type'),\n                    'has_object': has_impassable_object,\n                    'is_warp': t.get('is-warp') == 'true',\n                    'original_object_node': obj_node\n                }\n        \n        impassable_types = ['impassable', 'unknown', 'cuttable', 'water', 'closed_gate']\n        \n        queue = deque([(start_x, start_y)])\n        visited = set([(start_x, start_y)])\n        reachable_tiles_coords = set([(start_x, start_y)])\n        reachable_warps, reachable_objects = [], []\n\n        while queue:\n            cx, cy = queue.popleft()\n            \n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = cx + dx, cy + dy\n\n                if (nx, ny) not in visited:\n                    neighbor_data = grid.get((nx, ny))\n                    if neighbor_data:\n                        visited.add((nx, ny))\n                        if neighbor_data['type'] not in impassable_types and not neighbor_data['has_object']:\n                            reachable_tiles_coords.add((nx, ny))\n                            queue.append((nx, ny))\n        \n        for x, y in reachable_tiles_coords:\n            tile_data = grid.get((x, y))\n            if tile_data:\n                if tile_data['is_warp']:\n                    if {'x': x, 'y': y} not in reachable_warps:\n                        reachable_warps.append({'x': x, 'y': y})\n                \n                obj_node = tile_data['original_object_node']\n                if obj_node is not None:\n                    obj_data = {\n                        'id': obj_node.get('id'),\n                        'id-name': obj_node.get('id-name'),\n                        'name': obj_node.get('name'),\n                        'x': x,\n                        'y': y\n                    }\n                    if obj_data not in reachable_objects:\n                        reachable_objects.append(obj_data)\n\n        result = {\n            \"reachable_tiles_count\": len(reachable_tiles_coords),\n            \"reachable_warps\": reachable_warps,\n            \"reachable_objects\": reachable_objects,\n            \"segment_size\": len(reachable_tiles_coords)\n        }\n        return json.dumps(result, indent=2)\n        \n    except Exception as e:\n        return json.dumps({\"error\": str(e), \"traceback\": traceback.format_exc()})\n\nprint(analyze_segment_fixed(map_xml_string, input_data['start_x'], input_data['start_y']))"
  },
  "pathfinder": {
    "description": "Calculates the shortest path on the current map using BFS. Can optionally ignore certain impassable tile types.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "ignorable_impassable_types": {
          "type": "string",
          "description": "A comma-separated string of tile types to ignore as impassable (e.g., 'closed_gate,water')."
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    ignorable_types_str = input_data.get('ignorable_impassable_types', '')\n    ignorable_types = [t.strip() for t in ignorable_types_str.split(',') if t.strip()] if ignorable_types_str else []\n\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n\n    grid = {}\n    for r in root.findall('Row'):\n        y = int(r.get('id'))\n        for t in r.findall('Tile'):\n            x = int(t.get('id'))\n            has_impassable_object = False\n            obj_node = t.find('Object')\n            if obj_node is not None and obj_node.get('id-name') != 'Pikachu':\n                has_impassable_object = True\n            grid[(x, y)] = {\n                'type': t.get('type'),\n                'has_object': has_impassable_object\n            }\n\n    base_impassable = ['impassable', 'unknown', 'cuttable', 'water']\n    impassable_types = [t for t in base_impassable if t not in ignorable_types]\n    if 'closed_gate' not in ignorable_types:\n        impassable_types.append('closed_gate')\n\n    queue = deque([([ (start_x, start_y) ])])\n    visited = {(start_x, start_y)}\n\n    while queue:\n        path = queue.popleft()\n        cx, cy = path[-1]\n\n        if (cx, cy) == (end_x, end_y):\n            json_path = [{'x': p[0], 'y': p[1]} for p in path]\n            print(json.dumps({'path_found': True, 'path': json_path}))\n            exit()\n\n        current_tile = grid.get((cx, cy))\n        \n        if current_tile and current_tile['type'] == 'ledge':\n            nx, ny = cx, cy + 1\n            if (1 <= ny <= height):\n                landing_x, landing_y = nx, ny + 1\n                if (landing_x, landing_y) not in visited and (1 <= landing_y <= height):\n                     landing_tile = grid.get((landing_x, landing_y))\n                     if landing_tile and landing_tile['type'] not in impassable_types and not landing_tile['has_object']:\n                        visited.add((landing_x, landing_y))\n                        new_path = path + [(landing_x, landing_y)]\n                        queue.append(new_path)\n            continue\n\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = cx + dx, cy + dy\n\n            if not (1 <= nx <= width and 1 <= ny <= height) or (nx, ny) in visited:\n                continue\n\n            neighbor_tile = grid.get((nx, ny))\n            if not neighbor_tile:\n                continue\n\n            if neighbor_tile['type'] in impassable_types or neighbor_tile['has_object']:\n                continue\n            \n            if neighbor_tile['type'] == 'ledge':\n                if dy == -1 or dx != 0:\n                    continue\n            \n            visited.add((nx, ny))\n            new_path = path + [(nx, ny)]\n            queue.append(new_path)\n\n    print(json.dumps({'path_found': False, 'path': []}))\n\nexcept Exception as e:\n    print(json.dumps({'path_found': False, 'error': str(e)}))"
  },
  "wkg_checker": {
    "description": "Checks the World Knowledge Graph to see if a node or edge already exists based on its key properties, preventing duplicates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "element_type": {
          "type": "string",
          "enum": [
            "node",
            "edge"
          ]
        },
        "map_id": {
          "type": "string"
        },
        "x": {
          "type": "string"
        },
        "y": {
          "type": "string"
        },
        "to_map_id": {
          "type": "string"
        },
        "to_x": {
          "type": "string"
        },
        "to_y": {
          "type": "string"
        }
      },
      "required": [
        "element_type",
        "map_id",
        "x",
        "y"
      ]
    },
    "python_script": "import json\nwkg = json.loads(world_knowledge_graph_json_string)\nelement_type = input_data['element_type']\nmap_id = input_data['map_id']\nx = int(input_data['x'])\ny = int(input_data['y'])\nfound = False\n\nif element_type == 'node':\n    for node in wkg.get('nodes', []):\n        if node.get('map_id') == map_id and node.get('coordinates', {}).get('x') == x and node.get('coordinates', {}).get('y') == y:\n            found = True\n            break\nelif element_type == 'edge':\n    to_map_id = input_data['to_map_id']\n    to_x = int(input_data['to_x'])\n    to_y = int(input_data['to_y'])\n    \n    source_node_id = None\n    dest_node_id = None\n    \n    for node in wkg.get('nodes', []):\n        if node.get('map_id') == map_id and node.get('coordinates', {}).get('x') == x and node.get('coordinates', {}).get('y') == y:\n            source_node_id = node.get('id')\n        if node.get('map_id') == to_map_id and node.get('coordinates', {}).get('x') == to_x and node.get('coordinates', {}).get('y') == to_y:\n            dest_node_id = node.get('id')\n    \n    if source_node_id and dest_node_id:\n        for edge in wkg.get('edges', []):\n            s_id = edge.get('source_node_id')\n            d_id = edge.get('destination_node_id')\n            if (s_id == source_node_id and d_id == dest_node_id) or \\\n               (not edge.get('is_one_way', False) and s_id == dest_node_id and d_id == source_node_id):\n                found = True\n                break\n\nprint(json.dumps({'exists': found}))"
  },
  "object_finder": {
    "description": "Finds the coordinates of a named NPC or item on the current map by searching its `id-name` or `name` attribute.",
    "input_schema": {
      "type": "object",
      "properties": {
        "object_name": {
          "type": "string"
        }
      },
      "required": [
        "object_name"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\n\ntry:\n    object_name_to_find = input_data['object_name']\n    root = ET.fromstring(map_xml_string)\n    \n    found_objects = []\n\n    for r in root.findall('Row'):\n        for t in r.findall('Tile'):\n            for obj in t.findall('Object'):\n                id_name = obj.get('id-name', '')\n                event_name = obj.get('name', '')\n                \n                if object_name_to_find.lower() in id_name.lower() or object_name_to_find.lower() in event_name.lower():\n                    found_objects.append({\n                        'id-name': id_name,\n                        'name': event_name,\n                        'x': int(t.get('id')),\n                        'y': int(r.get('id'))\n                    })\n\n    if found_objects:\n        print(json.dumps({'found': True, 'objects': found_objects}))\n    else:\n        print(json.dumps({'found': False, 'message': f\"Object '{object_name_to_find}' not found on the current map.\"}))\n\nexcept Exception as e:\n    print(json.dumps({'found': False, 'error': str(e)}))"
  }
}