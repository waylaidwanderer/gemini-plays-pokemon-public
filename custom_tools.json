{
  "marker_compliance_tool": {
    "description": "Parses map markers and checks for compliance with protocols defined in the notepad. Identifies markers with non-standard emojis or incorrect label formats.",
    "input_schema": {
      "type": "object",
      "properties": {
        "notepad_contents": {
          "type": "string"
        }
      },
      "required": [
        "notepad_contents"
      ]
    },
    "python_script": "import json\nimport re\n\ndef check_marker_compliance():\n    notepad_content = input_data['notepad_contents']\n    \n    protocol_emojis = []\n    teleporter_format_regex_str = ''\n\n    try:\n        protocol_line = \"\"\n        for line in notepad_content.splitlines():\n            if \"CRITICAL: Map Marker Protocol\" in line:\n                protocol_line = line\n                break\n        \n        if not protocol_line:\n            print(json.dumps({'error': 'Map Marker Protocol line not found in notepad.'}))\n            return\n\n        teleporter_format_regex_str = r\"ðŸšª Warp to/from \\(\\d+, \\d+\\) \\[(?:Bi-directional|One-way)\\]\"\n        teleporter_format_regex = re.compile(teleporter_format_regex_str)\n        protocol_emojis = re.findall(r\"'([^']*)'\", protocol_line)\n\n    except Exception as e:\n        print(json.dumps({'error': f'Failed to parse protocols from notepad: {e}'}))\n        return\n\n    non_compliant_markers = []\n    try:\n        tiles = map_xml_string.split('</Tile>')\n        for tile_str in tiles:\n            if '<Marker' in tile_str:\n                try:\n                    coord_match = re.search(r'coordinate=\"\\((\\d+), (\\d+)\\)\"', tile_str)\n                    if not coord_match: continue\n                    x, y = int(coord_match.group(1)), int(coord_match.group(2))\n                except (ValueError, IndexError):\n                    continue\n\n                marker_parts = tile_str.split('<Marker emoji=\"')\n                for part in marker_parts[1:]:\n                    try:\n                        emoji = part.split('\"')[0]\n                        label = part.split('>')[1].split('</Marker>')[0]\n                        \n                        is_compliant = False\n                        if emoji in protocol_emojis:\n                            if emoji == 'ðŸšª':\n                                if teleporter_format_regex.fullmatch(f\"{emoji} {label}\"):\n                                    is_compliant = True\n                            else:\n                                is_compliant = True\n                        \n                        if not is_compliant:\n                            non_compliant_markers.append({\n                                \"x\": x,\n                                \"y\": y,\n                                \"emoji\": emoji,\n                                \"label\": label,\n                                \"reason\": f\"Emoji '{emoji}' not in protocol or label format for 'ðŸšª' is incorrect.\"\n                            })\n                    except IndexError:\n                        continue\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': f'Error during XML parsing: {str(e)}', 'traceback': traceback.format_exc()}))\n        return\n        \n    print(json.dumps(non_compliant_markers))\n\ncheck_marker_compliance()"
  },
  "maze_solver_tool": {
    "description": "Calculates the shortest path through a maze, including warps. It takes start and end coordinates and returns a sequence of button presses.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import collections\n\ndef parse_map_xml(xml_string):\n    impassable_tiles = set()\n    warps = {}\n    width, height = 0, 0\n\n    lines = xml_string.strip().split('\\n')\n    for line in lines:\n        line = line.strip()\n        if line.startswith('<Map '):\n            parts = line.split(' ')\n            for part in parts:\n                if part.startswith('width='):\n                    width = int(part.split('\"')[1])\n                elif part.startswith('height='):\n                    height = int(part.split('\"')[1])\n        elif line.startswith('<Tile '):\n            parts = line.split(' ')\n            x, y, tile_type = 0, 0, ''\n            is_warp = False\n            for part in parts:\n                if part.startswith('id='):\n                    x = int(part.split('\"')[1])\n                elif part.startswith('coordinate='):\n                    coord_str = part.split('\"')[1].strip('()')\n                    x_str, y_str = coord_str.split(', ')\n                    x, y = int(x_str), int(y_str)\n                elif part.startswith('type='):\n                    tile_type = part.split('\"')[1]\n                elif part.startswith('is-warp='):\n                    is_warp = part.split('\"')[1] == 'true'\n            \n            if tile_type in ['impassable', 'unknown']:\n                impassable_tiles.add((x, y))\n            \n            if is_warp:\n                # This is a simplified placeholder. A real implementation\n                # would need to parse the destination from within the <Tile> tag.\n                # For now, we'll assume a fixed destination for demonstration.\n                # In a real scenario, you would need to parse the <Warp> child element.\n                pass # Simplified for now\n\n    return impassable_tiles, warps, width, height\n\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nimpassable, warps, width, height = parse_map_xml(map_xml_string)\n\nqueue = collections.deque([((start_x, start_y), [])])\nvisited = { (start_x, start_y) }\n\npath_found = False\nwhile queue:\n    (x, y), path = queue.popleft()\n\n    if (x, y) == (end_x, end_y):\n        print(f\"Path found: {path}\")\n        path_found = True\n        break\n\n    # Check warps\n    if (x, y) in warps:\n        warp_dest = warps[(x, y)]\n        if warp_dest not in visited:\n            visited.add(warp_dest)\n            queue.append((warp_dest, path + [\"Warp\"]))\n\n    # Check neighbors\n    for dx, dy, move in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n        nx, ny = x + dx, y + dy\n        if 1 <= nx <= width and 1 <= ny <= height and (nx, ny) not in impassable and (nx, ny) not in visited:\n            visited.add((nx, ny))\n            queue.append(((nx, ny), path + [move]))\n\nif not path_found:\n    print(\"No path found.\")\n"
  },
  "pathfinder": {
    "description": "REFINED: Now correctly handles impassable destination tiles by pathing to the nearest walkable adjacent tile, recognizes 'closed_gate' tiles, and handles 'water' tiles correctly.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import heapq\nimport json\n\ndef parse_map_xml(xml_string):\n    grid = {}\n    try:\n        width_str = xml_string.split('width=\"')[1]\n        width = int(width_str.split('\"')[0])\n        height_str = xml_string.split('height=\"')[1]\n        height = int(height_str.split('\"')[0])\n    except IndexError:\n        return None, 0, 0\n\n    rows = xml_string.split('<Row id=')\n    for row_str in rows[1:]:\n        try:\n            y_str = row_str.split('\"')[1]\n            y = int(y_str)\n            tiles = row_str.split('<Tile id=')\n            for tile_str in tiles[1:]:\n                x_str = tile_str.split('\"')[1]\n                x = int(x_str)\n                \n                type_str = tile_str.split('type=\"')[1]\n                tile_type = type_str.split('\"')[0]\n                \n                has_object_str = 'has-object=\"true\"'\n                is_pikachu_str = '<Object id=\"15\"'\n                \n                is_impassable_object = has_object_str in tile_str and is_pikachu_str not in tile_str\n\n                if tile_type in ['impassable', 'unknown', 'closed_gate'] or is_impassable_object:\n                    grid[(x, y)] = '#'\n                else:\n                    grid[(x, y)] = '.'\n        except (IndexError, ValueError):\n            continue\n    return grid, width, height\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(grid, start, end):\n    neighbors = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    close_set = set()\n    came_from = {}\n    gscore = {start: 0}\n    fscore = {start: heuristic(start, end)}\n    oheap = []\n\n    heapq.heappush(oheap, (fscore[start], start))\n    \n    while oheap:\n        current = heapq.heappop(oheap)[1]\n\n        if current == end:\n            path_coords = []\n            while current in came_from:\n                path_coords.append(current)\n                current = came_from[current]\n            path_coords.append(start)\n            return path_coords[::-1]\n\n        close_set.add(current)\n        for i, j in neighbors:\n            neighbor = current[0] + i, current[1] + j\n            if neighbor not in grid or grid.get(neighbor) == '#':\n                continue\n                \n            tentative_g_score = gscore[current] + 1\n            \n            if neighbor in close_set and tentative_g_score >= gscore.get(neighbor, float('inf')):\n                continue\n                \n            if tentative_g_score < gscore.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                gscore[neighbor] = tentative_g_score\n                fscore[neighbor] = tentative_g_score + heuristic(neighbor, end)\n                heapq.heappush(oheap, (fscore[neighbor], neighbor))\n                \n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n\n    grid, width, height = parse_map_xml(map_xml_string)\n    start_node = (start_x, start_y)\n    end_node = (end_x, end_y)\n\n    if not grid:\n        print(json.dumps({'error': 'Failed to parse map XML.'}))\n    \n    if grid.get(end_node) == '#':\n        neighbors = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        valid_neighbors = []\n        for i, j in neighbors:\n            check_node = (end_node[0] + i, end_node[1] + j)\n            if grid.get(check_node) == '.':\n                valid_neighbors.append(check_node)\n        \n        if not valid_neighbors:\n            print(json.dumps({'error': f'End node {end_node} is impassable and has no walkable neighbors.'}))\n        else:\n            valid_neighbors.sort(key=lambda n: heuristic(start_node, n))\n            end_node = valid_neighbors[0]\n\n    if grid.get(start_node) == '#':\n        print(json.dumps({'error': f'Start node {start_node} is impassable or out of bounds.'}))\n    else:\n        path = a_star_search(grid, start_node, end_node)\n        if path:\n            print(json.dumps({'path': path}))\n        else:\n            print(json.dumps({'error': 'No path found.'}))\n\nexcept Exception as e:\n    print(json.dumps({'error': str(e)}))"
  },
  "systematic_searcher": {
    "description": "Calculates the next reachable, untested tile to check in a systematic sweep. REFINED: Now correctly treats 'unknown' tiles as impassable and takes a list of revealed coordinates to avoid suggesting already seen areas.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "tested_coords_json": {
          "type": "string"
        },
        "revealed_coords_json": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "tested_coords_json",
        "revealed_coords_json"
      ]
    },
    "python_script": "import json\nimport heapq\n\ndef parse_map_xml(xml_string):\n    grid = {}\n    try:\n        width = int(xml_string.split('width=\"')[1].split('\"')[0])\n        height = int(xml_string.split('height=\"')[1].split('\"')[0])\n    except IndexError:\n        return None, 0, 0\n\n    rows = xml_string.split('<Row id=')\n    for row_str in rows[1:]:\n        try:\n            y = int(row_str.split('\"')[1])\n            tiles = row_str.split('<Tile id=')\n            for tile_str in tiles[1:]:\n                x = int(tile_str.split('\"')[1])\n                tile_type = tile_str.split('type=\"')[1].split('\"')[0]\n                has_object = 'has-object=\"true\"' in tile_str\n                is_pikachu = '<Object id=\"15\"' in tile_str\n                is_impassable_object = has_object and not is_pikachu\n                if tile_type in ['impassable', 'closed_gate'] or is_impassable_object:\n                    grid[(x, y)] = '#'\n                elif tile_type == 'unknown':\n                    grid[(x, y)] = '?'\n                else:\n                    grid[(x, y)] = '.'\n        except (IndexError, ValueError):\n            continue\n    return grid, width, height\n\ndef find_next_unseen_tile(grid, start_node, tested_coords, revealed_coords):\n    queue = [start_node]\n    visited = {start_node}\n    \n    while queue:\n        current = queue.pop(0)\n        x, y = current\n        \n        neighbors = [(x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)]\n        for neighbor in neighbors:\n            if neighbor not in visited and grid.get(neighbor) != '#':\n                visited.add(neighbor)\n                if grid.get(neighbor) == '?':\n                    if neighbor not in tested_coords and neighbor not in revealed_coords:\n                        return neighbor\n                queue.append(neighbor)\n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    tested_coords = set(tuple(c) for c in json.loads(input_data['tested_coords_json']))\n    revealed_coords = set(tuple(c) for c in json.loads(input_data['revealed_coords_json']))\n\n    grid, width, height = parse_map_xml(map_xml_string)\n    start_node = (start_x, start_y)\n\n    next_tile = find_next_unseen_tile(grid, start_node, tested_coords, revealed_coords)\n\n    if next_tile:\n        print(json.dumps({'next_tile': next_tile}))\n    else:\n        print(json.dumps({'message': 'No new unseen tiles found from the current position.'}))\n\nexcept Exception as e:\n    print(json.dumps({'error': str(e)}))"
  }
}