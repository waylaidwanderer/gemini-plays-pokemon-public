{
  "path_master": {
    "description": "Finds the shortest path on the current map using A*. Avoids impassable tiles (including WALL, PILLAR, STATUE) and all objects, including off-screen ones identified by markers. This is a newly revised and more reliable version.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\nmap_xml_string = globals().get(\"map_xml_string\")\nroot = ET.fromstring(map_xml_string)\nmap_width = int(root.attrib['width'])\nmap_height = int(root.attrib['height'])\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\nstart_node = (start_x, start_y)\nend_node = (end_x, end_y)\n\ngrid = [['VOID' for _ in range(map_width + 1)] for _ in range(map_height + 1)]\nobstacles = set()\n\nimpassable_types = {\n    'WALL', 'VOID', 'PILLAR', 'COUNTER', 'MART_SHELF', 'BOOKSHELF', 'TV', \n    'RADIO', 'PC', 'TOWN_MAP', 'WINDOW', 'PAINTING', 'CUT_TREE', 'WATER', \n    'BUOY', 'STATUE'\n}\n\nfor row in root.findall('Row'):\n    y = int(row.attrib['id'])\n    for tile in row.findall('Tile'):\n        x = int(tile.attrib['id'])\n        tile_type = tile.attrib['type']\n        grid[y][x] = tile_type\n        \n        if tile_type in impassable_types:\n            obstacles.add((x, y))\n            continue\n            \n        if tile.attrib.get('has-object') == 'true':\n            obstacles.add((x, y))\n            \n        for marker in tile.findall('Marker'):\n            if marker.attrib.get('emoji') == '☠️':\n                obstacles.add((x, y))\n                break\n\ndef is_impassable(coord):\n    x, y = coord\n    if not (1 <= x <= map_width and 1 <= y <= map_height):\n        return True\n    if coord in obstacles:\n        return True\n    return False\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\nopen_set = []\nheapq.heappush(open_set, (0, start_node))\ncame_from = {}\ng_score = {start_node: 0}\nf_score = {start_node: heuristic(start_node, end_node)}\n\npath_found = False\nwhile open_set:\n    _, current = heapq.heappop(open_set)\n\n    if current == end_node:\n        path = []\n        while current in came_from:\n            path.append(f\"{current[0]},{current[1]}\")\n            current = came_from[current]\n        path.append(f\"{start_node[0]},{start_node[1]}\")\n        print(','.join(path[::-1]))\n        path_found = True\n        break\n\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        neighbor = (current[0] + dx, current[1] + dy)\n        if is_impassable(neighbor):\n            continue\n\n        tentative_g_score = g_score.get(current, float('inf')) + 1\n        if tentative_g_score < g_score.get(neighbor, float('inf')):\n            came_from[neighbor] = current\n            g_score[neighbor] = tentative_g_score\n            f_score[neighbor] = tentative_g_score + heuristic(neighbor, end_node)\n            if neighbor not in [i[1] for i in open_set]:\n                heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\nif not path_found:\n    print(\"No path found\")"
  }
}