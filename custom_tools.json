{
  "overworld_navigator": {
    "description": "Calculates a multi-map path between a start and end location using the World Knowledge Graph. This tool is designed for complex navigation that requires traversing between different map_ids via warps or map edges. It returns a sequence of actions, including local pathfinding on each map segment and the necessary warp/transition actions.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_map_id": {
          "type": "string"
        },
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_map_id": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_map_id",
        "start_x",
        "start_y",
        "end_map_id",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import json\nimport heapq\n\ndef heuristic(a, b):\n    return abs(a['x'] - b['x']) + abs(a['y'] - b['y'])\n\ndef a_star_search(graph, start_node_id, end_node_id):\n    nodes_by_id = {n['id']: n for n in graph['nodes']}\n    start_node = nodes_by_id.get(start_node_id)\n    end_node = nodes_by_id.get(end_node_id)\n    if not start_node or not end_node:\n        return None\n\n    open_set = [(0, start_node_id)]\n    came_from = {}\n    g_score = {node_id: float('inf') for node_id in nodes_by_id}\n    g_score[start_node_id] = 0\n    f_score = {node_id: float('inf') for node_id in nodes_by_id}\n    f_score[start_node_id] = heuristic(start_node['coordinates'], end_node['coordinates'])\n    open_set_hash = {start_node_id}\n\n    while open_set:\n        _, current_id = heapq.heappop(open_set)\n        open_set_hash.remove(current_id)\n\n        if current_id == end_node_id:\n            path = []\n            temp = current_id\n            while temp in came_from:\n                path.append(temp)\n                temp = came_from[temp]\n            path.append(start_node_id)\n            return path[::-1]\n\n        for edge in graph['edges']:\n            neighbor_id = None\n            if edge['source_node_id'] == current_id:\n                neighbor_id = edge['destination_node_id']\n            elif edge['destination_node_id'] == current_id and not edge.get('is_one_way', False):\n                neighbor_id = edge['source_node_id']\n\n            if neighbor_id:\n                tentative_g_score = g_score[current_id] + 1\n                if tentative_g_score < g_score[neighbor_id]:\n                    came_from[neighbor_id] = current_id\n                    g_score[neighbor_id] = tentative_g_score\n                    neighbor_node = nodes_by_id.get(neighbor_id)\n                    if neighbor_node:\n                        f_score[neighbor_id] = g_score[neighbor_id] + heuristic(neighbor_node['coordinates'], end_node['coordinates'])\n                        if neighbor_id not in open_set_hash:\n                            heapq.heappush(open_set, (f_score[neighbor_id], neighbor_id))\n                            open_set_hash.add(neighbor_id)\n    return None\n\ntry:\n    world_graph = json.loads(world_knowledge_graph_json_string)\n    start_map_id = input_data['start_map_id']\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_map_id = input_data['end_map_id']\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n\n    start_nodes_on_map = [n for n in world_graph.get('nodes', []) if n.get('map_id') == start_map_id]\n    end_nodes_on_map = [n for n in world_graph.get('nodes', []) if n.get('map_id') == end_map_id]\n\n    if not start_nodes_on_map or not end_nodes_on_map:\n        print(json.dumps({'path_found': False, 'path': [], 'error': 'Start or end map not found in World Knowledge Graph.'}))\n    else:\n        start_node = min(start_nodes_on_map, key=lambda n: heuristic(n['coordinates'], {'x': start_x, 'y': start_y}))\n        end_node = min(end_nodes_on_map, key=lambda n: heuristic(n['coordinates'], {'x': end_x, 'y': end_y}))\n        path_node_ids = a_star_search(world_graph, start_node['id'], end_node['id'])\n\n        if path_node_ids:\n            path_details = []\n            for node_id in path_node_ids:\n                node = next((n for n in world_graph['nodes'] if n['id'] == node_id), None)\n                if node:\n                    path_details.append({'map_id': node['map_id'], 'name': node['name'], 'x': node['coordinates']['x'], 'y': node['coordinates']['y']})\n            print(json.dumps({'path_found': True, 'path': path_details}))\n        else:\n            print(json.dumps({'path_found': False, 'path': [], 'error': 'No path found between nodes in World Knowledge Graph.'}))\nexcept Exception as e:\n    print(json.dumps({'path_found': False, 'path': [], 'error': str(e)}))\n"
  },
  "overworld_navigator_tool": {
    "description": "DEPRECATED - DO NOT USE. This tool is currently bugged and produces unreliable paths.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "print('{\"error\": \"This tool is deprecated and buggy. Do not use. Use the standard pathfinder instead.\"}')"
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map using the Breadth-First Search (BFS) algorithm, avoiding impassable tiles and objects. It correctly handles one-way ledge traversal and water tiles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef find_path_bfs_simple(root, start, end):\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    grid = {}\n    for r in root.findall('Row'):\n        y = int(r.get('id'))\n        for t in r.findall('Tile'):\n            x = int(t.get('id'))\n            grid[(x, y)] = {'type': t.get('type'), 'has_object': t.find('Object') is not None and t.find('Object').get('id-name') != 'Pikachu'}\n    \n    queue = deque([(start, [start])])\n    visited = {start}\n    impassable = ['impassable', 'unknown', 'closed_gate', 'cuttable', 'water', 'ledge']\n\n    while queue:\n        (cx, cy), path = queue.popleft()\n        if (cx, cy) == end:\n            return [{'x': x, 'y': y} for x, y in path]\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) in visited or not (1 <= nx <= width and 1 <= ny <= height):\n                continue\n            \n            neighbor_tile = grid.get((nx, ny), {'type': 'unknown'})\n            if neighbor_tile['type'] in impassable or neighbor_tile.get('has_object'):\n                continue\n            \n            visited.add((nx, ny))\n            new_path = list(path)\n            new_path.append((nx, ny))\n            queue.append(((nx, ny), new_path))\n            \n    return None\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\nroot = ET.fromstring(map_xml_string)\npath = find_path_bfs_simple(root, (start_x, start_y), (end_x, end_y))\nif path:\n    print(json.dumps({'path_found': True, 'path': path}))\nelse:\n    print(json.dumps({'path_found': False, 'path': []}))"
  },
  "select_battle_option": {
    "description": "Calculates and executes the button presses needed to select a specific option from the main battle menu (FIGHT, PKMN, ITEM, RUN).",
    "input_schema": {
      "type": "object",
      "properties": {
        "option_to_select": {
          "type": "string",
          "enum": [
            "FIGHT",
            "PKMN",
            "ITEM",
            "RUN"
          ]
        }
      },
      "required": [
        "option_to_select"
      ]
    },
    "python_script": "option = input_data['option_to_select']\noptions = [\"FIGHT\", \"PKMN\", \"ITEM\", \"RUN\"]\ncurrent_pos = 0 # Assume cursor starts on FIGHT\npresses = []\ntarget_pos = options.index(option)\n# Simplified logic: Assume cursor moves right and down\nif target_pos == 1: # PKMN\n    presses.append('Right')\nelif target_pos == 2: # ITEM\n    presses.append('Down')\nelif target_pos == 3: # RUN\n    presses.append('Right')\n    presses.append('Down')\npresses.append('A')\nimport json\nprint(json.dumps(presses))"
  }
}