{
  "find_unmarked_floor_tiles_v2_fixed": {
    "description": "Finds all FLOOR tiles on the current map within the specified bounds that do not have a map marker with the given emoji and do not contain any objects. Useful for tracking exploration or sweeping an area. Returns a list of coordinates or button strings. Excludes the player's current tile from targets.",
    "input_schema": {
      "properties": {
        "autopress_buttons": {
          "default": false,
          "description": "If true and the tool returns a list of buttons, they will be pressed automatically.",
          "type": "boolean"
        },
        "emoji": {
          "description": "The emoji of the marker to check for.",
          "type": "string"
        },
        "x_max": {
          "type": "integer"
        },
        "x_min": {
          "type": "integer"
        },
        "y_max": {
          "type": "integer"
        },
        "y_min": {
          "type": "integer"
        }
      },
      "required": [
        "x_min",
        "x_max",
        "y_min",
        "y_max",
        "emoji",
        "autopress_buttons"
      ],
      "type": "object"
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef find_unmarked():\n    try:\n        root = ET.fromstring(map_xml_string)\n        x_min, x_max = int(input_data['x_min']), int(input_data['x_max'])\n        y_min, y_max = int(input_data['y_min']), int(input_data['y_max'])\n        emoji = input_data['emoji']\n        autopress = bool(input_data.get('autopress_buttons', False))\n        \n        px, py = -1, -1\n        grid = {}\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                x = int(tile.attrib['id'])\n                if tile.find('Player') is not None or tile.attrib.get('has-player') == 'true':\n                    px, py = x, y\n                t_type = tile.attrib['type']\n                has_obj = tile.attrib.get('has-object') == 'true'\n                has_marker = any(m.attrib.get('emoji') == emoji for m in tile.findall('Marker'))\n                grid[(x, y)] = {'type': t_type, 'obj': has_obj, 'marker': has_marker}\n        \n        targets = []\n        for x in range(x_min, x_max + 1):\n            for y in range(y_min, y_max + 1):\n                if (x, y) in grid:\n                    # EXCLUDE current tile from targets to avoid standing still\n                    if x == px and y == py: continue\n                    t = grid[(x, y)]\n                    if t['type'] in ['FLOOR', 'GRASS', 'TALL_GRASS'] and not t['obj'] and not t['marker']:\n                        targets.append((x, y))\n        \n        if not targets:\n            print(json.dumps([]))\n            return\n            \n        if not autopress:\n            print(json.dumps([f\"({x}, {y})\" for x, y in targets]))\n            return\n\n        queue = deque([(px, py, [])])\n        visited = set([(px, py)])\n        passable = [\n            'FLOOR', 'TALL_GRASS', 'CAVE', 'GRASS', 'SAND', 'STAIRS', 'DOCK', 'WARP', \n            'STAIRCASE', 'ICE', 'WHIRLPOOL', 'WATER', 'DIRT', 'PATH', 'DOOR',\n            'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', 'WARP_CARPET_UP', 'WARP_CARPET_DOWN',\n            'LEDGE_HOP_DOWN', 'LEDGE_HOP_RIGHT', 'LEDGE_HOP_LEFT', 'FLOOR_UP_WALL'\n        ]\n        \n        while queue:\n            cx, cy, path = queue.popleft()\n            if (cx, cy) in targets:\n                print(json.dumps(path))\n                return\n            \n            current_tile_type = grid[(cx, cy)]['type']\n            for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n                nx, ny = cx + dx, cy + dy\n                if (nx, ny) in grid and (nx, ny) not in visited:\n                    target_tile = grid[(nx, ny)]\n                    \n                    # One-way logic\n                    if target_tile['type'] == 'LEDGE_HOP_DOWN' and btn != 'Down': continue\n                    if target_tile['type'] == 'LEDGE_HOP_LEFT' and btn != 'Left': continue\n                    if target_tile['type'] == 'LEDGE_HOP_RIGHT' and btn != 'Right': continue\n                    if current_tile_type == 'LEDGE_HOP_DOWN' and btn != 'Down': continue\n                    if current_tile_type == 'LEDGE_HOP_LEFT' and btn != 'Left': continue\n                    if current_tile_type == 'LEDGE_HOP_RIGHT' and btn != 'Right': continue\n\n                    if target_tile['type'] in passable and not target_tile['obj']:\n                        visited.add((nx, ny))\n                        queue.append((nx, ny, path + [btn]))\n        print(json.dumps([]))\n    except Exception as e:\n        print(json.dumps([str(e)]))\n\nfind_unmarked()",
    "history": [
      {
        "commit_message": "Fixed input schema to correctly handle autopress_buttons and updated logic to avoid type errors. Added logic to return button strings if autopress_buttons is True.",
        "timestamp": "2025-12-26T06:25:22.066Z",
        "action_counter": 21752
      },
      {
        "commit_message": "Fix find_unmarked_floor_tiles_v2_fixed to correctly return a JSON array of button strings when autopress_buttons is true, by implementing a basic BFS pathfinder within the tool.",
        "timestamp": "2025-12-26T12:31:45.484Z",
        "action_counter": 22582
      },
      {
        "commit_message": "Refine find_unmarked_floor_tiles_v2_fixed to exclude the player's current tile from targets and include ledge traversal logic.",
        "timestamp": "2025-12-26T12:35:05.377Z",
        "action_counter": 22591
      }
    ]
  },
  "find_path_v3": {
    "description": "Calculates a path between two coordinates on the current map using BFS, accounting for walls, objects, and avoiding unintentional warps. Returns a list of button strings. Updated to include more traversable tile types (including WARP_CARPET and STAIRS) and robust player position detection from the Mental Map.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer",
          "nullable": true
        },
        "start_y": {
          "type": "integer",
          "nullable": true
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "can_surf": {
          "type": "boolean",
          "default": false
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "end_x",
        "end_y",
        "autopress_buttons"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef solve():\n    root = ET.fromstring(map_xml_string)\n    \n    # Get current position from XML if not provided\n    start_x = input_data.get('start_x')\n    start_y = input_data.get('start_y')\n    \n    if start_x is None or start_y is None:\n        for row in root.findall('Row'):\n            y = int(row.attrib['id'])\n            for tile in row.findall('Tile'):\n                if tile.find('Player') is not None:\n                    start_x = int(tile.attrib['id'])\n                    start_y = y\n                    break\n            if start_x is not None: break\n\n    if start_x is None:\n        print(json.dumps([]))\n        return\n\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    can_surf = input_data.get('can_surf', False)\n\n    # Build grid\n    grid = {}\n    objects = set()\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            grid[(x, y)] = t_type\n            if tile.find('Object') is not None or tile.attrib.get('has-object') == 'true':\n                objects.add((x, y))\n\n    def is_traversable(x, y):\n        if (x, y) not in grid: return False\n        # Allow walking onto the target even if it has an object (e.g. interacting with an item)\n        if (x, y) in objects and (x, y) != (end_x, end_y): return False\n        \n        t_type = grid[(x, y)]\n        traversable_types = [\n            'FLOOR', 'TALL_GRASS', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT', \n            'WARP_CARPET_UP', 'WARP_CARPET_DOWN', 'CAVE', 'FLOOR_UP_WALL', \n            'STAIRS', 'WARP_CARPET'\n        ]\n        if t_type in traversable_types:\n            return True\n        if can_surf and t_type == 'WATER':\n            return True\n        return False\n\n    queue = deque([(start_x, start_y, [])])\n    visited = {(start_x, start_y)}\n    \n    while queue:\n        cx, cy, path = queue.popleft()\n        if (cx, cy) == (end_x, end_y):\n            print(json.dumps(path))\n            return\n\n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) not in visited and is_traversable(nx, ny):\n                visited.add((nx, ny))\n                queue.append((nx, ny, path + [btn]))\n\n    print(json.dumps([]))\n\nsolve()",
    "history": [
      {
        "commit_message": "Refined pathfinding with more robust tile type handling and improved BFS for overworld navigation.",
        "timestamp": "2025-12-26T16:54:12.345Z",
        "action_counter": 23112
      },
      {
        "commit_message": "Refined pathfinding with robust position detection and improved traversability checks for overworld navigation.",
        "timestamp": "2025-12-26T16:56:20.298Z",
        "action_counter": 23116
      }
    ]
  },
  "menu_navigator_v4_robust": {
    "description": "Navigates a vertical list (Bag, Pokedex, etc.) to a target string and selects it. Accounts for cursor position and scrolls if necessary. Supports menu borders. Optimized for the Johto main menu.",
    "input_schema": {
      "type": "object",
      "properties": {
        "screen_text": {
          "type": "string"
        },
        "target": {
          "type": "string"
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "screen_text",
        "target",
        "autopress_buttons"
      ]
    },
    "python_script": "import json\n\ndef solve():\n    text = input_data['screen_text']\n    target = input_data['target'].upper()\n    \n    lines = [line.strip() for line in text.split('\\n') if line.strip() and not all(c in '┌┐└┘─│' for c in line.strip())]\n    \n    # Identify options and current cursor position\n    options = []\n    cursor_idx = -1\n    for i, line in enumerate(lines):\n        clean_line = line.replace('▶', '').replace('▷', '').strip()\n        if '▶' in line or '▷' in line:\n            cursor_idx = len(options)\n        if clean_line:\n            options.append(clean_line)\n\n    if target not in options:\n        # Fallback for partial matches or common misspellings\n        for i, opt in enumerate(options):\n            if target in opt or opt in target:\n                target = opt\n                break\n        else:\n            print(json.dumps([]))\n            return\n\n    target_idx = options.index(target)\n    diff = target_idx - cursor_idx\n    \n    buttons = []\n    if diff > 0:\n        buttons.extend(['Down'] * diff)\n    elif diff < 0:\n        buttons.extend(['Up'] * abs(diff))\n    \n    buttons.append('A')\n    print(json.dumps(buttons))\n\nsolve()",
    "history": [
      {
        "commit_message": "Improved menu navigation with better target matching and border handling.",
        "timestamp": "2025-12-26T16:54:12.346Z",
        "action_counter": 23112
      }
    ]
  },
  "find_path_bfs_v2": {
    "description": "Finds a path between two coordinates on the current map using BFS, accounting for walls and objects. Returns a list of button strings. Designed for overworld navigation. Supports warp carpet exit directions.",
    "input_schema": {
      "properties": {
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "nullable": true,
          "type": "integer"
        },
        "start_y": {
          "nullable": true,
          "type": "integer"
        }
      },
      "required": [
        "end_x",
        "end_y"
      ],
      "type": "object"
    },
    "python_script": "import collections\nimport json\nimport xml.etree.ElementTree as ET\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n    except Exception:\n        print(json.dumps([]))\n        return\n\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    px, py = None, None\n    if input_data.get('start_x') is not None and input_data.get('start_y') is not None:\n        px, py = int(input_data['start_x']), int(input_data['start_y'])\n    else:\n        for row in root.findall('Row'):\n            for tile in row.findall('Tile'):\n                if tile.find('Player') is not None:\n                    px = int(tile.get('id'))\n                    py = int(row.get('id'))\n                    break\n            if px is not None: break\n\n    if px is None:\n        print(json.dumps([]))\n        return\n\n    target_x, target_y = int(input_data['end_x']), int(input_data['end_y'])\n    \n    impassable = set()\n    warp_tiles = {}\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            t_type = tile.get('type')\n            if t_type == 'WALL' or (tile.find('Object') is not None and tile.find('Player') is None):\n                impassable.add((x, y))\n            if 'WARP_CARPET' in t_type:\n                warp_tiles[(x, y)] = t_type\n    \n    queue = collections.deque([(px, py, [])])\n    visited = {(px, py)}\n    \n    while queue:\n        x, y, path = queue.popleft()\n        if x == target_x and y == target_y:\n            print(json.dumps(path))\n            return\n        \n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            nx, ny = x + dx, y + dy\n            \n            # Check for warp carpet exit\n            is_warp_exit = False\n            if (x, y) in warp_tiles:\n                wt = warp_tiles[(x, y)]\n                if (wt == 'WARP_CARPET_UP' and btn == 'Up') or \\\n                   (wt == 'WARP_CARPET_DOWN' and btn == 'Down') or \\\n                   (wt == 'WARP_CARPET_LEFT' and btn == 'Left') or \\\n                   (wt == 'WARP_CARPET_RIGHT' and btn == 'Right'):\n                    is_warp_exit = True\n\n            if 0 <= nx < width and 0 <= ny < height:\n                # Standard move or warp exit into wall\n                if (nx, ny) not in visited:\n                    if (nx, ny) not in impassable or is_warp_exit:\n                        visited.add((nx, ny))\n                        queue.append((nx, ny, path + [btn]))\n            elif is_warp_exit:\n                # Off-map movement\n                if (nx == target_x and ny == target_y):\n                    print(json.dumps(path + [btn]))\n                    return\n                \n    print(json.dumps([]))\n\nsolve()\n",
    "history": [
      {
        "commit_message": "Refined BFS to handle warp carpet directions and off-map movement.",
        "timestamp": "2025-12-27T01:12:08.762Z",
        "action_counter": 24302
      }
    ]
  },
  "navigate_fly_map_v1": {
    "description": "Navigates the Johto FLY map from a known starting city to a target city. City names: 'New Bark Town', 'Cherrygrove City', 'Violet City', 'Azalea Town', 'Goldenrod City', 'Ecruteak City', 'Olivine City', 'Cianwood City', 'Mahogany Town', 'Lake of Rage', 'Blackthorn City', 'Mt. Silver', 'Indigo Plateau'. Assumes the FLY map is already open.",
    "input_schema": {
      "properties": {
        "start_city": {
          "default": "New Bark Town",
          "type": "string"
        },
        "target_city": {
          "type": "string"
        }
      },
      "required": [
        "target_city"
      ],
      "type": "object"
    },
    "python_script": "import json\n\ndef navigate_fly_map(target_city, start_city=\"New Bark Town\"):\n    cities = [\n        \"New Bark Town\", \"Cherrygrove City\", \"Violet City\", \"Azalea Town\",\n        \"Goldenrod City\", \"Ecruteak City\", \"Olivine City\", \"Cianwood City\",\n        \"Mahogany Town\", \"Lake of Rage\", \"Blackthorn City\", \"Mt. Silver\", \"Indigo Plateau\"\n    ]\n    \n    if target_city not in cities or start_city not in cities:\n        print(json.dumps([]))\n        return\n\n    start_idx = cities.index(start_city)\n    target_idx = cities.index(target_city)\n    diff = target_idx - start_idx\n    \n    buttons = []\n    if diff > 0:\n        buttons = [\"Up\"] * diff\n    elif diff < 0:\n        buttons = [\"Down\"] * abs(diff)\n    \n    buttons.append(\"A\")\n    print(json.dumps(buttons))\n\nimport sys\ninput_data = json.load(sys.stdin)\nnavigate_fly_map(input_data['target_city'], input_data.get('start_city', 'New Bark Town'))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-27T02:51:15.614Z",
        "action_counter": 24545
      }
    ]
  }
}