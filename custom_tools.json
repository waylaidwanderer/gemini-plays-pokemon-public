{
  "give_item_v1_refined": {
    "description": "Gives an item from the PACK to a Pokémon. Assumes overworld. Parameters: item_index (0-indexed position in the current pocket), pokemon_index (1-indexed position in the party), current_menu_index (0-indexed position of the menu cursor, POKEDEX=0, EXIT=7).",
    "input_schema": {
      "type": "object",
      "properties": {
        "item_index": {
          "type": "integer",
          "description": "0-indexed position of the item in the current pocket"
        },
        "pokemon_index": {
          "type": "integer",
          "description": "1-indexed position of the Pokémon in the party"
        },
        "current_menu_index": {
          "type": "integer",
          "description": "0-indexed position of the current menu cursor (POKEDEX=0, EXIT=7)"
        }
      },
      "required": [
        "item_index",
        "pokemon_index",
        "current_menu_index"
      ]
    },
    "python_script": "\nimport json\n\ndef main():\n    item_index = int(input_data['item_index'])\n    pokemon_index = int(input_data['pokemon_index'])\n    current_menu_index = int(input_data['current_menu_index'])\n    \n    buttons = [\"Start\", \"sleep 500\"]\n    \n    # Navigate to Pack (index 2)\n    diff = 2 - current_menu_index\n    if diff > 0:\n        for _ in range(diff):\n            buttons.append(\"Down\")\n    elif diff < 0:\n        for _ in range(abs(diff)):\n            buttons.append(\"Up\")\n            \n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # Navigate to Item\n    for _ in range(item_index):\n        buttons.append(\"Down\")\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # Select GIVE (2nd option)\n    buttons.append(\"Down\")\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    \n    # Select Pokemon\n    for _ in range(pokemon_index - 1):\n        buttons.append(\"Down\")\n    buttons.append(\"A\")\n    buttons.append(\"sleep 1000\")\n    \n    # Clear text\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    buttons.append(\"A\")\n    \n    print(json.dumps(buttons))\n\nif __name__ == \"__main__\":\n    main()\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-19T10:55:52.584Z",
        "action_counter": 3933
      }
    ]
  },
  "press_sequence": {
    "description": "Executes a specific sequence of button presses, allowing for mixed directional and action inputs. Useful for complex menu navigation.",
    "input_schema": {
      "type": "object",
      "properties": {
        "buttons": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "buttons"
      ]
    },
    "python_script": "import json\nprint(json.dumps(input_data['buttons']))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-18T06:11:16.135Z",
        "action_counter": 948
      }
    ]
  },
  "find_path": {
    "description": "Finds the shortest path to a target coordinate, correctly handling all collision types, one-way ledges, and treating 'unseen' tiles as traversable. Treats tiles with is-warp=\"true\" or markers as impassable unless they are the target. Returns a list of coordinate objects.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef solve():\n    try:\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        print(f\"Error parsing map_xml_string: {e}\")\n        return\n\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    player_x, player_y = -1, -1\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            if tile.find('Player') is not None:\n                player_x = int(tile.attrib['id'])\n                player_y = y\n                break\n        if player_x != -1:\n            break\n            \n    if player_x == -1:\n        print(\"Player position not found.\")\n        return\n\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n\n    impassable_types = {\"WALL\", \"WATER\", \"HEADBUTT_TREE\", \"CUT_TREE\", \"BOOKSHELF\", \"PC\", \"TOWN_MAP\", \"WINDOW\"}\n\n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            has_obj = tile.attrib.get('has-object') == 'true'\n            is_warp = tile.attrib.get('is-warp') == 'true'\n            has_marker = tile.find('Marker') is not None\n            grid[(x, y)] = (t_type, has_obj, is_warp, has_marker)\n\n    queue = deque([(player_x, player_y, [{\"x\": player_x, \"y\": player_y}])])\n    visited = {(player_x, player_y)}\n    \n    while queue:\n        x, y, path = queue.popleft()\n        \n        if x == target_x and y == target_y:\n            print(json.dumps(path))\n            return\n            \n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:\n                t_info = grid.get((nx, ny))\n                if not t_info: continue\n                t_type, has_obj, is_warp, has_marker = t_info\n                \n                is_target = (nx == target_x and ny == target_y)\n                is_obstacle = has_obj or (is_warp and not is_target) or (has_marker and not is_target)\n\n                is_passable = (t_type not in impassable_types and not is_obstacle) or t_type == \"unseen\"\n                \n                is_blocked = False\n                curr_type, _, _, _ = grid[(x, y)]\n                if \"LEDGE_HOP_DOWN\" in curr_type and dy != 1: is_blocked = True\n                if \"LEDGE_HOP_UP\" in curr_type and dy != -1: is_blocked = True\n                if \"LEDGE_HOP_LEFT\" in curr_type and dx != -1: is_blocked = True\n                if \"LEDGE_HOP_RIGHT\" in curr_type and dx != 1: is_blocked = True\n                \n                if \"LEDGE_HOP_DOWN\" in t_type and dy == -1: is_blocked = True\n                if \"LEDGE_HOP_UP\" in t_type and dy == 1: is_blocked = True\n                if \"LEDGE_HOP_LEFT\" in t_type and dx == 1: is_blocked = True\n                if \"LEDGE_HOP_RIGHT\" in t_type and dx == -1: is_blocked = True\n\n                if not is_blocked:\n                    if is_passable:\n                        visited.add((nx, ny))\n                        queue.append((nx, ny, path + [{\"x\": nx, \"y\": ny}]))\n\n    print(\"No path found.\")\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-20T01:20:05.033Z",
        "action_counter": 4861
      },
      {
        "commit_message": "Treat tiles with is-warp=\"true\" as impassable to avoid falling into holes.",
        "timestamp": "2025-12-20T01:47:21.967Z",
        "action_counter": 4928
      },
      {
        "commit_message": "Treat tiles with markers as impassable unless they are the target tile. This prevents walking through NPCs or into known holes.",
        "timestamp": "2025-12-20T01:48:12.765Z",
        "action_counter": 4929
      }
    ]
  },
  "get_reachable_unseen_tiles_v1": {
    "description": "Finds all reachable unseen tiles on the current map using the Mental Map XML. Returns a list of coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef find_reachable_unseen():\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    # Map layout and player position\n    grid = {}\n    player_pos = None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tile_type = tile.attrib['type']\n            seen = tile.attrib['seen'] == 'true'\n            is_warp = tile.attrib['is-warp'] == 'true'\n            has_object = tile.attrib.get('has-object') == 'true'\n            \n            grid[(x, y)] = {\n                'type': tile_type,\n                'seen': seen,\n                'is_warp': is_warp,\n                'has_object': has_object\n            }\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n\n    if not player_pos:\n        return []\n\n    # BFS to find reachable tiles\n    reachable_unseen = set()\n    visited = set()\n    queue = deque([player_pos])\n    visited.add(player_pos)\n    \n    while queue:\n        cx, cy = queue.popleft()\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            \n            if (nx, ny) not in grid:\n                continue\n            \n            tile = grid[(nx, ny)]\n            \n            if not tile['seen']:\n                reachable_unseen.add((nx, ny))\n                continue\n                \n            if (nx, ny) not in visited:\n                # Basic collision check: FLOOR and seen warps are walkable\n                # Objects and WALLs are not.\n                if tile['type'] == 'FLOOR' and not tile['has_object']:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n                    \n    return sorted(list(reachable_unseen))\n\nreachable = find_reachable_unseen()\nprint(reachable)\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-20T02:20:21.962Z",
        "action_counter": 4983
      }
    ]
  }
}