{
  "get_type_effectiveness_gen2": {
    "description": "Returns the type effectiveness multiplier for an attack in Gen 2 Pokemon Crystal.",
    "input_schema": {
      "properties": {
        "attacking_type": {
          "description": "The type of the move being used.",
          "type": "string"
        },
        "defending_type1": {
          "description": "The first type of the defending Pokemon.",
          "type": "string"
        },
        "defending_type2": {
          "description": "The second type of the defending Pokemon (optional).",
          "nullable": true,
          "type": "string"
        }
      },
      "required": [
        "attacking_type",
        "defending_type1"
      ],
      "type": "object"
    },
    "python_script": "import json\n\ndef get_effectiveness():\n    attacking_type = input_data.get('attacking_type').upper()\n    def1 = input_data.get('defending_type1').upper()\n    def2 = input_data.get('defending_type2')\n    if def2: def2 = def2.upper()\n    \n    chart = {\n        \"NORMAL\": {\"ROCK\": 0.5, \"GHOST\": 0, \"STEEL\": 0.5},\n        \"FIRE\": {\"FIRE\": 0.5, \"WATER\": 0.5, \"GRASS\": 2, \"ICE\": 2, \"BUG\": 2, \"ROCK\": 0.5, \"DRAGON\": 0.5, \"STEEL\": 2},\n        \"WATER\": {\"FIRE\": 2, \"WATER\": 0.5, \"GRASS\": 0.5, \"GROUND\": 2, \"ROCK\": 2, \"DRAGON\": 0.5},\n        \"ELECTRIC\": {\"WATER\": 2, \"ELECTRIC\": 0.5, \"GRASS\": 0.5, \"GROUND\": 0, \"FLYING\": 2, \"DRAGON\": 0.5},\n        \"GRASS\": {\"FIRE\": 0.5, \"WATER\": 2, \"GRASS\": 0.5, \"POISON\": 0.5, \"GROUND\": 2, \"FLYING\": 0.5, \"BUG\": 0.5, \"ROCK\": 2, \"DRAGON\": 0.5, \"STEEL\": 0.5},\n        \"ICE\": {\"FIRE\": 0.5, \"WATER\": 0.5, \"GRASS\": 2, \"ICE\": 0.5, \"GROUND\": 2, \"FLYING\": 2, \"DRAGON\": 2, \"STEEL\": 0.5},\n        \"FIGHTING\": {\"NORMAL\": 2, \"ICE\": 2, \"POISON\": 0.5, \"FLYING\": 0.5, \"PSYCHIC\": 0.5, \"BUG\": 0.5, \"ROCK\": 2, \"GHOST\": 0, \"DARK\": 2, \"STEEL\": 2},\n        \"POISON\": {\"GRASS\": 2, \"POISON\": 0.5, \"GROUND\": 0.5, \"ROCK\": 0.5, \"GHOST\": 0.5, \"STEEL\": 0},\n        \"GROUND\": {\"FIRE\": 2, \"ELECTRIC\": 2, \"GRASS\": 0.5, \"POISON\": 2, \"FLYING\": 0, \"BUG\": 0.5, \"ROCK\": 2, \"STEEL\": 2},\n        \"FLYING\": {\"ELECTRIC\": 0.5, \"GRASS\": 2, \"FIGHTING\": 2, \"BUG\": 2, \"ROCK\": 0.5, \"STEEL\": 0.5},\n        \"PSYCHIC\": {\"FIGHTING\": 2, \"POISON\": 2, \"PSYCHIC\": 0.5, \"DARK\": 0, \"STEEL\": 0.5},\n        \"BUG\": {\"FIRE\": 0.5, \"GRASS\": 2, \"POISON\": 0.5, \"FIGHTING\": 0.5, \"FLYING\": 0.5, \"PSYCHIC\": 2, \"GHOST\": 0.5, \"DARK\": 2, \"STEEL\": 0.5},\n        \"ROCK\": {\"FIRE\": 2, \"ICE\": 2, \"FIGHTING\": 0.5, \"GROUND\": 0.5, \"FLYING\": 2, \"BUG\": 2, \"STEEL\": 0.5},\n        \"GHOST\": {\"NORMAL\": 0, \"PSYCHIC\": 2, \"GHOST\": 2, \"DARK\": 0.5, \"STEEL\": 0.5},\n        \"DRAGON\": {\"DRAGON\": 2, \"STEEL\": 0.5},\n        \"DARK\": {\"FIGHTING\": 0.5, \"PSYCHIC\": 2, \"GHOST\": 2, \"DARK\": 0.5, \"STEEL\": 0.5},\n        \"STEEL\": {\"FIRE\": 0.5, \"WATER\": 0.5, \"ELECTRIC\": 0.5, \"ICE\": 2, \"ROCK\": 2, \"STEEL\": 0.5}\n    }\n    \n    eff = chart.get(attacking_type, {}).get(def1, 1.0)\n    if def2:\n        eff *= chart.get(attacking_type, {}).get(def2, 1.0)\n    \n    print(json.dumps({\"multiplier\": eff}))\n\nif __name__ == \"__main__\":\n    get_effectiveness()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-23T09:05:37.668Z",
        "action_counter": 14041
      },
      {
        "commit_message": "Fixed the tool to actually print the result using input_data.",
        "timestamp": "2025-12-23T09:26:49.920Z",
        "action_counter": 14085
      },
      {
        "commit_message": "Defining the missing type effectiveness tool for Gen 2.",
        "timestamp": "2025-12-23T12:40:44.706Z",
        "action_counter": 14405
      }
    ]
  },
  "use_pokemon_move_v1": {
    "description": "Uses a specific move from a Pokémon in the party. Cursor-agnostic: clears menus, opens Start, navigates to POKEMON, selects the target Pokémon, and executes the field move. Requires current cursor indices for the Start and Party menus. Assumes pop-up menu cursor starts on the first field move (or STATS if no FM).",
    "input_schema": {
      "properties": {
        "current_party_index": {
          "description": "The 1-based index of the Party menu cursor (1-7, where 7 is CANCEL). Use 1 if just opening the menu.",
          "type": "integer"
        },
        "current_start_index": {
          "description": "The 1-based index of the Start menu cursor.",
          "type": "integer"
        },
        "move_index": {
          "description": "The 1-based index of the move in the Pokémon's move list (1-4).",
          "type": "integer"
        },
        "pokemon_slot": {
          "description": "The 1-based index of the Pokémon in the party (1-6).",
          "type": "integer"
        }
      },
      "required": [
        "pokemon_slot",
        "move_index",
        "current_start_index",
        "current_party_index"
      ],
      "type": "object"
    },
    "python_script": "import json\n\ndef navigate_wrapping_menu(current, target, total):\n    diff = (target - current) % total\n    if diff == 0:\n        return []\n    if diff <= total // 2:\n        return [\"Down\"] * diff\n    else:\n        return [\"Up\"] * (total - diff)\n\ndef use_pokemon_move():\n    try:\n        slot = int(input_data.get('pokemon_slot', 6))\n        move = int(input_data.get('move_index', 2))\n        start_idx = int(input_data.get('current_start_index', 2))\n        party_idx = int(input_data.get('current_party_index', 1))\n    except (ValueError, TypeError):\n        slot, move, start_idx, party_idx = 6, 2, 2, 1\n\n    buttons = [\"B\", \"B\", \"B\", \"B\", \"sleep 500\", \"Start\", \"sleep 500\"]\n\n    # 1. Start Menu (8 items): 1.POKEDEX, 2.POKEMON...\n    buttons.extend(navigate_wrapping_menu(start_idx, 2, 8))\n    buttons.extend([\"A\", \"sleep 500\"])\n\n    # 2. Party Menu (7 items: 1-6 + CANCEL). Resets to Slot 1 on open.\n    buttons.extend(navigate_wrapping_menu(party_idx, slot, 7))\n    buttons.extend([\"A\", \"sleep 500\"])\n\n    # 3. Pop-up Menu. Field moves are at the top. Cursor starts on Index 1.\n    # FM positions for KIMCHI: 1: Sweet Scent (move 2), 2: Cut (move 3)\n    target_idx = 1\n    if slot == 6 and move == 3: target_idx = 2\n    \n    # Menu size for wrapping logic\n    fm_counts = {1:0, 2:1, 3:1, 4:1, 5:0, 6:2}\n    num_fm = fm_counts.get(slot, 0)\n    menu_size = 5 + num_fm\n\n    buttons.extend(navigate_wrapping_menu(1, target_idx, menu_size))\n    buttons.append(\"A\")\n    print(json.dumps(buttons))\n\nif __name__ == \"__main__\":\n    use_pokemon_move()",
    "history": [
      {
        "commit_message": "Creating a robust, parameterized tool for using a Pokémon's move from the overworld menu. Replaces the hardcoded Sweet Scent tool.",
        "timestamp": "2025-12-23T11:38:00.524Z",
        "action_counter": 14311
      },
      {
        "commit_message": "Refining tool to use relative navigation in wrapping menus. Added start_menu_index parameter. Replaced hardcoded sequence with logic that accounts for cursor state.",
        "timestamp": "2025-12-23T11:39:54.572Z",
        "action_counter": 14315
      },
      {
        "commit_message": "Reverting to absolute reset logic for Start and Party menus for maximum reliability. Cursor-agnostic move usage.",
        "timestamp": "2025-12-23T11:45:36.873Z",
        "action_counter": 14325
      },
      {
        "commit_message": "Refining use_pokemon_move_v1 to correctly handle the overworld pop-up menu structure in Pokémon Crystal, where field moves are listed directly at the top. Specifically optimized for KIMCHI's Sweet Scent.",
        "timestamp": "2025-12-23T11:48:30.650Z",
        "action_counter": 14328
      },
      {
        "commit_message": "Refining move tool to use a reliable Down-reset for the Start menu and relative navigation for the fully-wrapping Party menu. Added current_party_index and current_start_index parameters.",
        "timestamp": "2025-12-23T11:53:53.038Z",
        "action_counter": 14333
      },
      {
        "commit_message": "Refining move tool to use correct relative navigation for fully-wrapping menus. Added current_party_index and current_start_index parameters. Optimized pathfinding for the shortest direction.",
        "timestamp": "2025-12-23T11:55:40.410Z",
        "action_counter": 14335
      },
      {
        "commit_message": "Refining move tool to use correct relative navigation for fully-wrapping menus. Added current_party_index and current_start_index parameters. Optimized pathfinding for the shortest direction. Ensure defaults match post-battle state.",
        "timestamp": "2025-12-23T12:12:09.641Z",
        "action_counter": 14355
      },
      {
        "commit_message": "Refining move tool to handle pop-up menu navigation starting from 'STATS'. Optimized for the current team's field moves.",
        "timestamp": "2025-12-23T12:14:58.831Z",
        "action_counter": 14358
      },
      {
        "commit_message": "Refining move tool: Cursor in pop-up menu starts on index 1 (first FM or STATS). Fixed target calculation for Sweet Scent. Assumes Party menu resets to Slot 1 upon opening.",
        "timestamp": "2025-12-23T12:17:56.169Z",
        "action_counter": 14361
      }
    ]
  },
  "select_battle_move_refined": {
    "description": "Selects a move from the battle move menu. Automatically detects the current cursor position from screen text. Takes the 1-based index of the move to select (1-4). Accounts for menu wrapping. Navigation is restricted to Up/Down buttons only.",
    "input_schema": {
      "type": "object",
      "properties": {
        "move_index": {
          "type": "integer",
          "minimum": 1,
          "maximum": 4,
          "description": "The 1-based index of the move to select (1-4)."
        },
        "screen_text": {
          "type": "string",
          "description": "The current screen text containing the move menu."
        }
      },
      "required": [
        "move_index",
        "screen_text"
      ]
    },
    "python_script": "import json\nimport sys\nimport re\n\ndef main():\n    try:\n        input_raw = sys.stdin.read()\n        if not input_raw:\n            print(json.dumps([\"A\"]))\n            return\n        input_data = json.loads(input_raw)\n        target_index = int(input_data.get('move_index', 1))\n        screen_text = input_data.get('screen_text', \"\")\n        \n        lines = screen_text.split('\\n')\n        move_lines = []\n        for line in lines:\n            # Move slots in battle contain vertical bars but not horizontal lines or headers\n            if '\\u2502' in line and not any(c in line for c in ['\\u250c', '\\u2510', '\\u2514', '\\u2518', '\\u2500']):\n                if any(c.isalpha() or c == '-' for c in line) and \"TYPE\" not in line:\n                    move_lines.append(line)\n        \n        # Determine current index by searching for cursor ▶ (\\u25b6)\n        current_index = 1\n        for i, line in enumerate(move_lines):\n            if '\\u25b6' in line or '▶' in line:\n                current_index = i + 1\n                break\n        \n        buttons = []\n        if current_index != target_index:\n            diff = target_index - current_index\n            # Shortest path wrapping logic for 4 items\n            if diff == 1 or diff == -3:\n                buttons.append(\"Down\")\n            elif diff == 2 or diff == -2:\n                buttons.extend([\"Down\", \"Down\"])\n            elif diff == 3 or diff == -1:\n                buttons.append(\"Up\")\n        \n        buttons.append(\"A\")\n        print(json.dumps(buttons))\n    except Exception:\n        print(json.dumps([\"A\"]))\n\nif __name__ == \"__main__\":\n    main()\n",
    "history": [
      {
        "commit_message": "Refine move selection logic to use print() for JSON output and improve move line filtering. Navigation restricted to Up/Down.",
        "timestamp": "2025-12-23T13:30:50.096Z",
        "action_counter": 14481
      },
      {
        "commit_message": "Refine cursor detection and move slot filtering for battle menu. Ensure robust JSON output. Use regex for cursor detection.",
        "timestamp": "2025-12-23T13:33:42.607Z",
        "action_counter": 14486
      }
    ]
  }
}