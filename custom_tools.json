{
  "wkg_updater": {
    "description": "Streamlined tool to manage the World Knowledge Graph. It verifies if a node or edge already exists and, if not, directly calls `manage_world_knowledge` to add it. This is a single-step action to prevent manual errors.",
    "input_schema": {
      "type": "object",
      "properties": {
        "operation": {
          "type": "string",
          "enum": [
            "add_node",
            "add_edge"
          ]
        },
        "map_id": {
          "type": "string"
        },
        "x": {
          "type": "string"
        },
        "y": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "type": {
          "type": "string"
        },
        "tags": {
          "type": "string"
        },
        "source_map_id": {
          "type": "string"
        },
        "source_x": {
          "type": "string"
        },
        "source_y": {
          "type": "string"
        },
        "dest_map_id": {
          "type": "string"
        },
        "dest_x": {
          "type": "string"
        },
        "dest_y": {
          "type": "string"
        },
        "connection_type": {
          "type": "string"
        },
        "is_one_way": {
          "type": "string"
        },
        "destination_entry_point": {
          "type": "string"
        }
      },
      "required": [
        "operation"
      ]
    },
    "python_script": "import json\n\ndef find_node_by_coords(graph, map_id, x, y):\n    for node in graph.get('nodes', []):\n        if str(node.get('map_id')) == str(map_id) and node['coordinates']['x'] == x and node['coordinates']['y'] == y:\n            return node\n    return None\n\ndef find_edge(graph, source_id, dest_id):\n    for edge in graph.get('edges', []):\n        if (edge['source_node_id'] == source_id and edge['destination_node_id'] == dest_id) or \\\n           (edge['source_node_id'] == dest_id and edge['destination_node_id'] == source_id and not edge.get('is_one_way')):\n            return edge\n    return None\n\noperation = input_data['operation']\ngraph = json.loads(world_knowledge_graph_json_string)\n\nif operation == 'add_node':\n    map_id = input_data['map_id']\n    x = int(input_data['x'])\n    y = int(input_data['y'])\n    name = input_data['name']\n    node_type = input_data.get('type', '')\n    tags = json.loads(input_data.get('tags', '[]'))\n\n    if not find_node_by_coords(graph, map_id, x, y):\n        payload = {'map_id': map_id, 'name': name, 'coordinates': {'x': x, 'y': y}, 'type': node_type, 'tags': tags}\n        print(json.dumps({'action': 'call_tool', 'tool_name': 'manage_world_knowledge', 'tool_action': 'add_node', 'payload': json.dumps(payload)}))\n\nelif operation == 'add_edge':\n    source_node = find_node_by_coords(graph, input_data['source_map_id'], int(input_data['source_x']), int(input_data['source_y']))\n    dest_node = find_node_by_coords(graph, input_data['dest_map_id'], int(input_data['dest_x']), int(input_data['dest_y']))\n\n    if source_node and dest_node and not find_edge(graph, source_node['id'], dest_node['id']):\n        payload = {\n            'source_node_id': source_node['id'],\n            'destination_node_id': dest_node['id'],\n            'connection_type': input_data['connection_type'],\n            'source_coordinates': {'x': int(input_data['source_x']), 'y': int(input_data['source_y']), 'map_id': input_data['source_map_id']},\n            'destination_coordinates': {'x': int(input_data['dest_x']), 'y': int(input_data['dest_y']), 'map_id': input_data['dest_map_id']},\n            'is_one_way': input_data.get('is_one_way', 'false').lower() == 'true'\n        }\n        if 'destination_entry_point' in input_data and input_data['connection_type'] == 'warp':\n            payload['destination_entry_point'] = int(input_data['destination_entry_point'])\n        print(json.dumps({'action': 'call_tool', 'tool_name': 'manage_world_knowledge', 'tool_action': 'add_edge', 'payload': json.dumps(payload)}))"
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map using the Breadth-First Search (BFS) algorithm. It considers tile types (including elevation), impassable objects (excluding Pikachu), and special ledge traversal rules. The output is a JSON string containing the list of coordinates for the path.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\nimport traceback\n\ndef find_path_tool(start_x, start_y, end_x, end_y, map_xml_string):\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n\n        grid = [['' for _ in range(width + 1)] for _ in range(height + 1)]\n        \n        start_coords = (int(start_x), int(start_y))\n        end_coords = (int(end_x), int(end_y))\n\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                tile_type = tile_elem.get('type')\n                current_coords = (x,y)\n\n                has_impassable_object = False\n                if current_coords != end_coords:\n                    for obj in tile_elem.findall('Object'):\n                        if obj.get('id-name') != 'Pikachu':\n                            has_impassable_object = True\n                            break\n\n                if has_impassable_object:\n                    grid[y][x] = 'impassable'\n                else:\n                    grid[y][x] = tile_type\n\n        if not (1 <= start_coords[0] <= width and 1 <= start_coords[1] <= height and 1 <= end_coords[0] <= width and 1 <= end_coords[1] <= height):\n            print(json.dumps({\"error\": \"Start or end coordinates are out of bounds.\"}))\n            return\n\n        if grid[end_coords[1]][end_coords[0]] == 'impassable':\n             print(json.dumps({\"error\": \"End point is on an impassable tile.\"}))\n             return\n\n        queue = deque([start_coords])\n        came_from = {start_coords: None}\n        \n        valid_transitions = {\n            'ground': ['ground', 'grass', 'steps'],\n            'grass': ['ground', 'grass', 'steps'],\n            'steps': ['ground', 'grass', 'elevated_ground', 'steps'],\n            'elevated_ground': ['elevated_ground', 'steps'],\n            'impassable': ['ground', 'grass', 'steps', 'elevated_ground']\n        }\n\n        while queue:\n            current = queue.popleft()\n\n            if current == end_coords:\n                path = []\n                temp = current\n                while temp is not None:\n                    path.append({'x': temp[0], 'y': temp[1]})\n                    temp = came_from[temp]\n                print(json.dumps({\"path\": path[::-1]}))\n                return\n\n            cx, cy = current\n            current_type = grid[cy][cx]\n            \n            potential_neighbors_coords = [(cx, cy - 1), (cx, cy + 1), (cx - 1, cy), (cx + 1, cy)]\n            for nx, ny in potential_neighbors_coords:\n                if 1 <= nx <= width and 1 <= ny <= height:\n                    neighbor_coords = (nx, ny)\n                    if neighbor_coords in came_from:\n                        continue\n\n                    neighbor_type = grid[ny][nx]\n                    \n                    if neighbor_type == 'ledge':\n                        if ny == cy + 1:\n                            if 1 <= ny + 1 <= height and grid[ny+1][nx] not in ['impassable', 'water']:\n                                ledge_jump_target = (nx, ny + 1)\n                                if ledge_jump_target not in came_from:\n                                    came_from[ledge_jump_target] = current\n                                    queue.append(ledge_jump_target)\n                        continue\n\n                    is_valid_move = False\n                    if current_type in valid_transitions and neighbor_type in valid_transitions.get(current_type, []):\n                        is_valid_move = True\n                    \n                    if is_valid_move:\n                        came_from[neighbor_coords] = current\n                        queue.append(neighbor_coords)\n\n        print(json.dumps({\"path\": []}))\n    except Exception as e:\n        print(json.dumps({\"error\": \"Caught exception\", \"details\": traceback.format_exc()}))\n\nfind_path_tool(input_data['start_x'], input_data['start_y'], input_data['end_x'], input_data['end_y'], map_xml_string)"
  },
  "wkg_pathfinder": {
    "description": "Calculates the shortest path between two maps in the World Knowledge Graph, returning a sequence of map IDs and warp coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_map_id": {
          "type": "string"
        },
        "end_map_id": {
          "type": "string"
        }
      },
      "required": [
        "start_map_id",
        "end_map_id"
      ]
    },
    "python_script": "import json\nfrom collections import deque\n\ndef find_wkg_path(start_map_id, end_map_id, wkg_json_string):\n    wkg = json.loads(wkg_json_string)\n    nodes = {node['id']: node for node in wkg['nodes']}\n    adj = {node_id: [] for node_id in nodes}\n    for edge in wkg['edges']:\n        adj[edge['source_node_id']].append(edge['destination_node_id'])\n        if not edge.get('is_one_way', False):\n            adj[edge['destination_node_id']].append(edge['source_node_id'])\n\n    start_nodes = [node_id for node_id, node in nodes.items() if node['map_id'] == start_map_id]\n    if not start_nodes:\n        print(json.dumps({'error': 'Start map not in WKG'}))\n        return\n\n    queue = deque([(node, [node]) for node in start_nodes])\n    visited = set(start_nodes)\n    \n    while queue:\n        current_node_id, path = queue.popleft()\n        current_map_id = nodes[current_node_id]['map_id']\n\n        if current_map_id == end_map_id:\n            result_path = []\n            for node_id in path:\n                node = nodes[node_id]\n                result_path.append({'map_id': node['map_id'], 'coordinates': node['coordinates']})\n            print(json.dumps({'path': result_path}))\n            return\n\n        for neighbor_id in adj.get(current_node_id, []):\n            if neighbor_id not in visited:\n                visited.add(neighbor_id)\n                new_path = list(path)\n                new_path.append(neighbor_id)\n                queue.append((neighbor_id, new_path))\n\n    print(json.dumps({'path': []}))\n\nfind_wkg_path(input_data['start_map_id'], input_data['end_map_id'], world_knowledge_graph_json_string)"
  }
}