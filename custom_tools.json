{
  "get_type_effectiveness_gen2": {
    "description": "Returns the type effectiveness multiplier for an attack in Gen 2 Pokemon Crystal.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacking_type": {
          "type": "string",
          "description": "The type of the move being used."
        },
        "defending_type1": {
          "type": "string",
          "description": "The first type of the defending Pokemon."
        },
        "defending_type2": {
          "type": "string",
          "description": "The second type of the defending Pokemon (optional).",
          "nullable": true
        }
      },
      "required": [
        "attacking_type",
        "defending_type1"
      ]
    },
    "python_script": "import json\n\ndef get_effectiveness(attacking_type, defending_type1, defending_type2=None):\n    # Gen 2 Type Chart\n    chart = {\n        \"NORMAL\": {\"ROCK\": 0.5, \"GHOST\": 0, \"STEEL\": 0.5},\n        \"FIRE\": {\"FIRE\": 0.5, \"WATER\": 0.5, \"GRASS\": 2, \"ICE\": 2, \"BUG\": 2, \"ROCK\": 0.5, \"DRAGON\": 0.5, \"STEEL\": 2},\n        \"WATER\": {\"FIRE\": 2, \"WATER\": 0.5, \"GRASS\": 0.5, \"GROUND\": 2, \"ROCK\": 2, \"DRAGON\": 0.5},\n        \"ELECTRIC\": {\"WATER\": 2, \"ELECTRIC\": 0.5, \"GRASS\": 0.5, \"GROUND\": 0, \"FLYING\": 2, \"DRAGON\": 0.5},\n        \"GRASS\": {\"FIRE\": 0.5, \"WATER\": 2, \"GRASS\": 0.5, \"POISON\": 0.5, \"GROUND\": 2, \"FLYING\": 0.5, \"BUG\": 0.5, \"ROCK\": 2, \"DRAGON\": 0.5, \"STEEL\": 0.5},\n        \"ICE\": {\"FIRE\": 0.5, \"WATER\": 0.5, \"GRASS\": 2, \"ICE\": 0.5, \"GROUND\": 2, \"FLYING\": 2, \"DRAGON\": 2, \"STEEL\": 0.5},\n        \"FIGHTING\": {\"NORMAL\": 2, \"ICE\": 2, \"POISON\": 0.5, \"FLYING\": 0.5, \"PSYCHIC\": 0.5, \"BUG\": 0.5, \"ROCK\": 2, \"GHOST\": 0, \"DARK\": 2, \"STEEL\": 2},\n        \"POISON\": {\"GRASS\": 2, \"POISON\": 0.5, \"GROUND\": 0.5, \"ROCK\": 0.5, \"GHOST\": 0.5, \"STEEL\": 0},\n        \"GROUND\": {\"FIRE\": 2, \"ELECTRIC\": 2, \"GRASS\": 0.5, \"POISON\": 2, \"FLYING\": 0, \"BUG\": 0.5, \"ROCK\": 2, \"STEEL\": 2},\n        \"FLYING\": {\"ELECTRIC\": 0.5, \"GRASS\": 2, \"FIGHTING\": 2, \"BUG\": 2, \"ROCK\": 0.5, \"STEEL\": 0.5},\n        \"PSYCHIC\": {\"FIGHTING\": 2, \"POISON\": 2, \"PSYCHIC\": 0.5, \"DARK\": 0, \"STEEL\": 0.5},\n        \"BUG\": {\"FIRE\": 0.5, \"GRASS\": 2, \"FIGHTING\": 0.5, \"POISON\": 0.5, \"FLYING\": 0.5, \"PSYCHIC\": 2, \"GHOST\": 0.5, \"DARK\": 2, \"STEEL\": 0.5},\n        \"ROCK\": {\"FIRE\": 2, \"ICE\": 2, \"FIGHTING\": 0.5, \"GROUND\": 0.5, \"FLYING\": 2, \"BUG\": 2, \"STEEL\": 0.5},\n        \"GHOST\": {\"NORMAL\": 0, \"PSYCHIC\": 2, \"GHOST\": 2, \"DARK\": 0.5, \"STEEL\": 0.5},\n        \"DRAGON\": {\"DRAGON\": 2, \"STEEL\": 0.5},\n        \"STEEL\": {\"FIRE\": 0.5, \"WATER\": 0.5, \"ELECTRIC\": 0.5, \"ICE\": 2, \"ROCK\": 2, \"STEEL\": 0.5},\n        \"DARK\": {\"FIGHTING\": 0.5, \"PSYCHIC\": 2, \"GHOST\": 2, \"DARK\": 0.5, \"STEEL\": 0.5}\n    }\n    \n    atk = attacking_type.upper()\n    def1 = defending_type1.upper()\n    \n    mult = chart.get(atk, {}).get(def1, 1.0)\n    if defending_type2:\n        def2 = defending_type2.upper()\n        mult *= chart.get(atk, {}).get(def2, 1.0)\n        \n    return mult\n\nif __name__ == \"__main__\":\n    attacking_type = input_data.get(\"attacking_type\")\n    defending_type1 = input_data.get(\"defending_type1\")\n    defending_type2 = input_data.get(\"defending_type2\")\n    \n    if attacking_type and defending_type1:\n        result = get_effectiveness(attacking_type, defending_type1, defending_type2)\n        print(json.dumps({\"multiplier\": result}))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-23T09:05:37.668Z",
        "action_counter": 14041
      },
      {
        "commit_message": "Fixed the tool to actually print the result using input_data.",
        "timestamp": "2025-12-23T09:26:49.920Z",
        "action_counter": 14085
      }
    ]
  },
  "select_move_v4": {
    "description": "Selects a move from the battle move menu. Assumes the move menu is already open. Returns a JSON array of button strings. Guarantees top position by pressing 'Up' 3 times first (as this menu does not wrap).",
    "input_schema": {
      "type": "object",
      "properties": {
        "move_index": {
          "type": "integer",
          "description": "The 1-based index of the move to select (1-4).",
          "minimum": 1,
          "maximum": 4
        }
      },
      "required": [
        "move_index"
      ]
    },
    "python_script": "import json\ntry:\n    move_index = int(input_data.get('move_index', 1))\n    buttons = [\"Up\", \"Up\", \"Up\"]\n    for _ in range(move_index - 1):\n        buttons.append(\"Down\")\n    buttons.append(\"A\")\n    print(json.dumps(buttons))\nexcept Exception as e:\n    print(json.dumps([]))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-23T10:56:42.854Z",
        "action_counter": 14240
      }
    ]
  },
  "use_sweet_scent_v8": {
    "description": "Uses Sweet Scent from KIMCHI (slot 6). Cursor-agnostic: clears menus, opens Start, navigates to POKEMON, selects KIMCHI, and uses move.",
    "input_schema": {
      "properties": {},
      "type": "object"
    },
    "python_script": "import json\n\ndef use_sweet_scent():\n    # 1. Clear to overworld\n    buttons = [\"B\", \"B\", \"B\", \"B\", \"sleep 500\"]\n    # 2. Open Start Menu\n    buttons.append(\"Start\")\n    buttons.append(\"sleep 500\")\n    # 3. Reset Start Menu to POKEDEX (1)\n    for _ in range(8):\n        buttons.append(\"Up\")\n    # 4. Navigate to POKEMON (2)\n    buttons.append(\"Down\")\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    # 5. Reset Party Menu to Slot 1\n    for _ in range(7):\n        buttons.append(\"Up\")\n    # 6. Navigate to KIMCHI (Slot 6)\n    # Slot 1 -> Up -> CANCEL (7) -> Up -> Slot 6.\n    buttons.append(\"Up\")\n    buttons.append(\"Up\")\n    buttons.append(\"A\")\n    buttons.append(\"sleep 500\")\n    # 7. Move Menu: Down 1 is Sweet Scent\n    buttons.append(\"Down\")\n    buttons.append(\"A\")\n    print(json.dumps(buttons))\n\nif __name__ == \"__main__\":\n    use_sweet_scent()",
    "history": [
      {
        "commit_message": "Defined use_sweet_scent_v8: a cursor-agnostic tool that clears dialogue, resets the Start menu to POKEDEX using Up*7, navigates to POKEMON, resets the Party menu to XENON using Up*6, navigates to KIMCHI, and uses Sweet Scent. Includes sleep commands for reliability.",
        "timestamp": "2025-12-23T11:16:01.164Z",
        "action_counter": 14275
      },
      {
        "commit_message": "Refining tool with a more robust sequence to navigate from the overworld (after clearing menus) to the POKEMON menu and select KIMCHI for Sweet Scent.",
        "timestamp": "2025-12-23T11:19:13.392Z",
        "action_counter": 14279
      },
      {
        "commit_message": "Refining use_sweet_scent_v8 to be more robust against menu state and phone calls. It now explicitly clears menus with B-presses, opens Start, navigates from EXIT (bottom) to POKEMON, selects KIMCHI (slot 6), and uses the move.",
        "timestamp": "2025-12-23T11:31:39.524Z",
        "action_counter": 14300
      },
      {
        "commit_message": "Redefining Sweet Scent tool to assume cursor starts on GEM (item 5) in the Start menu. This is the most common state. Also added explicit clearing of menus.",
        "timestamp": "2025-12-23T11:32:54.505Z",
        "action_counter": 14301
      },
      {
        "commit_message": "Refining Sweet Scent tool to use a cursor-agnostic reset for the Start menu (Up*7 to POKEDEX) now that it's confirmed not to wrap.",
        "timestamp": "2025-12-23T11:34:53.516Z",
        "action_counter": 14304
      },
      {
        "commit_message": "Refining Sweet Scent tool to be truly cursor-agnostic by using explicit Up-resets for both Start and Party menus.",
        "timestamp": "2025-12-23T11:36:06.957Z",
        "action_counter": 14306
      }
    ]
  },
  "select_move_v5": {
    "description": "Selects a move from the battle move menu. Assumes the move menu is already open. Takes the 1-based index of the move to select (1-4) and the current 1-based index of the cursor. Accounts for menu wrapping.",
    "input_schema": {
      "properties": {
        "current_index": {
          "description": "The 1-based index of the current cursor position (1-4).",
          "maximum": 4,
          "minimum": 1,
          "type": "integer"
        },
        "move_index": {
          "description": "The 1-based index of the move to select (1-4).",
          "maximum": 4,
          "minimum": 1,
          "type": "integer"
        }
      },
      "required": [
        "move_index",
        "current_index"
      ],
      "type": "object"
    },
    "python_script": "import json\n\ndef select_move():\n    try:\n        # input_data is a dictionary containing the tool arguments\n        move_index = int(input_data.get('move_index', 1))\n        current_index = int(input_data.get('current_index', 1))\n        \n        # Calculate shortest path in a wrapping 4-item menu\n        diff = (move_index - current_index) % 4\n        if diff == 0:\n            buttons = [\"A\"]\n        elif diff == 1:\n            buttons = [\"Down\", \"A\"]\n        elif diff == 2:\n            buttons = [\"Down\", \"Down\", \"A\"]\n        elif diff == 3:\n            buttons = [\"Up\", \"A\"]\n        else:\n            buttons = [\"A\"]\n        print(json.dumps(buttons))\n    except Exception as e:\n        # Fallback to just pressing A if logic fails\n        print(json.dumps([\"A\"]))\n\nif __name__ == \"__main__\":\n    select_move()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-23T11:26:23.701Z",
        "action_counter": 14290
      },
      {
        "commit_message": "Fixing select_move_v5 to correctly parse input_data and execute the wrapping menu logic.",
        "timestamp": "2025-12-23T11:29:04.097Z",
        "action_counter": 14297
      },
      {
        "commit_message": "Fixing select_move_v5 to use input_data.get() for safer access and wrapping the logic in a function.",
        "timestamp": "2025-12-23T11:36:06.959Z",
        "action_counter": 14306
      }
    ]
  },
  "use_pokemon_move_v1": {
    "description": "Uses a specific move from a Pokémon in the party. Cursor-agnostic: clears menus, opens POKEMON, selects the target Pokémon, selects 'USE MOVE', and executes the move at the given index.",
    "input_schema": {
      "properties": {
        "move_index": {
          "description": "The 1-based index of the move to use (1-4).",
          "maximum": 4,
          "minimum": 1,
          "type": "integer"
        },
        "pokemon_slot": {
          "description": "The 1-based index of the Pokémon in the party (1-6).",
          "maximum": 6,
          "minimum": 1,
          "type": "integer"
        }
      },
      "required": [
        "pokemon_slot",
        "move_index"
      ],
      "type": "object"
    },
    "python_script": "import json\n\ndef use_pokemon_move():\n    # input_data contains: pokemon_slot, move_index\n    slot = int(input_data.get('pokemon_slot', 1))\n    move = int(input_data.get('move_index', 1))\n    \n    # 1. Clear to overworld\n    buttons = [\"B\", \"B\", \"B\", \"B\", \"sleep 500\", \"Start\", \"sleep 500\"]\n    \n    # 2. Navigate to POKEMON (Item 2 in Start Menu)\n    # Start menu wraps. Reset to top (Item 1: POKEDEX)\n    for _ in range(8): buttons.append(\"Up\")\n    buttons.extend([\"Down\", \"A\", \"sleep 500\"])\n    \n    # 3. Navigate to Pokemon Slot\n    # Party menu wraps. Reset to top (Slot 1)\n    for _ in range(7): buttons.append(\"Up\")\n    for _ in range(slot - 1): buttons.append(\"Down\")\n    buttons.extend([\"A\", \"sleep 500\"])\n    \n    # 4. Select \"USE MOVE\" (Item 1 in the PKMN sub-menu)\n    # Sub-menu (USE MOVE, STATS, SWITCH, ITEM, CANCEL) wraps. Reset to top.\n    for _ in range(5): buttons.append(\"Up\")\n    buttons.extend([\"A\", \"sleep 500\"])\n    \n    # 5. Select Move Index\n    # Move list doesn't wrap in this menu. Reset to top.\n    for _ in range(4): buttons.append(\"Up\")\n    for _ in range(move - 1): buttons.append(\"Down\")\n    buttons.append(\"A\")\n    \n    print(json.dumps(buttons))\n\nif __name__ == \"__main__\":\n    use_pokemon_move()",
    "history": [
      {
        "commit_message": "Creating a robust, parameterized tool for using a Pokémon's move from the overworld menu. Replaces the hardcoded Sweet Scent tool.",
        "timestamp": "2025-12-23T11:38:00.524Z",
        "action_counter": 14311
      }
    ]
  }
}