{
  "pathfind": {
    "description": "Finds a path from the player's current position to a target coordinate using BFS. Returns a list of buttons.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "autopress_buttons": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\n# Retrieve arguments safely from input_data\ntry:\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    autopress_buttons = bool(input_data.get('autopress_buttons', False))\nexcept (NameError, KeyError, ValueError) as e:\n    print(json.dumps({\"error\": f\"Invalid arguments: {e}\"}))\n    exit()\n\ndef pathfind(target_x, target_y, autopress_buttons=False):\n    # Parse the map XML\n    try:\n        root = ET.fromstring(map_xml_string)\n    except Exception as e:\n        print(json.dumps({\"error\": f\"Error parsing XML: {e}\"}))\n        return []\n\n    # Get map dimensions\n    try:\n        width = int(root.attrib.get('width'))\n        height = int(root.attrib.get('height'))\n    except:\n        return []\n    \n    # Get player position\n    player_pos = None\n    \n    # Build the grid and find player\n    grid = {}\n    \n    for row in root.findall('Row'):\n        try:\n            y = int(row.attrib['id'])\n        except:\n            continue\n            \n        for tile in row.findall('Tile'):\n            try:\n                x = int(tile.attrib['id'])\n            except:\n                continue\n                \n            t_type = tile.attrib.get('type', 'unseen')\n            \n            # Check for player\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n            elif tile.attrib.get('has-player') == 'true':\n                 player_pos = (x, y)\n\n            # Determine walkability\n            walkable = True\n            # Basic blocking types\n            if t_type in ['WALL', 'HEADBUTT_TREE', 'unseen', 'WATER']: \n                walkable = False\n            # Ledges are complicated, treat as obstacles for simple pathfinding unless we want to handle one-way logic\n            if 'LEDGE' in t_type:\n                walkable = False\n                \n            # Check for objects (which act as walls)\n            # Note: We do NOT filter out the target tile if it has an object/warp, \n            # because sometimes we want to path TO an object to interact.\n            # But we can't stand ON it.\n            # For this 'movement' tool, we assume we want to stand on the target.\n            # If target has object, we effectively can't go there.\n            \n            has_object = False\n            if tile.find('Object') is not None:\n                has_object = True\n            if tile.attrib.get('has-object') == 'true':\n                has_object = True\n            \n            if has_object:\n                walkable = False\n\n            grid[(x, y)] = walkable\n\n    if player_pos is None:\n        print(json.dumps({\"error\": \"Player position not found in XML.\"}))\n        return []\n\n    start = player_pos\n    goal = (target_x, target_y)\n\n    if start == goal:\n        return []\n        \n    # Check if goal is walkable according to our strict grid\n    if not grid.get(goal, False):\n        # Optional: Print why it failed for debugging, but return empty list to not break schema\n        # print(f\"Target {goal} is not walkable.\")\n        return []\n\n    # BFS\n    queue = deque([(start, [])])\n    visited = {start}\n    \n    while queue:\n        (cx, cy), path = queue.popleft()\n        \n        if (cx, cy) == goal:\n            return path\n        \n        moves = [\n            (0, -1, 'Up'),\n            (0, 1, 'Down'),\n            (-1, 0, 'Left'),\n            (1, 0, 'Right')\n        ]\n        \n        for dx, dy, direction in moves:\n            nx, ny = cx + dx, cy + dy\n            \n            if 0 <= nx < width and 0 <= ny < height:\n                if grid.get((nx, ny), False):\n                    if (nx, ny) not in visited:\n                        visited.add((nx, ny))\n                        queue.append(((nx, ny), path + [direction]))\n                        \n    # No path found\n    return []\n\nprint(json.dumps(pathfind(target_x, target_y, autopress_buttons)))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T09:01:19.563Z",
        "action_counter": 33384
      },
      {
        "commit_message": "Fixed NameError by using globals().get() to safely retrieve injected arguments. Added autopress_buttons support.",
        "timestamp": "2026-01-11T16:48:12.265Z",
        "action_counter": 34015
      },
      {
        "commit_message": "Refined JSON output compliance using json.dumps to avoid parsing errors.",
        "timestamp": "2026-01-11T16:49:46.390Z",
        "action_counter": 34017
      },
      {
        "commit_message": "Added debug logic to inspect available variables if arguments are missing.",
        "timestamp": "2026-01-11T16:50:53.134Z",
        "action_counter": 34018
      },
      {
        "commit_message": "Updated to retrieve arguments from `input_data` global dictionary.",
        "timestamp": "2026-01-11T16:51:34.865Z",
        "action_counter": 34019
      },
      {
        "commit_message": "Fixed XML parsing logic to correctly iterate Rows and Tiles instead of using unsupported '..' XPath.",
        "timestamp": "2026-01-11T16:52:03.375Z",
        "action_counter": 34020
      },
      {
        "commit_message": "Added WARP_CARPET_* and DOOR types to traversable list.",
        "timestamp": "2026-01-11T17:10:57.545Z",
        "action_counter": 34044
      },
      {
        "commit_message": "Fixing pathfind tool to return valid JSON array on failure instead of an object, preventing schema validation errors.",
        "timestamp": "2026-01-12T04:10:40.878Z",
        "action_counter": 34986
      },
      {
        "commit_message": "Fixed 'pathfind' tool by explicitly accessing 'target_x' and 'target_y' from the 'input_data' dictionary, resolving the NameError.",
        "timestamp": "2026-01-12T04:13:03.377Z",
        "action_counter": 34988
      },
      {
        "commit_message": "Fixed XML parsing, added proper grid construction checking for walls, objects, and ledges, and implemented BFS for shortest path.",
        "timestamp": "2026-01-12T09:14:34.850Z",
        "action_counter": 35403
      },
      {
        "commit_message": "Fixed NameError by explicitly retrieving arguments from the `input_data` dictionary.",
        "timestamp": "2026-01-12T09:15:49.641Z",
        "action_counter": 35405
      }
    ]
  },
  "open_map": {
    "description": "Opens the Pokegear and navigates to the Map card. Assumes the main menu cursor is already on 'POKEGEAR' (last used). Uses a 'Left, Left, Left, Right' sequence inside Pokegear to reliably select the Map regardless of previous cursor position (Back, Map, Phone, Radio). Includes safety 'B' presses and sleep delays.",
    "input_schema": {
      "type": "object",
      "properties": {
        "autopress_buttons": {
          "type": "boolean",
          "default": false,
          "description": "If true and the tool returns a list of buttons, they will be pressed automatically. Safety limit of 50 buttons per turn."
        }
      },
      "required": [
        "autopress_buttons"
      ]
    },
    "python_script": "print('[\"B\", \"B\", \"Start\", \"sleep 500\", \"A\", \"sleep 500\", \"Left\", \"Left\", \"Left\", \"Right\", \"sleep 500\", \"A\"]')",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-12T18:35:50.856Z",
        "action_counter": 36061
      },
      {
        "commit_message": "Updated to include 'B' presses to ensure menus are closed and added sleep delays for reliability during map transitions.",
        "timestamp": "2026-01-12T22:13:13.244Z",
        "action_counter": 36332
      },
      {
        "commit_message": "Fixed JSON formatting in python script by importing json and using json.dumps.",
        "timestamp": "2026-01-12T22:13:55.445Z",
        "action_counter": 36334
      },
      {
        "commit_message": "Forced double quotes in output string to ensure valid JSON, avoiding reliance on json library imports or default stringification.",
        "timestamp": "2026-01-12T22:15:38.245Z",
        "action_counter": 36336
      },
      {
        "commit_message": "Fixed output format to be a JSON array of strings, not a JSON object with a 'buttons' key, as required by the tool definition.",
        "timestamp": "2026-01-12T22:17:24.564Z",
        "action_counter": 36339
      },
      {
        "commit_message": "Improved reliability: Added an extra 'Left' press to handle starting from the 'Radio' card (4th slot) assuming non-wrapping menu, and added a sleep before the final 'A' press to ensure the Map View opens after navigation.",
        "timestamp": "2026-01-13T07:37:57.819Z",
        "action_counter": 37022
      }
    ]
  },
  "perform_grass_scan": {
    "description": "Walks a specified number of steps in a simple oscillating pattern (Left/Right) to search for wild PokÃ©mon within a grass patch. Use this to automate encounter scanning.",
    "input_schema": {
      "type": "object",
      "properties": {
        "num_steps": {
          "type": "integer",
          "description": "The number of steps to walk."
        }
      },
      "required": [
        "num_steps"
      ]
    },
    "python_script": "import json\n\n# Attempt to retrieve num_steps from various potential sources provided by the environment\ntry:\n    # Try direct global variable access (standard for some harnesses)\n    steps = int(num_steps)\nexcept NameError:\n    try:\n        # Try input_data dictionary (standard for others)\n        steps = int(input_data['num_steps'])\n    except (NameError, KeyError):\n        # Fallback default\n        steps = 10\n\nbuttons = []\nfor i in range(steps):\n    if i % 2 == 0:\n        buttons.append(\"Left\")\n    else:\n        buttons.append(\"Right\")\n\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-13T20:01:43.329Z",
        "action_counter": 37741
      },
      {
        "commit_message": "Fixed variable access to correctly handle input arguments by checking input_data dictionary.",
        "timestamp": "2026-01-13T20:04:38.111Z",
        "action_counter": 37745
      }
    ]
  },
  "reset_roamers": {
    "description": "Automates the process of exiting Route 37 to Ecruteak City (Up) and returning to the grass patch on Route 37 (Down) to reset Roamer positions. Uses extended sleeps (8s) and extra steps to handle map transition latency and border crossing. Hardcoded for player at y=4 on Route 37.",
    "input_schema": {
      "type": "object",
      "properties": {
        "autopress_buttons": {
          "type": "boolean",
          "default": false,
          "description": "If true and the tool returns a list of buttons, they will be pressed automatically. Safety limit of 50 buttons per turn."
        }
      },
      "required": [
        "autopress_buttons"
      ]
    },
    "python_script": "import json\nbuttons = [\"Up\"] * 5\nbuttons.append(\"sleep 8000\")\nbuttons.extend([\"Down\"] * 3)\nbuttons.append(\"sleep 8000\")\nbuttons.extend([\"Down\"] * 4)\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-13T20:34:11.588Z",
        "action_counter": 37801
      },
      {
        "commit_message": "Increased sleep duration to 5000ms to ensure reliable map transition handling.",
        "timestamp": "2026-01-13T20:38:31.188Z",
        "action_counter": 37806
      },
      {
        "commit_message": "Added a second sleep delay to handle the return warp from Ecruteak City back to Route 37, preventing input loss during the transition.",
        "timestamp": "2026-01-13T20:39:10.691Z",
        "action_counter": 37807
      },
      {
        "commit_message": "Increased sleep times to 8s to handle map transition latency. Optimized step counts for reliability.",
        "timestamp": "2026-01-13T21:13:48.971Z",
        "action_counter": 37862
      },
      {
        "commit_message": "Fixed JSON formatting issue in python script by importing json and using json.dumps.",
        "timestamp": "2026-01-13T21:19:16.884Z",
        "action_counter": 37874
      },
      {
        "commit_message": "Fixed output format to be a JSON array instead of an object, as required by the system.",
        "timestamp": "2026-01-13T21:21:43.017Z",
        "action_counter": 37879
      }
    ]
  }
}