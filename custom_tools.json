{
  "find_reachable_unseen_tiles": {
    "description": "Identifies all unseen tiles on the current map that are adjacent to reachable walkable tiles. If autopress_buttons is true, returns a path to the nearest one.",
    "input_schema": {
      "properties": {
        "current_x": {
          "type": "integer"
        },
        "current_y": {
          "type": "integer"
        }
      },
      "required": [
        "current_x",
        "current_y"
      ],
      "type": "object"
    },
    "python_script": "import json, xml.etree.ElementTree as ET\nfrom collections import deque\ndef solve(d):\n    cx, cy = d['current_x'], d['current_y']\n    try: root = ET.fromstring(map_xml_string)\n    except: return {\"unseen_tiles\": [], \"buttons\": []}\n    w, h, g = int(root.attrib['width']), int(root.attrib['height']), {}\n    for r in root.findall('Row'):\n        y = int(r.attrib['id'])\n        for t in r.findall('Tile'):\n            x = int(t.attrib['id'])\n            g[(x,y)] = {'t': t.attrib['type'], 'o': t.attrib.get('has-object') == 'true'}\n    reachable = set([(cx, cy)])\n    q = deque([(cx, cy)])\n    while q:\n        x, y = q.popleft()\n        for dx, dy in [(0,-1),(0,1),(-1,0),(1,0)]:\n            nx, ny = x+dx, y+dy\n            if 0<=nx<w and 0<=ny<h and (nx,ny) not in reachable:\n                t, ct = g.get((nx,ny)), g.get((x,y))\n                if not t or t['t'] in ['WALL','WATER','CUT_TREE','BOULDER','unseen'] or t['o']: continue\n                if (ct['t']=='FLOOR_UP_WALL' and dy==-1) or (t['t']=='FLOOR_UP_WALL' and dy==1): continue\n                if (ct['t']=='FLOOR_DOWN_WALL' and dy==1) or (t['t']=='FLOOR_DOWN_WALL' and dy==-1): continue\n                if (ct['t']=='FLOOR_LEFT_WALL' and dx==-1) or (t['t']=='FLOOR_LEFT_WALL' and dx==1): continue\n                if (ct['t']=='FLOOR_RIGHT_WALL' and dx==1) or (t['t']=='FLOOR_RIGHT_WALL' and dx==-1): continue\n                if (t['t']=='LEDGE_HOP_DOWN' and dy!=1) or (ct['t']=='LEDGE_HOP_DOWN' and dy!=1): continue\n                if (t['t']=='LEDGE_HOP_UP' and dy!=-1) or (ct['t']=='LEDGE_HOP_UP' and dy!=-1): continue\n                if (t['t']=='LEDGE_HOP_LEFT' and dx!=-1) or (ct['t']=='LEDGE_HOP_LEFT' and dx!=-1): continue\n                if (t['t']=='LEDGE_HOP_RIGHT' and dx!=1) or (ct['t']=='LEDGE_HOP_RIGHT' and dx!=1): continue\n                reachable.add((nx,ny)); q.append((nx,ny))\n    unseen = []\n    for (rx, ry) in reachable:\n        for dx, dy in [(0,-1),(0,1),(-1,0),(1,0)]:\n            nx, ny = rx+dx, ry+dy\n            if 0<=nx<w and 0<=ny<h:\n                t = g.get((nx,ny))\n                if t and t['t'] == 'unseen': unseen.append((nx,ny))\n    return {\"unseen_tiles\": list(set(unseen)), \"buttons\": []}\nprint(json.dumps(solve(input_data)))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-11T18:35:24.812Z",
        "action_counter": 41414
      },
      {
        "commit_message": "Refined logic to correctly identify unseen tiles adjacent to reachable walkable tiles. Removed 'unseen' from walkable types to ensure search only passes through confirmed traversable areas.",
        "timestamp": "2026-01-11T22:25:41.646Z",
        "action_counter": 41821
      },
      {
        "commit_message": "Fix find_reachable_unseen_tiles to return button strings when autopress_buttons is true.",
        "timestamp": "2026-01-12T01:57:28.881Z",
        "action_counter": 42305
      },
      {
        "commit_message": "Initial implementation of find_reachable_unseen_tiles. Fixed collision check to include BOOKSHELF.",
        "timestamp": "2026-01-12T04:26:41.177Z",
        "action_counter": 42572
      },
      {
        "commit_message": "Refined collision logic to include PC and WINDOW. Ensured exploration tool accounts for indoor obstacles.",
        "timestamp": "2026-01-12T04:49:49.116Z",
        "action_counter": 42622
      },
      {
        "commit_message": "Initial implementation of reachable unseen tiles finder.",
        "timestamp": "2026-01-12T06:33:54.023Z",
        "action_counter": 42797
      },
      {
        "commit_message": "Initial implementation with basic collision check and reachability analysis.",
        "timestamp": "2026-01-12T10:23:29.129Z",
        "action_counter": 43173
      },
      {
        "commit_message": "Refined to return a path of buttons to the nearest unseen tile when called with autopress_buttons.",
        "timestamp": "2026-01-12T10:27:10.775Z",
        "action_counter": 43180
      },
      {
        "commit_message": "Refined collision logic to handle ledges (Down, Left, Right) and one-way walls (FLOOR_UP_WALL, WALL_UP_FLOOR). Removed WATER from default walkable list.",
        "timestamp": "2026-01-12T10:56:58.943Z",
        "action_counter": 43237
      },
      {
        "commit_message": "Adding wall and ledge collision logic to find_reachable_unseen_tiles.",
        "timestamp": "2026-01-12T14:00:58.389Z",
        "action_counter": 43503
      },
      {
        "commit_message": "Refining collision logic for all wall types and ledges in the exploration tool.",
        "timestamp": "2026-01-12T14:16:45.409Z",
        "action_counter": 43531
      }
    ]
  },
  "menu_navigator": {
    "description": "Executes a sequence of button presses to navigate menus. Returns a JSON array of buttons. Use this to bypass the restriction on mixing directional and action inputs. Automatically handles autopress_buttons.",
    "input_schema": {
      "properties": {
        "sequence": {
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "sequence"
      ],
      "type": "object"
    },
    "python_script": "import json\n# input_data is a dictionary containing the tool's input arguments.\n# This script simply returns the sequence of buttons provided in the input.\nsequence = input_data.get('sequence', [])\nprint(json.dumps(sequence))\n",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-12T07:58:07.386Z",
        "action_counter": 42950
      },
      {
        "commit_message": "Fixing menu_navigator to correctly use input_data dictionary instead of sys.stdin.",
        "timestamp": "2026-01-12T07:59:05.011Z",
        "action_counter": 42952
      },
      {
        "commit_message": "Fixing menu_navigator to correctly use the injected input_data dictionary and avoid sys.stdin.",
        "timestamp": "2026-01-12T07:59:59.685Z",
        "action_counter": 42953
      }
    ]
  },
  "find_path_v7_robust": {
    "description": "Finds a path between two coordinates on the current map, accounting for complex collision types (like one-way ledges and direction-specific walls) and treating 'unseen' tiles as walkable FLOOR for exploration. Returns a JSON array of buttons.",
    "input_schema": {
      "properties": {
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ],
      "type": "object"
    },
    "python_script": "import json, xml.etree.ElementTree as ET\nfrom collections import deque\ndef solve(d):\n    sx, sy, ex, ey = d['start_x'], d['start_y'], d['end_x'], d['end_y']\n    try: root = ET.fromstring(map_xml_string)\n    except: return []\n    w, h, g = int(root.attrib['width']), int(root.attrib['height']), {}\n    for r in root.findall('Row'):\n        y = int(r.attrib['id'])\n        for t in r.findall('Tile'):\n            x = int(t.attrib['id'])\n            tp = t.attrib['type']\n            if tp == 'unseen': tp = 'FLOOR'\n            g[(x,y)] = {'t': tp, 'o': t.attrib.get('has-object') == 'true'}\n    q, v = deque([(sx, sy, [])]), set([(sx, sy)])\n    while q:\n        cx, cy, p = q.popleft()\n        if cx == ex and cy == ey: return p\n        for dx, dy, b in [(0,-1,'Up'),(0,1,'Down'),(-1,0,'Left'),(1,0,'Right')]:\n            nx, ny = cx+dx, cy+dy\n            if 0<=nx<w and 0<=ny<h and (nx,ny) not in v:\n                t, ct = g.get((nx,ny)), g.get((cx,cy))\n                if not t or not ct or t['t'] in ['WALL','WATER','CUT_TREE','BOULDER'] or t['o']: continue\n                if (ct['t']=='FLOOR_UP_WALL' and dy==-1) or (t['t']=='FLOOR_UP_WALL' and dy==1): continue\n                if (ct['t']=='FLOOR_DOWN_WALL' and dy==1) or (t['t']=='FLOOR_DOWN_WALL' and dy==-1): continue\n                if (ct['t']=='FLOOR_LEFT_WALL' and dx==-1) or (t['t']=='FLOOR_LEFT_WALL' and dx==1): continue\n                if (ct['t']=='FLOOR_RIGHT_WALL' and dx==1) or (t['t']=='FLOOR_RIGHT_WALL' and dx==-1): continue\n                if (t['t']=='LEDGE_HOP_DOWN' and dy!=1) or (ct['t']=='LEDGE_HOP_DOWN' and dy!=1): continue\n                if (t['t']=='LEDGE_HOP_UP' and dy!=-1) or (ct['t']=='LEDGE_HOP_UP' and dy!=-1): continue\n                if (t['t']=='LEDGE_HOP_LEFT' and dx!=-1) or (ct['t']=='LEDGE_HOP_LEFT' and dx!=-1): continue\n                if (t['t']=='LEDGE_HOP_RIGHT' and dx!=1) or (ct['t']=='LEDGE_HOP_RIGHT' and dx!=1): continue\n                v.add((nx,ny)); q.append((nx,ny,p+[b]))\n    return []\nprint(json.dumps(solve(input_data)))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2026-01-12T12:21:09.333Z",
        "action_counter": 43372
      },
      {
        "commit_message": "Update FLOOR_UP_WALL collision logic to check both 'from' and 'to' tiles.",
        "timestamp": "2026-01-12T12:24:45.250Z",
        "action_counter": 43376
      },
      {
        "commit_message": "Refine FLOOR_UP_WALL collision to block all North/South entry and exit.",
        "timestamp": "2026-01-12T12:44:31.097Z",
        "action_counter": 43404
      },
      {
        "commit_message": "Update find_path_v7_robust to handle WATER, WATERFALL, and Objects. Added coordinate-based output option.",
        "timestamp": "2026-01-12T13:01:25.227Z",
        "action_counter": 43420
      },
      {
        "commit_message": "Fixing pathfinding logic to include all wall types and ledges and adding button output.",
        "timestamp": "2026-01-12T14:00:23.450Z",
        "action_counter": 43502
      },
      {
        "commit_message": "Refining collision logic for all wall types and ledges. Added consistent entry/exit blocking for one-way tiles.",
        "timestamp": "2026-01-12T14:16:45.408Z",
        "action_counter": 43531
      }
    ]
  }
}