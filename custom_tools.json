{
  "pathfinder": {
    "description": "DIAGNOSTIC VERSION: Parses the map XML into a grid and prints a 5x5 area around the player for verification. Does not perform pathfinding.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ndef pathfinder(input_data):\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.attrib['width'])\n        height = int(root.attrib['height'])\n    except (ValueError, ET.ParseError) as e:\n        print(json.dumps({'error': f'Failed to parse map XML: {e}'}))\n        return\n\n    player_pos = None\n    for row_elem in root.findall('Row'):\n        tile_with_player = row_elem.find('Tile[Player]')\n        if tile_with_player is not None:\n            player_pos = (int(tile_with_player.attrib['id']), int(row_elem.attrib['id']))\n            break\n    \n    if player_pos is None:\n        print(json.dumps({'error': 'Player start position not found on the map.'}))\n        return\n\n    grid = [['' for _ in range(width + 1)] for _ in range(height + 1)]\n    impassable_base_types = ['impassable', 'cuttable', 'boulder_barrier', 'closed_gate', 'water']\n    \n    for r_elem in root.findall('Row'):\n        y = int(r_elem.attrib['id'])\n        for t_elem in r_elem.findall('Tile'):\n            x = int(t_elem.attrib['id'])\n            tile_type = t_elem.attrib['type']\n            obj = t_elem.find('Object')\n            has_blocking_obj = obj is not None and obj.attrib.get('id-name') != 'Pikachu'\n            if tile_type in impassable_base_types or has_blocking_obj:\n                grid[y][x] = 'impassable'\n            else:\n                grid[y][x] = tile_type\n\n    debug_output = []\n    px, py = player_pos\n    for y_offset in range(-2, 3):\n        row_str = []\n        for x_offset in range(-2, 3):\n            check_x, check_y = px + x_offset, py + y_offset\n            if 1 <= check_x <= width and 1 <= check_y <= height:\n                row_str.append(f'({check_x},{check_y}):{grid[check_y][check_x]}')\n            else:\n                row_str.append(f'({check_x},{check_y}):OOB')\n        debug_output.append(' | '.join(row_str))\n    \n    print('--- Grid Parsing Diagnostic ---')\n    for row in debug_output:\n        print(row)\n    print('--- End Diagnostic ---')"
  },
  "boulder_puzzle_solver": {
    "description": "Analyzes the map XML for a boulder puzzle and provides a step-by-step solution. This version includes A* pathfinding to ensure the player can reach the boulders before attempting a push. It correctly handles puzzles with more boulders than switches, includes an iteration limit, and validates that the player can reach the exact push position. **This version now correctly checks for the SURF HM and allows the player pathfinding to traverse water tiles.**",
    "input_schema": {
      "type": "object",
      "properties": {
        "boulder_coords": {
          "type": "string"
        },
        "switch_coords": {
          "type": "string"
        },
        "party_data": {
          "type": "string"
        }
      },
      "required": [
        "boulder_coords",
        "switch_coords",
        "party_data"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\nfrom collections import deque\n\ndef solve_boulder_puzzle(input_data):\n    grid = {}\n    player_pos = None\n    map_width = 0\n    map_height = 0\n    party_data = []\n\n    def parse_map_and_party(xml_string, party_str):\n        nonlocal grid, player_pos, map_width, map_height, party_data\n        root = ET.fromstring(xml_string)\n        map_width = int(root.get('width'))\n        map_height = int(root.get('height'))\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                is_warp = tile_elem.get('is-warp') == 'true'\n                object_id_name = None\n                obj_elem = tile_elem.find('Object')\n                if obj_elem is not None:\n                    object_id_name = obj_elem.get('id-name')\n                if tile_elem.find('Player') is not None:\n                    player_pos = (x, y)\n                grid[(x, y)] = {'type': tile_type, 'has_object': has_object, 'is_warp': is_warp, 'object_id_name': object_id_name}\n        party_data = json.loads(party_str) if party_str else []\n\n    def has_hm(hm_name):\n        for pokemon in party_data:\n            if not pokemon.get('is_fainted', False):\n                for move in pokemon.get('moves', []):\n                    if isinstance(move, dict) and move.get('name') == hm_name: return True\n                    elif isinstance(move, str) and move == hm_name: return True\n        return False\n\n    def is_player_traversable(from_coord, to_coord, current_boulders):\n        if to_coord not in grid: return False\n        to_tile = grid[to_coord]\n        from_tile = grid[from_coord]\n        from_type = from_tile['type']\n        to_type = to_tile['type']\n\n        if to_type in ['impassable', 'boulder_barrier'] or to_coord in current_boulders: return False\n        if to_tile['has_object'] and not to_tile['is_warp'] and to_tile.get('object_id_name') != 'PIKACHU': return False\n        \n        if to_type == 'water' and has_hm('SURF'):\n            if from_type in ['ground', 'steps', 'grass', 'water']:\n                return True\n        if from_type == 'water' and to_type in ['ground', 'steps', 'grass'] and has_hm('SURF'):\n            return True\n\n        valid_land_types = {'ground', 'grass', 'steps', 'elevated_ground', 'ladder_up', 'ladder_down'}\n        if from_type in valid_land_types and to_type in valid_land_types:\n            if from_type == 'steps' and to_type in {'ground', 'grass', 'elevated_ground', 'steps'}: return True\n            if to_type == 'steps' and from_type in {'ground', 'grass', 'elevated_ground'}: return True\n            if from_type == to_type: return True\n            if from_type in {'ground', 'grass'} and to_type in {'ground', 'grass'}: return True\n            if from_type in {'ladder_up', 'ladder_down'} or to_type in {'ladder_up', 'ladder_down'}: return True\n            return False\n        return False\n\n    def get_player_neighbors(node, current_boulders):\n        x, y = node\n        neighbors = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 1 <= nx <= map_width and 1 <= ny <= map_height:\n                if is_player_traversable((x, y), (nx, ny), current_boulders):\n                    neighbors.append((nx, ny))\n        return neighbors\n\n    def player_a_star(start, goal, current_boulders):\n        frontier = [(0, start)]\n        came_from = {start: None}\n        cost_so_far = {start: 0}\n        max_iterations = 2000\n        iterations = 0\n        while frontier:\n            iterations += 1\n            if iterations > max_iterations: return None\n            _, current = heapq.heappop(frontier)\n            if current == goal: break\n            for next_node in get_player_neighbors(current, current_boulders):\n                new_cost = cost_so_far[current] + 1\n                if next_node not in cost_so_far or new_cost < cost_so_far[next_node]:\n                    cost_so_far[next_node] = new_cost\n                    priority = new_cost + abs(goal[0] - next_node[0]) + abs(goal[1] - next_node[1])\n                    heapq.heappush(frontier, (priority, next_node))\n                    came_from[next_node] = current\n        else: return None\n        path = []\n        current = goal\n        while current is not None: path.append(current); current = came_from.get(current)\n        path.reverse()\n        return path\n\n    def get_boulder_neighbors(state, current_player_pos):\n        neighbors = []\n        boulders = set(state)\n        for i, boulder in enumerate(state):\n            bx, by = boulder\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                player_pos_req = (bx - dx, by - dy)\n                new_boulder_pos = (bx + dx, by + dy)\n                if new_boulder_pos in boulders or new_boulder_pos not in grid or grid[new_boulder_pos]['type'] in ['impassable', 'boulder_barrier'] or (grid[new_boulder_pos]['has_object'] and not grid[new_boulder_pos]['is_warp'] and grid[new_boulder_pos].get('object_id_name') != 'PIKACHU'): continue\n                path_to_push = player_a_star(current_player_pos, player_pos_req, boulders)\n                if path_to_push:\n                    new_state_list = list(state)\n                    new_state_list[i] = new_boulder_pos\n                    new_state_tuple = tuple(sorted(new_state_list))\n                    move = {'boulder_index': i, 'start_pos': boulder, 'end_pos': new_boulder_pos, 'player_path': path_to_push}\n                    neighbors.append((new_state_tuple, move))\n        return neighbors\n\n    def puzzle_heuristic(state, switches):\n        total_dist = 0\n        unplaced_boulders = sorted([b for b in state if b not in switches])\n        open_switches = sorted([s for s in switches if s not in state])\n        for boulder in unplaced_boulders:\n            if not open_switches: break\n            min_dist = float('inf')\n            best_switch = None\n            for switch in open_switches:\n                dist = abs(boulder[0] - switch[0]) + abs(boulder[1] - switch[1])\n                if dist < min_dist: min_dist = dist; best_switch = switch\n            total_dist += min_dist\n            if best_switch: open_switches.remove(best_switch)\n        return total_dist\n\n    def puzzle_a_star_solver(start_state, switches, initial_player_pos):\n        start_node = (tuple(sorted(start_state)), initial_player_pos)\n        frontier = [(puzzle_heuristic(start_node[0], switches), start_node)]\n        came_from = {start_node: (None, None)}\n        cost_so_far = {start_node: 0}\n        max_iterations = 15000\n        iterations = 0\n        while frontier:\n            iterations += 1\n            if iterations > max_iterations: return 'timeout'\n            _, current_node = heapq.heappop(frontier)\n            current_state, current_player_pos = current_node\n            if len(switches) > 0 and set(switches).issubset(set(current_state)):\n                path = []\n                curr = current_node\n                while curr is not None:\n                    parent, move = came_from.get(curr, (None, None))\n                    if move: path.append(move)\n                    curr = parent\n                path.reverse()\n                return path\n            for next_state, move in get_boulder_neighbors(current_state, current_player_pos):\n                new_cost = cost_so_far[current_node] + 1\n                next_player_pos = move['start_pos']\n                next_node = (next_state, next_player_pos)\n                if next_node not in cost_so_far or new_cost < cost_so_far[next_node]:\n                    cost_so_far[next_node] = new_cost\n                    priority = new_cost + puzzle_heuristic(next_state, switches)\n                    heapq.heappush(frontier, (priority, next_node))\n                    came_from[next_node] = (current_node, move)\n        return None\n\n    try:\n        parse_map_and_party(map_xml_string, input_data['party_data'])\n        boulder_coords = [tuple(coord) for coord in json.loads(input_data['boulder_coords'])]\n        switch_coords = [tuple(coord) for coord in json.loads(input_data['switch_coords'])]\n        solution = puzzle_a_star_solver(boulder_coords, switch_coords, player_pos)\n        if solution == 'timeout':\n            print(json.dumps({'error': 'Solver timed out after too many iterations.'}))\n        elif solution:\n            print(json.dumps({'solution_path': solution}))\n        else:\n            print(json.dumps({'error': 'No solution found for the puzzle.'}))\n    except Exception as e:\n        import traceback\n        print(json.dumps({'error': f'An error occurred: {str(e)}', 'traceback': traceback.format_exc()}))\n\nsolve_boulder_puzzle(input_data)\n"
  },
  "find_closest_unseen_tile": {
    "description": "Finds the closest reachable unseen tile and a reachable adjacent tile to pathfind to. This version uses a more robust traversal logic that correctly handles non-adjacent traversals like warps and ladders.",
    "input_schema": {
      "type": "object",
      "properties": {
        "party_data": {
          "type": "string"
        }
      },
      "required": [
        "party_data"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport collections\n\ndef find_closest_unseen_tile_script(map_xml_string, input_data):\n    try:\n        party_data = json.loads(input_data['party_data'])\n        root = ET.fromstring(map_xml_string)\n        width = int(root.attrib['width'])\n        height = int(root.attrib['height'])\n\n        start_x, start_y = -1, -1\n        player_found = False\n        unseen_tiles = []\n        tile_map = {}\n\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.attrib['id'])\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.attrib['id'])\n                tile_map[(x - 1, y - 1)] = tile_elem\n                if tile_elem.attrib.get('seen') != 'true':\n                    unseen_tiles.append((x, y))\n                if tile_elem.attrib.get('has-player') == 'true':\n                    start_x, start_y = x, y\n                    player_found = True\n                else:\n                    player_child = tile_elem.find('Player')\n                    if player_child is not None:\n                        start_x, start_y = x, y\n                        player_found = True\n            if player_found:\n                break\n        \n        if not player_found:\n            return json.dumps({\"error\": \"Player not found on map.\"})\n\n        start = (start_x - 1, start_y - 1)\n        \n        walkable_types = {'ground', 'grass', 'cleared_boulder_barrier', 'open_gate', 'gate_offscreen', 'steps', 'elevated_ground', 'teleport', 'hole', 'ladder_up', 'ladder_down', 'spinner_stop', 'boulder_switch'}\n        traversal_tags = {'Warp', 'Ladder', 'Teleport'}\n\n        has_surf = any('SURF' in move['name'].upper() for pokemon in party_data for move in pokemon['moves'])\n        if has_surf:\n            walkable_types.add('water')\n\n        def get_tile_type(x, y):\n            tile_elem = tile_map.get((x, y))\n            return tile_elem.attrib.get('type', 'unknown') if tile_elem is not None else 'unknown'\n\n        def is_impassable(x, y):\n            tile_elem = tile_map.get((x, y))\n            if tile_elem is None: return True\n            \n            tile_type = tile_elem.attrib.get('type', 'unknown')\n            if tile_type not in walkable_types:\n                return True\n            \n            for child in tile_elem:\n                if child.tag not in traversal_tags and child.tag != 'Player' and child.tag != 'Marker':\n                    return True\n            \n            return False\n\n        queue = collections.deque([start])\n        reachable_tiles = {start}\n        \n        while queue:\n            current_x, current_y = queue.popleft()\n            current_elem = tile_map.get((current_x, current_y))\n\n            if current_elem is not None:\n                warp_elem = current_elem.find('Warp')\n                if warp_elem is not None and 'dest_x' in warp_elem.attrib and 'dest_y' in warp_elem.attrib:\n                    dest_x = int(warp_elem.attrib['dest_x'])\n                    dest_y = int(warp_elem.attrib['dest_y'])\n                    destination = (dest_x - 1, dest_y - 1)\n                    if destination not in reachable_tiles and not is_impassable(destination[0], destination[1]):\n                        reachable_tiles.add(destination)\n                        queue.append(destination)\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                neighbor = (current_x + dx, current_y + dy)\n\n                if not (0 <= neighbor[0] < width and 0 <= neighbor[1] < height) or neighbor in reachable_tiles:\n                    continue\n                \n                neighbor_type = get_tile_type(neighbor[0], neighbor[1])\n                if neighbor_type == 'ledge' and dy == 1:\n                    landing_spot = (neighbor[0], neighbor[1] + 1)\n                    if (0 <= landing_spot[0] < width and 0 <= landing_spot[1] < height) and \\\n                       landing_spot not in reachable_tiles and not is_impassable(landing_spot[0], landing_spot[1]):\n                        reachable_tiles.add(landing_spot)\n                        queue.append(landing_spot)\n                    continue\n\n                if not is_impassable(neighbor[0], neighbor[1]):\n                    reachable_tiles.add(neighbor)\n                    queue.append(neighbor)\n\n        border_unseen_tiles = []\n        for ux, uy in unseen_tiles:\n            unseen_coord_0based = (ux - 1, uy - 1)\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adj_tile = (unseen_coord_0based[0] + dx, unseen_coord_0based[1] + dy)\n                if adj_tile in reachable_tiles:\n                    border_unseen_tiles.append((ux, uy))\n                    break\n\n        if not border_unseen_tiles:\n            return json.dumps({'message': 'No reachable unseen tiles found.'})\n\n        closest_tile = min(border_unseen_tiles, key=lambda t: abs(t[0] - start_x) + abs(t[1] - start_y))\n        \n        closest_tile_0based = (closest_tile[0] - 1, closest_tile[1] - 1)\n        \n        best_adj_tile = None\n        min_dist = float('inf')\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_tile = (closest_tile_0based[0] + dx, closest_tile_0based[1] + dy)\n            if adj_tile in reachable_tiles:\n                dist = abs(adj_tile[0] - start[0]) + abs(adj_tile[1] - start[1])\n                if dist < min_dist:\n                    min_dist = dist\n                    best_adj_tile = adj_tile\n\n        if best_adj_tile:\n            return json.dumps({\n                'closest_reachable_unseen_tile': {'x': closest_tile[0], 'y': closest_tile[1]},\n                'adjacent_tile': {'x': best_adj_tile[0] + 1, 'y': best_adj_tile[1] + 1}\n            })\n        else:\n            return json.dumps({'message': 'Found a reachable unseen tile, but no reachable adjacent tile to path to.'})\n\n    except Exception as e:\n        import traceback\n        return json.dumps({'error': str(e), 'traceback': traceback.format_exc()})\n"
  },
  "debug_runner": {
    "description": "A simple diagnostic tool to test the code execution environment and XML parsing.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nprint(\"--- Debug Runner Start ---\")\nprint(\"Step 1: Testing basic print functionality.\")\nprint(\"Hello from debug_runner! If you see this, the execution environment is working.\")\nprint(\"\\nStep 2: Testing map_xml_string parsing.\")\ntry:\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    print(f\"SUCCESS: map_xml_string parsed successfully. Map: {root.attrib['name']}, Size: {width}x{height}\")\nexcept Exception as e:\n    print(f\"FAILURE: Could not parse map_xml_string. Error: {e}\")\nprint(\"\\n--- Debug Runner End ---\")"
  },
  "robust_pathfinder": {
    "description": "A more robust A* pathfinding tool that can be told to avoid specific 'hazard' coordinates. This is to prevent getting stuck in loops with problematic warps.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        },
        "party_data": {
          "type": "string"
        },
        "hazard_coords": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "target_x",
        "target_y",
        "party_data"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\nimport json\n\ndef parse_party_data(party_data_str):\n    try:\n        party_data = json.loads(party_data_str)\n        hms_known = set()\n        for pokemon in party_data:\n            for move in pokemon.get('moves', []):\n                move_name = move.get('name', '').upper()\n                if move_name == 'CUT':\n                    hms_known.add('cut')\n                elif move_name == 'SURF':\n                    hms_known.add('surf')\n                elif move_name == 'STRENGTH':\n                    hms_known.add('strength')\n        return hms_known\n    except (json.JSONDecodeError, TypeError):\n        return set()\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star_search(start, goal, walls, map_width, map_height, hms_known, water_tiles, cut_trees, ledges):\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {start: 0}\n    f_score = {start: heuristic(start, goal)}\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            return path[::-1]\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n\n            # Boundary check\n            if not (1 <= neighbor[0] <= map_width and 1 <= neighbor[1] <= map_height):\n                continue\n\n            # Tentative score for this path\n            tentative_g_score = g_score[current] + 1\n\n            # If path to neighbor is worse than a known path, skip\n            if tentative_g_score >= g_score.get(neighbor, float('inf')):\n                continue\n\n            # --- Start of Traversal Rule Checks ---\n            # Rule: Cannot move into walls\n            if neighbor in walls:\n                continue\n            \n            # Rule: Cannot move into cuttable tree without 'cut'\n            if neighbor in cut_trees and 'cut' not in hms_known:\n                continue\n\n            # Rule: Ledge can only be entered by moving down (dy=1)\n            if neighbor in ledges and dy != 1:\n                continue\n\n            # Rule: Handle water traversal\n            is_neighbor_water = neighbor in water_tiles\n            if is_neighbor_water:\n                # Cannot enter water at all without Surf\n                if 'surf' not in hms_known:\n                    continue\n                # CRITICAL FIX: Cannot move from a land tile directly to a water tile.\n                # Must already be on a water tile (surfing) to move to another.\n                is_current_water = current in water_tiles\n                if not is_current_water:\n                    continue\n            # --- End of Traversal Rule Checks ---\n\n            # This path is the best so far. Record it.\n            came_from[neighbor] = current\n            g_score[neighbor] = tentative_g_score\n            f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n            heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    return None # No path found\n\n# Main execution\ntry:\n    root = ET.fromstring(map_xml_string)\n    map_width = int(root.get('width'))\n    map_height = int(root.get('height'))\n    \n    player_pos = None\n    walls = set()\n    water_tiles = set()\n    cut_trees = set()\n    ledges = set()\n\n    for tile in root.findall('.//Tile'):\n        x, y = int(tile.get('id')), int(tile.get('coordinate').split(',')[1].strip(')'))\n        tile_type = tile.get('type')\n        \n        if tile.find('Player') is not None:\n            player_pos = (x, y)\n        \n        impassable_types = ['impassable', 'boulder_barrier', 'closed_gate', 'unknown']\n        if tile_type in impassable_types or tile.find('Object') is not None:\n            obj = tile.find('Object')\n            if obj is None or obj.get('id-name') != 'Pikachu':\n                 walls.add((x, y))\n        elif tile_type == 'water':\n            water_tiles.add((x, y))\n        elif tile_type == 'cuttable':\n            cut_trees.add((x, y))\n        elif tile_type == 'ledge':\n            ledges.add((x,y))\n\n    if 'hazard_coords' in input_data and input_data['hazard_coords']:\n        try:\n            hazards = json.loads(input_data['hazard_coords'])\n            for hx, hy in hazards:\n                walls.add((int(hx), int(hy)))\n        except (json.JSONDecodeError, ValueError, TypeError):\n            pass # Ignore malformed hazard_coords\n\n    start_pos = player_pos\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    goal_pos = (target_x, target_y)\n    \n    party_data_str = input_data.get('party_data', '[]')\n    hms = parse_party_data(party_data_str)\n\n    if not start_pos:\n        print('Error: Player position not found in map data.')\n    else:\n        path = a_star_search(start_pos, goal_pos, walls, map_width, map_height, hms, water_tiles, cut_trees, ledges)\n        if path:\n            # To handle ledge jumps correctly, create a new path that skips the ledge tile itself\n            final_path = []\n            i = 0\n            while i < len(path):\n                current_tile = path[i]\n                final_path.append(current_tile)\n                if current_tile in ledges and i > 0:\n                    if i + 1 < len(path):\n                        next_tile_on_path = path[i+1]\n                        if next_tile_on_path[0] == current_tile[0] and next_tile_on_path[1] == current_tile[1] + 1:\n                             i += 1\n                i += 1\n            print(json.dumps(final_path))\n        else:\n            print('Error: No path found.')\nexcept Exception as e:\n    print(f'An unexpected error occurred: {e}')"
  }
}