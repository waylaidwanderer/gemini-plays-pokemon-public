{
  "automated_explorer": {
    "description": "Finds the nearest reachable unseen tile and generates a path to an adjacent traversable tile. Now correctly handles water traversal by checking for SURF capability and planning paths across water even when not currently surfing.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\nimport json\n\ndef find_all_reachable_and_paths(start, grid, width, height, can_surf):\n    queue = collections.deque([(start, grid.get(start, {}).get('type') == 'water')])\n    came_from = {start: None}\n    \n    while queue:\n        (current, is_surfing_state) = queue.popleft()\n        \n        for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = current[0] + move_x, current[1] + move_y\n            next_pos = (next_x, next_y)\n            \n            if not (1 <= next_x <= width and 1 <= next_y <= height):\n                continue\n            \n            if next_pos in came_from:\n                continue\n                \n            current_tile_info = grid.get(current, {})\n            next_tile_info = grid.get(next_pos, {})\n            next_tile_type = next_tile_info.get('type')\n            \n            if move_y == 1 and current_tile_info.get('type') != 'ledge' and next_tile_type == 'ledge':\n                ledge_jump_pos = (next_x, next_y + 1)\n                if ledge_jump_pos in came_from: continue\n                if grid.get(ledge_jump_pos, {}).get('type') not in ['impassable', 'unknown']:\n                    came_from[next_pos] = current\n                    came_from[ledge_jump_pos] = next_pos\n                    queue.append((ledge_jump_pos, is_surfing_state))\n                continue\n\n            impassable_types = ['impassable', 'unknown', 'closed_gate']\n            if current_tile_info.get('type') != 'water':\n                 impassable_types.append('ledge')\n            \n            if next_tile_type in impassable_types:\n                continue\n\n            if next_tile_type == 'water' and not (is_surfing_state or can_surf):\n                continue\n            \n            if next_tile_info.get('has_object') and next_tile_info.get('object_name') != 'Pikachu' and not next_tile_info.get('is_defeated_trainer', False):\n                continue\n\n            current_elevation = 'elevated' if current_tile_info.get('type') == 'elevated_ground' else 'ground'\n            next_elevation = 'elevated' if next_tile_type == 'elevated_ground' else 'ground'\n            if current_elevation != next_elevation and current_tile_info.get('type') not in ['steps', 'ladder_up', 'ladder_down'] and next_tile_type not in ['steps', 'ladder_up', 'ladder_down']:\n                continue\n            \n            came_from[next_pos] = current\n            queue.append((next_pos, next_tile_type == 'water'))\n            \n    return came_from\n\ndef reconstruct_path(came_from, end):\n    if end not in came_from:\n        return None\n    path = []\n    current = end\n    while current is not None:\n        path.append(list(current))\n        current = came_from.get(current)\n    return path[::-1]\n\ndef main():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n        start_node = (start_x, start_y)\n\n        grid = {}\n        unseen_tiles = []\n        can_surf = any(node.get('name') == 'HM03 SURF' for node in json.loads(world_knowledge_graph_json_string).get('nodes', []))\n\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                is_defeated = any(marker.get('emoji') == '☠️' for marker in tile_elem.findall('Marker'))\n                grid[(x, y)] = {\n                    'type': tile_elem.get('type'),\n                    'has_object': tile_elem.get('has-object') == 'true',\n                    'object_name': tile_elem.find('Object').get('id-name') if tile_elem.find('Object') is not None else None,\n                    'is_defeated_trainer': is_defeated\n                }\n                if tile_elem.get('seen') == 'false':\n                    unseen_tiles.append((x, y))\n\n        if not unseen_tiles:\n            print(json.dumps({'status': 'success', 'message': 'No unseen tiles found.'}))\n            return\n\n        came_from = find_all_reachable_and_paths(start_node, grid, width, height, can_surf)\n        reachable_nodes = set(came_from.keys())\n        \n        targetable_unseen_tiles = [tile for tile in unseen_tiles if any((tile[0] + dx, tile[1] + dy) in reachable_nodes for dx, dy in [(0,1),(0,-1),(1,0),(-1,0)])]\n\n        if not targetable_unseen_tiles:\n            print(json.dumps({'status': 'error', 'message': 'No unseen tiles are adjacent to reachable areas.', 'reachable_nodes_count': len(reachable_nodes)}))\n            return\n\n        shortest_path = None\n        target_unseen = None\n        \n        sorted_targets = sorted(targetable_unseen_tiles, key=lambda t: (abs(t[0] - start_x) + abs(t[1] - start_y)))\n\n        for tile in sorted_targets:\n            best_adj_path = None\n            for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adj_x, adj_y = tile[0] + move_x, tile[1] + move_y\n                adj_pos = (adj_x, adj_y)\n                if adj_pos in reachable_nodes:\n                    path = reconstruct_path(came_from, adj_pos)\n                    if path and (best_adj_path is None or len(path) < len(best_adj_path)):\n                        best_adj_path = path\n            \n            if best_adj_path:\n                shortest_path = best_adj_path\n                target_unseen = tile\n                break\n        \n        if shortest_path:\n            print(json.dumps({'status': 'success', 'path': shortest_path, 'target_unseen_tile': target_unseen}))\n        else:\n            print(json.dumps({'status': 'error', 'message': 'Could not find a path to any adjacent tile of any reachable unseen tiles.'}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'status': 'error', 'message': f'An exception occurred: {traceback.format_exc()}'}))\n\nmain()"
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map. It now correctly handles dynamic transitions between walking and surfing by checking for the passed `can_surf` capability, and properly navigates ledges and other terrain.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "is_surfing": {
          "type": "string",
          "enum": [
            "true",
            "false"
          ]
        },
        "can_surf": {
          "type": "string",
          "enum": [
            "true",
            "false"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "is_surfing",
        "can_surf"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\nimport json\n\ndef find_path_v4():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        start = (int(input_data['start_x']), int(input_data['start_y']))\n        end = (int(input_data['end_x']), int(input_data['end_y']))\n        initial_is_surfing = input_data['is_surfing'] == 'true'\n        can_surf_in_field = input_data['can_surf'] == 'true'\n\n        grid = {}\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                grid[(x, y)] = {'type': tile_elem.get('type'), 'has_object': tile_elem.get('has-object') == 'true', 'object_name': tile_elem.find('Object').get('id-name') if tile_elem.find('Object') is not None else None}\n\n        queue = collections.deque([(start, initial_is_surfing)])\n        came_from = {(start, initial_is_surfing): None}\n        visited = {(start, initial_is_surfing)}\n        path_found = False\n        final_state = None\n\n        while queue:\n            current_pos, current_is_surfing = queue.popleft()\n\n            if current_pos == end:\n                path_found = True\n                final_state = (current_pos, current_is_surfing)\n                break\n\n            for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                next_pos = (current_pos[0] + move_x, current_pos[1] + move_y)\n\n                if not (1 <= next_pos[0] <= width and 1 <= next_pos[1] <= height):\n                    continue\n\n                next_tile_info = grid.get(next_pos, {})\n                next_tile_type = next_tile_info.get('type')\n                next_is_surfing = current_is_surfing\n\n                if next_tile_type in ['impassable', 'unknown', 'closed_gate']:\n                    continue\n                \n                if next_tile_info.get('has_object') and next_tile_info.get('object_name') != 'Pikachu':\n                    if next_pos != end:\n                        continue\n\n                if next_tile_type == 'water':\n                    if not current_is_surfing:\n                        if not can_surf_in_field:\n                            continue\n                        next_is_surfing = True\n                elif current_is_surfing:\n                    if next_tile_type != 'water':\n                        next_is_surfing = False\n\n                next_state = (next_pos, next_is_surfing)\n                if next_state in visited:\n                    continue\n\n                if next_tile_type == 'ledge':\n                    if current_is_surfing: continue\n                    if move_y == 1:\n                        ledge_jump_pos = (next_pos[0], next_pos[1] + 1)\n                        ledge_jump_state = (ledge_jump_pos, False)\n                        if ledge_jump_state in visited: continue\n                        if grid.get(ledge_jump_pos, {}).get('type') not in ['impassable', 'unknown', 'closed_gate']:\n                            visited.add((next_pos, False))\n                            visited.add(ledge_jump_state)\n                            came_from[(next_pos, False)] = (current_pos, current_is_surfing)\n                            came_from[ledge_jump_state] = (next_pos, False)\n                            queue.append(ledge_jump_state)\n                        continue\n                    else:\n                        continue\n\n                visited.add(next_state)\n                came_from[next_state] = (current_pos, current_is_surfing)\n                queue.append(next_state)\n        \n        if path_found:\n            path = []\n            current = final_state\n            while current is not None:\n                path.append(list(current[0]))\n                current = came_from.get(current)\n            print(json.dumps({\"status\": \"success\", \"path\": path[::-1]}))\n        else:\n            print(json.dumps({\"status\": \"error\", \"message\": \"No path found. The destination is on an unreachable segment of the map.\"}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({\"status\": \"error\", \"message\": f'An exception occurred: {traceback.format_exc()}'}))\n\nfind_path_v4()\n"
  },
  "wkg_pathfinder": {
    "description": "Calculates the shortest path between two maps in the World Knowledge Graph, returning a sequence of map IDs and warp coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_map_id": {
          "type": "string"
        },
        "end_map_id": {
          "type": "string"
        }
      },
      "required": [
        "start_map_id",
        "end_map_id"
      ]
    },
    "python_script": "import json\nimport collections\n\ndef find_path_in_wkg():\n    try:\n        graph = json.loads(world_knowledge_graph_json_string)\n        start_map = input_data['start_map_id']\n        end_map = input_data['end_map_id']\n\n        nodes = graph.get('nodes', [])\n        edges = graph.get('edges', [])\n\n        adj = collections.defaultdict(list)\n        for edge in edges:\n            adj[edge['source_node_id']].append(edge['destination_node_id'])\n            if not edge.get('is_one_way', False):\n                adj[edge['destination_node_id']].append(edge['source_node_id'])\n\n        node_map = {node['id']: node for node in nodes}\n\n        start_nodes = [node['id'] for node in nodes if node['map_id'] == start_map]\n        if not start_nodes:\n            print(json.dumps({\"status\": \"error\", \"message\": f\"Start map ID '{start_map}' not found in World Knowledge Graph.\"}))\n            return\n\n        queue = collections.deque([(start_node, [start_node]) for start_node in start_nodes])\n        visited = set(start_nodes)\n        \n        path_found = False\n        final_path = []\n\n        while queue:\n            current_node_id, path = queue.popleft()\n\n            if node_map[current_node_id]['map_id'] == end_map:\n                path_found = True\n                final_path = path\n                break\n\n            for neighbor_id in adj[current_node_id]:\n                if neighbor_id not in visited:\n                    visited.add(neighbor_id)\n                    new_path = list(path)\n                    new_path.append(neighbor_id)\n                    queue.append((neighbor_id, new_path))\n\n        if path_found:\n            result_path = []\n            for node_id in final_path:\n                node_info = node_map.get(node_id)\n                if node_info:\n                    result_path.append({\n                        \"map_id\": node_info.get(\"map_id\"),\n                        \"coordinates\": node_info.get(\"coordinates\")\n                    })\n            print(json.dumps({\"status\": \"success\", \"path\": result_path}))\n        else:\n            print(json.dumps({\"status\": \"error\", \"message\": f\"No path found from map '{start_map}' to '{end_map}'.\"}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({\"status\": \"error\", \"message\": f'An exception occurred: {traceback.format_exc()}'}))\n\nfind_path_in_wkg()\n"
  },
  "find_wkg_node_by_coords": {
    "description": "Finds a World Knowledge Graph node ID by map ID and coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "map_id": {
          "type": "string"
        },
        "x": {
          "type": "string"
        },
        "y": {
          "type": "string"
        }
      },
      "required": [
        "map_id",
        "x",
        "y"
      ]
    },
    "python_script": "import json\n\ndef find_node():\n    try:\n        wkg = json.loads(world_knowledge_graph_json_string)\n        target_map_id = input_data['map_id']\n        target_x = int(input_data['x'])\n        target_y = int(input_data['y'])\n\n        for node in wkg['nodes']:\n            if str(node['map_id']) == str(target_map_id) and node['coordinates']['x'] == target_x and node['coordinates']['y'] == target_y:\n                print(json.dumps({'status': 'success', 'node_id': node['id']}))\n                return\n        \n        print(json.dumps({'status': 'error', 'message': f'Node not found on map {target_map_id} at ({target_x}, {target_y}).'}))\n\n    except Exception as e:\n        import traceback\n        print(json.dumps({'status': 'error', 'message': f'An exception occurred: {traceback.format_exc()}'}))\n\nfind_node()"
  },
  "check_wkg_edge_exists": {
    "description": "Checks if a bidirectional edge exists between two nodes in the World Knowledge Graph, identified by their map IDs and coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "source_map_id": {
          "type": "string"
        },
        "source_x": {
          "type": "string"
        },
        "source_y": {
          "type": "string"
        },
        "dest_map_id": {
          "type": "string"
        },
        "dest_x": {
          "type": "string"
        },
        "dest_y": {
          "type": "string"
        }
      },
      "required": [
        "source_map_id",
        "source_x",
        "source_y",
        "dest_map_id",
        "dest_x",
        "dest_y"
      ]
    },
    "python_script": "import json\n\nwkg = json.loads(world_knowledge_graph_json_string)\nnodes = wkg['nodes']\nedges = wkg['edges']\n\nsource_map_id = input_data['source_map_id']\nsource_x = int(input_data['source_x'])\nsource_y = int(input_data['source_y'])\ndest_map_id = input_data['dest_map_id']\ndest_x = int(input_data['dest_x'])\ndest_y = int(input_data['dest_y'])\n\nsource_node_id = None\ndest_node_id = None\n\nfor node in nodes:\n    if str(node['map_id']) == source_map_id and node['coordinates']['x'] == source_x and node['coordinates']['y'] == source_y:\n        source_node_id = node['id']\n    if str(node['map_id']) == dest_map_id and node['coordinates']['x'] == dest_x and node['coordinates']['y'] == dest_y:\n        dest_node_id = node['id']\n\nif not source_node_id or not dest_node_id:\n    print(json.dumps({'exists': False, 'reason': 'One or both nodes not found in WKG.'}))\nelse:\n    edge_found = False\n    for edge in edges:\n        if (edge['source_node_id'] == source_node_id and edge['destination_node_id'] == dest_node_id) or \\\n           (edge['source_node_id'] == dest_node_id and edge['destination_node_id'] == source_node_id):\n            edge_found = True\n            break\n    print(json.dumps({'exists': edge_found}))"
  }
}