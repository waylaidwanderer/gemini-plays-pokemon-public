{
  "find_path_v11": {
    "description": "Advanced pathfinding tool that handles land-water transitions and avoids obstacles. Uses global map_xml_string.",
    "input_schema": {
      "properties": {
        "can_cut": {
          "default": true,
          "type": "boolean"
        },
        "can_surf": {
          "default": true,
          "type": "boolean"
        },
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        }
      },
      "required": [
        "end_x",
        "end_y"
      ],
      "type": "object"
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\nimport json\nimport sys\n\ndef solve():\n    global map_xml_string\n    if 'map_xml_string' not in globals() or not map_xml_string:\n        print(json.dumps([]))\n        return\n\n    input_data = {}\n    try:\n        raw_input = sys.stdin.read()\n        if raw_input:\n            input_data = json.loads(raw_input)\n    except:\n        pass\n        \n    root = ET.fromstring(map_xml_string)\n    if 'end_x' not in input_data or 'end_y' not in input_data:\n        print(json.dumps([]))\n        return\n        \n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    can_cut = input_data.get('can_cut', True)\n    can_surf = input_data.get('can_surf', True)\n    \n    grid = {}\n    player_pos = None\n    \n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            t_type = tile.get('type')\n            has_player = tile.find('Player') is not None\n            has_object = tile.find('Object') is not None\n            \n            if has_player:\n                player_pos = (x, y)\n            \n            grid[(x, y)] = {\n                'type': t_type,\n                'has_object': has_object\n            }\n\n    if player_pos is None:\n        print(json.dumps([]))\n        return\n\n    def get_buttons(path):\n        buttons = []\n        for i in range(len(path) - 1):\n            curr = path[i]\n            nxt = path[i+1]\n            if nxt[0] > curr[0]: buttons.append(\"Right\")\n            elif nxt[0] < curr[0]: buttons.append(\"Left\")\n            elif nxt[1] > curr[1]: buttons.append(\"Down\")\n            elif nxt[1] < curr[1]: buttons.append(\"Up\")\n        return buttons\n\n    queue = collections.deque([(player_pos, [])])\n    visited = {player_pos}\n    \n    impassable_types = {'WALL', 'BUOY', 'COUNTER', 'HEADBUTT_TREE'}\n    \n    while queue:\n        (curr_x, curr_y), path = queue.popleft()\n        \n        if curr_x == end_x and curr_y == end_y:\n            print(json.dumps(get_buttons(path + [(curr_x, curr_y)])))\n            return\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = curr_x + dx, curr_y + dy\n            if (nx, ny) in grid and (nx, ny) not in visited:\n                tile = grid[(nx, ny)]\n                \n                is_blocked = False\n                if tile['type'] in impassable_types: is_blocked = True\n                if tile['type'] == 'CUT_TREE' and not can_cut: is_blocked = True\n                if tile['type'] == 'WATER' and not can_surf: is_blocked = True\n                if tile['has_object'] and (nx != end_x or ny != end_y): is_blocked = True\n                \n                if not is_blocked:\n                    visited.add((nx, ny))\n                    queue.append(((nx, ny), path + [(curr_x, curr_y)]))\n    \n    print(json.dumps([]))\n\nif __name__ == \"__main__\":\n    solve()",
    "history": [
      {
        "commit_message": "Initial version of refined pathfinding tool for land/water transitions.",
        "timestamp": "2025-12-28T06:02:21.601Z",
        "action_counter": 27924
      }
    ]
  },
  "get_reachable_unseen_tiles": {
    "description": "Finds all unseen tiles that are directly adjacent to reachable, passable tiles on the current map. Returns a JSON array of coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\n# map_xml_string and input_data are provided by the harness\n\nroot = ET.fromstring(map_xml_string)\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\n\ngrid = {}\nfor row in root.findall('Row'):\n    y = int(row.attrib['id'])\n    for tile in row.findall('Tile'):\n        x = int(tile.attrib['id'])\n        tile_type = tile.attrib['type']\n        seen = tile.attrib['seen'] == 'true'\n        grid[(x, y)] = {'type': tile_type, 'seen': seen}\n        \nreachable = set()\nqueue = deque([(start_x, start_y)])\nvisited = set([(start_x, start_y)])\n\n# Passable types\npassable_types = ['FLOOR', 'TALL_GRASS', 'LONG_GRASS', 'WARP_CARPET', 'WATER', 'ICE', 'WARP_CARPET_DOWN', 'WARP_CARPET_UP', 'WARP_CARPET_LEFT', 'WARP_CARPET_RIGHT']\n\nwhile queue:\n    cx, cy = queue.popleft()\n    reachable.add((cx, cy))\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nx, ny = cx + dx, cy + dy\n        if (nx, ny) in grid and (nx, ny) not in visited:\n            if grid[(nx, ny)]['seen'] and grid[(nx, ny)]['type'] in passable_types:\n                visited.add((nx, ny))\n                queue.append((nx, ny))\n\nunseen_reachable = set()\nfor rx, ry in reachable:\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nx, ny = rx + dx, ry + dy\n        if (nx, ny) in grid and not grid[(nx, ny)]['seen']:\n            unseen_reachable.add((nx, ny))\n\nprint(json.dumps(sorted(list(unseen_reachable))))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T06:20:54.963Z",
        "action_counter": 27975
      },
      {
        "commit_message": "Fixed the tool to execute the logic and print the result properly. Removed function wrapping to ensure execution in the harness environment.",
        "timestamp": "2025-12-28T06:21:58.588Z",
        "action_counter": 27977
      },
      {
        "commit_message": "Added 'ICE' and 'WARP_CARPET_DOWN' to passable types for better exploration.",
        "timestamp": "2025-12-28T07:02:21.682Z",
        "action_counter": 28055
      }
    ]
  },
  "find_ice_path_v1": {
    "description": "Calculates a path through ice sliding tiles using the global map_xml_string. Returns a JSON array of button presses.",
    "input_schema": {
      "properties": {
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "type": "integer"
        },
        "start_y": {
          "type": "integer"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ],
      "type": "object"
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef solve():\n    root = ET.fromstring(map_xml_string)\n    grid = {}\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            grid[(x, y)] = tile.attrib['type']\n\n    start = (int(input_data['start_x']), int(input_data['start_y']))\n    goal = (int(input_data['end_x']), int(input_data['end_y']))\n\n    queue = deque([(start, [])])\n    visited = {start}\n\n    while queue:\n        (x, y), path = queue.popleft()\n        if (x, y) == goal:\n            print(json.dumps(path))\n            return\n        \n        for dx, dy, btn in [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]:\n            cx, cy = x, y\n            while True:\n                nx, ny = cx + dx, cy + dy\n                if (nx, ny) not in grid: break\n                t_type = grid[(nx, ny)]\n                if t_type in ['WALL', 'FLOOR_UP_WALL', 'SIGNPOST', 'VOID']: break\n                \n                cx, cy = nx, ny\n                if grid[(cx, cy)] != 'ICE': break\n                \n            if (cx, cy) not in visited:\n                visited.add((cx, cy))\n                queue.append(((cx, cy), path + [btn]))\n    print(\"[]\")\n\nsolve()",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-28T07:58:41.341Z",
        "action_counter": 28172
      }
    ]
  }
}