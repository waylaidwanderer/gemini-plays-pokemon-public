{
  "find_path_bfs": {
    "description": "Finds a path from the player's current position to a target coordinate using Breadth-First Search (BFS). It correctly handles one-way ledges and other obstacles (including marked, off-screen objects), and will find a path to an adjacent tile if the target is impassable.",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_x": {
          "type": "integer"
        },
        "target_y": {
          "type": "integer"
        }
      },
      "required": [
        "target_x",
        "target_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef parse_map(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    tiles = {}\n    player_pos = None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tiles[(x, y)] = tile\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n    return tiles, player_pos, width, height\n\ndef is_obstacle(tile):\n    if tile is None: return True\n    tile_type = tile.attrib['type']\n    if tile_type in ['WALL', 'HEADBUTT_TREE', 'VOID', 'CUT_TREE', 'COUNTER', 'unseen'] or tile.find('Object') is not None or tile.find('Marker') is not None:\n        if tile.attrib.get('is-warp') == 'true':\n             return False\n        return True\n    return False\n\ndef bfs_search(tiles, start, goal, width, height):\n    neighbors = [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]\n\n    if is_obstacle(tiles.get(goal)):\n        potential_goals = []\n        for dx, dy, _ in neighbors:\n            adj_coord = (goal[0] + dx, goal[1] + dy)\n            if not is_obstacle(tiles.get(adj_coord)):\n                potential_goals.append(adj_coord)\n        if not potential_goals:\n            return None\n        potential_goals.sort(key=lambda p: abs(p[0] - start[0]) + abs(p[1] - start[1]))\n        goal = potential_goals[0]\n\n    queue = deque([[start]])\n    visited = {start}\n\n    while queue:\n        path = queue.popleft()\n        node = path[-1]\n\n        if node == goal:\n            return path\n\n        for i, j, move_dir in neighbors:\n            neighbor_coord = (node[0] + i, node[1] + j)\n            \n            if not (1 <= neighbor_coord[0] <= width and 1 <= neighbor_coord[1] <= height):\n                continue\n\n            if neighbor_coord in visited:\n                continue\n            \n            neighbor_tile = tiles.get(neighbor_coord)\n\n            if is_obstacle(neighbor_tile):\n                continue\n            \n            current_tile_type = tiles.get(node).attrib.get('type')\n            neighbor_tile_type = neighbor_tile.attrib.get('type')\n\n            if move_dir == 'Up' and neighbor_tile_type == 'LEDGE_HOP_DOWN': continue\n            if move_dir == 'Right' and neighbor_tile_type == 'LEDGE_HOP_LEFT': continue\n            if move_dir == 'Left' and neighbor_tile_type == 'LEDGE_HOP_RIGHT': continue\n\n            new_path = list(path)\n            new_path.append(neighbor_coord)\n            queue.append(new_path)\n            visited.add(neighbor_coord)\n            \n    return None\n\ntry:\n    target_x = int(input_data['target_x'])\n    target_y = int(input_data['target_y'])\n    tiles, player_pos, map_width, map_height = parse_map(map_xml_string)\n    if player_pos:\n        path = bfs_search(tiles, player_pos, (target_x, target_y), map_width, map_height)\n        if path:\n            path_coords = [{'x': p[0], 'y': p[1]} for p in path]\n            print(json.dumps(path_coords))\n        else:\n            print(json.dumps([]))\n    else:\n        print(json.dumps([]))\nexcept Exception as e:\n    import traceback\n    print(f'An error occurred: {e}\\n{traceback.format_exc()}')"
  },
  "find_reachable_unseen_tiles": {
    "description": "Parses the map to find all unseen tiles that are adjacent to walkable tiles and then uses BFS to determine which of them are reachable from the player's current position.",
    "input_schema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef parse_map(xml_string):\n    root = ET.fromstring(xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    tiles = {}\n    player_pos = None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            tiles[(x, y)] = tile\n            if tile.find('Player') is not None:\n                player_pos = (x, y)\n    return tiles, player_pos, width, height\n\ndef is_obstacle(tile):\n    if tile is None: return True\n    tile_type = tile.attrib['type']\n    return tile_type in ['WALL', 'HEADBUTT_TREE', 'VOID', 'CUT_TREE', 'COUNTER'] or tile.find('Object') is not None\n\ndef bfs_find_all_reachable(tiles, start, width, height):\n    queue = deque([start])\n    visited = {start}\n    reachable = set()\n    neighbors = [(0, 1, 'Down'), (0, -1, 'Up'), (1, 0, 'Right'), (-1, 0, 'Left')]\n\n    while queue:\n        node = queue.popleft()\n        reachable.add(node)\n\n        for dx, dy, move_dir in neighbors:\n            neighbor_coord = (node[0] + dx, node[1] + dy)\n            if not (1 <= neighbor_coord[0] <= width and 1 <= neighbor_coord[1] <= height):\n                continue\n            if neighbor_coord in visited:\n                continue\n            \n            neighbor_tile = tiles.get(neighbor_coord)\n            if is_obstacle(neighbor_tile):\n                continue\n\n            # Corrected Ledge logic\n            current_tile_type = tiles.get(node).attrib.get('type')\n            neighbor_tile_type = neighbor_tile.attrib.get('type')\n\n            if move_dir == 'Up' and neighbor_tile_type == 'LEDGE_HOP_DOWN': continue\n            if move_dir == 'Right' and neighbor_tile_type == 'LEDGE_HOP_LEFT': continue\n            if move_dir == 'Left' and neighbor_tile_type == 'LEDGE_HOP_RIGHT': continue\n\n            visited.add(neighbor_coord)\n            queue.append(neighbor_coord)\n    return reachable\n\ntry:\n    tiles, player_pos, map_width, map_height = parse_map(map_xml_string)\n    if player_pos:\n        reachable_tiles = bfs_find_all_reachable(tiles, player_pos, map_width, map_height)\n        unseen_reachable = []\n        for coord in reachable_tiles:\n            tile = tiles.get(coord)\n            if tile is not None and tile.attrib['seen'] == 'false':\n                unseen_reachable.append({'x': coord[0], 'y': coord[1]})\n        print(json.dumps(unseen_reachable))\n    else:\n        print(json.dumps([]))\nexcept Exception as e:\n    import traceback\n    print(f'An error occurred: {e}\\n{traceback.format_exc()}')"
  }
}