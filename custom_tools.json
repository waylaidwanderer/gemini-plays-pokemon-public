{
  "find_path": {
    "description": "Finds the shortest path on the current map using BFS. Avoids impassable tiles, objects, and unseen areas.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef find_path_logic(map_xml_string, start_x, start_y, end_x, end_y):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = [['' for _ in range(width + 1)] for _ in range(height + 1)]\n    \n    impassable_tiles = {'WALL', 'HEADBUTT_TREE', 'CUT_TREE', 'WATER', 'COUNTER', 'MART_SHELF', 'BUOY', 'TOWN_MAP', 'WINDOW', 'BOOKSHELF', 'TV', 'RADIO', 'VOID'}\n    \n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.attrib['id'])\n            tile_type = tile_elem.attrib['type']\n            seen = tile_elem.attrib['seen']\n            \n            if seen == 'false' or tile_elem.find('Object') is not None or tile_type in impassable_tiles:\n                grid[y][x] = 'WALL'\n            else:\n                grid[y][x] = tile_type\n\n    start = (start_x, start_y)\n    end = (end_x, end_y)\n    \n    if not (1 <= start[0] <= width and 1 <= start[1] <= height and 1 <= end[0] <= width and 1 <= end[1] <= height):\n        return json.dumps({\"error\": \"Start or end coordinates are out of bounds.\"})\n\n    if grid[start[1]][start[0]] == 'WALL' or grid[end[1]][end[0]] == 'WALL':\n        return json.dumps({\"error\": \"Start or end tile is impassable.\"})\n\n    queue = deque([(start, [start])])\n    visited = {start}\n    \n    while queue:\n        (current_x, current_y), path = queue.popleft()\n        \n        if (current_x, current_y) == end:\n            return json.dumps([{'x': p[0], 'y': p[1]} for p in path])\n            \n        moves = [(0, -1, 'Up'), (0, 1, 'Down'), (-1, 0, 'Left'), (1, 0, 'Right')]\n        \n        for dx, dy, move_dir in moves:\n            next_x, next_y = current_x + dx, current_y + dy\n            \n            if not (1 <= next_x <= width and 1 <= next_y <= height):\n                continue\n\n            if (next_x, next_y) in visited:\n                continue\n\n            next_tile_type = grid[next_y][next_x]\n            if next_tile_type == 'WALL':\n                continue\n            \n            current_tile_type = grid[current_y][current_x]\n            if dy == 1 and 'LEDGE' in current_tile_type: \n                pass\n            elif dy == -1 and 'LEDGE' in grid[next_y][next_x]:\n                continue\n\n            visited.add((next_x, next_y))\n            new_path = list(path)\n            new_path.append((next_x, next_y))\n            queue.append(((next_x, next_y), new_path))\n            \n    return json.dumps({\"error\": \"No path found.\"})\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\n\nresult = find_path_logic(map_xml_string, start_x, start_y, end_x, end_y)\nprint(result)"
  },
  "path_master": {
    "description": "Finds the shortest path on the current map using A*. Avoids impassable tiles, objects, and unseen areas. It also correctly handles one-way tiles like ledges.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import heapq\nimport xml.etree.ElementTree as ET\nimport json\n\ndef run_path_master(start_x_str, start_y_str, end_x_str, end_y_str):\n    start_x, start_y = int(start_x_str), int(start_y_str)\n    end_x, end_y = int(end_x_str), int(end_y_str)\n\n    try:\n        root = ET.fromstring(map_xml_string)\n    except ET.ParseError as e:\n        print(f\"Error parsing map_xml_string: {e}\")\n        return\n\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = [['VOID' for _ in range(width + 1)] for _ in range(height + 1)]\n    objects = set()\n\n    impassable_types = {'WALL', 'WATER', 'CUT_TREE', 'BUOY', 'TOWN_MAP', 'WINDOW', 'BOOKSHELF', 'TV', 'RADIO', 'VOID', 'MART_SHELF', 'COUNTER', 'PC', 'HEADBUTT_TREE', 'PILLAR'}\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            \n            grid[y][x] = tile_type\n            \n            if tile_elem.get('seen') == 'false':\n                grid[y][x] = 'unseen'\n            \n            if tile_elem.find('Object') is not None:\n                objects.add((y, x))\n\n    def get_possible_moves(y, x):\n        tile_type = grid[y][x]\n        if 'FLOOR_HOP_DOWN_LEDGE' in tile_type:\n            return [(1, 0)]\n        if 'FLOOR_HOP_RIGHT_LEDGE' in tile_type:\n            return [(0, 1)]\n        if 'FLOOR_HOP_LEFT_LEDGE' in tile_type:\n            return [(0, -1)]\n        if 'FLOOR_HOP_DOWN_OR_RIGHT_LEDGE' in tile_type:\n            return [(1, 0), (0, 1)]\n        if 'FLOOR_HOP_DOWN_OR_LEFT_LEDGE' in tile_type:\n            return [(1, 0), (0, -1)]\n        return [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    def is_traversable(y, x, from_y, from_x):\n        if not (0 <= y <= height and 0 <= x <= width):\n            return False\n        tile_type = grid[y][x]\n        if tile_type in impassable_types or tile_type == 'unseen' or (y, x) in objects:\n            return False\n        \n        if y < from_y and 'LEDGE' in tile_type:\n            return False\n\n        return True\n\n    start = (start_y, start_x)\n    end = (end_y, end_x)\n\n    if not (0 <= start[0] <= height and 0 <= start[1] <= width):\n        print(f\"Start {start_x, start_y} is out of bounds.\")\n        return\n\n    pq = [(0, start, [])]\n    visited = set()\n    cost_so_far = {start: 0}\n\n    while pq:\n        _, current, path = heapq.heappop(pq)\n        y, x = current\n\n        if current in visited:\n            continue\n        \n        visited.add(current)\n        new_path = path + [current]\n\n        if current == end:\n            path_coords = [{\"x\": px, \"y\": py} for py, px in new_path]\n            print(json.dumps(path_coords))\n            return\n\n        for dy, dx in get_possible_moves(y, x):\n            ny, nx = y + dy, x + dx\n            neighbor = (ny, nx)\n            \n            if is_traversable(ny, nx, y, x):\n                new_cost = cost_so_far[current] + 1\n                if neighbor not in cost_so_far or new_cost < cost_so_far[neighbor]:\n                    cost_so_far[neighbor] = new_cost\n                    heuristic = abs(ny - end[0]) + abs(nx - end[1])\n                    priority = new_cost + heuristic\n                    heapq.heappush(pq, (priority, neighbor, new_path))\n                \n    print(\"No path found\")\n\nrun_path_master(input_data['start_x'], input_data['start_y'], input_data['end_x'], input_data['end_y'])"
  },
  "unstick_me_tool": {
    "description": "Analyzes the map XML to find the nearest cluster of 'unseen' tiles when stuck. Returns coordinates for a new navigation goal. Can also check for softlock conditions (e.g., no path to any warp/exit).",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef find_unseen_cluster(start_x_str, start_y_str):\n    start_x, start_y = int(start_x_str), int(start_y_str)\n\n    try:\n        root = ET.fromstring(map_xml_string)\n    except ET.ParseError as e:\n        print(f\"Error parsing map_xml_string: {e}\")\n        return\n\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    \n    grid = [['VOID' for _ in range(width + 2)] for _ in range(height + 2)]\n    objects = set()\n    unseen_tiles = []\n    warps = []\n\n    impassable_types = {'WALL', 'WATER', 'CUT_TREE', 'BUOY', 'TOWN_MAP', 'WINDOW', 'BOOKSHELF', 'TV', 'RADIO', 'VOID', 'MART_SHELF', 'COUNTER', 'PC', 'HEADBUTT_TREE', 'PILLAR'}\n\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.get('id'))\n        for tile_elem in row_elem.findall('Tile'):\n            x = int(tile_elem.get('id'))\n            tile_type = tile_elem.get('type')\n            \n            grid[y][x] = tile_type\n            \n            if tile_elem.get('seen') == 'false':\n                unseen_tiles.append((x, y))\n            \n            if tile_elem.find('Object') is not None:\n                objects.add((y, x))\n            \n            if tile_elem.find('Warp') is not None:\n                warps.append((x, y))\n\n    def is_traversable(y, x):\n        if not (0 <= y < len(grid) and 0 <= x < len(grid[0])):\n            return False\n        tile_type = grid[y][x]\n        if tile_type in impassable_types or (y, x) in objects or tile_type == 'unseen':\n            return False\n        return True\n\n    q = deque([(start_y, start_x)])\n    visited = {(start_y, start_x)}\n    reachable_unseen = []\n\n    while q:\n        y, x = q.popleft()\n\n        for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            ny, nx = y + dy, x + dx\n            neighbor = (ny, nx)\n            if (nx, ny) in unseen_tiles and neighbor not in visited:\n                reachable_unseen.append((nx, ny))\n                visited.add(neighbor)\n            elif is_traversable(ny, nx) and neighbor not in visited:\n                visited.add(neighbor)\n                q.append(neighbor)\n\n    if not reachable_unseen:\n        is_softlocked = True\n        q_warp = deque([(start_y, start_x)])\n        visited_warp = {(start_y, start_x)}\n        while q_warp:\n            y, x = q_warp.popleft()\n            if (x, y) in warps:\n                is_softlocked = False\n                break\n            for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                ny, nx = y + dy, x + dx\n                neighbor = (ny, nx)\n                if is_traversable(ny, nx) and neighbor not in visited_warp:\n                    visited_warp.add(neighbor)\n                    q_warp.append(neighbor)\n        if is_softlocked:\n            print(json.dumps({\"status\": \"softlocked\", \"message\": \"No path to any warp or exit and no reachable unseen tiles.\"}))\n        else:\n            print(json.dumps({\"status\": \"no_unseen\", \"message\": \"No reachable unseen tiles found.\"}))\n        return\n\n    # Find the closest unseen tile\n    closest_tile = None\n    min_dist = float('inf')\n    for ux, uy in reachable_unseen:\n        dist = abs(ux - start_x) + abs(uy - start_y)\n        if dist < min_dist:\n            min_dist = dist\n            closest_tile = (ux, uy)\n    \n    print(json.dumps({\"status\": \"found\", \"goal_x\": closest_tile[0], \"goal_y\": closest_tile[1]}))\n\nfind_unseen_cluster(input_data['start_x'], input_data['start_y'])"
  }
}