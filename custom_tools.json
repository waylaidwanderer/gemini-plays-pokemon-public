{
  "object_finder": {
    "description": "Finds a specific map object by its ID and returns its coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "object_id": {
          "type": "string"
        }
      },
      "required": [
        "object_id"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\ntarget_id = input_data['object_id']\nroot = ET.fromstring(map_xml_string)\nfound = False\nfor row in root.findall('Row'):\n    y = row.get('id')\n    for tile in row.findall('Tile'):\n        x = tile.get('id')\n        for obj in tile.findall('Object'):\n            if obj.get('id') == target_id:\n                print(json.dumps({'x': x, 'y': y}))\n                found = True\n                break\n        if found:\n            break\n    if found:\n        break\n\nif not found:\n    print(json.dumps({'error': 'Object not found on screen.'}))"
  },
  "pathfinder": {
    "description": "A* pathfinding tool. Finds the shortest path between two points. If the target is impassable, it finds a path to the closest traversable adjacent tile. Can be given a list of coordinates to avoid.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "traversable_tiles": {
          "type": "string"
        },
        "avoid_coordinates": {
          "type": "string",
          "description": "Optional. Comma-separated coordinates to avoid, e.g., 'x1,y1,x2,y2'"
        },
        "hms_available": {
          "type": "string",
          "description": "Optional. Comma-separated list of HMs the player has, e.g., 'SURF,FLASH'"
        },
        "debug": {
          "type": "string",
          "description": "Optional. Set to 'true' to enable debug logging."
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "traversable_tiles"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\nimport json\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef find_path_on_graph(start_node, end_node, graph, debug=False):\n    open_set = []\n    heapq.heappush(open_set, (0, start_node))\n    came_from = {}\n    g_score = {node: float('inf') for node in graph}\n    g_score[start_node] = 0\n    f_score = {node: float('inf') for node in graph}\n    f_score[start_node] = heuristic(start_node, end_node)\n\n    if debug:\n        print(f\"Pathfinding from {start_node} to {end_node}...\")\n\n    while open_set:\n        _, current = heapq.heappop(open_set)\n\n        if current == end_node:\n            path = []\n            temp = current\n            while temp in came_from:\n                path.append(temp)\n                temp = came_from[temp]\n            path.append(start_node)\n            path.reverse()\n            return path\n\n        for neighbor, weight in graph.get(current, {}).items():\n            tentative_g_score = g_score[current] + weight\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + heuristic(neighbor, end_node)\n                if neighbor not in [i[1] for i in open_set]:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    base_traversable_tiles = {tile.strip() for tile in input_data.get('traversable_tiles', '').split(',')}\n    hms_available = {hm.strip().upper() for hm in input_data.get('hms_available', '').split(',') if hm.strip()}\n    avoid_coords_str = input_data.get('avoid_coordinates', '')\n    avoid_set = set()\n    if avoid_coords_str:\n        parts = [int(c.strip()) for c in avoid_coords_str.split(',')]\n        avoid_set = set(zip(parts[0::2], parts[1::2]))\n\n    debug = input_data.get('debug', 'false').lower() == 'true'\n\n    if debug:\n        print(\"--- Pathfinder Debug ---\")\n        print(f\"Start: ({start_x}, {start_y}), End: ({end_x}, {end_y})\")\n        print(f\"Traversable Tiles: {base_traversable_tiles}\")\n        print(f\"Avoid Coords: {avoid_set}\")\n\n    root = ET.fromstring(map_xml_string)\n    tile_data = {}\n    nodes = set()\n    for row_elem in root.findall('Row'):\n        y = int(row_elem.attrib['id'])\n        for tile_elem in row_elem.findall('Tile'):\n            if tile_elem.attrib.get('seen') != 'true':\n                continue\n            x = int(tile_elem.attrib['id'])\n            coord = (x, y)\n            if coord in avoid_set:\n                continue\n            tile_type = tile_elem.attrib['type']\n            has_object = tile_elem.attrib.get('has-object') == 'true'\n            tile_data[coord] = {'type': tile_type, 'has_object': has_object}\n            is_traversable = tile_type in base_traversable_tiles\n            if not has_object and is_traversable:\n                nodes.add(coord)\n\n    if debug:\n        print(f\"Total traversable nodes found: {len(nodes)}\")\n\n    graph = {}\n    for node in nodes:\n        graph[node] = {}\n        node_type = tile_data[node]['type']\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (node[0] + dx, node[1] + dy)\n            if neighbor not in nodes: continue\n            neighbor_type = tile_data.get(neighbor, {}).get('type')\n            if not neighbor_type: continue\n            \n            if node_type == 'LEDGE_HOP_DOWN' and (dx != 0 or dy != 1): continue\n            if node_type == 'LEDGE_HOP_LEFT' and (dx != -1 or dy != 0): continue\n            if node_type == 'LEDGE_HOP_RIGHT' and (dx != 1 or dy != 0): continue\n            is_node_fuw = node_type == 'FLOOR_UP_WALL'\n            is_neighbor_fuw = neighbor_type == 'FLOOR_UP_WALL'\n            if is_neighbor_fuw and not is_node_fuw and dy != -1: continue\n            if is_node_fuw and not is_neighbor_fuw and dy != 1: continue\n\n            graph[node][neighbor] = 1\n\n    start_node = (start_x, start_y)\n    target_node = (end_x, end_y)\n    \n    if debug:\n        serializable_graph = {str(k): {str(nk): nv for nk, nv in v.items()} for k, v in graph.items()}\n        print(\"--- Generated Graph ---\")\n        print(json.dumps(serializable_graph))\n\n    if start_node not in graph:\n        print(json.dumps({'error': f'Start node ({start_node}) is not in the traversable graph.'}))\n        exit()\n\n    if target_node not in graph:\n        if debug:\n            print(f\"Target node {target_node} is not traversable. Finding closest adjacent node.\")\n        possible_targets = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_node = (end_x + dx, end_y + dy)\n            if adj_node in graph:\n                possible_targets.append(adj_node)\n        \n        if not possible_targets:\n            print(json.dumps({'error': 'No traversable adjacent tiles found for the target.'}))\n            exit()\n\n        closest_target = min(possible_targets, key=lambda p: heuristic(start_node, p))\n        if debug:\n            print(f\"New target node: {closest_target}\")\n        target_node = closest_target\n\n    final_path = find_path_on_graph(start_node, target_node, graph, debug)\n    if final_path:\n        print(json.dumps({'path': [{'x': p[0], 'y': p[1]} for p in final_path]}))\n    else:\n        print(json.dumps({'error': 'No path found.'}))\nexcept Exception as e:\n    print(json.dumps({'error': f'An error occurred: {e}'}))"
  },
  "warp_scanner": {
    "description": "Scans the current map XML and returns the coordinates of all warp tiles that do not have a map marker.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\n\nroot = ET.fromstring(map_xml_string)\nunmarked_warps = []\nfor row_elem in root.findall('Row'):\n    for tile_elem in row_elem.findall('Tile'):\n        if tile_elem.attrib.get('is-warp') == 'true':\n            has_marker = False\n            for child in tile_elem:\n                if child.tag == 'Marker':\n                    has_marker = True\n                    break\n            if not has_marker:\n                x = tile_elem.attrib['id']\n                y = row_elem.attrib['id']\n                unmarked_warps.append({'x': int(x), 'y': int(y)})\nprint(json.dumps({'unmarked_warps': unmarked_warps}))"
  },
  "cianwood_gym_solver": {
    "description": "Analyzes the Cianwood Gym boulder puzzle using pathfinding and returns the next optimal action (BATTLE, PUSH, or MOVE to reset).",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef cianwood_gym_solver(map_xml_string):\n    root = ET.fromstring(map_xml_string)\n    width = int(root.attrib['width'])\n    height = int(root.attrib['height'])\n    \n    grid = [['' for _ in range(width)] for _ in range(height)]\n    player_pos = None\n    boulders = []\n    trainers = []\n    non_battling_trainer_ids = {2, 3} # Ignore list for non-battling trainers like Yoshi (ID 2) and Lao (ID 3)\n\n    for y, row_element in enumerate(root.findall('Row')):\n        for x, tile_element in enumerate(row_element.findall('Tile')):\n            grid[y][x] = tile_element.attrib['type']\n            if tile_element.find('Player') is not None:\n                player_pos = (x, y)\n            \n            obj_element = tile_element.find('Object')\n            if obj_element is not None:\n                obj_id_name = obj_element.attrib.get('id-name', '')\n                if not obj_id_name:\n                    continue\n\n                obj_id = int(obj_element.attrib['id'])\n                facing = obj_element.attrib.get('facing', 'down')\n                grid[y][x] = 'WALL' # Treat all objects as walls for pathing\n                \n                markers = tile_element.findall('Marker')\n                is_defeated = False\n                for marker in markers:\n                    if '☠️' in marker.attrib.get('emoji', ''):\n                        is_defeated = True\n                        break\n\n                if 'BOULDER' in obj_id_name:\n                    boulders.append({'id': obj_id, 'pos': (x, y)})\n                elif 'BLACK_BELT' in obj_id_name:\n                    trainers.append({'id': obj_id, 'pos': (x, y), 'facing': facing, 'defeated': is_defeated})\n\n    if not player_pos:\n        print(json.dumps({\"error\": \"Player not found on map.\"}))\n        return\n\n    def bfs(start, traversable_tiles):\n        q = deque([start])\n        visited = {start}\n        reachable_nodes = {start}\n        while q:\n            curr_x, curr_y = q.popleft()\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = curr_x + dx, curr_y + dy\n                if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:\n                    if grid[ny][nx] in traversable_tiles:\n                        visited.add((nx, ny))\n                        q.append((nx, ny))\n                        reachable_nodes.add((nx, ny))\n        return reachable_nodes\n\n    traversable = {'FLOOR'}\n    reachable_tiles = bfs(player_pos, traversable)\n\n    undefeated_trainers = [t for t in trainers if not t['defeated'] and t['id'] not in non_battling_trainer_ids]\n    for trainer in sorted(undefeated_trainers, key=lambda t: abs(t['pos'][0] - player_pos[0]) + abs(t['pos'][1] - player_pos[1])):\n        tx, ty = trainer['pos']\n        # BUG FIX: Corrected interaction point logic.\n        # To interact, player must be in front of the trainer.\n        if trainer['facing'] == 'left': ix, iy = tx - 1, ty\n        elif trainer['facing'] == 'right': ix, iy = tx + 1, ty\n        elif trainer['facing'] == 'up': ix, iy = tx, ty - 1\n        elif trainer['facing'] == 'down': ix, iy = tx, ty + 1\n        else: continue\n\n        if (ix, iy) in reachable_tiles:\n            print(json.dumps({\"action\": \"BATTLE\", \"target_coordinates\": {\"x\": tx, \"y\": ty}, \"justification\": f\"Prioritizing battle with undefeated trainer at ({tx}, {ty}). Player should move to ({ix}, {iy}) to initiate.\"}))\n            return\n\n    for boulder in sorted(boulders, key=lambda b: abs(b['pos'][0] - player_pos[0]) + abs(b['pos'][1] - player_pos[1])):\n        bx, by = boulder['pos']\n        # This puzzle only allows pushing boulders UP.\n        push_pos = (bx, by + 1) # Position to stand to push up\n        target_pos = (bx, by - 1) # Position boulder will move to\n        \n        if push_pos in reachable_tiles:\n            if 0 <= target_pos[1] < height and grid[target_pos[1]][target_pos[0]] == 'FLOOR':\n                 print(json.dumps({\"action\": \"PUSH\", \"target_coordinates\": {\"x\": bx, \"y\": by}, \"justification\": f\"No reachable trainers. Recommending to push boulder at ({bx}, {by}) upwards. Player should move to ({push_pos[0]}, {push_pos[1]}) and face UP.\"}))\n                 return\n\n    print(json.dumps({\"action\": \"MOVE\", \"target_coordinates\": {\"x\": 4, \"y\": 8}, \"justification\": \"No reachable trainers or pushable boulders. The puzzle may be in an unsolvable state. Recommending moving to the reset tile.\"}))\n\ncianwood_gym_solver(map_xml_string)"
  }
}