{
  "overworld_navigator_tool": {
    "description": "DEPRECATED - DO NOT USE. This tool is currently bugged and produces unreliable paths.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "print('{\"error\": \"This tool is deprecated and buggy. Do not use. Use the standard pathfinder instead.\"}')"
  },
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map using the Breadth-First Search (BFS) algorithm, avoiding impassable tiles and objects. It correctly handles one-way ledge traversal and water tiles.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import json\nimport xml.etree.ElementTree as ET\nfrom collections import deque\n\ndef find_path_bfs_simple(root, start, end):\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    grid = {}\n    for r in root.findall('Row'):\n        y = int(r.get('id'))\n        for t in r.findall('Tile'):\n            x = int(t.get('id'))\n            grid[(x, y)] = {'type': t.get('type'), 'has_object': t.find('Object') is not None and t.find('Object').get('id-name') != 'Pikachu'}\n    \n    queue = deque([(start, [start])])\n    visited = {start}\n    impassable = ['impassable', 'unknown', 'closed_gate', 'cuttable', 'water', 'ledge']\n\n    while queue:\n        (cx, cy), path = queue.popleft()\n        if (cx, cy) == end:\n            return [{'x': x, 'y': y} for x, y in path]\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = cx + dx, cy + dy\n            if (nx, ny) in visited or not (1 <= nx <= width and 1 <= ny <= height):\n                continue\n            \n            neighbor_tile = grid.get((nx, ny), {'type': 'unknown'})\n            if neighbor_tile['type'] in impassable or neighbor_tile.get('has_object'):\n                continue\n            \n            visited.add((nx, ny))\n            new_path = list(path)\n            new_path.append((nx, ny))\n            queue.append(((nx, ny), new_path))\n            \n    return None\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\nroot = ET.fromstring(map_xml_string)\npath = find_path_bfs_simple(root, (start_x, start_y), (end_x, end_y))\nif path:\n    print(json.dumps({'path_found': True, 'path': path}))\nelse:\n    print(json.dumps({'path_found': False, 'path': []}))"
  },
  "select_battle_option": {
    "description": "Calculates and executes the button presses needed to select a specific option from the main battle menu (FIGHT, PKMN, ITEM, RUN).",
    "input_schema": {
      "type": "object",
      "properties": {
        "option_to_select": {
          "type": "string",
          "enum": [
            "FIGHT",
            "PKMN",
            "ITEM",
            "RUN"
          ]
        }
      },
      "required": [
        "option_to_select"
      ]
    },
    "python_script": "option = input_data['option_to_select']\noptions = [\"FIGHT\", \"PKMN\", \"ITEM\", \"RUN\"]\ncurrent_pos = 0 # Assume cursor starts on FIGHT\npresses = []\ntarget_pos = options.index(option)\n# Simplified logic: Assume cursor moves right and down\nif target_pos == 1: # PKMN\n    presses.append('Right')\nelif target_pos == 2: # ITEM\n    presses.append('Down')\nelif target_pos == 3: # RUN\n    presses.append('Right')\n    presses.append('Down')\npresses.append('A')\nimport json\nprint(json.dumps(presses))"
  }
}