{
  "path_master": {
    "description": "Finds the shortest path on the current map using A*. Avoids impassable tiles and all objects, including off-screen ones identified by markers.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\nmap_xml_string = globals().get(\"map_xml_string\")\nroot = ET.fromstring(map_xml_string)\nmap_width = int(root.attrib['width'])\nmap_height = int(root.attrib['height'])\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\nend_x = int(input_data['end_x'])\nend_y = int(input_data['end_y'])\nstart_node = (start_x, start_y)\nend_node = (end_x, end_y)\n\n# Initialize a complete grid, defaulting to VOID\ngrid = [['VOID' for _ in range(map_width + 1)] for _ in range(map_height + 1)]\nobjects = set()\ndefeated_trainers = set()\n\n# Populate the grid with known tile data\nfor row in root.findall('Row'):\n    y = int(row.attrib['id'])\n    for tile in row.findall('Tile'):\n        x = int(tile.attrib['id'])\n        grid[y][x] = tile.attrib['type']\n        if tile.attrib.get('has-object') == 'true':\n            objects.add((x, y))\n        for marker in tile.findall('Marker'):\n            if marker.attrib.get('emoji') == '☠️':\n                defeated_trainers.add((x, y))\n\nimpassable_types = ['WALL', 'VOID', 'PILLAR', 'COUNTER', 'MART_SHELF', 'BOOKSHELF', 'TV', 'RADIO', 'PC', 'TOWN_MAP', 'WINDOW', 'PAINTING', 'CUT_TREE', 'WATER', 'BUOY']\n\ndef is_impassable(coord):\n    x, y = coord\n    if not (1 <= x <= map_width and 1 <= y <= map_height):\n        return True\n    if grid[y][x] in impassable_types:\n        return True\n    if coord in objects:\n        return True\n    if coord in defeated_trainers:\n        return True\n    return False\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\nopen_set = []\nheapq.heappush(open_set, (0, start_node))\ncame_from = {}\ng_score = {start_node: 0}\nf_score = {start_node: heuristic(start_node, end_node)}\n\npath_found = False\nwhile open_set:\n    _, current = heapq.heappop(open_set)\n\n    if current == end_node:\n        path = []\n        while current in came_from:\n            path.append(f\"{current[0]},{current[1]}\")\n            current = came_from[current]\n        path.append(f\"{start_node[0]},{start_node[1]}\")\n        print(','.join(path[::-1]))\n        path_found = True\n        break\n\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        neighbor = (current[0] + dx, current[1] + dy)\n        if is_impassable(neighbor):\n            continue\n\n        tentative_g_score = g_score.get(current, float('inf')) + 1\n        if tentative_g_score < g_score.get(neighbor, float('inf')):\n            came_from[neighbor] = current\n            g_score[neighbor] = tentative_g_score\n            f_score[neighbor] = tentative_g_score + heuristic(neighbor, end_node)\n            if neighbor not in [i[1] for i in open_set]:\n                heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\nif not path_found:\n    print(\"No path found\")"
  },
  "unstick_me_tool": {
    "description": "Analyzes the map to find the nearest traversable tile adjacent to an 'unseen' area or suggests warps to other maps if no unseen areas are reachable. Helps escape getting stuck.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport collections\nimport sys\n\nmap_xml_string = globals().get(\"map_xml_string\")\ninput_data = globals().get(\"input_data\")\n\nstart_x = int(input_data['start_x'])\nstart_y = int(input_data['start_y'])\n\ntry:\n    root = ET.fromstring(map_xml_string)\n    width = int(root.get('width'))\n    height = int(root.get('height'))\nexcept (ET.ParseError, TypeError):\n    print(json.dumps({'status': 'error', 'message': 'Could not parse map XML.'}))\n    sys.exit()\n\ngrid = [['VOID' for _ in range(width + 1)] for _ in range(height + 1)]\nunseen_tiles = set()\nobjects = set()\nwarps = {}\nimpassable_types = ['WALL', 'VOID', 'PILLAR', 'COUNTER', 'MART_SHELF', 'BOOKSHELF', 'TV', 'RADIO', 'PC', 'TOWN_MAP', 'WINDOW', 'PAINTING', 'CUT_TREE', 'WATER', 'BUOY']\n\nfor row_elem in root.findall('Row'):\n    y = int(row_elem.get('id'))\n    for tile_elem in row_elem.findall('Tile'):\n        x = int(tile_elem.get('id'))\n        coord = (x, y)\n        grid[y][x] = tile_elem.get('type')\n        if tile_elem.get('seen') == 'false':\n            unseen_tiles.add(coord)\n        if tile_elem.get('has-object') == 'true':\n            objects.add(coord)\n        for marker in tile_elem.findall('Marker'):\n            if marker.get('emoji') == '☠️':\n                objects.add(coord)\n                break\n        if tile_elem.get('is-warp') == 'true':\n            warps[coord] = None\n\ndef is_impassable(coord):\n    x, y = coord\n    if not (1 <= x <= width and 1 <= y <= height):\n        return True\n    if grid[y][x] in impassable_types:\n        return True\n    if coord in objects:\n        return True\n    return False\n\nqueue = collections.deque([((start_x, start_y), [])])\nvisited = {(start_x, start_y)}\n\nwhile queue:\n    (x, y), path = queue.popleft()\n    \n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        neighbor = (x + dx, y + dy)\n        if neighbor in unseen_tiles:\n            if is_impassable((x,y)):\n                continue\n            print(json.dumps({\n                'status': 'unseen_found',\n                'message': f'Found reachable unseen area. Suggesting moving to ({x}, {y}) to explore.',\n                'goal': {'x': x, 'y': y}\n            }))\n            sys.exit()\n\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nx, ny = x + dx, y + dy\n        neighbor = (nx, ny)\n        if not is_impassable(neighbor) and neighbor not in visited:\n            visited.add(neighbor)\n            queue.append((neighbor, path + [(x, y)]))\n\nreachable_warps = {coord for coord in warps if coord in visited}\nif not reachable_warps:\n    print(json.dumps({'status': 'softlocked', 'message': 'No reachable unseen tiles or warps found on this map.'}))\nelse:\n    print(json.dumps({\n        'status': 'warps_found',\n        'message': 'No unseen areas on this map. Here are reachable warps:',\n        'suggestions': [{'warp_coord': list(coord)} for coord in reachable_warps]\n    }))"
  }
}