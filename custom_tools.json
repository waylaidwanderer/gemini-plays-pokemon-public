{
  "pathfinder": {
    "description": "Calculates the shortest path between two points on the current map using the Breadth-First Search (BFS) algorithm. It considers tile types (including elevation, water), impassable objects (excluding Pikachu), and special ledge traversal rules. The output is a JSON string containing the list of coordinates for the path or debug info if no path is found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\nimport json\n\ndef find_path():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        start = (int(input_data['start_x']), int(input_data['start_y']))\n        end = (int(input_data['end_x']), int(input_data['end_y']))\n\n        grid = {}\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                object_name = None\n                if has_object:\n                    obj_elem = tile_elem.find('Object')\n                    if obj_elem is not None:\n                        object_name = obj_elem.get('id-name')\n                grid[(x, y)] = {'type': tile_type, 'has_object': has_object, 'object_name': object_name}\n\n        queue = collections.deque([[start]])\n        seen = {start}\n\n        while queue:\n            path = queue.popleft()\n            x, y = path[-1]\n\n            if (x, y) == end:\n                print(json.dumps({\"status\": \"success\", \"path\": path}))\n                return\n\n            for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                next_x, next_y = x + move_x, y + move_y\n                next_pos = (next_x, next_y)\n\n                if not (1 <= next_x <= width and 1 <= next_y <= height):\n                    continue\n\n                if next_pos in seen:\n                    continue\n\n                current_tile_info = grid.get((x,y), {})\n                next_tile_info = grid.get(next_pos, {})\n                next_tile_type = next_tile_info.get('type')\n\n                if move_y == 1 and current_tile_info.get('type') != 'ledge' and next_tile_type == 'ledge':\n                    ledge_jump_pos = (next_x, next_y + 1)\n                    if ledge_jump_pos in seen:\n                        continue\n                    ledge_jump_tile_info = grid.get(ledge_jump_pos, {})\n                    if ledge_jump_tile_info.get('type') not in ['impassable', 'unknown']:\n                        new_path = list(path)\n                        new_path.append(ledge_jump_pos)\n                        queue.append(new_path)\n                        seen.add(next_pos)\n                        seen.add(ledge_jump_pos)\n                    continue\n                \n                impassable_types = ['impassable', 'unknown', 'ledge', 'water']\n                if next_tile_type in impassable_types:\n                    continue\n\n                if next_pos != end and next_tile_info.get('has_object') and next_tile_info.get('object_name') != 'Pikachu':\n                    continue\n                \n                current_elevation = 'elevated' if current_tile_info.get('type') == 'elevated_ground' else 'ground'\n                next_elevation = 'elevated' if next_tile_type == 'elevated_ground' else 'ground'\n                if current_elevation != next_elevation and current_tile_info.get('type') != 'steps' and next_tile_type != 'steps':\n                    continue\n\n                seen.add(next_pos)\n                new_path = list(path)\n                new_path.append(next_pos)\n                queue.append(new_path)\n\n        print(json.dumps({\"status\": \"error\", \"message\": \"No path found\"}))\n    except Exception as e:\n        print(json.dumps({\"status\": \"error\", \"message\": str(e)}))\n\nfind_path()\n"
  },
  "wkg_pathfinder": {
    "description": "Calculates the shortest path between two maps in the World Knowledge Graph, returning a sequence of map IDs and warp coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_map_id": {
          "type": "string"
        },
        "end_map_id": {
          "type": "string"
        }
      },
      "required": [
        "start_map_id",
        "end_map_id"
      ]
    },
    "python_script": "import json\nfrom collections import deque\n\ndef find_wkg_path(start_map_id, end_map_id, wkg_json_string):\n    wkg = json.loads(wkg_json_string)\n    nodes = {node['id']: node for node in wkg['nodes']}\n    adj = {node_id: [] for node_id in nodes}\n    for edge in wkg['edges']:\n        adj[edge['source_node_id']].append(edge['destination_node_id'])\n        if not edge.get('is_one_way', False):\n            adj[edge['destination_node_id']].append(edge['source_node_id'])\n\n    start_nodes = [node_id for node_id, node in nodes.items() if node['map_id'] == start_map_id]\n    if not start_nodes:\n        print(json.dumps({'error': 'Start map not in WKG'}))\n        return\n\n    queue = deque([(node, [node]) for node in start_nodes])\n    visited = set(start_nodes)\n    \n    while queue:\n        current_node_id, path = queue.popleft()\n        current_map_id = nodes[current_node_id]['map_id']\n\n        if current_map_id == end_map_id:\n            result_path = []\n            for node_id in path:\n                node = nodes[node_id]\n                result_path.append({'map_id': node['map_id'], 'coordinates': node['coordinates']})\n            print(json.dumps({'path': result_path}))\n            return\n\n        for neighbor_id in adj.get(current_node_id, []):\n            if neighbor_id not in visited:\n                visited.add(neighbor_id)\n                new_path = list(path)\n                new_path.append(neighbor_id)\n                queue.append((neighbor_id, new_path))\n\n    print(json.dumps({'path': []}))\n\nfind_wkg_path(input_data['start_map_id'], input_data['end_map_id'], world_knowledge_graph_json_string)"
  },
  "wkg_edge_payload_generator": {
    "description": "A helper tool that generates the correct JSON payload for adding an edge to the World Knowledge Graph. It finds the required node IDs based on map and coordinate inputs.",
    "input_schema": {
      "type": "object",
      "properties": {
        "source_map_id": {
          "type": "string"
        },
        "source_x": {
          "type": "string"
        },
        "source_y": {
          "type": "string"
        },
        "dest_map_id": {
          "type": "string"
        },
        "dest_x": {
          "type": "string"
        },
        "dest_y": {
          "type": "string"
        },
        "connection_type": {
          "type": "string"
        },
        "is_one_way": {
          "type": "string"
        },
        "destination_entry_point": {
          "type": "string"
        }
      },
      "required": [
        "source_map_id",
        "source_x",
        "source_y",
        "dest_map_id",
        "dest_x",
        "dest_y"
      ]
    },
    "python_script": "import json\n\ndef find_node_id(nodes, map_id, x, y):\n    for node in nodes:\n        if node['map_id'] == map_id and node['coordinates']['x'] == x and node['coordinates']['y'] == y:\n            return node['id']\n    return None\n\ntry:\n    wkg = json.loads(world_knowledge_graph_json_string)\n    nodes = wkg.get('nodes', [])\n\n    source_map_id = input_data['source_map_id']\n    source_x = int(input_data['source_x'])\n    source_y = int(input_data['source_y'])\n    dest_map_id = input_data['dest_map_id']\n    dest_x = int(input_data['dest_x'])\n    dest_y = int(input_data['dest_y'])\n    \n    source_node_id = find_node_id(nodes, source_map_id, source_x, source_y)\n    dest_node_id = find_node_id(nodes, dest_map_id, dest_x, dest_y)\n\n    if source_node_id and dest_node_id:\n        payload = {\n            \"source_node_id\": source_node_id,\n            \"destination_node_id\": dest_node_id,\n            \"connection_type\": input_data.get('connection_type', 'map_edge'),\n            \"source_coordinates\": {\"x\": source_x, \"y\": source_y, \"map_id\": source_map_id},\n            \"destination_coordinates\": {\"x\": dest_x, \"y\": dest_y, \"map_id\": dest_map_id},\n            \"is_one_way\": input_data.get('is_one_way', 'false').lower() == 'true'\n        }\n        if 'destination_entry_point' in input_data and input_data['destination_entry_point']:\n            payload['destination_entry_point'] = int(input_data['destination_entry_point'])\n\n        print(json.dumps(payload))\n    else:\n        missing = []\n        if not source_node_id:\n            missing.append(f\"Source node ({source_map_id} at {source_x},{source_y})\")\n        if not dest_node_id:\n            missing.append(f\"Destination node ({dest_map_id} at {dest_x},{dest_y})\")\n        print(json.dumps({\"status\": \"error\", \"message\": f\"Could not find nodes: {', '.join(missing)}\"}))\n\nexcept Exception as e:\n    print(json.dumps({\"status\": \"error\", \"message\": str(e)}))"
  },
  "automated_explorer": {
    "description": "Finds the nearest reachable unseen tile and generates a path to an adjacent traversable tile. Now correctly handles defeated trainers.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        }
      },
      "required": [
        "start_x",
        "start_y"
      ]
    },
    "python_script": "import collections\nimport xml.etree.ElementTree as ET\nimport json\n\ndef find_path(start_x, start_y, end_x, end_y, grid, width, height):\n    start = (start_x, start_y)\n    end = (end_x, end_y)\n    queue = collections.deque([[start]])\n    seen = {start}\n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n        if (x, y) == end:\n            return path\n        for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_x, next_y = x + move_x, y + move_y\n            next_pos = (next_x, next_y)\n            if not (1 <= next_x <= width and 1 <= next_y <= height):\n                continue\n            if next_pos in seen:\n                continue\n            current_tile_info = grid.get((x,y), {})\n            next_tile_info = grid.get(next_pos, {})\n            next_tile_type = next_tile_info.get('type')\n            if move_y == 1 and current_tile_info.get('type') != 'ledge' and next_tile_type == 'ledge':\n                ledge_jump_pos = (next_x, next_y + 1)\n                if ledge_jump_pos in seen:\n                    continue\n                ledge_jump_tile_info = grid.get(ledge_jump_pos, {})\n                if ledge_jump_tile_info.get('type') not in ['impassable', 'unknown']:\n                    new_path = list(path)\n                    new_path.append(ledge_jump_pos)\n                    queue.append(new_path)\n                    seen.add(next_pos)\n                    seen.add(ledge_jump_pos)\n                continue\n            impassable_types = ['impassable', 'unknown', 'ledge', 'water']\n            if next_tile_type in impassable_types:\n                continue\n            if next_pos != end and next_tile_info.get('has_object') and next_tile_info.get('object_name') != 'Pikachu' and not next_tile_info.get('is_defeated_trainer', False):\n                continue\n            current_elevation = 'elevated' if current_tile_info.get('type') == 'elevated_ground' else 'ground'\n            next_elevation = 'elevated' if next_tile_type == 'elevated_ground' else 'ground'\n            if current_elevation != next_elevation and current_tile_info.get('type') != 'steps' and next_tile_type != 'steps':\n                continue\n            seen.add(next_pos)\n            new_path = list(path)\n            new_path.append(next_pos)\n            queue.append(new_path)\n    return None\n\ndef find_nearest_unseen():\n    try:\n        root = ET.fromstring(map_xml_string)\n        width = int(root.get('width'))\n        height = int(root.get('height'))\n        start_x = int(input_data['start_x'])\n        start_y = int(input_data['start_y'])\n\n        grid = {}\n        unseen_tiles = []\n        for row_elem in root.findall('Row'):\n            y = int(row_elem.get('id'))\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                tile_type = tile_elem.get('type')\n                has_object = tile_elem.get('has-object') == 'true'\n                object_name = None\n                if has_object:\n                    obj_elem = tile_elem.find('Object')\n                    if obj_elem is not None:\n                        object_name = obj_elem.get('id-name')\n                is_defeated = False\n                for marker_elem in tile_elem.findall('Marker'):\n                    if marker_elem.get('emoji') == '\"\\u2620\\ufe0f\"':\n                        is_defeated = True\n                        break\n                grid[(x, y)] = {'type': tile_type, 'has_object': has_object, 'object_name': object_name, 'is_defeated_trainer': is_defeated}\n                if tile_elem.get('seen') == 'false':\n                    unseen_tiles.append((x, y))\n\n        if not unseen_tiles:\n            print(json.dumps({\"status\": \"success\", \"message\": \"No unseen tiles found.\"}))\n            return\n\n        # BFS to find all reachable tiles from start\n        q = collections.deque([(start_x, start_y)])\n        reachable_nodes = {(start_x, start_y)}\n        while q:\n            x, y = q.popleft()\n            for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                next_x, next_y = x + move_x, y + move_y\n                next_pos = (next_x, next_y)\n                if not (1 <= next_x <= width and 1 <= next_y <= height):\n                    continue\n                if next_pos in reachable_nodes:\n                    continue\n                current_tile_info = grid.get((x,y), {})\n                next_tile_info = grid.get(next_pos, {})\n                next_tile_type = next_tile_info.get('type')\n                if move_y == 1 and current_tile_info.get('type') != 'ledge' and next_tile_type == 'ledge':\n                    ledge_jump_pos = (next_x, next_y + 1)\n                    if ledge_jump_pos in reachable_nodes: continue\n                    ledge_jump_tile_info = grid.get(ledge_jump_pos, {})\n                    if ledge_jump_tile_info.get('type') not in ['impassable', 'unknown']:\n                        reachable_nodes.add(next_pos)\n                        reachable_nodes.add(ledge_jump_pos)\n                        q.append(ledge_jump_pos)\n                    continue\n                impassable_types = ['impassable', 'unknown', 'ledge', 'water']\n                if next_tile_type in impassable_types:\n                    continue\n                if next_tile_info.get('has_object') and next_tile_info.get('object_name') != 'Pikachu' and not next_tile_info.get('is_defeated_trainer', False):\n                    continue\n                current_elevation = 'elevated' if current_tile_info.get('type') == 'elevated_ground' else 'ground'\n                next_elevation = 'elevated' if next_tile_type == 'elevated_ground' else 'ground'\n                if current_elevation != next_elevation and current_tile_info.get('type') != 'steps' and next_tile_type != 'steps':\n                    continue\n                reachable_nodes.add(next_pos)\n                q.append(next_pos)\n        \n        reachable_unseen = [tile for tile in unseen_tiles if tile in reachable_nodes]\n        if not reachable_unseen:\n            print(json.dumps({\"status\": \"error\", \"message\": \"No reachable unseen tiles found.\"}))\n            return\n\n        # Find path to the nearest reachable unseen tile\n        shortest_path = None\n        for ux, uy in reachable_unseen:\n            for move_x, move_y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                adj_x, adj_y = ux + move_x, uy + move_y\n                if (adj_x, adj_y) in reachable_nodes:\n                    path = find_path(start_x, start_y, adj_x, adj_y, grid, width, height)\n                    if path and (shortest_path is None or len(path) < len(shortest_path)):\n                        shortest_path = path\n                        break # Found a path to an adjacent tile, no need to check other adjacents for this unseen tile\n            if shortest_path:\n                 break # Found a path to the first unseen tile, no need to check others for now\n\n        if shortest_path:\n            print(json.dumps({\"status\": \"success\", \"path\": shortest_path}))\n        else:\n            print(json.dumps({\"status\": \"error\", \"message\": \"No path found to any adjacent tile of reachable unseen tiles.\"}))\n\n    except Exception as e:\n        print(json.dumps({\"status\": \"error\", \"message\": str(e)}))\n\nfind_nearest_unseen()\n"
  }
}