{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "inventory_scanner": {
    "description": "Scans the player's inventory list for a target item and returns whether it was found.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory_list": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "inventory_list",
        "target_item"
      ]
    },
    "python_script": "import json\n\ntry:\n    inventory_list = json.loads(input_data['inventory_list'])\n    target_item = input_data['target_item']\n    found = False\n    for item in inventory_list:\n        if target_item.lower() in item.lower():\n            found = True\n            break\n    print(f'Item found: {found}')\nexcept Exception as e:\n    print(f'An error occurred: {e}')"
  },
  "gem_path_planner_v15": {
    "description": "A custom pathfinding tool by Gem. This version dynamically determines map size from the XML structure, making it robust against incorrect width/height metadata.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "target_x": {
          "type": "string"
        },
        "target_y": {
          "type": "string"
        },
        "current_movement_state": {
          "type": "string",
          "enum": [
            "walking",
            "biking",
            "surfing"
          ]
        }
      },
      "required": [
        "start_x",
        "start_y",
        "target_x",
        "target_y",
        "current_movement_state"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport heapq\n\nclass AStar:\n    def __init__(self, map_xml_string, movement_state):\n        self.root = ET.fromstring(map_xml_string)\n        self.movement_state = movement_state\n        max_x, max_y = 0, 0\n        rows = self.root.findall('Row')\n        for row_elem in rows:\n            y = int(row_elem.get('id'))\n            if y > max_y: max_y = y\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id'))\n                if x > max_x: max_x = x\n        self.width = max_x\n        self.height = max_y\n        self.grid = [[None for _ in range(self.width + 1)] for _ in range(self.height + 1)]\n        self.impassable_objects = set()\n        for row_elem in rows:\n            y = int(row_elem.get('id')) - 1\n            for tile_elem in row_elem.findall('Tile'):\n                x = int(tile_elem.get('id')) - 1\n                tile_type = tile_elem.get('type')\n                self.grid[y][x] = tile_type\n                if tile_elem.find('Object') is not None:\n                    obj = tile_elem.find('Object')\n                    if obj.get('id-name') != 'Pikachu':\n                        self.impassable_objects.add((x, y))\n\n    def heuristic(self, a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def get_neighbors(self, pos):\n        x, y = pos\n        neighbors = []\n        valid_transitions = {\n            'ground': {'ground', 'grass', 'steps', 'ladder_up', 'ladder_down', 'hole'},\n            'grass': {'ground', 'grass', 'steps'},\n            'elevated_ground': {'elevated_ground', 'steps', 'ladder_up', 'ladder_down', 'hole'},\n            'steps': {'ground', 'grass', 'elevated_ground'},\n            'ladder_up': {'ground', 'grass', 'elevated_ground', 'steps'},\n            'ladder_down': {'ground', 'grass', 'elevated_ground', 'steps'},\n            'hole': {'ground', 'grass', 'elevated_ground', 'steps'}\n        }\n\n        if self.movement_state == 'surfing':\n            valid_transitions['water'] = {'water', 'ground', 'grass', 'steps'}\n            valid_transitions['ground'].add('water')\n            valid_transitions['grass'].add('water')\n            valid_transitions['steps'].add('water')\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if not (0 <= nx < self.width and 0 <= ny < self.height):\n                continue\n            if (nx, ny) in self.impassable_objects:\n                continue\n\n            current_tile_type = self.grid[y][x]\n            neighbor_tile_type = self.grid[ny][nx]\n            \n            if neighbor_tile_type == 'impassable' or neighbor_tile_type == 'unknown':\n                continue\n\n            if current_tile_type != 'ledge' and neighbor_tile_type == 'ledge':\n                if ny < y:\n                    continue\n            \n            if current_tile_type in valid_transitions and neighbor_tile_type in valid_transitions.get(current_tile_type, set()):\n                neighbors.append((nx, ny))\n        return neighbors\n\n    def find_path(self, start, end):\n        open_set = []\n        heapq.heappush(open_set, (0, start))\n        came_from = {}\n        g_score = { (x,y): float('inf') for y in range(self.height + 1) for x in range(self.width + 1) }\n        g_score[start] = 0\n        f_score = { (x,y): float('inf') for y in range(self.height + 1) for x in range(self.width + 1) }\n        f_score[start] = self.heuristic(start, end)\n        while open_set:\n            _, current = heapq.heappop(open_set)\n            if current == end:\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(start)\n                return path[::-1]\n            for neighbor in self.get_neighbors(current):\n                tentative_g_score = g_score[current] + 1\n                if tentative_g_score < g_score[neighbor]:\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = g_score[neighbor] + self.heuristic(neighbor, end)\n                    if neighbor not in [i[1] for i in open_set]:\n                        heapq.heappush(open_set, (f_score[neighbor], neighbor))\n        return None\n\ntry:\n    start_x = int(input_data['start_x']) - 1\n    start_y = int(input_data['start_y']) - 1\n    target_x = int(input_data['target_x']) - 1\n    target_y = int(input_data['target_y']) - 1\n    movement_state = input_data['current_movement_state']\n    pathfinder = AStar(map_xml_string, movement_state)\n    path = pathfinder.find_path((start_x, start_y), (target_x, target_y))\n    if path:\n        buttons = []\n        for i in range(len(path) - 1):\n            cx, cy = path[i]\n            nx, ny = path[i+1]\n            if nx > cx: buttons.append('Right')\n            elif nx < cx: buttons.append('Left')\n            elif ny > cy: buttons.append('Down')\n            elif ny < cy: buttons.append('Up')\n        print(','.join(buttons))\n    else:\n        print('No path found')\nexcept Exception as e:\n    print(f'An error occurred: {e}')"
  }
}