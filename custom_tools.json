{
  "battle_log_formatter": {
    "description": "Formats a battle outcome into a standardized string for easy logging in the notepad.",
    "input_schema": {
      "type": "object",
      "properties": {
        "attacker_type": {
          "type": "string"
        },
        "defender_type1": {
          "type": "string"
        },
        "defender_type2": {
          "type": "string",
          "nullable": true
        },
        "effectiveness": {
          "type": "string",
          "enum": [
            "super effective",
            "not very effective",
            "no effect"
          ]
        }
      },
      "required": [
        "attacker_type",
        "defender_type1",
        "effectiveness"
      ]
    },
    "python_script": "effectiveness_map = {\"super effective\": \">\", \"not very effective\": \"!>\", \"no effect\": \"x>\"}\nsymbol = effectiveness_map[input_data[\"effectiveness\"]]\ndefender_type2_str = f'/{input_data[\"defender_type2\"]}' if input_data.get(\"defender_type2\") else \"\"\nlog_entry = f'- {input_data[\"attacker_type\"]} {symbol} {input_data[\"defender_type1\"]}{defender_type2_str}'\nprint(log_entry)"
  },
  "get_impassable_tiles": {
    "description": "Extracts and returns a JSON list of all impassable tile coordinates from the current map XML.",
    "input_schema": {},
    "python_script": "import xml.etree.ElementTree as ET; import json; root = ET.fromstring(map_xml_string); impassable_tiles = []; for row_elem in root.findall('Row'): y = int(row_elem.get('id')); for tile_elem in row_elem.findall('Tile'): x = int(tile_elem.get('id')); if tile_elem.get('type') == 'impassable' or tile_elem.find('Object') is not None: impassable_tiles.append({'x': x, 'y': y}); print(json.dumps(impassable_tiles))"
  },
  "inventory_navigator_tool": {
    "description": "Calculates the optimal number of button presses (Up/Down) to navigate from a current selection to a target item in a list-based menu. This version correctly handles non-wrapping menus.",
    "input_schema": {
      "type": "object",
      "properties": {
        "inventory_list": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "current_selection": {
          "type": "string"
        },
        "target_item": {
          "type": "string"
        }
      },
      "required": [
        "inventory_list",
        "current_selection",
        "target_item"
      ]
    },
    "python_script": "import json\ntry:\n    inventory = json.loads(input_data['inventory_list'])\n    current_item = input_data['current_selection']\n    target_item = input_data['target_item']\n\n    if current_item not in inventory or target_item not in inventory:\n        print(json.dumps({'error': 'Item not found in inventory list.'}))\n    else:\n        current_idx = inventory.index(current_item)\n        target_idx = inventory.index(target_item)\n        \n        if current_idx == target_idx:\n            print(json.dumps({'direction': 'NONE', 'presses': 0}))\n        elif target_idx > current_idx:\n            presses = target_idx - current_idx\n            print(json.dumps({'direction': 'DOWN', 'presses': presses}))\n        else: # target_idx < current_idx\n            presses = current_idx - target_idx\n            print(json.dumps({'direction': 'UP', 'presses': presses}))\nexcept Exception as e:\n    print(json.dumps({'error': str(e), 'type': type(e).__name__}))"
  },
  "find_path": {
    "description": "A consolidated and robust pathfinding tool. Finds a path from a start to an end coordinate using A* algorithm, correctly handling all known tile types including ledges, open gates, and offscreen gates. If the destination is impassable, it finds a path to an adjacent walkable tile.",
    "input_schema": {
      "type": "object",
      "properties": {
        "start_x": {
          "type": "string"
        },
        "start_y": {
          "type": "string"
        },
        "end_x": {
          "type": "string"
        },
        "end_y": {
          "type": "string"
        },
        "movement_mode": {
          "type": "string",
          "enum": [
            "walking",
            "surfing"
          ]
        },
        "ignore_npc_ids": {
          "type": "string",
          "nullable": true
        }
      },
      "required": [
        "start_x",
        "start_y",
        "end_x",
        "end_y",
        "movement_mode"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nimport heapq\n\ndef parse_map_xml(xml_string, ignore_ids):\n    root = ET.fromstring(xml_string)\n    grid = {}\n    width = int(root.get('width'))\n    height = int(root.get('height'))\n    for row in root.findall('Row'):\n        y = int(row.get('id'))\n        for tile in row.findall('Tile'):\n            x = int(tile.get('id'))\n            tile_type = tile.get('type')\n            is_warp = tile.get('is-warp') == 'true'\n            object_element = tile.find('Object')\n            has_object = False\n            is_pikachu = False\n            if object_element is not None:\n                obj_id_str = object_element.get('id')\n                if obj_id_str is not None and obj_id_str.isdigit():\n                    obj_id = int(obj_id_str)\n                    if obj_id not in ignore_ids:\n                        has_object = True\n                        if object_element.get('id-name') == 'Pikachu':\n                            is_pikachu = True\n                else: \n                    has_object = True\n            grid[(x, y)] = {'type': tile_type, 'has_object': has_object, 'is_pikachu': is_pikachu, 'is_warp': is_warp}\n    return grid, width, height\n\ndef is_walkable(tile_data, movement_mode):\n    if not tile_data: return False\n    if tile_data.get('is_warp'): return False\n    walkable_types = ['ground', 'grass', 'steps', 'elevated_ground', 'ladder_up', 'ladder_down', 'hole', 'teleport', 'spinner_stop', 'cuttable', 'open_gate', 'gate_offscreen']\n    surfable_types = ['water']\n    if movement_mode == 'walking':\n        return tile_data.get('type') in walkable_types\n    elif movement_mode == 'surfing':\n        return tile_data.get('type') in surfable_types\n    return False\n\ndef get_neighbors(current_pos, grid, width, height, movement_mode):\n    x, y = current_pos\n    neighbors = []\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nx, ny = x + dx, y + dy\n        if not (1 <= nx <= width and 1 <= ny <= height): continue\n        current_tile_data = grid.get((x, y), {})\n        if current_tile_data.get('type') == 'ledge':\n            if dx == 0 and dy == 1:\n                final_y = ny + 1\n                if 1 <= final_y <= height:\n                    landing_tile_data = grid.get((nx, final_y), {})\n                    if is_walkable(landing_tile_data, movement_mode) and not (landing_tile_data.get('has_object') and not landing_tile_data.get('is_pikachu')):\n                        neighbors.append((nx, final_y))\n            continue\n        next_tile_data = grid.get((nx, ny), {})\n        if is_walkable(next_tile_data, movement_mode) and not (next_tile_data.get('has_object') and not next_tile_data.get('is_pikachu')):\n            neighbors.append((nx, ny))\n    return neighbors\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef find_path_astar(grid, width, height, start, end, movement_mode):\n    original_end = end\n    target_tile_data = grid.get(end)\n    if not target_tile_data or not is_walkable(target_tile_data, movement_mode) or (target_tile_data.get('has_object') and not target_tile_data.get('is_pikachu')):\n        possible_ends = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_x, adj_y = original_end[0] + dx, original_end[1] + dy\n            adj_pos = (adj_x, adj_y)\n            adj_tile_data = grid.get(adj_pos)\n            if adj_tile_data and is_walkable(adj_tile_data, movement_mode) and not (adj_tile_data.get('has_object') and not adj_tile_data.get('is_pikachu')):\n                num_walkable_neighbors = len(get_neighbors(adj_pos, grid, width, height, movement_mode))\n                is_trap = 1 if num_walkable_neighbors <= 1 and adj_pos != start else 0\n                dist = heuristic(start, adj_pos)\n                heapq.heappush(possible_ends, (is_trap, dist, adj_pos))\n        if not possible_ends:\n            return None\n        _, _, end = heapq.heappop(possible_ends)\n\n    open_set = []\n    heapq.heappush(open_set, (0, start))\n    came_from = {}\n    g_score = {pos: float('inf') for pos in grid}\n    g_score[start] = 0\n    f_score = {pos: float('inf') for pos in grid}\n    f_score[start] = heuristic(start, end)\n    while open_set:\n        _, current = heapq.heappop(open_set)\n        if current == end:\n            path = []\n            temp = current\n            while temp in came_from:\n                path.append(temp)\n                temp = came_from[temp]\n            path.append(start)\n            return path[::-1]\n        for neighbor in get_neighbors(current, grid, width, height, movement_mode):\n            tentative_g_score = g_score[current] + 1\n            if tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, end)\n                if neighbor not in [i[1] for i in open_set]:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    return None\n\ntry:\n    start_x = int(input_data['start_x'])\n    start_y = int(input_data['start_y'])\n    end_x = int(input_data['end_x'])\n    end_y = int(input_data['end_y'])\n    movement_mode = input_data['movement_mode']\n    ignore_npc_ids_str = input_data.get('ignore_npc_ids', '')\n    ignore_ids = [int(id_str) for id_str in ignore_npc_ids_str.split(',') if id_str.strip().isdigit()] if ignore_npc_ids_str else []\n    grid, width, height = parse_map_xml(map_xml_string, ignore_ids)\n    path = find_path_astar(grid, width, height, (start_x, start_y), (end_x, end_y), movement_mode)\n    if path:\n        final_path = []\n        for (px, py) in path:\n            final_path.append({'x': str(px), 'y': str(py)})\n        print(json.dumps(final_path))\n    else:\n        print(json.dumps([]))\nexcept Exception as e:\n    import traceback\n    err_msg = f\"Error: {str(e)}, Type: {type(e).__name__}, Traceback: {traceback.format_exc()}\"\n    print(json.dumps([{'error': err_msg}]))"
  }
}