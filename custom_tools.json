{
  "battle_grind": {
    "description": "Selects a move from the battle move menu. Assumes the move menu is already open. Takes target move index and current cursor position.",
    "input_schema": {
      "type": "object",
      "properties": {
        "move_index": {
          "type": "integer",
          "description": "The 0-indexed position of the move to select (0-3)."
        },
        "current_index": {
          "type": "integer",
          "description": "The current 0-indexed position of the cursor (0-3). Defaults to 0."
        }
      },
      "required": [
        "move_index"
      ]
    },
    "python_script": "import json\n\n# input_data is a dictionary automatically provided in the global scope\nmove_index = int(input_data.get('move_index', 0))\ncurrent_index = int(input_data.get('current_index', 0))\n\n# Calculate the shortest path in a wrapping menu of 4 items\ndiff = move_index - current_index\n\nbuttons = [\"sleep 1500\"]\n\n# Move the cursor\nif diff > 0:\n    for _ in range(diff):\n        buttons.extend([\"Down\", \"sleep 500\"])\nelif diff < 0:\n    for _ in range(-diff):\n        buttons.extend([\"Up\", \"sleep 500\"])\n\nbuttons.append(\"A\")\n\n# Wait for animation\nbuttons.append(\"sleep 4000\")\n\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-24T04:55:28.965Z",
        "action_counter": 16351
      },
      {
        "commit_message": "Fix battle_grind: add mandatory main function wrapper.",
        "timestamp": "2025-12-24T04:59:12.693Z",
        "action_counter": 16355
      },
      {
        "commit_message": "Fix battle_grind: call the main function with input_data.",
        "timestamp": "2025-12-24T05:03:06.090Z",
        "action_counter": 16361
      },
      {
        "commit_message": "Fix battle_grind: simplify script to avoid function scoping issues and ensure it always prints a valid JSON array.",
        "timestamp": "2025-12-24T05:03:57.479Z",
        "action_counter": 16362
      },
      {
        "commit_message": "Fix battle_grind: properly wrap in main(input_data) and print JSON array.",
        "timestamp": "2025-12-24T05:04:59.202Z",
        "action_counter": 16363
      },
      {
        "commit_message": "Simplify battle_grind script and remove main function wrapper to avoid scoping issues.",
        "timestamp": "2025-12-24T05:06:02.927Z",
        "action_counter": 16364
      },
      {
        "commit_message": "Fix battle_grind: properly wrap in main(input_data), reset cursor to top, and print JSON array.",
        "timestamp": "2025-12-24T05:06:55.258Z",
        "action_counter": 16365
      },
      {
        "commit_message": "Refine battle_grind: Remove 'Up' presses to avoid wrapping issues; assume menu starts at top move.",
        "timestamp": "2025-12-24T05:07:44.703Z",
        "action_counter": 16366
      },
      {
        "commit_message": "Simplify battle_grind script: remove main function to avoid scoping issues.",
        "timestamp": "2025-12-24T05:11:39.789Z",
        "action_counter": 16369
      },
      {
        "commit_message": "Fix battle_grind: Ensure input_data is correctly handled and script prints valid JSON.",
        "timestamp": "2025-12-24T05:13:02.293Z",
        "action_counter": 16370
      },
      {
        "commit_message": "Refine battle_grind: Add initial sleep to allow move menu animation to complete.",
        "timestamp": "2025-12-24T05:22:48.271Z",
        "action_counter": 16377
      },
      {
        "commit_message": "Fix battle_grind: Ensure script prints valid JSON and handles input_data correctly. Added move menu reset.",
        "timestamp": "2025-12-24T05:27:27.269Z",
        "action_counter": 16381
      },
      {
        "commit_message": "Fix battle_grind: Add initial sleep and robust reset sequence.",
        "timestamp": "2025-12-24T05:30:05.050Z",
        "action_counter": 16383
      },
      {
        "commit_message": "Simplify battle_grind: Remove unreliable reset sequence; assume menu starts at move 0.",
        "timestamp": "2025-12-24T05:33:28.112Z",
        "action_counter": 16385
      },
      {
        "commit_message": "Refine battle_grind: Increase initial sleep to 1000ms for more reliable move selection.",
        "timestamp": "2025-12-24T05:37:33.701Z",
        "action_counter": 16392
      },
      {
        "commit_message": "Refine battle_grind: Increase sleeps and add robust move selection.",
        "timestamp": "2025-12-24T05:39:13.371Z",
        "action_counter": 16393
      },
      {
        "commit_message": "Refine battle_grind: Increase sleeps significantly and add move menu reset to ensure reliability.",
        "timestamp": "2025-12-24T05:41:16.549Z",
        "action_counter": 16394
      },
      {
        "commit_message": "Increased timing between cursor moves and buffer B-spam to improve reliability in battle menus. Added comments to explain Gen 2 move menu behavior.",
        "timestamp": "2025-12-24T06:27:57.937Z",
        "action_counter": 16441
      },
      {
        "commit_message": "Fixed battle_grind to use the 'input_data' variable directly, as it is automatically provided in the global scope for custom tools.",
        "timestamp": "2025-12-24T06:37:02.747Z",
        "action_counter": 16463
      },
      {
        "commit_message": "Removed B-spam from battle_grind to prevent accidentally skipping move-learning prompts during level-ups.",
        "timestamp": "2025-12-24T07:01:38.986Z",
        "action_counter": 16485
      },
      {
        "commit_message": "Updated battle_grind to use relative movement from a known current index, making move selection more reliable by accounting for menu wrapping.",
        "timestamp": "2025-12-24T07:04:04.799Z",
        "action_counter": 16488
      }
    ]
  },
  "find_path_v2": {
    "description": "Calculates a path between two coordinates on the current map using BFS, accounting for walls, objects, and one-way tiles (ledges, floor-up-walls). Returns a list of button strings.",
    "input_schema": {
      "type": "object",
      "properties": {
        "end_x": {
          "type": "integer"
        },
        "end_y": {
          "type": "integer"
        },
        "start_x": {
          "type": "integer",
          "nullable": true
        },
        "start_y": {
          "type": "integer",
          "nullable": true
        },
        "can_surf": {
          "type": "boolean"
        }
      },
      "required": [
        "end_x",
        "end_y"
      ]
    },
    "python_script": "import xml.etree.ElementTree as ET\nimport json\nfrom collections import deque\n\ndef solve():\n    try:\n        # Use injected input_data dictionary\n        if 'input_data' not in globals():\n            print(json.dumps([\"Error: input_data not found\"]))\n            return\n            \n        data = input_data\n        end_x = int(data['end_x'])\n        end_y = int(data['end_y'])\n        start_x = data.get('start_x')\n        start_y = data.get('start_y')\n        can_surf = data.get('can_surf', False)\n        \n        root = ET.fromstring(map_xml_string)\n        map_width = int(root.get('width'))\n        map_height = int(root.get('height'))\n        \n        tiles = {}\n        player_coords = None\n        for row in root.findall('Row'):\n            y = int(row.get('id'))\n            for tile in row.findall('Tile'):\n                x = int(tile.get('id'))\n                t_type = tile.get('type')\n                has_obj = tile.get('has-object') == 'true'\n                tiles[(x, y)] = {'type': t_type, 'has_obj': has_obj}\n                if tile.find('Player') is not None:\n                    player_coords = (x, y)\n\n        if start_x is None or start_y is None:\n            if player_coords:\n                start_x, start_y = player_coords\n            else:\n                print(json.dumps([\"Error: Player position not found\"]))\n                return\n\n        start = (int(start_x), int(start_y))\n        end = (end_x, end_y)\n        \n        if start == end:\n            print(json.dumps([]))\n            return\n\n        queue = deque([(start, [])])\n        visited = {start}\n        \n        while queue:\n            (curr_x, curr_y), path = queue.popleft()\n            \n            for dx, dy, btn in [(0, -1, \"Up\"), (0, 1, \"Down\"), (-1, 0, \"Left\"), (1, 0, \"Right\")]:\n                nx, ny = curr_x + dx, curr_y + dy\n                \n                if 0 <= nx < map_width and 0 <= ny < map_height:\n                    target_tile = tiles.get((nx, ny))\n                    if not target_tile: continue\n                    \n                    t_type = target_tile['type']\n                    has_obj = target_tile['has_obj']\n                    \n                    if (nx, ny) == end:\n                        print(json.dumps(path + [btn]))\n                        return\n\n                    impassable = [\"WALL\", \"MOUNTAIN\", \"HEADBUTT_TREE\", \"TREE\"]\n                    if t_type in impassable: continue\n                    if has_obj: continue \n                    if t_type == \"WATER\" and not can_surf: continue\n                    \n                    curr_tile_info = tiles.get((curr_x, curr_y))\n                    if not curr_tile_info: continue\n                    curr_tile_type = curr_tile_info['type']\n                    \n                    if curr_tile_type == \"LEDGE_HOP_DOWN\" and btn != \"Down\": continue\n                    if curr_tile_type == \"LEDGE_HOP_UP\" and btn != \"Up\": continue\n                    if curr_tile_type == \"LEDGE_HOP_LEFT\" and btn != \"Left\": continue\n                    if curr_tile_type == \"LEDGE_HOP_RIGHT\" and btn != \"Right\": continue\n                    \n                    if btn == \"Down\" and t_type == \"FLOOR_UP_WALL\": continue\n                    \n                    if (nx, ny) not in visited:\n                        visited.add((nx, ny))\n                        queue.append(((nx, ny), path + [btn]))\n                        \n        print(json.dumps([\"Error: No path found\"]))\n    except Exception as e:\n        print(json.dumps([f\"Error: {str(e)}\"]))\n\nsolve()",
    "history": [
      {
        "commit_message": "Refined find_path to use the globally available map_xml_string and removed it from input_schema. Fixed one-way logic and impassable types.",
        "timestamp": "2025-12-23T14:36:16.850Z",
        "action_counter": 14568
      },
      {
        "commit_message": "Updated find_path_v2 to automatically detect player position from map_xml_string if start_x/y are not provided. Added start_x/y to input_schema as optional properties.",
        "timestamp": "2025-12-23T14:37:43.655Z",
        "action_counter": 14570
      },
      {
        "commit_message": "Fixed a bug in find_path_v2 where the path reconstruction loop would never terminate if the start position was found, leading to a KeyError: (None, None). Also fixed start_x/y handling to properly detect player position from XML if not provided as arguments.",
        "timestamp": "2025-12-23T14:38:20.004Z",
        "action_counter": 14571
      },
      {
        "commit_message": "Corrected output format of find_path_v2 to return a flat list of coordinates, matching the expected input for the navigate tool.",
        "timestamp": "2025-12-23T14:41:01.719Z",
        "action_counter": 14573
      },
      {
        "commit_message": "Fixed a bug in path reconstruction where (None, None) was not correctly identified as the termination condition, causing a KeyError. Also improved player position detection.",
        "timestamp": "2025-12-23T14:54:49.565Z",
        "action_counter": 14596
      },
      {
        "commit_message": "Refined find_path_v2 to handle pathfinding more robustly, correctly detecting the player's position from the XML if not provided, and returning a list of coordinate objects suitable for the navigate tool's path_plan. Added checks for impassable tiles including HEADBUTT_TREE and WATER.",
        "timestamp": "2025-12-23T14:56:11.952Z",
        "action_counter": 14599
      },
      {
        "commit_message": "Fixing find_path_v2 to correctly return a JSON array of button strings when autopress_buttons is true, and ensuring it handles the end tile correctly even if it's marked as impassable (like an NPC).",
        "timestamp": "2025-12-23T17:23:41.688Z",
        "action_counter": 14852
      },
      {
        "commit_message": "Updating find_path_v2 to support an optional 'can_surf' parameter. When true, WATER tiles are treated as traversable. This allows for pathfinding across ponds and oceans when the player has a Pokemon with Surf.",
        "timestamp": "2025-12-23T18:04:50.520Z",
        "action_counter": 14936
      },
      {
        "commit_message": "Refined passable types and added better error handling for unreachable destinations.",
        "timestamp": "2025-12-23T20:52:10.769Z",
        "action_counter": 15273
      },
      {
        "commit_message": "Refined passable types, added better error handling, and fixed button output for overworld/menu navigation.",
        "timestamp": "2025-12-23T20:52:38.251Z",
        "action_counter": 15274
      },
      {
        "commit_message": "Reverted to returning coordinates for 'navigate' tool and added specific logic for FLOOR_UP_WALL one-way tiles.",
        "timestamp": "2025-12-23T20:54:14.377Z",
        "action_counter": 15278
      },
      {
        "commit_message": "Fix find_path_v2 to handle autopress_buttons correctly by returning a JSON array of button strings when enabled, and account for one-way tiles like LEDGE and FLOOR_UP_WALL.",
        "timestamp": "2025-12-23T21:48:39.009Z",
        "action_counter": 15375
      },
      {
        "commit_message": "Fix find_path_v2 to handle autopress_buttons correctly and add one-way tile logic for LEDGE and FLOOR_UP_WALL.",
        "timestamp": "2025-12-23T21:49:12.615Z",
        "action_counter": 15376
      },
      {
        "commit_message": "Fix find_path_v2 by removing the function wrapper and ensuring it prints the result directly to stdout, and refine traversable types to include CAVE and warps.",
        "timestamp": "2025-12-23T21:51:09.492Z",
        "action_counter": 15382
      },
      {
        "commit_message": "Refine find_path_v2 to handle traversable types more robustly (including LONG_GRASS), fix button output logic, and improve error reporting when no path is found.",
        "timestamp": "2025-12-23T21:52:41.372Z",
        "action_counter": 15383
      },
      {
        "commit_message": "Ensure all outputs of find_path_v2 are JSON-encoded arrays of strings to prevent parsing errors in the harness, and include WARP in the passable list.",
        "timestamp": "2025-12-23T21:55:48.757Z",
        "action_counter": 15387
      },
      {
        "commit_message": "Added can_surf parameter and updated pathfinding logic for ledges and one-way walls.",
        "timestamp": "2025-12-24T02:44:55.343Z",
        "action_counter": 16074
      },
      {
        "commit_message": "Fixed FLOOR_UP_WALL logic and improved ledge hopping.",
        "timestamp": "2025-12-24T02:48:02.495Z",
        "action_counter": 16081
      },
      {
        "commit_message": "Fixed FLOOR_UP_WALL logic to block Southward movement as verified on Route 42.",
        "timestamp": "2025-12-24T02:53:18.188Z",
        "action_counter": 16094
      },
      {
        "commit_message": "Fixed FLOOR_UP_WALL logic to block Northward entry.",
        "timestamp": "2025-12-24T02:56:43.743Z",
        "action_counter": 16101
      },
      {
        "commit_message": "Corrected FLOOR_UP_WALL logic to block Southward movement.",
        "timestamp": "2025-12-24T03:01:54.819Z",
        "action_counter": 16109
      },
      {
        "commit_message": "Finalized ledge and FLOOR_UP_WALL (Southward block) logic for accurate pathfinding.",
        "timestamp": "2025-12-24T03:26:52.936Z",
        "action_counter": 16154
      },
      {
        "commit_message": "Implement robust BFS pathfinding for overworld navigation, accounting for ledge directions and hypothetical floor-up-wall behavior.",
        "timestamp": "2025-12-24T04:03:42.841Z",
        "action_counter": 16231
      },
      {
        "commit_message": "Refine pathfinding logic: allow destination to be an object-occupied tile and ensure the start tile's object/impassable status doesn't block the initial step.",
        "timestamp": "2025-12-24T04:09:54.304Z",
        "action_counter": 16244
      },
      {
        "commit_message": "Fix IndexError by checking sys.argv length and improve player position detection.",
        "timestamp": "2025-12-24T04:16:01.527Z",
        "action_counter": 16258
      },
      {
        "commit_message": "Refine find_path_v2 to use the injected input_data dictionary instead of sys.argv, and improve error handling.",
        "timestamp": "2025-12-24T04:18:55.006Z",
        "action_counter": 16263
      }
    ]
  },
  "get_reachable_unseen_tiles_v2": {
    "description": "Analyzes the current map XML to identify unseen tiles that are directly adjacent to tiles reachable from the player's current position. Handles ledges and one-way tiles. Returns a list of coordinates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "can_surf": {
          "type": "boolean"
        }
      }
    },
    "python_script": "import xml.etree.ElementTree as ET\nfrom collections import deque\nimport json\n\ndef run(input_data):\n    can_surf = input_data.get('can_surf', False)\n    if isinstance(can_surf, str):\n        can_surf = can_surf.lower() == 'true'\n\n    if not map_xml_string or \"<Map\" not in map_xml_string:\n        return {\"error\": \"Mental Map unavailable.\"}\n    \n    root = ET.fromstring(map_xml_string)\n    \n    start_x, start_y = None, None\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            if tile.find('Player') is not None:\n                start_x, start_y = int(tile.attrib['id']), y\n                break\n        if start_x is not None: break\n            \n    if start_x is None: return {\"reachable_unseen\": []}\n\n    grid = {}\n    impassable_types = {'WALL', 'HEADBUTT_TREE', 'unseen'}\n    if not can_surf:\n        impassable_types.add('WATER')\n\n    for row in root.findall('Row'):\n        y = int(row.attrib['id'])\n        for tile in row.findall('Tile'):\n            x = int(tile.attrib['id'])\n            t_type = tile.attrib['type']\n            grid[(x, y)] = t_type\n            if tile.find('Object') is not None: grid[(x, y)] = 'WALL'\n\n    queue = deque([(start_x, start_y)])\n    visited = {(start_x, start_y)}\n    reachable_tiles = {(start_x, start_y)}\n    \n    while queue:\n        curr_x, curr_y = queue.popleft()\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = curr_x + dx, curr_y + dy\n            if (nx, ny) in grid:\n                t_type = grid[(nx, ny)]\n                \n                # Relational movement logic\n                if dy == 1: # Moving South\n                    if t_type == 'FLOOR_UP_WALL' or t_type == 'LEDGE_HOP_UP': continue\n                    if t_type == 'LEDGE_HOP_DOWN':\n                        ny += 1\n                        if (nx, ny) in grid: t_type = grid[(nx, ny)]\n                        else: continue\n                elif dy == -1: # Moving North\n                    if t_type == 'LEDGE_HOP_DOWN': continue\n                    if t_type == 'LEDGE_HOP_UP':\n                        ny -= 1\n                        if (nx, ny) in grid: t_type = grid[(nx, ny)]\n                        else: continue\n                elif dx == 1: # Moving East\n                    if t_type == 'LEDGE_HOP_LEFT': continue\n                    if t_type == 'LEDGE_HOP_RIGHT':\n                        nx += 1\n                        if (nx, ny) in grid: t_type = grid[(nx, ny)]\n                        else: continue\n                elif dx == -1: # Moving West\n                    if t_type == 'LEDGE_HOP_RIGHT': continue\n                    if t_type == 'LEDGE_HOP_LEFT':\n                        nx -= 1\n                        if (nx, ny) in grid: t_type = grid[(nx, ny)]\n                        else: continue\n                \n                if t_type not in impassable_types:\n                    if (nx, ny) not in visited:\n                        visited.add((nx, ny))\n                        reachable_tiles.add((nx, ny))\n                        queue.append((nx, ny))\n\n    reachable_unseen = set()\n    for rx, ry in reachable_tiles:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ux, uy = rx + dx, ry + dy\n            if (ux, uy) in grid and grid[(ux, uy)] == 'unseen':\n                reachable_unseen.add((ux, uy))\n                \n    return {\"reachable_unseen\": sorted(list(reachable_unseen))}\n\nprint(json.dumps(run(input_data)))",
    "history": [
      {
        "commit_message": "Refined get_reachable_unseen_tiles to use the BFS logic from find_path_v2, correctly handling ledges and one-way movement. Added Mental Map availability check.",
        "timestamp": "2025-12-23T15:43:54.280Z",
        "action_counter": 14678
      },
      {
        "commit_message": "Updated get_reachable_unseen_tiles_v2 to support can_surf parameter and improved ledge logic.",
        "timestamp": "2025-12-24T02:46:05.281Z",
        "action_counter": 16078
      },
      {
        "commit_message": "Fixed FLOOR_UP_WALL logic and improved ledge hopping.",
        "timestamp": "2025-12-24T02:48:02.496Z",
        "action_counter": 16081
      },
      {
        "commit_message": "Fixed FLOOR_UP_WALL logic to block Southward movement.",
        "timestamp": "2025-12-24T02:53:18.190Z",
        "action_counter": 16094
      },
      {
        "commit_message": "Fixed FLOOR_UP_WALL logic to block Northward entry.",
        "timestamp": "2025-12-24T02:56:43.744Z",
        "action_counter": 16101
      },
      {
        "commit_message": "Corrected FLOOR_UP_WALL logic to block Southward movement.",
        "timestamp": "2025-12-24T03:01:54.820Z",
        "action_counter": 16109
      },
      {
        "commit_message": "Finalized ledge and FLOOR_UP_WALL (Southward block) logic for accurate map analysis.",
        "timestamp": "2025-12-24T03:26:52.937Z",
        "action_counter": 16154
      }
    ]
  },
  "switch_pokemon": {
    "description": "Automatically selects a Pokemon to switch to from the battle party menu. Assumes the party menu is already open and the cursor starts at the leading Pokemon (index 0).",
    "input_schema": {
      "type": "object",
      "properties": {
        "target_index": {
          "type": "integer",
          "description": "The 0-indexed position of the Pokemon to switch to (0-5)."
        },
        "current_index": {
          "type": "integer",
          "default": 0,
          "description": "The current 0-indexed position of the cursor (0-5)."
        }
      },
      "required": [
        "target_index"
      ]
    },
    "python_script": "import json\n\n# The variable input_data is automatically provided by the system\ntarget_index = int(input_data['target_index'])\ncurrent_index = int(input_data.get('current_index', 0))\n\nbuttons = []\ndiff = target_index - current_index\nif diff > 0:\n    buttons.extend([\"Down\"] * diff)\nelif diff < 0:\n    buttons.extend([\"Up\"] * abs(diff))\n\n# Select the Pokemon\nbuttons.append(\"A\")\n# Wait for the sub-menu (SWITCH/STATS/CANCEL) to appear\nbuttons.append(\"sleep 500\")\n# Select SWITCH (which is the default first option)\nbuttons.append(\"A\")\n\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-24T07:24:00.641Z",
        "action_counter": 16531
      },
      {
        "commit_message": "Fixed switch_pokemon tool to use the globally available input_data variable instead of reading from sys.stdin, resolving the JSONDecodeError.",
        "timestamp": "2025-12-24T07:28:37.799Z",
        "action_counter": 16539
      }
    ]
  },
  "grind_movement": {
    "description": "Moves the player back and forth between two adjacent tiles for a specified number of cycles to trigger wild encounters. Assumes the player starts on one of the tiles. Returns a maximum of 10 buttons (5 cycles).",
    "input_schema": {
      "type": "object",
      "properties": {
        "cycles": {
          "type": "integer",
          "description": "Number of back-and-forth cycles to perform (1-5)."
        },
        "direction": {
          "type": "string",
          "enum": [
            "horizontal",
            "vertical"
          ],
          "description": "The axis of movement."
        }
      },
      "required": [
        "cycles",
        "direction"
      ]
    },
    "python_script": "import json\nimport sys\n\ntry:\n    input_data = json.loads(sys.argv[1])\nexcept (IndexError, json.JSONDecodeError):\n    input_data = {}\n\ncycles = int(input_data.get('cycles', 1))\ncycles = max(1, min(cycles, 5))\ndirection = input_data.get('direction', 'horizontal')\n\nbuttons = []\nif direction == \"horizontal\":\n    for _ in range(cycles):\n        buttons.extend([\"Left\", \"Right\"])\nelif direction == \"vertical\":\n    for _ in range(cycles):\n        buttons.extend([\"Up\", \"Down\"])\n\nprint(json.dumps(buttons))",
    "history": [
      {
        "commit_message": "Initial version",
        "timestamp": "2025-12-24T08:26:13.633Z",
        "action_counter": 16674
      },
      {
        "commit_message": "Added error handling for input data to prevent IndexError.",
        "timestamp": "2025-12-24T08:26:59.825Z",
        "action_counter": 16676
      },
      {
        "commit_message": "Refined input parsing and added a cycle limit to ensure reliable button sequences.",
        "timestamp": "2025-12-24T08:32:58.267Z",
        "action_counter": 16690
      }
    ]
  }
}